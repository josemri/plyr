package com.plyr.viewmodel

import android.app.Application
import androidx.lifecycle.AndroidViewModel
import androidx.lifecycle.LiveData
import androidx.lifecycle.MutableLiveData
import androidx.media3.common.MediaItem
import androidx.media3.common.Player
import androidx.media3.exoplayer.ExoPlayer
import com.plyr.network.YouTubeAudioExtractor
import com.plyr.utils.isValidAudioUrl
import com.plyr.utils.Config
import com.plyr.service.YouTubeSearchManager
import com.plyr.database.TrackEntity
import android.os.Handler
import android.os.Looper
import kotlinx.coroutines.CoroutineScope
import kotlinx.coroutines.Dispatchers
import kotlinx.coroutines.launch
import kotlinx.coroutines.withContext
import kotlinx.coroutines.CompletableDeferred
import kotlinx.coroutines.flow.MutableStateFlow
import kotlinx.coroutines.flow.StateFlow
import kotlinx.coroutines.flow.asStateFlow
import android.util.Log

/**
 * PlayerViewModel - Maneja la reproducci√≥n de audio usando ExoPlayer y NewPipe
 * 
 * FUNCIONALIDADES PRINCIPALES:
 * - Gestionar el ciclo de vida del ExoPlayer
 * - Extraer URLs de audio de YouTube usando NewPipe Extractor
 * - Proporcionar una interfaz para reproducir audio desde videos o tracks de Spotify
 * - Manejar estados de reproducci√≥n (loading, error, etc.)
 * - Proporcionar funcionalidades como play, pause, seek y control de tiempo
 * 
 * NAVEGACI√ìN DE PLAYLIST:
 * - Mantener el estado de la playlist actual y el √≠ndice del track
 * - Navegaci√≥n manual hacia adelante/atr√°s con botones fwd/bwd
 * - Auto-navegaci√≥n autom√°tica al final de cada canci√≥n (configurable)
 * - Informaci√≥n de posici√≥n en playlist (ej: "3 de 10")
 * - Estados de disponibilidad de navegaci√≥n (hasPrevious/hasNext)
 * 
 * USO:
 * 1. Llamar setCurrentPlaylist() para establecer la lista de tracks
 * 2. Los botones fwd/bwd en FloatingMusicControls permiten navegaci√≥n manual
 * 3. La auto-navegaci√≥n se puede habilitar/deshabilitar con setAutoNavigationEnabled()
 * 4. Los estados de navegaci√≥n se observan autom√°ticamente en la UI
 * 
 * @param application Contexto de la aplicaci√≥n para acceder a recursos del sistema
 */
class PlayerViewModel(application: Application) : AndroidViewModel(application) {
    
    // === CONSTANTES ===
    
    companion object {
        private const val TAG = "PlayerViewModel"
    }
    
    // === PROPIEDADES PRIVADAS ===
    
    /** Instancia del ExoPlayer para reproducci√≥n de audio */
    private var _exoPlayer: ExoPlayer? = null
    
    /** LiveData privado para la URL de audio actual */
    private val _audioUrl = MutableLiveData<String?>()
    
    /** LiveData privado para el t√≠tulo de la canci√≥n actual */
    private val _currentTitle = MutableLiveData<String?>()
    
    /** LiveData privado para el estado de carga */
    private val _isLoading = MutableLiveData<Boolean>()
    
    /** LiveData privado para mensajes de error */
    private val _error = MutableLiveData<String?>()
    
    /** Handler para ejecutar c√≥digo en el hilo principal */
    private val mainHandler = Handler(Looper.getMainLooper())
    
    /** Manejador de b√∫squedas de YouTube usando NewPipe */
    private val youtubeSearchManager = YouTubeSearchManager(application)
    
    /** Callback para notificar cuando una canci√≥n termina de reproducirse */
    private var playbackEndedCallback: CompletableDeferred<Boolean>? = null
    
    // === PROPIEDADES DE PLAYLIST ===
    
    /** Lista actual de tracks de la playlist */
    private val _currentPlaylist = MutableLiveData<List<TrackEntity>?>()
    
    /** √çndice del track actual en la playlist */
    private val _currentTrackIndex = MutableLiveData<Int>()
    
    /** Track actual que se est√° reproduciendo */
    private val _currentTrack = MutableLiveData<TrackEntity?>()
    
    /** Estado de si hay track anterior disponible */
    private val _hasPrevious = MutableLiveData<Boolean>(false)
    
    /** Estado de si hay track siguiente disponible */
    private val _hasNext = MutableLiveData<Boolean>(false)
    
    /** Estado de auto-navegaci√≥n habilitada */
    private val _autoNavigationEnabled = MutableLiveData<Boolean>(true)
    
    // === PROPIEDADES DE COLA (QUEUE) ===
    
    /** Cola de reproducci√≥n - lista de tracks pendientes */
    private val _playbackQueue = MutableLiveData<MutableList<TrackEntity>>(mutableListOf())
    
    /** Indica si est√° en modo cola (queue) */
    private val _isQueueMode = MutableLiveData<Boolean>(false)
    
    // === PROPIEDADES DE COLA (STATEFLOW) ===
    
    /** Estado de la cola como StateFlow para Compose */
    private val _queueState = MutableStateFlow(QueueState())
    val queueState: StateFlow<QueueState> = _queueState.asStateFlow()

    // === PROPIEDADES P√öBLICAS (READONLY) ===
    
    /** Acceso p√∫blico de solo lectura al ExoPlayer */
    val exoPlayer: ExoPlayer? get() = _exoPlayer
    
    /** LiveData observable para la URL de audio actual */
    val audioUrl: LiveData<String?> = _audioUrl
    
    /** LiveData observable para el t√≠tulo de la canci√≥n actual */
    val currentTitle: LiveData<String?> = _currentTitle
    
    /** LiveData observable para el estado de carga */
    val isLoading: LiveData<Boolean> = _isLoading
    
    /** LiveData observable para mensajes de error */
    val error: LiveData<String?> = _error
    
    /** LiveData observable para la playlist actual */
    val currentPlaylist: LiveData<List<TrackEntity>?> = _currentPlaylist
    
    /** LiveData observable para el √≠ndice del track actual */
    val currentTrackIndex: LiveData<Int> = _currentTrackIndex
    
    /** LiveData observable para el track actual */
    val currentTrack: LiveData<TrackEntity?> = _currentTrack
    
    /** LiveData observable para disponibilidad de track anterior */
    val hasPrevious: LiveData<Boolean> = _hasPrevious
    
    /** LiveData observable para disponibilidad de track siguiente */
    val hasNext: LiveData<Boolean> = _hasNext
    
    /** LiveData observable para el estado de auto-navegaci√≥n */
    val autoNavigationEnabled: LiveData<Boolean> = _autoNavigationEnabled
    
    /** LiveData observable para la cola de reproducci√≥n */
    val playbackQueue: LiveData<MutableList<TrackEntity>> = _playbackQueue
    
    /** LiveData observable para el estado de modo cola */
    val isQueueMode: LiveData<Boolean> = _isQueueMode

    // === INICIALIZACI√ìN ===
    
    init {
        // Inicializar el estado de la cola
        updateQueueState()
        Log.d(TAG, "PlayerViewModel inicializado")
    }

    // === M√âTODOS P√öBLICOS ===
    
    /**
     * Inicializa el ExoPlayer si no ha sido creado a√∫n.
     * Configura los listeners necesarios para el manejo de estados de reproducci√≥n.
     */
    fun initializePlayer() {
        if (_exoPlayer == null) {
            _exoPlayer = ExoPlayer.Builder(getApplication()).build().apply {
                // Configurar listener para eventos de reproducci√≥n
                addListener(createPlayerListener())
            }
        }
    }
    
    /**
     * Crea el listener para el ExoPlayer que maneja cambios de estado.
     * @return Player.Listener configurado con los callbacks necesarios
     */
    private fun createPlayerListener(): Player.Listener {
        return object : Player.Listener {
            override fun onPlaybackStateChanged(playbackState: Int) {
                when (playbackState) {
                    Player.STATE_ENDED -> {
                        println("PlayerViewModel: üéµ Canci√≥n terminada - Player.STATE_ENDED")
                        playbackEndedCallback?.complete(true)
                        playbackEndedCallback = null
                        
                        // Auto-navegaci√≥n a la siguiente canci√≥n si hay playlist activa
                        handleAutoNavigation()
                    }
                    Player.STATE_IDLE -> {
                        println("PlayerViewModel: ExoPlayer en estado IDLE")
                    }
                    Player.STATE_BUFFERING -> {
                        println("PlayerViewModel: ExoPlayer bufferizando...")
                    }
                    Player.STATE_READY -> {
                        println("PlayerViewModel: ExoPlayer listo para reproducir")
                    }
                }
            }
            
            override fun onIsPlayingChanged(isPlaying: Boolean) {
                println("PlayerViewModel: Estado de reproducci√≥n cambi√≥: $isPlaying")
            }
        }
    }
    
    /**
     * Carga y reproduce audio desde un video ID de YouTube.
     * 
     * @param videoId ID del video de YouTube (ej: "dQw4w9WgXcQ")
     * @param title T√≠tulo opcional para mostrar en la UI
     */
    fun loadAudio(videoId: String, title: String? = null) {
        println("PlayerViewModel: Cargando audio para video ID: $videoId con t√≠tulo: $title")
        updateLoadingState(true, null, title)
        
        // Usar NewPipe Extractor para obtener la URL de audio
        CoroutineScope(Dispatchers.Main).launch {
            try {
                val audioUrl = extractAudioUrl(videoId)
                
                if (audioUrl != null && isValidAudioUrl(audioUrl)) {
                    println("PlayerViewModel: ‚úÖ URL obtenida con NewPipe: $audioUrl")
                    playAudioFromUrl(audioUrl)
                } else {
                    handleAudioExtractionError(videoId, audioUrl)
                }
            } catch (e: Exception) {
                handleException("Error al extraer audio", e)
            }
        }
    }
    
    /**
     * Extrae la URL de audio de un video de YouTube usando NewPipe.
     * @param videoId ID del video de YouTube
     * @return URL de audio o null si falla
     */
    private suspend fun extractAudioUrl(videoId: String): String? {
        return withContext(Dispatchers.IO) {
            YouTubeAudioExtractor.getAudioUrl(videoId)
        }
    }
    
    /**
     * Reproduce audio desde una URL espec√≠fica.
     * @param audioUrl URL del archivo de audio
     */
    private fun playAudioFromUrl(audioUrl: String) {
        _audioUrl.postValue(audioUrl)
        
        _exoPlayer?.apply {
            try {
                println("PlayerViewModel: Creando MediaItem con URL: $audioUrl")
                setMediaItem(MediaItem.fromUri(audioUrl))
                prepare()
                play()
                println("PlayerViewModel: ExoPlayer configurado y reproduciendo")
                _isLoading.postValue(false)
            } catch (e: Exception) {
                handleException("Error al configurar ExoPlayer", e)
            }
        }
    }
    
    /**
     * Maneja errores en la extracci√≥n de audio.
     */
    private fun handleAudioExtractionError(videoId: String, audioUrl: String?) {
        if (audioUrl == null) {
            println("PlayerViewModel: ‚ùå No se pudo obtener URL de audio")
            updateLoadingState(false, "No se pudo extraer la URL de audio para el video ID: $videoId")
        } else {
            println("PlayerViewModel: URL no v√°lida seg√∫n isValidAudioUrl")
            updateLoadingState(false, "La URL obtenida no es v√°lida para reproducci√≥n de audio")
        }
    }
    
    
    /**
     * Carga y reproduce audio desde un TrackEntity de forma transparente.
     * Obtiene el YouTube ID autom√°ticamente si no existe.
     * 
     * @param track Entidad del track con informaci√≥n de Spotify
     * @return true si la carga fue exitosa, false si fall√≥
     */
    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {
        try {
            println("PlayerViewModel: Cargando audio para track: ${track.name} - ${track.artists}")
            updateLoadingState(true, null, "${track.name} - ${track.artists}")
            
            // Obtener YouTube ID de forma transparente
            val youtubeId = obtainYouTubeId(track)
            
            if (youtubeId != null) {
                println("PlayerViewModel: ‚úÖ YouTube ID obtenido: $youtubeId")
                return@withContext playTrackAudio(youtubeId, track)
            } else {
                println("PlayerViewModel: ‚ùå No se encontr√≥ YouTube ID para: ${track.name}")
                updateLoadingState(false, "No se encontr√≥ el video para: ${track.name}")
                return@withContext false
            }
        } catch (e: Exception) {
            handleException("Error al cargar audio desde track", e)
            return@withContext false
        }
    }
    
    /**
     * Obtiene el YouTube ID para un track.
     * @param track Track del cual obtener el ID
     * @return YouTube ID o null si no se encuentra
     */
    private suspend fun obtainYouTubeId(track: TrackEntity): String? {
        return withContext(Dispatchers.IO) {
            youtubeSearchManager.getYouTubeIdTransparently(track)
        }
    }
    
    /**
     * Reproduce audio de un track usando su YouTube ID.
     * @param youtubeId ID de YouTube del track
     * @param track Informaci√≥n del track para logs
     * @return true si la reproducci√≥n fue exitosa
     */
    private suspend fun playTrackAudio(youtubeId: String, track: TrackEntity): Boolean {
        // Obtener URL de audio con el ID
        val audioUrl = withContext(Dispatchers.IO) {
            YouTubeAudioExtractor.getAudioUrl(youtubeId)
        }
        
        if (audioUrl != null && isValidAudioUrl(audioUrl)) {
            println("PlayerViewModel: ‚úÖ URL de audio obtenida: $audioUrl")
            return configureAndPlayAudio(audioUrl, track)
        } else {
            println("PlayerViewModel: ‚ùå No se pudo obtener URL de audio v√°lida")
            updateLoadingState(false, "No se pudo obtener el audio para: ${track.name}")
            return false
        }
    }
    
    /**
     * Configura ExoPlayer y inicia la reproducci√≥n.
     * @param audioUrl URL del audio a reproducir
     * @param track Informaci√≥n del track para logs
     * @return true si la configuraci√≥n fue exitosa
     */
    private suspend fun configureAndPlayAudio(audioUrl: String, track: TrackEntity): Boolean {
        _audioUrl.postValue(audioUrl)
        
        return withContext(Dispatchers.Main) {
            // Verificar que ExoPlayer est√© inicializado
            if (_exoPlayer == null) {
                Log.e(TAG, "‚ùå ExoPlayer es null, intentando inicializar...")
                initializePlayer()
            }
            
            _exoPlayer?.let { player ->
                try {
                    Log.d(TAG, "üéµ Configurando ExoPlayer para: ${track.name}")
                    player.setMediaItem(MediaItem.fromUri(audioUrl))
                    player.prepare()
                    player.play()
                    Log.d(TAG, "‚úÖ Reproducci√≥n iniciada para: ${track.name}")
                    _isLoading.postValue(false)
                    return@withContext true
                } catch (e: Exception) {
                    Log.e(TAG, "‚ùå Error configurando ExoPlayer para ${track.name}", e)
                    handleException("Error configurando ExoPlayer", e)
                    return@withContext false
                }
            } ?: run {
                Log.e(TAG, "‚ùå ExoPlayer sigue siendo null despu√©s de inicializaci√≥n")
                diagnoseExoPlayerState()
                _isLoading.postValue(false)
                _error.postValue("Error: Reproductor no disponible")
                return@withContext false
            }
        }
    }
    
    // === M√âTODOS DE CONTROL DE REPRODUCCI√ìN ===
    
    /**
     * Pausa la reproducci√≥n actual.
     */
    fun pausePlayer() {
        mainHandler.post {
            _exoPlayer?.pause()
        }
    }
    
    /**
     * Reanuda la reproducci√≥n.
     */
    fun playPlayer() {
        mainHandler.post {
            _exoPlayer?.play()
        }
    }
    
    /**
     * Busca a una posici√≥n espec√≠fica en la canci√≥n.
     * @param positionMs Posici√≥n en milisegundos
     */
    fun seekTo(positionMs: Long) {
        mainHandler.post {
            _exoPlayer?.seekTo(positionMs)
        }
    }
    
    /**
     * Obtiene la posici√≥n actual de reproducci√≥n.
     * @return Posici√≥n actual en milisegundos
     */
    fun getCurrentPosition(): Long {
        return try {
            _exoPlayer?.currentPosition ?: 0L
        } catch (e: Exception) {
            println("PlayerViewModel: Error obteniendo posici√≥n: ${e.message}")
            0L
        }
    }
    
    /**
     * Obtiene la duraci√≥n total de la canci√≥n actual.
     * @return Duraci√≥n en milisegundos
     */
    fun getDuration(): Long {
        return try {
            _exoPlayer?.duration?.takeIf { it > 0 } ?: 0L
        } catch (e: Exception) {
            println("PlayerViewModel: Error obteniendo duraci√≥n: ${e.message}")
            0L
        }
    }
    
    /**
     * Verifica si el reproductor est√° reproduciendo actualmente.
     * @return true si est√° reproduciendo, false en caso contrario
     */
    fun isPlaying(): Boolean {
        return try {
            _exoPlayer?.isPlaying ?: false
        } catch (e: Exception) {
            println("PlayerViewModel: Error verificando estado de reproducci√≥n: ${e.message}")
            false
        }
    }
    
    
    /**
     * Habilita o deshabilita la navegaci√≥n autom√°tica al final de cada canci√≥n.
     * @param enabled true para habilitar, false para deshabilitar
     */
    fun setAutoNavigationEnabled(enabled: Boolean) {
        _autoNavigationEnabled.postValue(enabled)
        println("PlayerViewModel: Auto-navegaci√≥n ${if (enabled) "habilitada" else "deshabilitada"}")
    }

    /**
     * Obtiene el estado actual de la auto-navegaci√≥n.
     * @return true si est√° habilitada, false en caso contrario
     */
    fun isAutoNavigationEnabled(): Boolean {
        return _autoNavigationEnabled.value ?: true
    }

    // === M√âTODOS DE NAVEGACI√ìN DE PLAYLIST ===
    
    /**
     * Establece la playlist actual y el √≠ndice del track.
     * @param playlist Lista de tracks de la playlist
     * @param startIndex √çndice del track inicial (por defecto 0)
     */
    fun setCurrentPlaylist(playlist: List<TrackEntity>, startIndex: Int = 0) {
        Log.d(TAG, "Estableciendo playlist: ${playlist.size} tracks, startIndex=$startIndex")
        _currentPlaylist.postValue(playlist)
        _currentTrackIndex.postValue(startIndex.coerceIn(0, playlist.size - 1))
        
        if (playlist.isNotEmpty() && startIndex in playlist.indices) {
            _currentTrack.postValue(playlist[startIndex])
            Log.d(TAG, "Track actual establecido: ${playlist[startIndex].name}")
        }
        
        updateNavigationState()
    }
    
    /**
     * Navega al track siguiente en la playlist o cola.
     * @return true si pudo navegar, false si no hay siguiente track
     */
    suspend fun navigateToNext(): Boolean {
        // Si est√° en modo cola, reproducir siguiente de la cola
        if (_isQueueMode.value == true) {
            return playNextFromQueue()
        }
        
        // Modo playlist normal
        val playlist = _currentPlaylist.value ?: return false
        val currentIndex = _currentTrackIndex.value ?: return false
        
        if (currentIndex < playlist.size - 1) {
            val nextIndex = currentIndex + 1
            val nextTrack = playlist[nextIndex]
            
            _currentTrackIndex.postValue(nextIndex)
            _currentTrack.postValue(nextTrack)
            updateNavigationState()
            
            // Cargar y reproducir el siguiente track
            val success = loadAudioFromTrack(nextTrack)
            if (success) {
                println("PlayerViewModel: ‚úÖ Navegaci√≥n exitosa al siguiente track: ${nextTrack.name}")
            }
            return success
        }
        
        return false
    }
    
    /**
     * Navega al track anterior en la playlist.
     * @return true si pudo navegar, false si no hay track anterior
     */
    suspend fun navigateToPrevious(): Boolean {
        val playlist = _currentPlaylist.value ?: return false
        val currentIndex = _currentTrackIndex.value ?: return false
        
        if (currentIndex > 0) {
            val previousIndex = currentIndex - 1
            val previousTrack = playlist[previousIndex]
            
            _currentTrackIndex.postValue(previousIndex)
            _currentTrack.postValue(previousTrack)
            updateNavigationState()
            
            // Cargar y reproducir el track anterior
            val success = loadAudioFromTrack(previousTrack)
            if (success) {
                println("PlayerViewModel: ‚úÖ Navegaci√≥n exitosa al track anterior: ${previousTrack.name}")
            }
            return success
        }
        
        return false
    }
    
    /**
     * Navega a un track espec√≠fico en la playlist por √≠ndice.
     * @param index √çndice del track al que navegar
     * @return true si pudo navegar, false si el √≠ndice es inv√°lido
     */
    suspend fun navigateToTrack(index: Int): Boolean {
        val playlist = _currentPlaylist.value ?: return false
        
        if (index in playlist.indices) {
            val track = playlist[index]
            
            _currentTrackIndex.postValue(index)
            _currentTrack.postValue(track)
            updateNavigationState()
            
            // Cargar y reproducir el track seleccionado
            val success = loadAudioFromTrack(track)
            if (success) {
                println("PlayerViewModel: ‚úÖ Navegaci√≥n exitosa al track ${index + 1}: ${track.name}")
            }
            return success
        }
        
        return false
    }
    
    /**
     * Actualiza el estado de navegaci√≥n (hasPrevious, hasNext).
     */
    private fun updateNavigationState() {
        val isQueue = _isQueueMode.value == true
        val queueSize = _playbackQueue.value?.size ?: 0
        val playlist = _currentPlaylist.value
        val currentIndex = _currentTrackIndex.value
        
        Log.d(TAG, "Actualizando estado de navegaci√≥n: isQueue=$isQueue, queueSize=$queueSize, playlist=${playlist?.size}, index=$currentIndex")
        
        if (isQueue) {
            // En modo cola: no hay "previous", pero s√≠ "next" si hay tracks en cola
            _hasPrevious.postValue(false)
            _hasNext.postValue(queueSize > 0)
            Log.d(TAG, "Modo cola: hasPrevious=false, hasNext=${queueSize > 0}")
        } else if (playlist != null && currentIndex != null) {
            val hasPrev = currentIndex > 0
            val hasNext = currentIndex < playlist.size - 1
            Log.d(TAG, "Modo playlist: hasPrevious=$hasPrev, hasNext=$hasNext")
            _hasPrevious.postValue(hasPrev)
            _hasNext.postValue(hasNext)
        } else {
            Log.d(TAG, "Deshabilitando navegaci√≥n (sin contexto)")
            _hasPrevious.postValue(false)
            _hasNext.postValue(false)
        }
    }
    
    /**
     * Obtiene informaci√≥n del track actual de la playlist.
     * @return Informaci√≥n del track actual o null si no hay playlist activa
     */
    fun getCurrentTrackInfo(): TrackEntity? {
        return _currentTrack.value
    }
    
    /**
     * Obtiene el n√∫mero total de tracks en la playlist actual.
     * @return N√∫mero de tracks o 0 si no hay playlist
     */
    fun getPlaylistSize(): Int {
        return _currentPlaylist.value?.size ?: 0
    }
    
    /**
     * Obtiene la posici√≥n actual en la playlist (1-indexed para mostrar al usuario).
     * @return Posici√≥n actual (ej: "3 de 10") o null si no hay playlist
     */
    fun getCurrentPlaylistPosition(): String? {
        val playlist = _currentPlaylist.value
        val currentIndex = _currentTrackIndex.value
        
        return if (playlist != null && currentIndex != null) {
            "${currentIndex + 1} de ${playlist.size}"
        } else {
            null
        }
    }

    // === M√âTODOS DE GESTI√ìN DE COLA (QUEUE) ===
    
    /**
     * Agrega un track a la cola de reproducci√≥n.
     * @param track Track a agregar a la cola
     */
    fun addToQueue(track: TrackEntity) {
        val currentQueue = _playbackQueue.value ?: mutableListOf()
        currentQueue.add(track)
        // Crear una nueva lista para asegurar que la UI se actualice
        val newQueue = currentQueue.toMutableList()
        _playbackQueue.postValue(newQueue)
        updateNavigationState()
        updateQueueState()
        Log.d(TAG, "Track agregado a la cola: ${track.name} (${newQueue.size} en cola)")
    }
    
    /**
     * Elimina un track de la cola por √≠ndice.
     * @param index √çndice del track a eliminar
     */
    fun removeFromQueue(index: Int) {
        val currentQueue = _playbackQueue.value ?: return
        if (index in currentQueue.indices) {
            val removedTrack = currentQueue.removeAt(index)
            // Crear una nueva lista para asegurar que la UI se actualice
            val newQueue = currentQueue.toMutableList()
            _playbackQueue.postValue(newQueue)
            updateQueueState()
            Log.d(TAG, "Track eliminado de la cola: ${removedTrack.name} (${newQueue.size} restantes)")
        }
    }
    
    /**
     * Limpia toda la cola de reproducci√≥n.
     */
    fun clearQueue() {
        _playbackQueue.postValue(mutableListOf())
        _isQueueMode.postValue(false)
        updateQueueState()
        Log.d(TAG, "Cola de reproducci√≥n limpiada")
    }
    
    /**
     * Inicia la reproducci√≥n en modo cola.
     * Reproduce el primer track de la cola y establece el modo cola.
     */
    suspend fun startQueueMode(): Boolean {
        val queue = _playbackQueue.value
        if (queue.isNullOrEmpty()) {
            Log.d(TAG, "No hay tracks en la cola para iniciar")
            return false
        }
        
        _isQueueMode.postValue(true)
        Log.d(TAG, "Iniciando modo cola con ${queue.size} tracks")
        
        // Reproducir el primer track de la cola
        return playNextFromQueue()
    }
    
    /**
     * Reproduce el siguiente track de la cola.
     * @return true si pudo reproducir, false si no hay m√°s tracks en cola
     */
    suspend fun playNextFromQueue(): Boolean {
        val queue = _playbackQueue.value
        if (queue.isNullOrEmpty()) {
            Log.d(TAG, "Cola vac√≠a, desactivando modo cola")
            _isQueueMode.postValue(false)
            updateNavigationState()
            return false
        }
        
        // Tomar el primer track de la cola
        val nextTrack = queue.removeAt(0)
        _playbackQueue.postValue(queue)
        updateNavigationState()
        
        Log.d(TAG, "üéµ Reproduciendo desde cola: ${nextTrack.name} (${queue.size} tracks restantes en cola)")
        
        // Cargar y reproducir el track
        val success = loadAudioFromTrack(nextTrack)
        if (success) {
            // Actualizar el track actual
            _currentTrack.postValue(nextTrack)
            Log.d(TAG, "‚úÖ Track de cola cargado exitosamente: ${nextTrack.name}")
        } else {
            Log.e(TAG, "‚ùå Error cargando track de cola: ${nextTrack.name}")
            diagnoseExoPlayerState()
        }
        
        return success
    }
    
    /**
     * Reproduce un track espec√≠fico de la cola por √≠ndice.
     * @param index √çndice del track en la cola a reproducir
     */
    suspend fun playFromQueue(index: Int) {
        val queue = _playbackQueue.value ?: return
        if (index !in queue.indices) {
            Log.e(TAG, "√çndice de cola fuera de rango: $index")
            return
        }
        
        val track = queue[index]
        Log.d(TAG, "Reproduciendo track de cola en √≠ndice $index: ${track.name}")
        
        // Actualizar el estado de la cola
        updateQueueState()
        
        // Cargar y reproducir el track
        val success = loadAudioFromTrack(track)
        if (success) {
            _currentTrack.postValue(track)
            _isQueueMode.postValue(true)
        }
    }
    
    /**
     * Inicia la reproducci√≥n de la cola desde el primer track.
     */
    fun startQueue() {
        CoroutineScope(Dispatchers.Main).launch {
            val success = startQueueMode()
            if (success) {
                Log.d(TAG, "Cola iniciada correctamente")
            } else {
                Log.w(TAG, "No se pudo iniciar la cola")
            }
        }
    }
    
    /**
     * Mezcla aleatoriamente los tracks en la cola.
     */
    fun shuffleQueue() {
        val currentQueue = _playbackQueue.value ?: return
        if (currentQueue.size <= 1) return
        
        currentQueue.shuffle()
        // Crear una nueva lista para asegurar que la UI se actualice
        val newQueue = currentQueue.toMutableList()
        _playbackQueue.postValue(newQueue)
        updateQueueState()
        Log.d(TAG, "Cola mezclada - ${newQueue.size} tracks")
    }
    
    /**
     * Reproduce la cola desde un √≠ndice espec√≠fico y activa el modo cola.
     * Esto reorganiza la cola para que comience desde el √≠ndice seleccionado
     * y contin√∫e con el resto de tracks en orden.
     * 
     * @param startIndex √çndice desde donde comenzar la reproducci√≥n
     */
    suspend fun playQueueFromIndex(startIndex: Int) {
        val queue = _playbackQueue.value ?: return
        if (startIndex !in queue.indices) {
            Log.e(TAG, "√çndice de cola fuera de rango: $startIndex")
            return
        }
        
        Log.d(TAG, "üéµ Iniciando cola desde √≠ndice $startIndex de ${queue.size} tracks")
        
        // Asegurar que ExoPlayer est√© inicializado
        if (_exoPlayer == null) {
            Log.d(TAG, "üîß Inicializando ExoPlayer para cola...")
            initializePlayer()
        }
        
        // Reorganizar la cola: tracks desde startIndex hasta el final
        val reorderedQueue = queue.drop(startIndex).toMutableList()
        
        // Actualizar la cola con la nueva secuencia
        _playbackQueue.postValue(reorderedQueue)
        
        // Activar modo cola
        _isQueueMode.postValue(true)
        updateQueueState()
        
        // Reproducir el primer track de la nueva secuencia
        val success = playNextFromQueue()
        if (success) {
            Log.d(TAG, "‚úÖ Cola iniciada correctamente desde √≠ndice $startIndex")
        } else {
            Log.w(TAG, "‚ùå No se pudo iniciar la cola desde √≠ndice $startIndex")
        }
    }
    
    /**
     * Actualiza el estado de la cola (StateFlow).
     */
    private fun updateQueueState() {
        val queue = _playbackQueue.value ?: emptyList()
        val isActive = _isQueueMode.value ?: false
        
        _queueState.value = QueueState(
            queue = queue.toList(), // Crear copia inmutable
            currentIndex = -1, // Por ahora no trackear √≠ndice espec√≠fico
            isActive = isActive
        )
    }

    // === M√âTODOS DE ESPERA Y SINCRONIZACI√ìN ===
    
    /**
     * Espera a que termine la canci√≥n actual usando el listener de ExoPlayer.
     * √ötil para reproducci√≥n secuencial de playlists.
     * 
     * @return true si termin√≥ naturalmente, false si se cancel√≥ o fall√≥
     */
    suspend fun waitForCurrentSongToFinish(): Boolean {
        return try {
            println("PlayerViewModel: ‚è≥ Esperando a que termine la canci√≥n actual...")
            
            // Verificar que hay una canci√≥n reproduci√©ndose
            val hasPlayback = checkCurrentPlayback()
            if (!hasPlayback) {
                println("PlayerViewModel: ‚ö†Ô∏è No hay canci√≥n reproduci√©ndose")
                return false
            }
            
            // Configurar callback para esperar el final
            playbackEndedCallback = CompletableDeferred()
            
            // Esperar el resultado con timeout
            waitForPlaybackCompletion()
            
        } catch (e: Exception) {
            handleWaitException(e)
        }
    }
    
    /**
     * Verifica si hay una canci√≥n reproduci√©ndose actualmente.
     * @return true si hay reproducci√≥n activa
     */
    private suspend fun checkCurrentPlayback(): Boolean {
        return withContext(Dispatchers.Main) {
            _exoPlayer != null && isPlaying()
        }
    }
    
    /**
     * Espera a que la reproducci√≥n termine con un timeout de seguridad.
     * @return true si termin√≥ correctamente
     */
    private suspend fun waitForPlaybackCompletion(): Boolean {
        return withContext(Dispatchers.IO) {
            // Timeout de 8 minutos (480 segundos) por seguridad
            val timeout = 480000L
            val startTime = System.currentTimeMillis()
            
            // Esperar hasta que termine o se agote el tiempo
            while (playbackEndedCallback != null && !playbackEndedCallback!!.isCompleted) {
                if (System.currentTimeMillis() - startTime > timeout) {
                    println("PlayerViewModel: ‚ö†Ô∏è Timeout esperando fin de canci√≥n")
                    playbackEndedCallback?.complete(false)
                    break
                }
                kotlinx.coroutines.delay(1000)
            }
            
            val result = playbackEndedCallback?.await() ?: false
            playbackEndedCallback = null
            
            println("PlayerViewModel: ${if (result) "‚úÖ" else "‚ö†Ô∏è"} Canci√≥n ${if (result) "terminada" else "cancelada"}")
            result
        }
    }
    
    /**
     * Maneja excepciones durante la espera de finalizaci√≥n.
     * @param e Excepci√≥n ocurrida
     * @return false indicando fallo
     */
    private fun handleWaitException(e: Exception): Boolean {
        println("PlayerViewModel: ‚ùå Error esperando fin de canci√≥n: ${e.message}")
        playbackEndedCallback?.complete(false)
        playbackEndedCallback = null
        return false
    }
    
    /**
     * Cancela la espera del final de la canci√≥n.
     * √ötil cuando se quiere detener la reproducci√≥n secuencial.
     */
    fun cancelWaitForSong() {
        playbackEndedCallback?.complete(false)
        playbackEndedCallback = null
    }
    
    /**
     * Maneja la navegaci√≥n autom√°tica al final de una canci√≥n.
     * Si hay una playlist activa y hay m√°s canciones, navega autom√°ticamente.
     */
    private fun handleAutoNavigation() {
        // Verificar si la auto-navegaci√≥n est√° habilitada
        if (!isAutoNavigationEnabled()) {
            println("PlayerViewModel: üéµ Auto-navegaci√≥n deshabilitada")
            return
        }
        
        CoroutineScope(Dispatchers.Main).launch {
            // Priorizar cola de reproducci√≥n si est√° activa
            val isQueueActive = _isQueueMode.value ?: false
            val queue = _playbackQueue.value
            
            if (isQueueActive && !queue.isNullOrEmpty()) {
                println("PlayerViewModel: üéµ Auto-navegando en modo cola...")
                
                // Peque√±a pausa antes de la siguiente canci√≥n
                kotlinx.coroutines.delay(1000)
                
                // Reproducir siguiente canci√≥n de la cola
                val success = playNextFromQueue()
                if (!success) {
                    println("PlayerViewModel: üéµ Cola terminada, saliendo de modo cola")
                    _isQueueMode.postValue(false)
                    updateQueueState()
                }
                return@launch
            }
            
            // Si no hay cola activa, usar navegaci√≥n de playlist
            val playlist = _currentPlaylist.value
            val currentIndex = _currentTrackIndex.value
            
            // Verificar si hay playlist activa y siguiente canci√≥n disponible
            if (playlist != null && currentIndex != null && 
                currentIndex < playlist.size - 1) {
                
                println("PlayerViewModel: üéµ Auto-navegando a la siguiente canci√≥n de playlist...")
                
                // Peque√±a pausa antes de la siguiente canci√≥n
                kotlinx.coroutines.delay(1000)
                
                // Navegar autom√°ticamente al siguiente track
                navigateToNext()
            } else {
                println("PlayerViewModel: üéµ Fin de playlist o no hay playlist activa")
            }
        }
    }
    
    // === M√âTODOS UTILITARIOS PRIVADOS ===
    
    /**
     * Actualiza el estado de carga y error de forma consistente.
     * @param loading Estado de carga
     * @param errorMessage Mensaje de error (null si no hay error)
     * @param title T√≠tulo a mostrar (opcional)
     */
    private fun updateLoadingState(loading: Boolean, errorMessage: String? = null, title: String? = null) {
        _isLoading.postValue(loading)
        _error.postValue(errorMessage)
        title?.let { _currentTitle.postValue(it) }
    }
    
    /**
     * Maneja excepciones de forma consistente.
     * @param message Mensaje descriptivo del error
     * @param exception Excepci√≥n ocurrida
     */
    private fun handleException(message: String, exception: Exception) {
        Log.e(TAG, "‚ùå $message: ${exception.message}", exception)
        updateLoadingState(false, "$message: ${exception.message}")
    }
    
    // === LIMPIEZA DE RECURSOS ===
    
    /**
     * Limpia los recursos cuando el ViewModel es destruido.
     * Cancela callbacks pendientes y libera el ExoPlayer.
     */
    override fun onCleared() {
        super.onCleared()
        
        // Cancelar cualquier callback pendiente
        playbackEndedCallback?.complete(false)
        playbackEndedCallback = null
        
        // Liberar ExoPlayer en el hilo principal
        mainHandler.post {
            _exoPlayer?.release()
            _exoPlayer = null
        }
    }
    
    /**
     * Estado de la cola de reproducci√≥n.
     * @param queue Lista de tracks en la cola
     * @param currentIndex √çndice del track actual en la cola (-1 si no hay track actual)
     * @param isActive Si la cola est√° activa
     */
    data class QueueState(
        val queue: List<TrackEntity> = emptyList(),
        val currentIndex: Int = -1,
        val isActive: Boolean = false
    )

    /**
     * Diagnostica el estado del ExoPlayer para debugging.
     */
    private fun diagnoseExoPlayerState() {
        Log.d(TAG, "üîç Diagn√≥stico ExoPlayer:")
        Log.d(TAG, "   - ExoPlayer instancia: ${if (_exoPlayer != null) "‚úÖ Existe" else "‚ùå Es null"}")
        _exoPlayer?.let { player ->
            Log.d(TAG, "   - Estado actual: ${player.playbackState}")
            Log.d(TAG, "   - ¬øEst√° reproduci√©ndose?: ${player.isPlaying}")
            Log.d(TAG, "   - ¬øEst√° preparado?: ${player.playbackState == Player.STATE_READY}")
            Log.d(TAG, "   - Duraci√≥n: ${player.duration}")
            Log.d(TAG, "   - Posici√≥n actual: ${player.currentPosition}")
        }
    }
}
