<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt" />
              <option name="originalContent" value="package com.plyr&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.nfc.NfcAdapter&#10;import android.nfc.Tag&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.PlyrTheme&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.NfcReader&#10;&#10;&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private var musicService: MusicService? = null&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            musicService = (service as MusicService.MusicBinder).getService()&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = { player -&gt;&#10;                musicService?.setupMediaSession(player)&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            musicService = null&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#9;&#9;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU &amp;&amp;&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), 123)&#10;        }&#10;&#10;        handleSpotifyCallback(intent)&#10;        enableEdgeToEdge()&#10;&#10;        Intent(this, MusicService::class.java).also {&#10;            startService(it)&#10;            bindService(it, serviceConnection, BIND_AUTO_CREATE)&#10;        }&#10;&#10;        setContent {&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            val theme = remember { mutableStateOf(Config.getTheme(this)) }&#10;&#10;            // Determinar el modo efectivo: 'dark', 'light' o seguir el sistema&#10;            val effectiveDark = when (theme.value) {&#10;                &quot;dark&quot; -&gt; true&#10;                &quot;light&quot; -&gt; false&#10;                &quot;system&quot; -&gt; isSystemInDarkTheme()&#10;                else -&gt; isSystemInDarkTheme()&#10;            }&#10;&#10;            PlyrTheme(darkTheme = effectiveDark) {&#10;                Surface(Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {&#10;                    ReachabilityScaffold {&#10;                    Box(Modifier.fillMaxSize().statusBarsPadding()) {&#10;                        Box(Modifier.fillMaxSize().padding(bottom = 140.dp)) {&#10;                            AudioListScreen(&#10;                                context = this@MainActivity,&#10;                                onVideoSelectedFromSearch = { _, _, results, index -&gt;&#10;                                    playerViewModel.initializePlayer()&#10;&#10;                                    val playlist = results.mapIndexed { i, item -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;search_${item.videoId}_$i&quot;,&#10;                                            playlistId = &quot;search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = &quot;&quot;,&#10;                                            name = item.title,&#10;                                            artists = item.channel,&#10;                                            youtubeVideoId = item.videoId,&#10;                                            audioUrl = null,&#10;                                            position = i,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    playerViewModel.setCurrentPlaylist(playlist, index)&#10;                                    lifecycleScope.launch {&#10;                                        playerViewModel.loadAudioFromTrack(&#10;                                            playlist[index]&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onThemeChanged = { theme.value = it },&#10;                                playerViewModel = playerViewModel&#10;                            )&#10;                        }&#10;&#10;                        FloatingMusicControls(&#10;                            playerViewModel = playerViewModel,&#10;                            modifier = Modifier.align(Alignment.BottomCenter)&#10;                                .padding(bottom = 48.dp)&#10;                        )&#10;                    }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        if (isFinishing) {&#10;            (application as PlyrApp).playerViewModel.pausePlayer()&#10;            stopService(Intent(this, MusicService::class.java))&#10;        }&#10;        unbindService(serviceConnection)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Activar automáticamente la lectura de NFC cuando la app está en primer plano&#10;        NfcReader.startReading(this)&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Desactivar la lectura de NFC cuando la app no está en primer plano&#10;        NfcReader.stopReading(this)&#10;    }&#10;&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;&#10;        // Manejar NFC tag para lectura de URLs&#10;        handleNfcUrlRead(intent)&#10;&#10;        // Manejar NFC tag (existente)&#10;        handleNfcIntent(intent)&#10;&#10;        // Manejar Spotify callback&#10;        handleSpotifyCallback(intent)&#10;    }&#10;&#10;    private fun handleNfcUrlRead(intent: Intent?) {&#10;        if (intent == null) return&#10;&#10;        val url = NfcReader.processNfcIntent(intent)&#10;        if (url != null) {&#10;            val urlType = NfcReader.getUrlType(url)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC URL READ SUCCESS!&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; URL: $url&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; Type: $urlType&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;&#10;            // Detener el modo de lectura después de leer exitosamente&#10;            NfcReader.stopReading(this)&#10;&#10;            // Obtener el resultado parseado y enviarlo al evento global&#10;            val scanResult = NfcReader.consumeScanResult()&#10;            if (scanResult != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot; Sending NFC result to SearchScreen - source: ${scanResult.source}, type: ${scanResult.type}, id: ${scanResult.id}&quot;)&#10;                com.plyr.utils.NfcScanEvent.onNfcScanned(scanResult)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleNfcIntent(intent: Intent?) {&#10;        if (intent?.action == NfcAdapter.ACTION_NDEF_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TECH_DISCOVERED) {&#10;&#10;            val tag: Tag? = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)&#10;            }&#10;&#10;            if (tag != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Tag detected in onNewIntent: $tag&quot;)&#10;                NfcTagEvent.onTagDetected(tag)&#10;            } else {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;⚠️ NFC intent received but tag is null&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;) {&#10;                uri.getQueryParameter(&quot;code&quot;)?.let { code -&gt;&#10;                    SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, error -&gt;&#10;                        if (tokens != null &amp;&amp; error == null) {&#10;                            Config.setSpotifyTokens(this, tokens.accessToken, tokens.refreshToken, tokens.expiresIn)&#10;&#10;                            // Obtener el perfil del usuario y guardar el nombre de usuario&#10;                            SpotifyRepository.getUserProfile(tokens.accessToken) { userProfile, profileError -&gt;&#10;                                if (userProfile != null &amp;&amp; !userProfile.displayName.isNullOrBlank()) {&#10;                                    Config.setSpotifyUserName(this, userProfile.displayName)&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;✓ Nombre de usuario guardado: ${userProfile.displayName}&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;⚠ displayName es null o vacío: ${userProfile?.displayName}&quot;)&#10;                                }&#10;                            }&#10;&#10;                            SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;                        } else {&#10;                            SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;                        }&#10;                    }&#10;                } ?: SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;            }&#10;        }&#10;    }&#10;    @Composable&#10;    fun ReachabilityScaffold(content: @Composable () -&gt; Unit) {&#10;        var lowered by remember { mutableStateOf(false) }&#10;        val density = LocalDensity.current&#10;        val targetOffsetDp = with(density) { (if (lowered) 400f else 0f).toDp() }&#10;        val animatedOffsetDp by animateDpAsState(targetValue = targetOffsetDp)&#10;&#10;        Box(Modifier.fillMaxSize()) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxSize()&#10;                    .offset(y = animatedOffsetDp)&#10;            ) {&#10;                content()&#10;            }&#10;&#10;            // Zona sensible en la parte baja&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .height(80.dp)&#10;                    .align(Alignment.BottomCenter)&#10;                    .pointerInput(Unit) {&#10;                        detectVerticalDragGestures { _, dragAmount -&gt;&#10;                            if (dragAmount &gt; 50) lowered = true&#10;                            if (dragAmount &lt; -50) lowered = false&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.nfc.NfcAdapter&#10;import android.nfc.Tag&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.PlyrTheme&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.NfcReader&#10;&#10;&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private var musicService: MusicService? = null&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            musicService = (service as MusicService.MusicBinder).getService()&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = { player -&gt;&#10;                musicService?.setupMediaSession(player)&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            musicService = null&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#9;&#9;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU &amp;&amp;&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), 123)&#10;        }&#10;&#10;        handleSpotifyCallback(intent)&#10;        enableEdgeToEdge()&#10;&#10;        Intent(this, MusicService::class.java).also {&#10;            startService(it)&#10;            bindService(it, serviceConnection, BIND_AUTO_CREATE)&#10;        }&#10;&#10;        setContent {&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            val theme = remember { mutableStateOf(Config.getTheme(this)) }&#10;&#10;            // Determinar el modo efectivo: 'dark', 'light' o seguir el sistema&#10;            val effectiveDark = when (theme.value) {&#10;                &quot;dark&quot; -&gt; true&#10;                &quot;light&quot; -&gt; false&#10;                &quot;system&quot; -&gt; isSystemInDarkTheme()&#10;                else -&gt; isSystemInDarkTheme()&#10;            }&#10;&#10;            PlyrTheme(darkTheme = effectiveDark) {&#10;                Surface(Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {&#10;                    ReachabilityScaffold {&#10;                    Box(Modifier.fillMaxSize().statusBarsPadding()) {&#10;                        Box(Modifier.fillMaxSize().padding(bottom = 140.dp)) {&#10;                            AudioListScreen(&#10;                                context = this@MainActivity,&#10;                                onVideoSelectedFromSearch = { _, _, results, index -&gt;&#10;                                    playerViewModel.initializePlayer()&#10;&#10;                                    val playlist = results.mapIndexed { i, item -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;search_${item.videoId}_$i&quot;,&#10;                                            playlistId = &quot;search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = &quot;&quot;,&#10;                                            name = item.title,&#10;                                            artists = item.channel,&#10;                                            youtubeVideoId = item.videoId,&#10;                                            audioUrl = null,&#10;                                            position = i,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    playerViewModel.setCurrentPlaylist(playlist, index)&#10;                                    lifecycleScope.launch {&#10;                                        playerViewModel.loadAudioFromTrack(&#10;                                            playlist[index]&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onThemeChanged = { theme.value = it },&#10;                                playerViewModel = playerViewModel&#10;                            )&#10;                        }&#10;&#10;                        FloatingMusicControls(&#10;                            playerViewModel = playerViewModel,&#10;                            modifier = Modifier.align(Alignment.BottomCenter)&#10;                                .padding(bottom = 48.dp)&#10;                        )&#10;                    }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        if (isFinishing) {&#10;            (application as PlyrApp).playerViewModel.pausePlayer()&#10;            stopService(Intent(this, MusicService::class.java))&#10;        }&#10;        unbindService(serviceConnection)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Activar automáticamente la lectura de NFC cuando la app está en primer plano&#10;        NfcReader.startReading(this)&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Desactivar la lectura de NFC cuando la app no está en primer plano&#10;        NfcReader.stopReading(this)&#10;    }&#10;&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;&#10;        // Manejar NFC tag para lectura de URLs&#10;        handleNfcUrlRead(intent)&#10;&#10;        // Manejar NFC tag (existente)&#10;        handleNfcIntent(intent)&#10;&#10;        // Manejar Spotify callback&#10;        handleSpotifyCallback(intent)&#10;    }&#10;&#10;    private fun handleNfcUrlRead(intent: Intent?) {&#10;        if (intent == null) return&#10;&#10;        // Si estamos en modo escritura, no procesar la lectura&#10;        if (NfcTagEvent.isInWriteMode()) {&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Read skipped - Write mode active&quot;)&#10;            return&#10;        }&#10;&#10;        val url = NfcReader.processNfcIntent(intent)&#10;        if (url != null) {&#10;            val urlType = NfcReader.getUrlType(url)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC URL READ SUCCESS!&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; URL: $url&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; Type: $urlType&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;&#10;            // Detener el modo de lectura después de leer exitosamente&#10;            NfcReader.stopReading(this)&#10;&#10;            // Obtener el resultado parseado y enviarlo al evento global&#10;            val scanResult = NfcReader.consumeScanResult()&#10;            if (scanResult != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot; Sending NFC result to SearchScreen - source: ${scanResult.source}, type: ${scanResult.type}, id: ${scanResult.id}&quot;)&#10;                com.plyr.utils.NfcScanEvent.onNfcScanned(scanResult)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleNfcIntent(intent: Intent?) {&#10;        if (intent?.action == NfcAdapter.ACTION_NDEF_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TECH_DISCOVERED) {&#10;&#10;            val tag: Tag? = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)&#10;            }&#10;&#10;            if (tag != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Tag detected in onNewIntent: $tag&quot;)&#10;                NfcTagEvent.onTagDetected(tag)&#10;            } else {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;⚠️ NFC intent received but tag is null&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;) {&#10;                uri.getQueryParameter(&quot;code&quot;)?.let { code -&gt;&#10;                    SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, error -&gt;&#10;                        if (tokens != null &amp;&amp; error == null) {&#10;                            Config.setSpotifyTokens(this, tokens.accessToken, tokens.refreshToken, tokens.expiresIn)&#10;&#10;                            // Obtener el perfil del usuario y guardar el nombre de usuario&#10;                            SpotifyRepository.getUserProfile(tokens.accessToken) { userProfile, profileError -&gt;&#10;                                if (userProfile != null &amp;&amp; !userProfile.displayName.isNullOrBlank()) {&#10;                                    Config.setSpotifyUserName(this, userProfile.displayName)&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;✓ Nombre de usuario guardado: ${userProfile.displayName}&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;⚠ displayName es null o vacío: ${userProfile?.displayName}&quot;)&#10;                                }&#10;                            }&#10;&#10;                            SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;                        } else {&#10;                            SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;                        }&#10;                    }&#10;                } ?: SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;            }&#10;        }&#10;    }&#10;    @Composable&#10;    fun ReachabilityScaffold(content: @Composable () -&gt; Unit) {&#10;        var lowered by remember { mutableStateOf(false) }&#10;        val density = LocalDensity.current&#10;        val targetOffsetDp = with(density) { (if (lowered) 400f else 0f).toDp() }&#10;        val animatedOffsetDp by animateDpAsState(targetValue = targetOffsetDp)&#10;&#10;        Box(Modifier.fillMaxSize()) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxSize()&#10;                    .offset(y = animatedOffsetDp)&#10;            ) {&#10;                content()&#10;            }&#10;&#10;            // Zona sensible en la parte baja&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .height(80.dp)&#10;                    .align(Alignment.BottomCenter)&#10;                    .pointerInput(Unit) {&#10;                        detectVerticalDragGestures { _, dragAmount -&gt;&#10;                            if (dragAmount &gt; 50) lowered = true&#10;                            if (dragAmount &lt; -50) lowered = false&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/QRDialog.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/QRDialog.kt" />
              <option name="originalContent" value="package com.plyr.ui.components&#10;&#10;import android.app.Activity&#10;import android.app.PendingIntent&#10;import android.content.Intent&#10;import android.graphics.Bitmap&#10;import android.nfc.*&#10;import android.nfc.tech.Ndef&#10;import android.nfc.tech.NdefFormatable&#10;import android.os.Build&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.core.graphics.createBitmap&#10;import androidx.core.graphics.set&#10;import com.google.zxing.BarcodeFormat&#10;import com.google.zxing.qrcode.QRCodeWriter&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.Translations&#10;import kotlinx.coroutines.delay&#10;&#10;data class ShareableItem(&#10;    val spotifyId: String?,&#10;    val spotifyUrl: String?,&#10;    val youtubeId: String?,&#10;    val title: String,&#10;    val artist: String,&#10;    val type: ShareType&#10;)&#10;&#10;enum class ShareType {&#10;    TRACK, PLAYLIST, ALBUM, ARTIST, APP&#10;}&#10;&#10;enum class NfcWriteState {&#10;    IDLE,&#10;    WAITING,&#10;    SUCCESS,&#10;    ERROR&#10;}&#10;&#10;@Composable&#10;fun ShareDialog(item: ShareableItem, onDismiss: () -&gt; Unit) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    val shareUrl = item.spotifyUrl ?: when {&#10;        item.type == ShareType.APP -&gt; &quot;https://github.com/josemri/plyr/releases/download/latest/plyr.apk&quot;&#10;        item.spotifyId != null -&gt; &quot;https://open.spotify.com/${item.type.name.lowercase()}/${item.spotifyId}&quot;&#10;        item.youtubeId != null -&gt; &quot;https://www.youtube.com/watch?v=${item.youtubeId}&quot;&#10;        else -&gt; null&#10;    }&#10;&#10;    var nfcState by remember { mutableStateOf(NfcWriteState.IDLE) }&#10;    var nfcAdapter by remember { mutableStateOf&lt;NfcAdapter?&gt;(null) }&#10;&#10;    val detectedTag by NfcTagEvent.detectedTag.collectAsState()&#10;&#10;    // Procesar el tag cuando se detecte&#10;    LaunchedEffect(detectedTag) {&#10;        val tag = detectedTag&#10;        if (tag != null &amp;&amp; nfcState == NfcWriteState.WAITING &amp;&amp; shareUrl != null) {&#10;            val fullUrl = if (!shareUrl.startsWith(&quot;http://&quot;) &amp;&amp; !shareUrl.startsWith(&quot;https://&quot;)) {&#10;                &quot;https://$shareUrl&quot;&#10;            } else {&#10;                shareUrl&#10;            }&#10;            val message = NdefMessage(arrayOf(NdefRecord.createUri(fullUrl)))&#10;            val success = writeNdefMessageToTag(tag, message)&#10;            nfcState = if (success) NfcWriteState.SUCCESS else NfcWriteState.ERROR&#10;            NfcTagEvent.clear()&#10;        }&#10;    }&#10;&#10;    // Inicializar NFC adapter&#10;    LaunchedEffect(Unit) {&#10;        nfcAdapter = NfcAdapter.getDefaultAdapter(context)&#10;    }&#10;&#10;    // Manejar el foreground dispatch para NFC&#10;    DisposableEffect(lifecycleOwner, nfcState) {&#10;        val activity = context as? Activity&#10;        val adapter = nfcAdapter&#10;&#10;        if (activity != null &amp;&amp; adapter != null &amp;&amp; nfcState == NfcWriteState.WAITING) {&#10;            val intent = Intent(context, activity::class.java).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)&#10;            val flags = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S)&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;            else PendingIntent.FLAG_UPDATE_CURRENT&#10;            val pendingIntent = PendingIntent.getActivity(context, 0, intent, flags)&#10;            try {&#10;                adapter.enableForegroundDispatch(activity, pendingIntent, null, null)&#10;            } catch (_: Exception) {}&#10;        }&#10;&#10;        onDispose {&#10;            if (activity != null &amp;&amp; adapter != null) {&#10;                try {&#10;                    adapter.disableForegroundDispatch(activity)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }&#10;    }&#10;&#10;    // Resetear estado después de éxito/error&#10;    LaunchedEffect(nfcState) {&#10;        if (nfcState == NfcWriteState.SUCCESS || nfcState == NfcWriteState.ERROR) {&#10;            delay(2000)&#10;            nfcState = NfcWriteState.IDLE&#10;        }&#10;    }&#10;&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            shape = RoundedCornerShape(16.dp),&#10;            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                if (shareUrl != null) {&#10;                    val qrBitmap = generateQrBitmap(shareUrl)&#10;                    if (qrBitmap != null) {&#10;                        Card(&#10;                            modifier = Modifier.size(220.dp),&#10;                            shape = RoundedCornerShape(8.dp),&#10;                            colors = CardDefaults.cardColors(containerColor = Color.White)&#10;                        ) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize().padding(8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Image(&#10;                                    bitmap = qrBitmap.asImageBitmap(),&#10;                                    contentDescription = &quot;QR Code&quot;,&#10;                                    modifier = Modifier.fillMaxSize()&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Error generando QR&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(fontFamily = FontFamily.Monospace)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    if (shareUrl != null) {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;btn_share&quot;),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier&#10;                                .clickable {&#10;                                    val sendIntent = Intent().apply {&#10;                                        action = Intent.ACTION_SEND&#10;                                        putExtra(Intent.EXTRA_TEXT, shareUrl)&#10;                                        type = &quot;text/plain&quot;&#10;                                    }&#10;                                    val chooserIntent = Intent.createChooser(sendIntent, &quot;Compartir via&quot;)&#10;                                    chooserIntent.flags = Intent.FLAG_ACTIVITY_NEW_TASK&#10;                                    context.startActivity(chooserIntent)&#10;                                }&#10;                                .padding(8.dp)&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                        NfcButton(&#10;                            state = nfcState,&#10;                            onToggle = {&#10;                                when (nfcState) {&#10;                                    NfcWriteState.IDLE -&gt; {&#10;                                        nfcState = if (nfcAdapter == null || nfcAdapter?.isEnabled == false) {&#10;                                            NfcWriteState.ERROR&#10;                                        } else {&#10;                                            NfcWriteState.WAITING&#10;                                        }&#10;                                    }&#10;                                    NfcWriteState.WAITING -&gt; nfcState = NfcWriteState.IDLE&#10;                                    else -&gt; {}&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NfcButton(&#10;    state: NfcWriteState,&#10;    onToggle: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val rings = remember { mutableStateListOf&lt;Int&gt;() }&#10;    var frameCounter by remember { mutableStateOf(0) }&#10;    val width = 11&#10;    val center = width / 2&#10;&#10;    LaunchedEffect(state) {&#10;        if (state == NfcWriteState.WAITING) {&#10;            rings.clear()&#10;            frameCounter = 0&#10;            while (state == NfcWriteState.WAITING) {&#10;                frameCounter++&#10;                if (frameCounter % 3 == 0) rings.add(0)&#10;                for (i in rings.indices) rings[i] = rings[i] + 1&#10;                rings.removeAll { r -&gt; (center - r &lt; 0) &amp;&amp; (center + r &gt; width - 1) }&#10;                delay(200L)&#10;            }&#10;            rings.clear()&#10;        } else {&#10;            rings.clear()&#10;            frameCounter = 0&#10;        }&#10;    }&#10;&#10;    val displayText = when (state) {&#10;        NfcWriteState.IDLE, NfcWriteState.SUCCESS, NfcWriteState.ERROR -&gt; Translations.get(context, &quot;btn_nfc&quot;)&#10;        NfcWriteState.WAITING -&gt; {&#10;            val chars = CharArray(width) { ' ' }&#10;            for (r in rings) {&#10;                val left = center - r&#10;                val right = center + r&#10;                if (left == right &amp;&amp; left in 0 until width) {&#10;                    chars[left] = '•'&#10;                } else {&#10;                    if (left in 0 until width) chars[left] = '('&#10;                    if (right in 0 until width) chars[right] = ')'&#10;                }&#10;            }&#10;            String(chars)&#10;        }&#10;    }&#10;&#10;    val textColor = when (state) {&#10;        NfcWriteState.IDLE -&gt; MaterialTheme.colorScheme.secondary&#10;        NfcWriteState.WAITING -&gt; MaterialTheme.colorScheme.primary&#10;        NfcWriteState.SUCCESS -&gt; Color(0xFF4CAF50)&#10;        NfcWriteState.ERROR -&gt; Color(0xFFFF5252)&#10;    }&#10;&#10;    Text(&#10;        text = displayText,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 16.sp,&#10;            color = textColor&#10;        ),&#10;        modifier = Modifier&#10;            .clickable(enabled = state != NfcWriteState.SUCCESS &amp;&amp; state != NfcWriteState.ERROR) { onToggle() }&#10;            .padding(8.dp)&#10;    )&#10;}&#10;&#10;private fun writeNdefMessageToTag(tag: Tag, message: NdefMessage): Boolean {&#10;    return try {&#10;        val ndef = Ndef.get(tag)&#10;        if (ndef != null) {&#10;            ndef.connect()&#10;            if (!ndef.isWritable || ndef.maxSize &lt; message.toByteArray().size) {&#10;                ndef.close()&#10;                return false&#10;            }&#10;            ndef.writeNdefMessage(message)&#10;            ndef.close()&#10;            true&#10;        } else {&#10;            val format = NdefFormatable.get(tag) ?: return false&#10;            format.connect()&#10;            format.format(message)&#10;            format.close()&#10;            true&#10;        }&#10;    } catch (_: Exception) {&#10;        false&#10;    }&#10;}&#10;&#10;fun generateQrBitmap(content: String): Bitmap? {&#10;    return try {&#10;        val size = 512&#10;        val bits = QRCodeWriter().encode(content, BarcodeFormat.QR_CODE, size, size)&#10;        val bmp = createBitmap(size, size, Bitmap.Config.RGB_565)&#10;        for (x in 0 until size) {&#10;            for (y in 0 until size) {&#10;                bmp[x, y] = if (bits[x, y]) android.graphics.Color.BLACK else android.graphics.Color.WHITE&#10;            }&#10;        }&#10;        bmp&#10;    } catch (_: Exception) {&#10;        null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components&#10;&#10;import android.app.Activity&#10;import android.app.PendingIntent&#10;import android.content.Intent&#10;import android.graphics.Bitmap&#10;import android.nfc.*&#10;import android.nfc.tech.Ndef&#10;import android.nfc.tech.NdefFormatable&#10;import android.os.Build&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.graphics.asImageBitmap&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalLifecycleOwner&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.core.graphics.createBitmap&#10;import androidx.core.graphics.set&#10;import com.google.zxing.BarcodeFormat&#10;import com.google.zxing.qrcode.QRCodeWriter&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.Translations&#10;import kotlinx.coroutines.delay&#10;&#10;data class ShareableItem(&#10;    val spotifyId: String?,&#10;    val spotifyUrl: String?,&#10;    val youtubeId: String?,&#10;    val title: String,&#10;    val artist: String,&#10;    val type: ShareType&#10;)&#10;&#10;enum class ShareType {&#10;    TRACK, PLAYLIST, ALBUM, ARTIST, APP&#10;}&#10;&#10;enum class NfcWriteState {&#10;    IDLE,&#10;    WAITING,&#10;    SUCCESS,&#10;    ERROR&#10;}&#10;&#10;@Composable&#10;fun ShareDialog(item: ShareableItem, onDismiss: () -&gt; Unit) {&#10;    val context = LocalContext.current&#10;    val lifecycleOwner = LocalLifecycleOwner.current&#10;&#10;    val shareUrl = item.spotifyUrl ?: when {&#10;        item.type == ShareType.APP -&gt; &quot;https://github.com/josemri/plyr/releases/download/latest/plyr.apk&quot;&#10;        item.spotifyId != null -&gt; &quot;https://open.spotify.com/${item.type.name.lowercase()}/${item.spotifyId}&quot;&#10;        item.youtubeId != null -&gt; &quot;https://www.youtube.com/watch?v=${item.youtubeId}&quot;&#10;        else -&gt; null&#10;    }&#10;&#10;    var nfcState by remember { mutableStateOf(NfcWriteState.IDLE) }&#10;    var nfcAdapter by remember { mutableStateOf&lt;NfcAdapter?&gt;(null) }&#10;&#10;    val detectedTag by NfcTagEvent.detectedTag.collectAsState()&#10;&#10;    // Procesar el tag cuando se detecte&#10;    LaunchedEffect(detectedTag) {&#10;        val tag = detectedTag&#10;        if (tag != null &amp;&amp; nfcState == NfcWriteState.WAITING &amp;&amp; shareUrl != null) {&#10;            val fullUrl = if (!shareUrl.startsWith(&quot;http://&quot;) &amp;&amp; !shareUrl.startsWith(&quot;https://&quot;)) {&#10;                &quot;https://$shareUrl&quot;&#10;            } else {&#10;                shareUrl&#10;            }&#10;            val message = NdefMessage(arrayOf(NdefRecord.createUri(fullUrl)))&#10;            val success = writeNdefMessageToTag(tag, message)&#10;            nfcState = if (success) NfcWriteState.SUCCESS else NfcWriteState.ERROR&#10;            NfcTagEvent.clear()&#10;        }&#10;    }&#10;&#10;    // Inicializar NFC adapter&#10;    LaunchedEffect(Unit) {&#10;        nfcAdapter = NfcAdapter.getDefaultAdapter(context)&#10;    }&#10;&#10;    // Manejar el foreground dispatch para NFC&#10;    DisposableEffect(lifecycleOwner, nfcState) {&#10;        val activity = context as? Activity&#10;        val adapter = nfcAdapter&#10;&#10;        if (activity != null &amp;&amp; adapter != null &amp;&amp; nfcState == NfcWriteState.WAITING) {&#10;            val intent = Intent(context, activity::class.java).addFlags(Intent.FLAG_ACTIVITY_SINGLE_TOP)&#10;            val flags = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.S)&#10;                PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_MUTABLE&#10;            else PendingIntent.FLAG_UPDATE_CURRENT&#10;            val pendingIntent = PendingIntent.getActivity(context, 0, intent, flags)&#10;            try {&#10;                adapter.enableForegroundDispatch(activity, pendingIntent, null, null)&#10;            } catch (_: Exception) {}&#10;        }&#10;&#10;        onDispose {&#10;            if (activity != null &amp;&amp; adapter != null) {&#10;                try {&#10;                    adapter.disableForegroundDispatch(activity)&#10;                } catch (_: Exception) {}&#10;            }&#10;        }&#10;    }&#10;&#10;    // Resetear estado después de éxito/error&#10;    LaunchedEffect(nfcState) {&#10;        if (nfcState == NfcWriteState.SUCCESS || nfcState == NfcWriteState.ERROR) {&#10;            delay(2000)&#10;            nfcState = NfcWriteState.IDLE&#10;        }&#10;    }&#10;&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Card(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(16.dp),&#10;            shape = RoundedCornerShape(16.dp),&#10;            colors = CardDefaults.cardColors(containerColor = MaterialTheme.colorScheme.surface)&#10;        ) {&#10;            Column(&#10;                modifier = Modifier.padding(24.dp),&#10;                horizontalAlignment = Alignment.CenterHorizontally,&#10;                verticalArrangement = Arrangement.spacedBy(16.dp)&#10;            ) {&#10;                if (shareUrl != null) {&#10;                    val qrBitmap = generateQrBitmap(shareUrl)&#10;                    if (qrBitmap != null) {&#10;                        Card(&#10;                            modifier = Modifier.size(220.dp),&#10;                            shape = RoundedCornerShape(8.dp),&#10;                            colors = CardDefaults.cardColors(containerColor = Color.White)&#10;                        ) {&#10;                            Box(&#10;                                modifier = Modifier.fillMaxSize().padding(8.dp),&#10;                                contentAlignment = Alignment.Center&#10;                            ) {&#10;                                Image(&#10;                                    bitmap = qrBitmap.asImageBitmap(),&#10;                                    contentDescription = &quot;QR Code&quot;,&#10;                                    modifier = Modifier.fillMaxSize()&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Text(&#10;                            text = &quot;Error generando QR&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(fontFamily = FontFamily.Monospace)&#10;                        )&#10;                    }&#10;                }&#10;&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.Center,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    if (shareUrl != null) {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;btn_share&quot;),&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier&#10;                                .clickable {&#10;                                    val sendIntent = Intent().apply {&#10;                                        action = Intent.ACTION_SEND&#10;                                        putExtra(Intent.EXTRA_TEXT, shareUrl)&#10;                                        type = &quot;text/plain&quot;&#10;                                    }&#10;                                    val chooserIntent = Intent.createChooser(sendIntent, &quot;Compartir via&quot;)&#10;                                    chooserIntent.flags = Intent.FLAG_ACTIVITY_NEW_TASK&#10;                                    context.startActivity(chooserIntent)&#10;                                }&#10;                                .padding(8.dp)&#10;                        )&#10;&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;&#10;                        NfcButton(&#10;                            state = nfcState,&#10;                            onToggle = {&#10;                                when (nfcState) {&#10;                                    NfcWriteState.IDLE -&gt; {&#10;                                        nfcState = if (nfcAdapter == null || nfcAdapter?.isEnabled == false) {&#10;                                            NfcWriteState.ERROR&#10;                                        } else {&#10;                                            NfcWriteState.WAITING&#10;                                        }&#10;                                    }&#10;                                    NfcWriteState.WAITING -&gt; nfcState = NfcWriteState.IDLE&#10;                                    else -&gt; {}&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun NfcButton(&#10;    state: NfcWriteState,&#10;    onToggle: () -&gt; Unit&#10;) {&#10;    val context = LocalContext.current&#10;    val rings = remember { mutableStateListOf&lt;Int&gt;() }&#10;    var frameCounter by remember { mutableStateOf(0) }&#10;    val width = 11&#10;    val center = width / 2&#10;&#10;    // Activar/desactivar modo escritura global cuando cambia el estado&#10;    LaunchedEffect(state) {&#10;        NfcTagEvent.setWriteMode(state == NfcWriteState.WAITING)&#10;    }&#10;&#10;    // Asegurar que se desactiva el modo escritura cuando el componente se desmonta&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            NfcTagEvent.setWriteMode(false)&#10;        }&#10;    }&#10;&#10;    LaunchedEffect(state) {&#10;        if (state == NfcWriteState.WAITING) {&#10;            rings.clear()&#10;            frameCounter = 0&#10;            while (state == NfcWriteState.WAITING) {&#10;                frameCounter++&#10;                if (frameCounter % 3 == 0) rings.add(0)&#10;                for (i in rings.indices) rings[i] = rings[i] + 1&#10;                rings.removeAll { r -&gt; (center - r &lt; 0) &amp;&amp; (center + r &gt; width - 1) }&#10;                delay(200L)&#10;            }&#10;            rings.clear()&#10;        } else {&#10;            rings.clear()&#10;            frameCounter = 0&#10;        }&#10;    }&#10;&#10;    val displayText = when (state) {&#10;        NfcWriteState.IDLE, NfcWriteState.SUCCESS, NfcWriteState.ERROR -&gt; Translations.get(context, &quot;btn_nfc&quot;)&#10;        NfcWriteState.WAITING -&gt; {&#10;            val chars = CharArray(width) { ' ' }&#10;            for (r in rings) {&#10;                val left = center - r&#10;                val right = center + r&#10;                if (left == right &amp;&amp; left in 0 until width) {&#10;                    chars[left] = '•'&#10;                } else {&#10;                    if (left in 0 until width) chars[left] = '('&#10;                    if (right in 0 until width) chars[right] = ')'&#10;                }&#10;            }&#10;            String(chars)&#10;        }&#10;    }&#10;&#10;    val textColor = when (state) {&#10;        NfcWriteState.IDLE -&gt; MaterialTheme.colorScheme.secondary&#10;        NfcWriteState.WAITING -&gt; MaterialTheme.colorScheme.primary&#10;        NfcWriteState.SUCCESS -&gt; Color(0xFF4CAF50)&#10;        NfcWriteState.ERROR -&gt; Color(0xFFFF5252)&#10;    }&#10;&#10;    Text(&#10;        text = displayText,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 16.sp,&#10;            color = textColor&#10;        ),&#10;        modifier = Modifier&#10;            .clickable(enabled = state != NfcWriteState.SUCCESS &amp;&amp; state != NfcWriteState.ERROR) { onToggle() }&#10;            .padding(8.dp)&#10;    )&#10;}&#10;&#10;private fun writeNdefMessageToTag(tag: Tag, message: NdefMessage): Boolean {&#10;    return try {&#10;        val ndef = Ndef.get(tag)&#10;        if (ndef != null) {&#10;            ndef.connect()&#10;            if (!ndef.isWritable || ndef.maxSize &lt; message.toByteArray().size) {&#10;                ndef.close()&#10;                return false&#10;            }&#10;            ndef.writeNdefMessage(message)&#10;            ndef.close()&#10;            true&#10;        } else {&#10;            val format = NdefFormatable.get(tag) ?: return false&#10;            format.connect()&#10;            format.format(message)&#10;            format.close()&#10;            true&#10;        }&#10;    } catch (_: Exception) {&#10;        false&#10;    }&#10;}&#10;&#10;fun generateQrBitmap(content: String): Bitmap? {&#10;    return try {&#10;        val size = 512&#10;        val bits = QRCodeWriter().encode(content, BarcodeFormat.QR_CODE, size, size)&#10;        val bmp = createBitmap(size, size, Bitmap.Config.RGB_565)&#10;        for (x in 0 until size) {&#10;            for (y in 0 until size) {&#10;                bmp[x, y] = if (bits[x, y]) android.graphics.Color.BLACK else android.graphics.Color.WHITE&#10;            }&#10;        }&#10;        bmp&#10;    } catch (_: Exception) {&#10;        null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/NfcTagEvent.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/NfcTagEvent.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.nfc.Tag&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;/**&#10; * Singleton para comunicar eventos de tags NFC detectados&#10; * entre la MainActivity y los composables que necesitan escribir NFC&#10; */&#10;object NfcTagEvent {&#10;    private val _detectedTag = MutableStateFlow&lt;Tag?&gt;(null)&#10;    val detectedTag: StateFlow&lt;Tag?&gt; = _detectedTag.asStateFlow()&#10;&#10;    fun onTagDetected(tag: Tag) {&#10;        android.util.Log.d(&quot;NfcTagEvent&quot;, &quot;️ Tag detected and stored: $tag&quot;)&#10;        _detectedTag.value = tag&#10;    }&#10;&#10;    fun consumeTag(): Tag? {&#10;        val tag = _detectedTag.value&#10;        _detectedTag.value = null&#10;        return tag&#10;    }&#10;&#10;    fun clear() {&#10;        _detectedTag.value = null&#10;    }&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.nfc.Tag&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;&#10;/**&#10; * Singleton para comunicar eventos de tags NFC detectados&#10; * entre la MainActivity y los composables que necesitan escribir NFC&#10; */&#10;object NfcTagEvent {&#10;    private val _detectedTag = MutableStateFlow&lt;Tag?&gt;(null)&#10;    val detectedTag: StateFlow&lt;Tag?&gt; = _detectedTag.asStateFlow()&#10;&#10;    // Estado que indica si estamos en modo escritura (bloquea la lectura automática)&#10;    private val _isWriteMode = MutableStateFlow(false)&#10;    val isWriteMode: StateFlow&lt;Boolean&gt; = _isWriteMode.asStateFlow()&#10;&#10;    fun onTagDetected(tag: Tag) {&#10;        android.util.Log.d(&quot;NfcTagEvent&quot;, &quot;️ Tag detected and stored: $tag&quot;)&#10;        _detectedTag.value = tag&#10;    }&#10;&#10;    fun consumeTag(): Tag? {&#10;        val tag = _detectedTag.value&#10;        _detectedTag.value = null&#10;        return tag&#10;    }&#10;&#10;    fun clear() {&#10;        _detectedTag.value = null&#10;    }&#10;&#10;    fun setWriteMode(enabled: Boolean) {&#10;        android.util.Log.d(&quot;NfcTagEvent&quot;, &quot;✏️ NFC Write mode: $enabled&quot;)&#10;        _isWriteMode.value = enabled&#10;    }&#10;&#10;    fun isInWriteMode(): Boolean = _isWriteMode.value&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>