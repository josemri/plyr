<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt" />
              <option name="originalContent" value="package com.plyr&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.nfc.NfcAdapter&#10;import android.nfc.Tag&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.PlyrTheme&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.utils.ShakeDetector&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.NfcReader&#10;&#10;&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private var musicService: MusicService? = null&#10;    private var shakeDetector: ShakeDetector? = null&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            musicService = (service as MusicService.MusicBinder).getService()&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = { player -&gt;&#10;                musicService?.setupMediaSession(player)&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            musicService = null&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#9;&#9;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU &amp;&amp;&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), 123)&#10;        }&#10;&#10;        handleSpotifyCallback(intent)&#10;        enableEdgeToEdge()&#10;&#10;        // Inicializar ShakeDetector&#10;        initializeShakeDetector()&#10;&#10;        Intent(this, MusicService::class.java).also {&#10;            startService(it)&#10;            bindService(it, serviceConnection, BIND_AUTO_CREATE)&#10;        }&#10;&#10;        setContent {&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            val theme = remember { mutableStateOf(Config.getTheme(this)) }&#10;&#10;            // Determinar el modo efectivo: 'dark', 'light' o seguir el sistema&#10;            val effectiveDark = when (theme.value) {&#10;                &quot;dark&quot; -&gt; true&#10;                &quot;light&quot; -&gt; false&#10;                &quot;system&quot; -&gt; isSystemInDarkTheme()&#10;                else -&gt; isSystemInDarkTheme()&#10;            }&#10;&#10;            PlyrTheme(darkTheme = effectiveDark) {&#10;                Surface(Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {&#10;                    ReachabilityScaffold {&#10;                    Box(Modifier.fillMaxSize().statusBarsPadding()) {&#10;                        Box(Modifier.fillMaxSize().padding(bottom = 140.dp)) {&#10;                            AudioListScreen(&#10;                                context = this@MainActivity,&#10;                                onVideoSelectedFromSearch = { _, _, results, index -&gt;&#10;                                    playerViewModel.initializePlayer()&#10;&#10;                                    val playlist = results.mapIndexed { i, item -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;search_${item.videoId}_$i&quot;,&#10;                                            playlistId = &quot;search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = &quot;&quot;,&#10;                                            name = item.title,&#10;                                            artists = item.channel,&#10;                                            youtubeVideoId = item.videoId,&#10;                                            audioUrl = null,&#10;                                            position = i,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    playerViewModel.setCurrentPlaylist(playlist, index)&#10;                                    lifecycleScope.launch {&#10;                                        playerViewModel.loadAudioFromTrack(&#10;                                            playlist[index]&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onThemeChanged = { theme.value = it },&#10;                                playerViewModel = playerViewModel&#10;                            )&#10;                        }&#10;&#10;                        FloatingMusicControls(&#10;                            playerViewModel = playerViewModel,&#10;                            modifier = Modifier.align(Alignment.BottomCenter)&#10;                                .padding(bottom = 48.dp)&#10;                        )&#10;                    }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeShakeDetector() {&#10;        val playerViewModel = (application as PlyrApp).playerViewModel&#10;&#10;        shakeDetector = ShakeDetector(this) { action -&gt;&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; Shake action received: $action&quot;)&#10;&#10;            when (action) {&#10;                ShakeDetector.ACTION_NEXT -&gt; {&#10;                    playerViewModel.navigateToNext()&#10;                }&#10;                ShakeDetector.ACTION_PREVIOUS -&gt; {&#10;                    playerViewModel.navigateToPrevious()&#10;                }&#10;                ShakeDetector.ACTION_PLAY_PAUSE -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player?.isPlaying == true) {&#10;                        playerViewModel.pausePlayer()&#10;                    } else {&#10;                        playerViewModel.playPlayer()&#10;                    }&#10;                }&#10;                ShakeDetector.ACTION_SHUFFLE -&gt; {&#10;                    // Mezclar la playlist actual&#10;                    val currentPlaylist = playerViewModel.currentPlaylist.value&#10;                    if (currentPlaylist != null &amp;&amp; currentPlaylist.size &gt; 1) {&#10;                        val shuffled = currentPlaylist.shuffled()&#10;                        playerViewModel.setCurrentPlaylist(shuffled, 0)&#10;                        lifecycleScope.launch {&#10;                            playerViewModel.loadAudioFromTrack(shuffled[0])&#10;                        }&#10;                    }&#10;                }&#10;                ShakeDetector.ACTION_ASSISTANT -&gt; {&#10;                    // Activar el asistente de voz (si está habilitado)&#10;                    if (Config.isAssistantEnabled(this)) {&#10;                        // TODO: Implementar activación del asistente&#10;                        android.util.Log.d(&quot;MainActivity&quot;, &quot; Assistant activation requested via shake&quot;)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        shakeDetector?.stop()&#10;        if (isFinishing) {&#10;            (application as PlyrApp).playerViewModel.pausePlayer()&#10;            stopService(Intent(this, MusicService::class.java))&#10;        }&#10;        unbindService(serviceConnection)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Activar automáticamente la lectura de NFC cuando la app está en primer plano&#10;        NfcReader.startReading(this)&#10;        // Iniciar detección de shake&#10;        shakeDetector?.start()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Desactivar la lectura de NFC cuando la app no está en primer plano&#10;        NfcReader.stopReading(this)&#10;        // Detener detección de shake&#10;        shakeDetector?.stop()&#10;    }&#10;&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;&#10;        // Manejar NFC tag (existente)&#10;        handleNfcIntent(intent)&#10;&#10;        // Manejar NFC tag para lectura de URLs&#10;        handleNfcUrlRead(intent)&#10;&#10;        // Manejar Spotify callback&#10;        handleSpotifyCallback(intent)&#10;    }&#10;&#10;    private fun handleNfcUrlRead(intent: Intent?) {&#10;        if (intent == null) return&#10;&#10;        // Si estamos en modo escritura, no procesar la lectura para navegación&#10;        // (pero el intent ya fue capturado, así que no se abrirá en el navegador)&#10;        if (NfcTagEvent.isInWriteMode()) {&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Read skipped - Write mode active (tag captured for writing)&quot;)&#10;            return&#10;        }&#10;&#10;        val url = NfcReader.processNfcIntent(intent)&#10;        if (url != null) {&#10;            val urlType = NfcReader.getUrlType(url)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC URL READ SUCCESS!&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; URL: $url&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; Type: $urlType&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;&#10;            // Detener el modo de lectura después de leer exitosamente&#10;            NfcReader.stopReading(this)&#10;&#10;            // Obtener el resultado parseado y enviarlo al evento global&#10;            val scanResult = NfcReader.consumeScanResult()&#10;            if (scanResult != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot; Sending NFC result to SearchScreen - source: ${scanResult.source}, type: ${scanResult.type}, id: ${scanResult.id}&quot;)&#10;                com.plyr.utils.NfcScanEvent.onNfcScanned(scanResult)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleNfcIntent(intent: Intent?) {&#10;        if (intent?.action == NfcAdapter.ACTION_NDEF_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TECH_DISCOVERED) {&#10;&#10;            val tag: Tag? = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)&#10;            }&#10;&#10;            if (tag != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Tag detected in onNewIntent: $tag&quot;)&#10;                NfcTagEvent.onTagDetected(tag)&#10;            } else {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;⚠️ NFC intent received but tag is null&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;) {&#10;                uri.getQueryParameter(&quot;code&quot;)?.let { code -&gt;&#10;                    SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, error -&gt;&#10;                        if (tokens != null &amp;&amp; error == null) {&#10;                            Config.setSpotifyTokens(this, tokens.accessToken, tokens.refreshToken, tokens.expiresIn)&#10;&#10;                            // Obtener el perfil del usuario y guardar el nombre de usuario&#10;                            SpotifyRepository.getUserProfile(tokens.accessToken) { userProfile, profileError -&gt;&#10;                                if (userProfile != null &amp;&amp; !userProfile.displayName.isNullOrBlank()) {&#10;                                    Config.setSpotifyUserName(this, userProfile.displayName)&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;✓ Nombre de usuario guardado: ${userProfile.displayName}&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;⚠ displayName es null o vacío: ${userProfile?.displayName}&quot;)&#10;                                }&#10;                            }&#10;&#10;                            SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;                        } else {&#10;                            SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;                        }&#10;                    }&#10;                } ?: SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;            }&#10;        }&#10;    }&#10;    @Composable&#10;    fun ReachabilityScaffold(content: @Composable () -&gt; Unit) {&#10;        var lowered by remember { mutableStateOf(false) }&#10;        val density = LocalDensity.current&#10;        val targetOffsetDp = with(density) { (if (lowered) 400f else 0f).toDp() }&#10;        val animatedOffsetDp by animateDpAsState(targetValue = targetOffsetDp)&#10;&#10;        Box(Modifier.fillMaxSize()) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxSize()&#10;                    .offset(y = animatedOffsetDp)&#10;            ) {&#10;                content()&#10;            }&#10;&#10;            // Zona sensible en la parte baja&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .height(80.dp)&#10;                    .align(Alignment.BottomCenter)&#10;                    .pointerInput(Unit) {&#10;                        detectVerticalDragGestures { _, dragAmount -&gt;&#10;                            if (dragAmount &gt; 50) lowered = true&#10;                            if (dragAmount &lt; -50) lowered = false&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr&#10;&#10;import android.Manifest&#10;import android.content.ComponentName&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.content.pm.PackageManager&#10;import android.nfc.NfcAdapter&#10;import android.nfc.Tag&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.core.app.ActivityCompat&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.PlyrTheme&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.utils.ShakeDetector&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.animation.core.Spring&#10;import androidx.compose.animation.core.spring&#10;import androidx.compose.animation.core.animateDpAsState&#10;import androidx.compose.foundation.layout.offset&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.layout.fillMaxWidth&#10;import androidx.compose.foundation.layout.height&#10;import androidx.compose.foundation.isSystemInDarkTheme&#10;import com.plyr.utils.NfcTagEvent&#10;import com.plyr.utils.NfcReader&#10;import com.plyr.utils.AssistantActivationEvent&#10;&#10;&#10;&#10;class MainActivity : ComponentActivity() {&#10;    private var musicService: MusicService? = null&#10;    private var shakeDetector: ShakeDetector? = null&#10;&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            musicService = (service as MusicService.MusicBinder).getService()&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = { player -&gt;&#10;                musicService?.setupMediaSession(player)&#10;            }&#10;        }&#10;&#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            musicService = null&#10;            (application as PlyrApp).playerViewModel.onMediaSessionUpdate = null&#10;        }&#10;    }&#10;&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;&#9;&#9;if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU &amp;&amp;&#10;            ContextCompat.checkSelfPermission(this, Manifest.permission.POST_NOTIFICATIONS) != PackageManager.PERMISSION_GRANTED) {&#10;            ActivityCompat.requestPermissions(this, arrayOf(Manifest.permission.POST_NOTIFICATIONS), 123)&#10;        }&#10;&#10;        handleSpotifyCallback(intent)&#10;        enableEdgeToEdge()&#10;&#10;        // Inicializar ShakeDetector&#10;        initializeShakeDetector()&#10;&#10;        Intent(this, MusicService::class.java).also {&#10;            startService(it)&#10;            bindService(it, serviceConnection, BIND_AUTO_CREATE)&#10;        }&#10;&#10;        setContent {&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            val theme = remember { mutableStateOf(Config.getTheme(this)) }&#10;&#10;            // Determinar el modo efectivo: 'dark', 'light' o seguir el sistema&#10;            val effectiveDark = when (theme.value) {&#10;                &quot;dark&quot; -&gt; true&#10;                &quot;light&quot; -&gt; false&#10;                &quot;system&quot; -&gt; isSystemInDarkTheme()&#10;                else -&gt; isSystemInDarkTheme()&#10;            }&#10;&#10;            PlyrTheme(darkTheme = effectiveDark) {&#10;                Surface(Modifier.fillMaxSize(), color = MaterialTheme.colorScheme.background) {&#10;                    ReachabilityScaffold {&#10;                    Box(Modifier.fillMaxSize().statusBarsPadding()) {&#10;                        Box(Modifier.fillMaxSize().padding(bottom = 140.dp)) {&#10;                            AudioListScreen(&#10;                                context = this@MainActivity,&#10;                                onVideoSelectedFromSearch = { _, _, results, index -&gt;&#10;                                    playerViewModel.initializePlayer()&#10;&#10;                                    val playlist = results.mapIndexed { i, item -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;search_${item.videoId}_$i&quot;,&#10;                                            playlistId = &quot;search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = &quot;&quot;,&#10;                                            name = item.title,&#10;                                            artists = item.channel,&#10;                                            youtubeVideoId = item.videoId,&#10;                                            audioUrl = null,&#10;                                            position = i,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    playerViewModel.setCurrentPlaylist(playlist, index)&#10;                                    lifecycleScope.launch {&#10;                                        playerViewModel.loadAudioFromTrack(&#10;                                            playlist[index]&#10;                                        )&#10;                                    }&#10;                                },&#10;                                onThemeChanged = { theme.value = it },&#10;                                playerViewModel = playerViewModel&#10;                            )&#10;                        }&#10;&#10;                        FloatingMusicControls(&#10;                            playerViewModel = playerViewModel,&#10;                            modifier = Modifier.align(Alignment.BottomCenter)&#10;                                .padding(bottom = 48.dp)&#10;                        )&#10;                    }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun initializeShakeDetector() {&#10;        val playerViewModel = (application as PlyrApp).playerViewModel&#10;&#10;        shakeDetector = ShakeDetector(this) { action -&gt;&#10;            when (action) {&#10;                ShakeDetector.ACTION_NEXT -&gt; {&#10;                    playerViewModel.navigateToNext()&#10;                }&#10;                ShakeDetector.ACTION_PREVIOUS -&gt; {&#10;                    playerViewModel.navigateToPrevious()&#10;                }&#10;                ShakeDetector.ACTION_PLAY_PAUSE -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player?.isPlaying == true) {&#10;                        playerViewModel.pausePlayer()&#10;                    } else {&#10;                        playerViewModel.playPlayer()&#10;                    }&#10;                }&#10;                ShakeDetector.ACTION_ASSISTANT -&gt; {&#10;                    // Activar el asistente de voz (si está habilitado)&#10;                    if (Config.isAssistantEnabled(this)) {&#10;                        AssistantActivationEvent.requestActivation()&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;        shakeDetector?.stop()&#10;        if (isFinishing) {&#10;            (application as PlyrApp).playerViewModel.pausePlayer()&#10;            stopService(Intent(this, MusicService::class.java))&#10;        }&#10;        unbindService(serviceConnection)&#10;    }&#10;&#10;    override fun onResume() {&#10;        super.onResume()&#10;        // Activar automáticamente la lectura de NFC cuando la app está en primer plano&#10;        NfcReader.startReading(this)&#10;        // Iniciar detección de shake&#10;        shakeDetector?.start()&#10;    }&#10;&#10;    override fun onPause() {&#10;        super.onPause()&#10;        // Desactivar la lectura de NFC cuando la app no está en primer plano&#10;        NfcReader.stopReading(this)&#10;        // Detener detección de shake&#10;        shakeDetector?.stop()&#10;    }&#10;&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;&#10;        // Manejar NFC tag (existente)&#10;        handleNfcIntent(intent)&#10;&#10;        // Manejar NFC tag para lectura de URLs&#10;        handleNfcUrlRead(intent)&#10;&#10;        // Manejar Spotify callback&#10;        handleSpotifyCallback(intent)&#10;    }&#10;&#10;    private fun handleNfcUrlRead(intent: Intent?) {&#10;        if (intent == null) return&#10;&#10;        // Si estamos en modo escritura, no procesar la lectura para navegación&#10;        // (pero el intent ya fue capturado, así que no se abrirá en el navegador)&#10;        if (NfcTagEvent.isInWriteMode()) {&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Read skipped - Write mode active (tag captured for writing)&quot;)&#10;            return&#10;        }&#10;&#10;        val url = NfcReader.processNfcIntent(intent)&#10;        if (url != null) {&#10;            val urlType = NfcReader.getUrlType(url)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC URL READ SUCCESS!&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; URL: $url&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot; Type: $urlType&quot;)&#10;            android.util.Log.d(&quot;MainActivity&quot;, &quot;═══════════════════════════════════════&quot;)&#10;&#10;            // Detener el modo de lectura después de leer exitosamente&#10;            NfcReader.stopReading(this)&#10;&#10;            // Obtener el resultado parseado y enviarlo al evento global&#10;            val scanResult = NfcReader.consumeScanResult()&#10;            if (scanResult != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot; Sending NFC result to SearchScreen - source: ${scanResult.source}, type: ${scanResult.type}, id: ${scanResult.id}&quot;)&#10;                com.plyr.utils.NfcScanEvent.onNfcScanned(scanResult)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleNfcIntent(intent: Intent?) {&#10;        if (intent?.action == NfcAdapter.ACTION_NDEF_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TAG_DISCOVERED ||&#10;            intent?.action == NfcAdapter.ACTION_TECH_DISCOVERED) {&#10;&#10;            val tag: Tag? = if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG, Tag::class.java)&#10;            } else {&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                intent.getParcelableExtra(NfcAdapter.EXTRA_TAG)&#10;            }&#10;&#10;            if (tag != null) {&#10;                android.util.Log.d(&quot;MainActivity&quot;, &quot;️ NFC Tag detected in onNewIntent: $tag&quot;)&#10;                NfcTagEvent.onTagDetected(tag)&#10;            } else {&#10;                android.util.Log.w(&quot;MainActivity&quot;, &quot;⚠️ NFC intent received but tag is null&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;) {&#10;                uri.getQueryParameter(&quot;code&quot;)?.let { code -&gt;&#10;                    SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, error -&gt;&#10;                        if (tokens != null &amp;&amp; error == null) {&#10;                            Config.setSpotifyTokens(this, tokens.accessToken, tokens.refreshToken, tokens.expiresIn)&#10;&#10;                            // Obtener el perfil del usuario y guardar el nombre de usuario&#10;                            SpotifyRepository.getUserProfile(tokens.accessToken) { userProfile, profileError -&gt;&#10;                                if (userProfile != null &amp;&amp; !userProfile.displayName.isNullOrBlank()) {&#10;                                    Config.setSpotifyUserName(this, userProfile.displayName)&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;✓ Nombre de usuario guardado: ${userProfile.displayName}&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;MainActivity&quot;, &quot;⚠ displayName es null o vacío: ${userProfile?.displayName}&quot;)&#10;                                }&#10;                            }&#10;&#10;                            SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;                        } else {&#10;                            SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;                        }&#10;                    }&#10;                } ?: SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;            }&#10;        }&#10;    }&#10;    @Composable&#10;    fun ReachabilityScaffold(content: @Composable () -&gt; Unit) {&#10;        var lowered by remember { mutableStateOf(false) }&#10;        val density = LocalDensity.current&#10;        val targetOffsetDp = with(density) { (if (lowered) 400f else 0f).toDp() }&#10;        val animatedOffsetDp by animateDpAsState(targetValue = targetOffsetDp)&#10;&#10;        Box(Modifier.fillMaxSize()) {&#10;            Box(&#10;                Modifier&#10;                    .fillMaxSize()&#10;                    .offset(y = animatedOffsetDp)&#10;            ) {&#10;                content()&#10;            }&#10;&#10;            // Zona sensible en la parte baja&#10;            Box(&#10;                Modifier&#10;                    .fillMaxWidth()&#10;                    .height(80.dp)&#10;                    .align(Alignment.BottomCenter)&#10;                    .pointerInput(Unit) {&#10;                        detectVerticalDragGestures { _, dragAmount -&gt;&#10;                            if (dragAmount &gt; 50) lowered = true&#10;                            if (dragAmount &lt; -50) lowered = false&#10;                        }&#10;                    }&#10;            )&#10;        }&#10;    }&#10;&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.MultiToggle&#10;import com.plyr.ui.components.Titulo&#10;import com.plyr.ui.components.AsciiWaveActionButton&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.plyr.assistant.AssistantTTSHelper&#10;&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify - se actualiza cada vez que se abre la pantalla&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var spotifyUserName by remember { mutableStateOf(Config.getSpotifyUserName(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Actualizar el estado de Spotify cuando la pantalla es visible&#10;    LaunchedEffect(Unit) {&#10;        isSpotifyConnected = Config.isSpotifyConnected(context)&#10;        spotifyUserName = Config.getSpotifyUserName(context)&#10;        android.util.Log.d(&quot;ConfigScreen&quot;, &quot; Estado actualizado - Conectado: $isSpotifyConnected, Usuario: $spotifyUserName&quot;)&#10;    }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Reemplazado BinaryToggle por TernaryToggle para soportar &quot;system&quot;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_system&quot;),&#10;                option2 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option3 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = when (selectedTheme) {&#10;                    &quot;system&quot; -&gt; 0&#10;                    &quot;dark&quot; -&gt; 1&#10;                    &quot;light&quot; -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedTheme = when (selectedIndex) {&#10;                        0 -&gt; &quot;system&quot;&#10;                        1 -&gt; &quot;dark&quot;&#10;                        2 -&gt; &quot;light&quot;&#10;                        else -&gt; &quot;system&quot;&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;lang_spanish&quot;),&#10;                    Translations.get(context, &quot;lang_english&quot;),&#10;                    Translations.get(context, &quot;lang_catalan&quot;),&#10;                    Translations.get(context, &quot;lang_japanese&quot;)&#10;                ),&#10;                initialIndex = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    Config.LANGUAGE_JAPANESE -&gt; 3&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        3 -&gt; Config.LANGUAGE_JAPANESE&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;                    Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de acciones de swipe&#10;            Text(&#10;                text = Translations.get(context, &quot;swipe_actions&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Selector de acción para swipe izquierdo&#10;            var selectedSwipeLeftAction by remember { mutableStateOf(Config.getSwipeLeftAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeLeftAction) {&#10;                Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_left&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeLeftAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeLeftAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                    }&#10;                    Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Selector de acción para swipe derecho&#10;            var selectedSwipeRightAction by remember { mutableStateOf(Config.getSwipeRightAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeRightAction) {&#10;                Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_right&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeRightAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeRightAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                    }&#10;                    Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    connectionMessage = message ?: if (success) Translations.get(context, &quot;connected&quot;) else &quot;error&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                // Botón de Spotify Login/Logout&#10;                Text(&#10;                    text = when {&#10;                        isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; {&#10;                            val userName = Config.getSpotifyUserName(context)&#10;                            if (!userName.isNullOrBlank()) {&#10;                                &quot;Hello $userName!&quot;&#10;                            } else {&#10;                                Translations.get(context, &quot;configured&quot;)&#10;                            }&#10;                        }&#10;                        else -&gt; Translations.get(context, &quot;login&quot;)&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = when {&#10;                            isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; MaterialTheme.colorScheme.primary&#10;                            else -&gt; MaterialTheme.colorScheme.error&#10;                        }&#10;                    ),&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                Config.clearSpotifyUserName(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                )&#10;&#10;                // Mostrar mensaje de conexión si existe&#10;                if (connectionMessage.isNotBlank()) {&#10;                    Spacer(modifier = Modifier.height(6.dp))&#10;                    Text(&#10;                        text = connectionMessage,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AcoustidApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            LastfmApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AssistantConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            SensorsConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Sección de compartir app&#10;            ShareAppSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Sección para compartir la app via QR Dialog&#10; */&#10;@Composable&#10;fun ShareAppSection(context: Context) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;    // Mostrar el diálogo de compartir&#10;    if (showShareDialog) {&#10;        com.plyr.ui.components.ShareDialog(&#10;            item = com.plyr.ui.components.ShareableItem(&#10;                spotifyId = null,&#10;                spotifyUrl = null,&#10;                youtubeId = null,&#10;                title = &quot;plyr&quot;,&#10;                artist = &quot;&quot;,&#10;                type = com.plyr.ui.components.ShareType.APP&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;&#10;    // Botón centrado&#10;    Box(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = Translations.get(context, &quot;share_me&quot;),&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            ),&#10;            modifier = Modifier&#10;                .clickable {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                    showShareDialog = true&#10;                }&#10;                .padding(vertical = 12.dp, horizontal = 16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;spotify_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.tertiary&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AcoustidApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getAcoustidApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;acoustid_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;&#10;            Text(&#10;                text = if (Config.hasAcoustidApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasAcoustidApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setAcoustidApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_acoustid_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre AcoustID&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;acoustid_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LastfmApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getLastfmApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;lastfm_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasLastfmApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasLastfmApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campo de entrada de API Key&#10;                Text(&#10;                    text = &quot;      api_key:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setLastfmApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_lastfm_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre Last.fm&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;lastfm_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AssistantConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var assistantEnabled by remember { mutableStateOf(Config.isAssistantEnabled(context)) }&#10;    var useSameLanguage by remember { mutableStateOf(Config.isAssistantSameLanguage(context)) }&#10;    var ttsEnabled by remember { mutableStateOf(Config.isAssistantTtsEnabled(context)) }&#10;    // assistant-specific language (only used when useSameLanguage == false)&#10;    var assistantLanguage by remember { mutableStateOf(Config.getAssistantLanguage(context)) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;assistant_settings&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (assistantEnabled) Translations.get(context, &quot;enabled&quot;) else Translations.get(context, &quot;disabled&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (assistantEnabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_assistant&quot;),&#10;                    checked = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        assistantEnabled = it&#10;                        Config.setAssistantEnabled(context, it)&#10;                        // When disabling assistant, force it to use app language&#10;                        if (!it) {&#10;                            useSameLanguage = true&#10;                            Config.setAssistantSameLanguage(context, true)&#10;                            // sync assistant language to app language&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;assistant_same_language&quot;),&#10;                    checked = useSameLanguage,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        useSameLanguage = it&#10;                        Config.setAssistantSameLanguage(context, it)&#10;                        // if now using same language, sync assistant language to app language&#10;                        if (it) {&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_tts&quot;),&#10;                    checked = ttsEnabled,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        ttsEnabled = it&#10;                        Config.setAssistantTtsEnabled(context, it)&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        // Optionally start/stop TTS engine&#10;                        if (it) {&#10;                            AssistantTTSHelper.initializeIfNeeded(context)&#10;                        } else {&#10;                            AssistantTTSHelper.shutdownIfNeeded()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // If not using app language, show a language selector identical to the main one&#10;                if (assistantEnabled &amp;&amp; !useSameLanguage) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;language&quot;),&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 6.dp)&#10;                    )&#10;&#10;                    // Map current assistantLanguage to an index&#10;                    var assistantLangIndex by remember {&#10;                        mutableStateOf(&#10;                            when (assistantLanguage) {&#10;                                Config.LANGUAGE_SPANISH -&gt; 0&#10;                                Config.LANGUAGE_ENGLISH -&gt; 1&#10;                                Config.LANGUAGE_CATALAN -&gt; 2&#10;                                Config.LANGUAGE_JAPANESE -&gt; 3&#10;                                else -&gt; 0&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    MultiToggle(&#10;                        options = listOf(&#10;                            Translations.get(context, &quot;lang_spanish&quot;),&#10;                            Translations.get(context, &quot;lang_english&quot;),&#10;                            Translations.get(context, &quot;lang_catalan&quot;),&#10;                            Translations.get(context, &quot;lang_japanese&quot;)&#10;                        ),&#10;                        initialIndex = assistantLangIndex,&#10;                        onChange = { selectedIndex -&gt;&#10;                            assistantLangIndex = selectedIndex&#10;                            val newLang = when (selectedIndex) {&#10;                                0 -&gt; Config.LANGUAGE_SPANISH&#10;                                1 -&gt; Config.LANGUAGE_ENGLISH&#10;                                2 -&gt; Config.LANGUAGE_CATALAN&#10;                                3 -&gt; Config.LANGUAGE_JAPANESE&#10;                                else -&gt; Config.LANGUAGE_SPANISH&#10;                            }&#10;                            assistantLanguage = newLang&#10;                            Config.setAssistantLanguage(context, newLang)&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Keep description&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;assistant_description&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 14.sp&#10;                )&#10;            }&#10;        }&#10;&#10;        // Ensure assistant language stays synced to app language when using same language&#10;        LaunchedEffect(key1 = Config.getLanguage(context), key2 = useSameLanguage) {&#10;            if (useSameLanguage) {&#10;                val appLang = Config.getLanguage(context)&#10;                assistantLanguage = appLang&#10;                Config.setAssistantLanguage(context, appLang)&#10;            }&#10;        }&#10;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SensorsConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var selectedShakeAction by remember { mutableStateOf(Config.getShakeAction(context)) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de configuración de sensores&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;sensors_section&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (selectedShakeAction != Config.SHAKE_ACTION_OFF)&#10;                    Translations.get(context, &quot;enabled&quot;)&#10;                else&#10;                    Translations.get(context, &quot;disabled&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (selectedShakeAction != Config.SHAKE_ACTION_OFF)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con opciones de sensores&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Selector de acción para shake&#10;                Text(&#10;                    text = Translations.get(context, &quot;shake_for&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                MultiToggle(&#10;                    options = listOf(&#10;                        Translations.get(context, &quot;shake_off&quot;),&#10;                        Translations.get(context, &quot;shake_next&quot;),&#10;                        Translations.get(context, &quot;shake_previous&quot;),&#10;                        Translations.get(context, &quot;shake_play_pause&quot;),&#10;                        Translations.get(context, &quot;shake_shuffle&quot;),&#10;                        Translations.get(context, &quot;shake_assistant&quot;)&#10;                    ),&#10;                    initialIndex = when (selectedShakeAction) {&#10;                        Config.SHAKE_ACTION_OFF -&gt; 0&#10;                        Config.SHAKE_ACTION_NEXT -&gt; 1&#10;                        Config.SHAKE_ACTION_PREVIOUS -&gt; 2&#10;                        Config.SHAKE_ACTION_PLAY_PAUSE -&gt; 3&#10;                        Config.SHAKE_ACTION_SHUFFLE -&gt; 4&#10;                        Config.SHAKE_ACTION_ASSISTANT -&gt; 5&#10;                        else -&gt; 0&#10;                    },&#10;                    onChange = { selectedIndex -&gt;&#10;                        selectedShakeAction = when (selectedIndex) {&#10;                            0 -&gt; Config.SHAKE_ACTION_OFF&#10;                            1 -&gt; Config.SHAKE_ACTION_NEXT&#10;                            2 -&gt; Config.SHAKE_ACTION_PREVIOUS&#10;                            3 -&gt; Config.SHAKE_ACTION_PLAY_PAUSE&#10;                            4 -&gt; Config.SHAKE_ACTION_SHUFFLE&#10;                            5 -&gt; Config.SHAKE_ACTION_ASSISTANT&#10;                            else -&gt; Config.SHAKE_ACTION_OFF&#10;                        }&#10;                        Config.setShakeAction(context, selectedShakeAction)&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Descripción&#10;                Text(&#10;                    text = Translations.get(context, &quot;sensors_description&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CheckboxOption(&#10;    label: String,&#10;    checked: Boolean,&#10;    enabled: Boolean = true,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(enabled = enabled) { onCheckedChange(!checked) }&#10;            .padding(vertical = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Text(&#10;            text = if (checked) &quot;[x]&quot; else &quot;[ ]&quot;,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (enabled) {&#10;                    if (checked) MaterialTheme.colorScheme.primary&#10;                    else MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 12.sp,&#10;                color = if (enabled) {&#10;                    MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.content.Intent&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.MultiToggle&#10;import com.plyr.ui.components.Titulo&#10;import com.plyr.ui.components.AsciiWaveActionButton&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.plyr.assistant.AssistantTTSHelper&#10;&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify - se actualiza cada vez que se abre la pantalla&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var spotifyUserName by remember { mutableStateOf(Config.getSpotifyUserName(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Actualizar el estado de Spotify cuando la pantalla es visible&#10;    LaunchedEffect(Unit) {&#10;        isSpotifyConnected = Config.isSpotifyConnected(context)&#10;        spotifyUserName = Config.getSpotifyUserName(context)&#10;        android.util.Log.d(&quot;ConfigScreen&quot;, &quot; Estado actualizado - Conectado: $isSpotifyConnected, Usuario: $spotifyUserName&quot;)&#10;    }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Reemplazado BinaryToggle por TernaryToggle para soportar &quot;system&quot;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_system&quot;),&#10;                option2 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option3 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = when (selectedTheme) {&#10;                    &quot;system&quot; -&gt; 0&#10;                    &quot;dark&quot; -&gt; 1&#10;                    &quot;light&quot; -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedTheme = when (selectedIndex) {&#10;                        0 -&gt; &quot;system&quot;&#10;                        1 -&gt; &quot;dark&quot;&#10;                        2 -&gt; &quot;light&quot;&#10;                        else -&gt; &quot;system&quot;&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;lang_spanish&quot;),&#10;                    Translations.get(context, &quot;lang_english&quot;),&#10;                    Translations.get(context, &quot;lang_catalan&quot;),&#10;                    Translations.get(context, &quot;lang_japanese&quot;)&#10;                ),&#10;                initialIndex = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    Config.LANGUAGE_JAPANESE -&gt; 3&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        3 -&gt; Config.LANGUAGE_JAPANESE&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;                    Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de acciones de swipe&#10;            Text(&#10;                text = Translations.get(context, &quot;swipe_actions&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Selector de acción para swipe izquierdo&#10;            var selectedSwipeLeftAction by remember { mutableStateOf(Config.getSwipeLeftAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeLeftAction) {&#10;                Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_left&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeLeftAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeLeftAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                    }&#10;                    Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Selector de acción para swipe derecho&#10;            var selectedSwipeRightAction by remember { mutableStateOf(Config.getSwipeRightAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeRightAction) {&#10;                Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_right&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeRightAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeRightAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                    }&#10;                    Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    connectionMessage = message ?: if (success) Translations.get(context, &quot;connected&quot;) else &quot;error&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                // Botón de Spotify Login/Logout&#10;                Text(&#10;                    text = when {&#10;                        isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; {&#10;                            val userName = Config.getSpotifyUserName(context)&#10;                            if (!userName.isNullOrBlank()) {&#10;                                &quot;Hello $userName!&quot;&#10;                            } else {&#10;                                Translations.get(context, &quot;configured&quot;)&#10;                            }&#10;                        }&#10;                        else -&gt; Translations.get(context, &quot;login&quot;)&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = when {&#10;                            isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; MaterialTheme.colorScheme.primary&#10;                            else -&gt; MaterialTheme.colorScheme.error&#10;                        }&#10;                    ),&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                Config.clearSpotifyUserName(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                )&#10;&#10;                // Mostrar mensaje de conexión si existe&#10;                if (connectionMessage.isNotBlank()) {&#10;                    Spacer(modifier = Modifier.height(6.dp))&#10;                    Text(&#10;                        text = connectionMessage,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AcoustidApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            LastfmApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AssistantConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            SensorsConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Sección de compartir app&#10;            ShareAppSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Sección para compartir la app via QR Dialog&#10; */&#10;@Composable&#10;fun ShareAppSection(context: Context) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;    // Mostrar el diálogo de compartir&#10;    if (showShareDialog) {&#10;        com.plyr.ui.components.ShareDialog(&#10;            item = com.plyr.ui.components.ShareableItem(&#10;                spotifyId = null,&#10;                spotifyUrl = null,&#10;                youtubeId = null,&#10;                title = &quot;plyr&quot;,&#10;                artist = &quot;&quot;,&#10;                type = com.plyr.ui.components.ShareType.APP&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;&#10;    // Botón centrado&#10;    Box(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentAlignment = Alignment.Center&#10;    ) {&#10;        Text(&#10;            text = Translations.get(context, &quot;share_me&quot;),&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = MaterialTheme.colorScheme.primary&#10;            ),&#10;            modifier = Modifier&#10;                .clickable {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                    showShareDialog = true&#10;                }&#10;                .padding(vertical = 12.dp, horizontal = 16.dp)&#10;        )&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;spotify_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.tertiary&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AcoustidApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getAcoustidApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;acoustid_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;&#10;            Text(&#10;                text = if (Config.hasAcoustidApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasAcoustidApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setAcoustidApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_acoustid_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre AcoustID&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;acoustid_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LastfmApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getLastfmApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;lastfm_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasLastfmApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasLastfmApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campo de entrada de API Key&#10;                Text(&#10;                    text = &quot;      api_key:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setLastfmApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_lastfm_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre Last.fm&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;lastfm_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AssistantConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var assistantEnabled by remember { mutableStateOf(Config.isAssistantEnabled(context)) }&#10;    var useSameLanguage by remember { mutableStateOf(Config.isAssistantSameLanguage(context)) }&#10;    var ttsEnabled by remember { mutableStateOf(Config.isAssistantTtsEnabled(context)) }&#10;    // assistant-specific language (only used when useSameLanguage == false)&#10;    var assistantLanguage by remember { mutableStateOf(Config.getAssistantLanguage(context)) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;assistant_settings&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (assistantEnabled) Translations.get(context, &quot;enabled&quot;) else Translations.get(context, &quot;disabled&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (assistantEnabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_assistant&quot;),&#10;                    checked = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        assistantEnabled = it&#10;                        Config.setAssistantEnabled(context, it)&#10;                        // When disabling assistant, force it to use app language&#10;                        if (!it) {&#10;                            useSameLanguage = true&#10;                            Config.setAssistantSameLanguage(context, true)&#10;                            // sync assistant language to app language&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;assistant_same_language&quot;),&#10;                    checked = useSameLanguage,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        useSameLanguage = it&#10;                        Config.setAssistantSameLanguage(context, it)&#10;                        // if now using same language, sync assistant language to app language&#10;                        if (it) {&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_tts&quot;),&#10;                    checked = ttsEnabled,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        ttsEnabled = it&#10;                        Config.setAssistantTtsEnabled(context, it)&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        // Optionally start/stop TTS engine&#10;                        if (it) {&#10;                            AssistantTTSHelper.initializeIfNeeded(context)&#10;                        } else {&#10;                            AssistantTTSHelper.shutdownIfNeeded()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // If not using app language, show a language selector identical to the main one&#10;                if (assistantEnabled &amp;&amp; !useSameLanguage) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;language&quot;),&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 6.dp)&#10;                    )&#10;&#10;                    // Map current assistantLanguage to an index&#10;                    var assistantLangIndex by remember {&#10;                        mutableStateOf(&#10;                            when (assistantLanguage) {&#10;                                Config.LANGUAGE_SPANISH -&gt; 0&#10;                                Config.LANGUAGE_ENGLISH -&gt; 1&#10;                                Config.LANGUAGE_CATALAN -&gt; 2&#10;                                Config.LANGUAGE_JAPANESE -&gt; 3&#10;                                else -&gt; 0&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    MultiToggle(&#10;                        options = listOf(&#10;                            Translations.get(context, &quot;lang_spanish&quot;),&#10;                            Translations.get(context, &quot;lang_english&quot;),&#10;                            Translations.get(context, &quot;lang_catalan&quot;),&#10;                            Translations.get(context, &quot;lang_japanese&quot;)&#10;                        ),&#10;                        initialIndex = assistantLangIndex,&#10;                        onChange = { selectedIndex -&gt;&#10;                            assistantLangIndex = selectedIndex&#10;                            val newLang = when (selectedIndex) {&#10;                                0 -&gt; Config.LANGUAGE_SPANISH&#10;                                1 -&gt; Config.LANGUAGE_ENGLISH&#10;                                2 -&gt; Config.LANGUAGE_CATALAN&#10;                                3 -&gt; Config.LANGUAGE_JAPANESE&#10;                                else -&gt; Config.LANGUAGE_SPANISH&#10;                            }&#10;                            assistantLanguage = newLang&#10;                            Config.setAssistantLanguage(context, newLang)&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Keep description&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;assistant_description&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 14.sp&#10;                )&#10;            }&#10;        }&#10;&#10;        // Ensure assistant language stays synced to app language when using same language&#10;        LaunchedEffect(key1 = Config.getLanguage(context), key2 = useSameLanguage) {&#10;            if (useSameLanguage) {&#10;                val appLang = Config.getLanguage(context)&#10;                assistantLanguage = appLang&#10;                Config.setAssistantLanguage(context, appLang)&#10;            }&#10;        }&#10;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SensorsConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var selectedShakeAction by remember { mutableStateOf(Config.getShakeAction(context)) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de configuración de sensores&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;sensors_section&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (selectedShakeAction != Config.SHAKE_ACTION_OFF)&#10;                    Translations.get(context, &quot;enabled&quot;)&#10;                else&#10;                    Translations.get(context, &quot;disabled&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (selectedShakeAction != Config.SHAKE_ACTION_OFF)&#10;                        MaterialTheme.colorScheme.primary&#10;                    else&#10;                        MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con opciones de sensores&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Selector de acción para shake&#10;                Text(&#10;                    text = Translations.get(context, &quot;shake_for&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                MultiToggle(&#10;                    options = listOf(&#10;                        Translations.get(context, &quot;shake_off&quot;),&#10;                        Translations.get(context, &quot;shake_next&quot;),&#10;                        Translations.get(context, &quot;shake_previous&quot;),&#10;                        Translations.get(context, &quot;shake_play_pause&quot;),&#10;                        Translations.get(context, &quot;shake_assistant&quot;)&#10;                    ),&#10;                    initialIndex = when (selectedShakeAction) {&#10;                        Config.SHAKE_ACTION_OFF -&gt; 0&#10;                        Config.SHAKE_ACTION_NEXT -&gt; 1&#10;                        Config.SHAKE_ACTION_PREVIOUS -&gt; 2&#10;                        Config.SHAKE_ACTION_PLAY_PAUSE -&gt; 3&#10;                        Config.SHAKE_ACTION_ASSISTANT -&gt; 4&#10;                        else -&gt; 0&#10;                    },&#10;                    onChange = { selectedIndex -&gt;&#10;                        selectedShakeAction = when (selectedIndex) {&#10;                            0 -&gt; Config.SHAKE_ACTION_OFF&#10;                            1 -&gt; Config.SHAKE_ACTION_NEXT&#10;                            2 -&gt; Config.SHAKE_ACTION_PREVIOUS&#10;                            3 -&gt; Config.SHAKE_ACTION_PLAY_PAUSE&#10;                            4 -&gt; Config.SHAKE_ACTION_ASSISTANT&#10;                            else -&gt; Config.SHAKE_ACTION_OFF&#10;                        }&#10;                        Config.setShakeAction(context, selectedShakeAction)&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Descripción&#10;                Text(&#10;                    text = Translations.get(context, &quot;sensors_description&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 14.sp&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CheckboxOption(&#10;    label: String,&#10;    checked: Boolean,&#10;    enabled: Boolean = true,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(enabled = enabled) { onCheckedChange(!checked) }&#10;            .padding(vertical = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Text(&#10;            text = if (checked) &quot;[x]&quot; else &quot;[ ]&quot;,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (enabled) {&#10;                    if (checked) MaterialTheme.colorScheme.primary&#10;                    else MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 12.sp,&#10;                color = if (enabled) {&#10;                    MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import kotlinx.coroutines.withContext&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    // Animación CAVA para escucha y procesamiento&#10;    val animationFrames = listOf(&#10;        &quot;▃▇▁▆▂█▄&quot;,&#10;        &quot;▆▂▅▁▇▃█&quot;,&#10;        &quot;▁▄█▃▆▅▂&quot;,&#10;        &quot;▇▅▂▄▁█▃&quot;,&#10;        &quot;▂█▆▇▄▁▅&quot;,&#10;        &quot;▅▁▃▂▇▄▆&quot;,&#10;        &quot;█▃▄▅▂▆▁&quot;,&#10;        &quot;▄▆▇▁▅▂█&quot;,&#10;        &quot;▃▂▆▄█▇▁&quot;,&#10;        &quot;▆▄▁▇▃▅█&quot;,&#10;        &quot;▁▇▅█▂▃▄&quot;,&#10;        &quot;▇▃█▂▆▁▅&quot;&#10;    )&#10;    var animationFrame by remember { mutableStateOf(0) }&#10;&#10;    // Animar durante escucha o procesamiento&#10;    LaunchedEffect(isListening, isProcessing) {&#10;        if (isListening || isProcessing) {&#10;            while (isListening || isProcessing) {&#10;                delay(100)&#10;                animationFrame = (animationFrame + 1) % animationFrames.size&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-dismiss de la respuesta después de 8 segundos&#10;    LaunchedEffect(displayedResponse, isTyping) {&#10;        if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;            delay(8000)&#10;            if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;                assistantResponse = &quot;&quot;&#10;                displayedResponse = &quot;&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    // Use the singleton helper methods instead of constructing AssistantTTSHelper directly&#10;    // (AssistantTTSHelper has a private constructor; use initializeIfNeeded / speakIfReady / stopIfNeeded / shutdownIfNeeded)&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;            val responseToType = assistantResponse&#10;            for (i in responseToType.indices) {&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20)&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    assistantResponse = reply&#10;                    com.plyr.assistant.AssistantTTSHelper.speakIfReady(context, reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;            }&#10;            override fun onReady() {&#10;                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;            }&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            com.plyr.assistant.AssistantTTSHelper.shutdownIfNeeded()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { _, dragAmount -&gt;&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_$i&quot;&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = Translations.get(context, &quot;app_logo&quot;),&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = listOf(&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.SEARCH)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.PLAYLISTS)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.QUEUE)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.LOCAL)&#10;                        }&#10;                    )&#10;                )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay with fade animation&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = displayedResponse.isNotEmpty() || isProcessing,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 100.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isProcessing) animationFrames[animationFrame]&#10;                               else displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = overlayVisible || isListening,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp)&#10;                        .align(Alignment.TopCenter)&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        if (isListening) {&#10;                            // Animación CAVA mientras escucha&#10;                            Text(&#10;                                text = animationFrames[animationFrame],&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = Translations.get(context, &quot;cancel&quot;),&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = Translations.get(context, &quot;assistant&quot;),&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import kotlinx.coroutines.withContext&#10;import com.plyr.utils.AssistantActivationEvent&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    // Animación CAVA para escucha y procesamiento&#10;    val animationFrames = listOf(&#10;        &quot;▃▇▁▆▂█▄&quot;,&#10;        &quot;▆▂▅▁▇▃█&quot;,&#10;        &quot;▁▄█▃▆▅▂&quot;,&#10;        &quot;▇▅▂▄▁█▃&quot;,&#10;        &quot;▂█▆▇▄▁▅&quot;,&#10;        &quot;▅▁▃▂▇▄▆&quot;,&#10;        &quot;█▃▄▅▂▆▁&quot;,&#10;        &quot;▄▆▇▁▅▂█&quot;,&#10;        &quot;▃▂▆▄█▇▁&quot;,&#10;        &quot;▆▄▁▇▃▅█&quot;,&#10;        &quot;▁▇▅█▂▃▄&quot;,&#10;        &quot;▇▃█▂▆▁▅&quot;&#10;    )&#10;    var animationFrame by remember { mutableStateOf(0) }&#10;&#10;    // Animar durante escucha o procesamiento&#10;    LaunchedEffect(isListening, isProcessing) {&#10;        if (isListening || isProcessing) {&#10;            while (isListening || isProcessing) {&#10;                delay(100)&#10;                animationFrame = (animationFrame + 1) % animationFrames.size&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-dismiss de la respuesta después de 8 segundos&#10;    LaunchedEffect(displayedResponse, isTyping) {&#10;        if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;            delay(8000)&#10;            if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;                assistantResponse = &quot;&quot;&#10;                displayedResponse = &quot;&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    // Use the singleton helper methods instead of constructing AssistantTTSHelper directly&#10;    // (AssistantTTSHelper has a private constructor; use initializeIfNeeded / speakIfReady / stopIfNeeded / shutdownIfNeeded)&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;            val responseToType = assistantResponse&#10;            for (i in responseToType.indices) {&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20)&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Escuchar evento de activación del asistente por shake&#10;    val assistantActivationRequested by AssistantActivationEvent.activationRequested.collectAsState()&#10;&#10;    LaunchedEffect(assistantActivationRequested) {&#10;        if (assistantActivationRequested) {&#10;            AssistantActivationEvent.consumeActivation()&#10;            // Activar el asistente de voz&#10;            if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) == android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;                assistantResponse = &quot;&quot;&#10;                displayedResponse = &quot;&quot;&#10;                isListening = true&#10;                assistantVoiceHelper.startListening()&#10;            }&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    assistantResponse = reply&#10;                    com.plyr.assistant.AssistantTTSHelper.speakIfReady(context, reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;            }&#10;            override fun onReady() {&#10;                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;            }&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            com.plyr.assistant.AssistantTTSHelper.shutdownIfNeeded()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { _, dragAmount -&gt;&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_$i&quot;&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = Translations.get(context, &quot;app_logo&quot;),&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = listOf(&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.SEARCH)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.PLAYLISTS)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.QUEUE)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.LOCAL)&#10;                        }&#10;                    )&#10;                )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay with fade animation&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = displayedResponse.isNotEmpty() || isProcessing,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 100.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isProcessing) animationFrames[animationFrame]&#10;                               else displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = overlayVisible || isListening,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp)&#10;                        .align(Alignment.TopCenter)&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        if (isListening) {&#10;                            // Animación CAVA mientras escucha&#10;                            Text(&#10;                                text = animationFrames[animationFrame],&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = Translations.get(context, &quot;cancel&quot;),&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = Translations.get(context, &quot;assistant&quot;),&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/AssistantActivationEvent.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/AssistantActivationEvent.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;&#10;/**&#10; * Evento global para activar el asistente de voz desde cualquier parte de la app.&#10; * Usado principalmente para la activación por shake.&#10; */&#10;object AssistantActivationEvent {&#10;    private val _activationRequested = MutableStateFlow(false)&#10;    val activationRequested: StateFlow&lt;Boolean&gt; = _activationRequested&#10;&#10;    /**&#10;     * Solicita la activación del asistente de voz.&#10;     */&#10;    fun requestActivation() {&#10;        _activationRequested.value = true&#10;    }&#10;&#10;    /**&#10;     * Consume el evento de activación (debe llamarse después de procesarlo).&#10;     */&#10;    fun consumeActivation() {&#10;        _activationRequested.value = false&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_LANGUAGE = &quot;language&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    private const val KEY_SPOTIFY_USER_NAME = &quot;spotify_user_name&quot;&#10;    private const val KEY_ACOUSTID_API_KEY = &quot;acoustid_api_key&quot;&#10;    private const val KEY_LASTFM_API_KEY = &quot;lastfm_api_key&quot;&#10;    private const val KEY_SWIPE_LEFT_ACTION = &quot;swipe_left_action&quot;&#10;    private const val KEY_SWIPE_RIGHT_ACTION = &quot;swipe_right_action&quot;&#10;&#10;    // Clave para configuración de shake&#10;    private const val KEY_SHAKE_ACTION = &quot;shake_action&quot;&#10;&#10;    // Nuevas claves para configuración del asistente&#10;    private const val KEY_ASSISTANT_ENABLED = &quot;assistant_enabled&quot;&#10;    private const val KEY_ASSISTANT_SAME_LANGUAGE = &quot;assistant_same_language&quot;&#10;    private const val KEY_ASSISTANT_TTS_ENABLED = &quot;assistant_tts_enabled&quot;&#10;    private const val KEY_ASSISTANT_LANGUAGE = &quot;assistant_language&quot;&#10;&#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;system&quot; // Por defecto en nuevas instalaciones seguir el tema del sistema&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;high&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;    private const val DEFAULT_LANGUAGE = &quot;english&quot;&#10;    private const val DEFAULT_SWIPE_LEFT_ACTION = &quot;add_to_queue&quot;&#10;    private const val DEFAULT_SWIPE_RIGHT_ACTION = &quot;add_to_liked_songs&quot;&#10;    private const val DEFAULT_SHAKE_ACTION = &quot;off&quot;&#10;    private const val DEFAULT_ASSISTANT_ENABLED = true&#10;    private const val DEFAULT_ASSISTANT_SAME_LANGUAGE = true&#10;    private const val DEFAULT_ASSISTANT_TTS_ENABLED = false&#10;    private const val DEFAULT_ASSISTANT_LANGUAGE = DEFAULT_LANGUAGE&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === CONSTANTES PÚBLICAS DE IDIOMAS ===&#10;&#10;    /** Idiomas disponibles */&#10;    const val LANGUAGE_SPANISH = &quot;español&quot;&#10;    const val LANGUAGE_ENGLISH = &quot;english&quot;&#10;    const val LANGUAGE_CATALAN = &quot;català&quot;&#10;    // Ajuste: usar la misma clave que en Translations (&quot;日本語&quot;) para que coincida la búsqueda&#10;    const val LANGUAGE_JAPANESE = &quot;日本語&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SWIPE ===&#10;&#10;    /** Acciones de swipe disponibles */&#10;    const val SWIPE_ACTION_ADD_TO_QUEUE = &quot;add_to_queue&quot;&#10;    const val SWIPE_ACTION_ADD_TO_LIKED = &quot;add_to_liked_songs&quot;&#10;    const val SWIPE_ACTION_ADD_TO_PLAYLIST = &quot;add_to_playlist&quot;&#10;    const val SWIPE_ACTION_SHARE = &quot;share&quot;&#10;    const val SWIPE_ACTION_DOWNLOAD = &quot;download&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SHAKE ===&#10;&#10;    /** Acciones de shake disponibles */&#10;    const val SHAKE_ACTION_OFF = &quot;off&quot;&#10;    const val SHAKE_ACTION_NEXT = &quot;next&quot;&#10;    const val SHAKE_ACTION_PREVIOUS = &quot;previous&quot;&#10;    const val SHAKE_ACTION_PLAY_PAUSE = &quot;play_pause&quot;&#10;    const val SHAKE_ACTION_SHUFFLE = &quot;shuffle&quot;&#10;    const val SHAKE_ACTION_ASSISTANT = &quot;assistant&quot;&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;system&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;&#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE IDIOMA ===&#10;&#10;    /**&#10;     * Establece el idioma de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param language Idioma a establecer (&quot;español&quot;, &quot;english&quot;, &quot;català&quot;)&#10;     */&#10;    fun setLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LANGUAGE, language)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el idioma actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Idioma actual (por defecto &quot;español&quot;)&#10;     */&#10;    fun getLanguage(context: Context): String {&#10;        val prefs = getPrefs(context)&#10;        val stored = prefs.getString(KEY_LANGUAGE, DEFAULT_LANGUAGE) ?: DEFAULT_LANGUAGE&#10;        // Migrar valor legacy &quot;japanese&quot; (ASCII) a la clave usada en Translations (&quot;日本語&quot;)&#10;        if (stored == &quot;japanese&quot;) {&#10;            // Actualizar la preferencia para futuras lecturas&#10;            setLanguage(context, LANGUAGE_JAPANESE)&#10;            return LANGUAGE_JAPANESE&#10;        }&#10;        return stored&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIONES DE SWIPE ===&#10;&#10;    /**&#10;     * Establece la acción para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeLeftAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_LEFT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_queue&quot;)&#10;     */&#10;    fun getSwipeLeftAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_LEFT_ACTION, DEFAULT_SWIPE_LEFT_ACTION) ?: DEFAULT_SWIPE_LEFT_ACTION&#10;    }&#10;&#10;    /**&#10;     * Establece la acción para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeRightAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_RIGHT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_liked_songs&quot;)&#10;     */&#10;    fun getSwipeRightAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_RIGHT_ACTION, DEFAULT_SWIPE_RIGHT_ACTION) ?: DEFAULT_SWIPE_RIGHT_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIÓN DE SHAKE ===&#10;&#10;    /**&#10;     * Establece la acción para el gesto de shake.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer (&quot;off&quot;, &quot;next&quot;, &quot;previous&quot;, &quot;play_pause&quot;, &quot;shuffle&quot;, &quot;assistant&quot;)&#10;     */&#10;    fun setShakeAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SHAKE_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el gesto de shake.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getShakeAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SHAKE_ACTION, DEFAULT_SHAKE_ACTION) ?: DEFAULT_SHAKE_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACOUSTID API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de AcoustID configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de AcoustID o null si no está configurada&#10;     */&#10;    fun getAcoustidApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de AcoustID del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de AcoustID&#10;     */&#10;    fun setAcoustidApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_ACOUSTID_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de AcoustID configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasAcoustidApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE LASTFM API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de Last.fm configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de Last.fm o null si no está configurada&#10;     */&#10;    fun getLastfmApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de Last.fm del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de Last.fm&#10;     */&#10;    fun setLastfmApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LASTFM_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de Last.fm configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasLastfmApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE NOMBRE DE USUARIO DE SPOTIFY ===&#10;&#10;    /**&#10;     * Obtiene el nombre de usuario de Spotify almacenado.&#10;     * @param context Contexto de la aplicación&#10;     * @return Nombre de usuario de Spotify o null si no está configurado&#10;     */&#10;    fun getSpotifyUserName(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_USER_NAME, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el nombre de usuario de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @param userName Nombre de usuario de Spotify&#10;     */&#10;    fun setSpotifyUserName(context: Context, userName: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_USER_NAME, userName.trim())&#10;        }&#10;    }&#10;&#10;    /** Elimina el nombre de usuario de Spotify almacenado. */&#10;    fun clearSpotifyUserName(context: Context) {&#10;        getPrefs(context).edit {&#10;            remove(KEY_SPOTIFY_USER_NAME)&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DEL ASISTENTE ===&#10;&#10;    /** Comprueba si el asistente está habilitado. */&#10;    fun isAssistantEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_ENABLED, DEFAULT_ASSISTANT_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva el asistente. */&#10;    fun setAssistantEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Comprueba si el asistente debe usar el mismo idioma de la app. */&#10;    fun isAssistantSameLanguage(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_SAME_LANGUAGE, DEFAULT_ASSISTANT_SAME_LANGUAGE)&#10;    }&#10;&#10;    /** Establece si el asistente usa el mismo idioma que la app. */&#10;    fun setAssistantSameLanguage(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_SAME_LANGUAGE, enabled) }&#10;    }&#10;&#10;    /** Comprueba si TTS del asistente está habilitado. */&#10;    fun isAssistantTtsEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_TTS_ENABLED, DEFAULT_ASSISTANT_TTS_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva TTS para el asistente. */&#10;    fun setAssistantTtsEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_TTS_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Obtiene el idioma específico del asistente (si se usa distinto del de la app). */&#10;    fun getAssistantLanguage(context: Context): String {&#10;        return getPrefs(context).getString(KEY_ASSISTANT_LANGUAGE, DEFAULT_ASSISTANT_LANGUAGE) ?: DEFAULT_ASSISTANT_LANGUAGE&#10;    }&#10;&#10;    /** Establece el idioma específico del asistente. */&#10;    fun setAssistantLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit { putString(KEY_ASSISTANT_LANGUAGE, language) }&#10;    }&#10;&#10; }&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_LANGUAGE = &quot;language&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    private const val KEY_SPOTIFY_USER_NAME = &quot;spotify_user_name&quot;&#10;    private const val KEY_ACOUSTID_API_KEY = &quot;acoustid_api_key&quot;&#10;    private const val KEY_LASTFM_API_KEY = &quot;lastfm_api_key&quot;&#10;    private const val KEY_SWIPE_LEFT_ACTION = &quot;swipe_left_action&quot;&#10;    private const val KEY_SWIPE_RIGHT_ACTION = &quot;swipe_right_action&quot;&#10;&#10;    // Clave para configuración de shake&#10;    private const val KEY_SHAKE_ACTION = &quot;shake_action&quot;&#10;&#10;    // Nuevas claves para configuración del asistente&#10;    private const val KEY_ASSISTANT_ENABLED = &quot;assistant_enabled&quot;&#10;    private const val KEY_ASSISTANT_SAME_LANGUAGE = &quot;assistant_same_language&quot;&#10;    private const val KEY_ASSISTANT_TTS_ENABLED = &quot;assistant_tts_enabled&quot;&#10;    private const val KEY_ASSISTANT_LANGUAGE = &quot;assistant_language&quot;&#10;&#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;system&quot; // Por defecto en nuevas instalaciones seguir el tema del sistema&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;high&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;    private const val DEFAULT_LANGUAGE = &quot;english&quot;&#10;    private const val DEFAULT_SWIPE_LEFT_ACTION = &quot;add_to_queue&quot;&#10;    private const val DEFAULT_SWIPE_RIGHT_ACTION = &quot;add_to_liked_songs&quot;&#10;    private const val DEFAULT_SHAKE_ACTION = &quot;off&quot;&#10;    private const val DEFAULT_ASSISTANT_ENABLED = true&#10;    private const val DEFAULT_ASSISTANT_SAME_LANGUAGE = true&#10;    private const val DEFAULT_ASSISTANT_TTS_ENABLED = false&#10;    private const val DEFAULT_ASSISTANT_LANGUAGE = DEFAULT_LANGUAGE&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === CONSTANTES PÚBLICAS DE IDIOMAS ===&#10;&#10;    /** Idiomas disponibles */&#10;    const val LANGUAGE_SPANISH = &quot;español&quot;&#10;    const val LANGUAGE_ENGLISH = &quot;english&quot;&#10;    const val LANGUAGE_CATALAN = &quot;català&quot;&#10;    // Ajuste: usar la misma clave que en Translations (&quot;日本語&quot;) para que coincida la búsqueda&#10;    const val LANGUAGE_JAPANESE = &quot;日本語&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SWIPE ===&#10;&#10;    /** Acciones de swipe disponibles */&#10;    const val SWIPE_ACTION_ADD_TO_QUEUE = &quot;add_to_queue&quot;&#10;    const val SWIPE_ACTION_ADD_TO_LIKED = &quot;add_to_liked_songs&quot;&#10;    const val SWIPE_ACTION_ADD_TO_PLAYLIST = &quot;add_to_playlist&quot;&#10;    const val SWIPE_ACTION_SHARE = &quot;share&quot;&#10;    const val SWIPE_ACTION_DOWNLOAD = &quot;download&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SHAKE ===&#10;&#10;    /** Acciones de shake disponibles */&#10;    const val SHAKE_ACTION_OFF = &quot;off&quot;&#10;    const val SHAKE_ACTION_NEXT = &quot;next&quot;&#10;    const val SHAKE_ACTION_PREVIOUS = &quot;previous&quot;&#10;    const val SHAKE_ACTION_PLAY_PAUSE = &quot;play_pause&quot;&#10;    const val SHAKE_ACTION_ASSISTANT = &quot;assistant&quot;&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;system&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;&#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE IDIOMA ===&#10;&#10;    /**&#10;     * Establece el idioma de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param language Idioma a establecer (&quot;español&quot;, &quot;english&quot;, &quot;català&quot;)&#10;     */&#10;    fun setLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LANGUAGE, language)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el idioma actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Idioma actual (por defecto &quot;español&quot;)&#10;     */&#10;    fun getLanguage(context: Context): String {&#10;        val prefs = getPrefs(context)&#10;        val stored = prefs.getString(KEY_LANGUAGE, DEFAULT_LANGUAGE) ?: DEFAULT_LANGUAGE&#10;        // Migrar valor legacy &quot;japanese&quot; (ASCII) a la clave usada en Translations (&quot;日本語&quot;)&#10;        if (stored == &quot;japanese&quot;) {&#10;            // Actualizar la preferencia para futuras lecturas&#10;            setLanguage(context, LANGUAGE_JAPANESE)&#10;            return LANGUAGE_JAPANESE&#10;        }&#10;        return stored&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIONES DE SWIPE ===&#10;&#10;    /**&#10;     * Establece la acción para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeLeftAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_LEFT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_queue&quot;)&#10;     */&#10;    fun getSwipeLeftAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_LEFT_ACTION, DEFAULT_SWIPE_LEFT_ACTION) ?: DEFAULT_SWIPE_LEFT_ACTION&#10;    }&#10;&#10;    /**&#10;     * Establece la acción para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeRightAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_RIGHT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_liked_songs&quot;)&#10;     */&#10;    fun getSwipeRightAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_RIGHT_ACTION, DEFAULT_SWIPE_RIGHT_ACTION) ?: DEFAULT_SWIPE_RIGHT_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIÓN DE SHAKE ===&#10;&#10;    /**&#10;     * Establece la acción para el gesto de shake.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer (&quot;off&quot;, &quot;next&quot;, &quot;previous&quot;, &quot;play_pause&quot;, &quot;shuffle&quot;, &quot;assistant&quot;)&#10;     */&#10;    fun setShakeAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SHAKE_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el gesto de shake.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getShakeAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SHAKE_ACTION, DEFAULT_SHAKE_ACTION) ?: DEFAULT_SHAKE_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACOUSTID API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de AcoustID configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de AcoustID o null si no está configurada&#10;     */&#10;    fun getAcoustidApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de AcoustID del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de AcoustID&#10;     */&#10;    fun setAcoustidApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_ACOUSTID_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de AcoustID configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasAcoustidApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE LASTFM API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de Last.fm configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de Last.fm o null si no está configurada&#10;     */&#10;    fun getLastfmApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de Last.fm del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de Last.fm&#10;     */&#10;    fun setLastfmApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LASTFM_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de Last.fm configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasLastfmApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE NOMBRE DE USUARIO DE SPOTIFY ===&#10;&#10;    /**&#10;     * Obtiene el nombre de usuario de Spotify almacenado.&#10;     * @param context Contexto de la aplicación&#10;     * @return Nombre de usuario de Spotify o null si no está configurado&#10;     */&#10;    fun getSpotifyUserName(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_USER_NAME, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el nombre de usuario de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @param userName Nombre de usuario de Spotify&#10;     */&#10;    fun setSpotifyUserName(context: Context, userName: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_USER_NAME, userName.trim())&#10;        }&#10;    }&#10;&#10;    /** Elimina el nombre de usuario de Spotify almacenado. */&#10;    fun clearSpotifyUserName(context: Context) {&#10;        getPrefs(context).edit {&#10;            remove(KEY_SPOTIFY_USER_NAME)&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DEL ASISTENTE ===&#10;&#10;    /** Comprueba si el asistente está habilitado. */&#10;    fun isAssistantEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_ENABLED, DEFAULT_ASSISTANT_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva el asistente. */&#10;    fun setAssistantEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Comprueba si el asistente debe usar el mismo idioma de la app. */&#10;    fun isAssistantSameLanguage(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_SAME_LANGUAGE, DEFAULT_ASSISTANT_SAME_LANGUAGE)&#10;    }&#10;&#10;    /** Establece si el asistente usa el mismo idioma que la app. */&#10;    fun setAssistantSameLanguage(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_SAME_LANGUAGE, enabled) }&#10;    }&#10;&#10;    /** Comprueba si TTS del asistente está habilitado. */&#10;    fun isAssistantTtsEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_TTS_ENABLED, DEFAULT_ASSISTANT_TTS_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva TTS para el asistente. */&#10;    fun setAssistantTtsEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_TTS_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Obtiene el idioma específico del asistente (si se usa distinto del de la app). */&#10;    fun getAssistantLanguage(context: Context): String {&#10;        return getPrefs(context).getString(KEY_ASSISTANT_LANGUAGE, DEFAULT_ASSISTANT_LANGUAGE) ?: DEFAULT_ASSISTANT_LANGUAGE&#10;    }&#10;&#10;    /** Establece el idioma específico del asistente. */&#10;    fun setAssistantLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit { putString(KEY_ASSISTANT_LANGUAGE, language) }&#10;    }&#10;&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/ShakeDetector.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/ShakeDetector.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import kotlin.math.sqrt&#10;&#10;/**&#10; * ShakeDetector - Detecta cuando el usuario agita el teléfono&#10; *&#10; * Acciones disponibles:&#10; * - OFF: Deshabilitado&#10; * - NEXT: Pasar a la siguiente canción&#10; * - PREVIOUS: Volver a la canción anterior&#10; * - PLAY_PAUSE: Reproducir/Pausar&#10; * - SHUFFLE: Mezclar la lista de reproducción&#10; * - ASSISTANT: Activar el asistente de voz&#10; */&#10;class ShakeDetector(&#10;    private val context: Context,&#10;    private val onShakeDetected: (String) -&gt; Unit&#10;) : SensorEventListener {&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private var accelerometer: Sensor? = null&#10;    private var isListening = false&#10;&#10;    private var lastShakeTime: Long = 0&#10;    private var lastX: Float = 0f&#10;    private var lastY: Float = 0f&#10;    private var lastZ: Float = 0f&#10;    private var lastUpdate: Long = 0&#10;    private var sensorEventCount: Int = 0&#10;&#10;    companion object {&#10;        private const val TAG = &quot;ShakeDetector&quot;&#10;        // Umbral de sensibilidad para detectar el shake (reducido para más sensibilidad)&#10;        private const val SHAKE_THRESHOLD = 10000&#10;        // Tiempo mínimo entre shakes para evitar múltiples detecciones&#10;        private const val SHAKE_COOLDOWN_MS = 1000L&#10;        // Intervalo mínimo entre actualizaciones del sensor&#10;        private const val UPDATE_INTERVAL_MS = 50&#10;&#10;        // Acciones disponibles&#10;        const val ACTION_OFF = &quot;off&quot;&#10;        const val ACTION_NEXT = &quot;next&quot;&#10;        const val ACTION_PREVIOUS = &quot;previous&quot;&#10;        const val ACTION_PLAY_PAUSE = &quot;play_pause&quot;&#10;        const val ACTION_SHUFFLE = &quot;shuffle&quot;&#10;        const val ACTION_ASSISTANT = &quot;assistant&quot;&#10;    }&#10;&#10;    /**&#10;     * Inicia la detección de shake&#10;     */&#10;    fun start() {&#10;        val action = Config.getShakeAction(context)&#10;        android.util.Log.d(TAG, &quot;═══════════════════════════════════════&quot;)&#10;        android.util.Log.d(TAG, &quot; START called - Current action: $action&quot;)&#10;&#10;        if (action == ACTION_OFF) {&#10;            android.util.Log.d(TAG, &quot;❌ Shake detection is DISABLED (action=off)&quot;)&#10;            return&#10;        }&#10;&#10;        if (isListening) {&#10;            android.util.Log.d(TAG, &quot;⚠️ Already listening, skipping start&quot;)&#10;            return&#10;        }&#10;&#10;        sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        accelerometer = sensorManager?.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)&#10;&#10;        if (accelerometer == null) {&#10;            android.util.Log.e(TAG, &quot;❌ No accelerometer sensor available on this device!&quot;)&#10;            return&#10;        }&#10;&#10;        android.util.Log.d(TAG, &quot;✓ Accelerometer found: ${accelerometer?.name}&quot;)&#10;&#10;        val registered = sensorManager?.registerListener(&#10;            this,&#10;            accelerometer,&#10;            SensorManager.SENSOR_DELAY_GAME&#10;        ) ?: false&#10;&#10;        isListening = registered&#10;        sensorEventCount = 0&#10;&#10;        if (registered) {&#10;            android.util.Log.d(TAG, &quot;✅ Sensor listener REGISTERED successfully!&quot;)&#10;            android.util.Log.d(TAG, &quot; Shake threshold: $SHAKE_THRESHOLD&quot;)&#10;            android.util.Log.d(TAG, &quot;⏱️ Cooldown: ${SHAKE_COOLDOWN_MS}ms&quot;)&#10;        } else {&#10;            android.util.Log.e(TAG, &quot;❌ Failed to register sensor listener!&quot;)&#10;        }&#10;        android.util.Log.d(TAG, &quot;═══════════════════════════════════════&quot;)&#10;    }&#10;&#10;    /**&#10;     * Detiene la detección de shake&#10;     */&#10;    fun stop() {&#10;        android.util.Log.d(TAG, &quot; STOP called - wasListening: $isListening, eventCount: $sensorEventCount&quot;)&#10;        sensorManager?.unregisterListener(this)&#10;        isListening = false&#10;    }&#10;&#10;    /**&#10;     * Reinicia el detector con la configuración actual&#10;     */&#10;    fun restart() {&#10;        android.util.Log.d(TAG, &quot; RESTART called&quot;)&#10;        stop()&#10;        start()&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type != Sensor.TYPE_ACCELEROMETER) return&#10;&#10;        sensorEventCount++&#10;&#10;        // Log cada 100 eventos para confirmar que el sensor funciona&#10;        if (sensorEventCount % 100 == 0) {&#10;            android.util.Log.v(TAG, &quot; Sensor events received: $sensorEventCount&quot;)&#10;        }&#10;&#10;        val currentTime = System.currentTimeMillis()&#10;&#10;        // Solo procesar si ha pasado suficiente tiempo desde la última actualización&#10;        if ((currentTime - lastUpdate) &lt; UPDATE_INTERVAL_MS) return&#10;&#10;        val diffTime = currentTime - lastUpdate&#10;        lastUpdate = currentTime&#10;&#10;        val x = event.values[0]&#10;        val y = event.values[1]&#10;        val z = event.values[2]&#10;&#10;        val deltaX = x - lastX&#10;        val deltaY = y - lastY&#10;        val deltaZ = z - lastZ&#10;&#10;        lastX = x&#10;        lastY = y&#10;        lastZ = z&#10;&#10;        // Calcular la velocidad del movimiento&#10;        val speed = sqrt((deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ).toDouble()) / diffTime * 10000&#10;&#10;        // Log cuando la velocidad es significativa (más de la mitad del umbral)&#10;        if (speed &gt; SHAKE_THRESHOLD / 2) {&#10;            android.util.Log.d(TAG, &quot; Movement detected - Speed: ${speed.toInt()} (threshold: $SHAKE_THRESHOLD)&quot;)&#10;        }&#10;&#10;        if (speed &gt; SHAKE_THRESHOLD) {&#10;            val timeSinceLastShake = currentTime - lastShakeTime&#10;            android.util.Log.d(TAG, &quot; SHAKE THRESHOLD EXCEEDED! Speed: ${speed.toInt()}, timeSinceLast: ${timeSinceLastShake}ms&quot;)&#10;&#10;            // Verificar cooldown para evitar múltiples detecciones&#10;            if (timeSinceLastShake &gt; SHAKE_COOLDOWN_MS) {&#10;                lastShakeTime = currentTime&#10;&#10;                val action = Config.getShakeAction(context)&#10;                android.util.Log.d(TAG, &quot;═══════════════════════════════════════&quot;)&#10;                android.util.Log.d(TAG, &quot; SHAKE DETECTED! Executing action: $action&quot;)&#10;                android.util.Log.d(TAG, &quot;═══════════════════════════════════════&quot;)&#10;&#10;                if (action != ACTION_OFF) {&#10;                    onShakeDetected(action)&#10;                }&#10;            } else {&#10;                android.util.Log.d(TAG, &quot;⏳ Shake ignored - cooldown active (${timeSinceLastShake}ms &lt; ${SHAKE_COOLDOWN_MS}ms)&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        android.util.Log.d(TAG, &quot; Sensor accuracy changed: $accuracy&quot;)&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.hardware.Sensor&#10;import android.hardware.SensorEvent&#10;import android.hardware.SensorEventListener&#10;import android.hardware.SensorManager&#10;import kotlin.math.sqrt&#10;&#10;/**&#10; * ShakeDetector - Detecta cuando el usuario agita el teléfono&#10; *&#10; * Acciones disponibles:&#10; * - OFF: Deshabilitado&#10; * - NEXT: Pasar a la siguiente canción&#10; * - PREVIOUS: Volver a la canción anterior&#10; * - PLAY_PAUSE: Reproducir/Pausar&#10; * - ASSISTANT: Activar el asistente de voz&#10; */&#10;class ShakeDetector(&#10;    private val context: Context,&#10;    private val onShakeDetected: (String) -&gt; Unit&#10;) : SensorEventListener {&#10;&#10;    private var sensorManager: SensorManager? = null&#10;    private var accelerometer: Sensor? = null&#10;    private var isListening = false&#10;&#10;    private var lastShakeTime: Long = 0&#10;    private var lastX: Float = 0f&#10;    private var lastY: Float = 0f&#10;    private var lastZ: Float = 0f&#10;    private var lastUpdate: Long = 0&#10;&#10;    companion object {&#10;        // Umbral de sensibilidad para detectar el shake&#10;        private const val SHAKE_THRESHOLD = 10000&#10;        // Tiempo mínimo entre shakes para evitar múltiples detecciones&#10;        private const val SHAKE_COOLDOWN_MS = 1000L&#10;        // Intervalo mínimo entre actualizaciones del sensor (aumentado para reducir carga)&#10;        private const val UPDATE_INTERVAL_MS = 100&#10;&#10;        // Acciones disponibles&#10;        const val ACTION_OFF = &quot;off&quot;&#10;        const val ACTION_NEXT = &quot;next&quot;&#10;        const val ACTION_PREVIOUS = &quot;previous&quot;&#10;        const val ACTION_PLAY_PAUSE = &quot;play_pause&quot;&#10;        const val ACTION_ASSISTANT = &quot;assistant&quot;&#10;    }&#10;&#10;    /**&#10;     * Inicia la detección de shake&#10;     */&#10;    fun start() {&#10;        val action = Config.getShakeAction(context)&#10;&#10;        if (action == ACTION_OFF) {&#10;            return&#10;        }&#10;&#10;        if (isListening) {&#10;            return&#10;        }&#10;&#10;        sensorManager = context.getSystemService(Context.SENSOR_SERVICE) as SensorManager&#10;        accelerometer = sensorManager?.getDefaultSensor(Sensor.TYPE_ACCELEROMETER)&#10;&#10;        if (accelerometer == null) {&#10;            return&#10;        }&#10;&#10;        val registered = sensorManager?.registerListener(&#10;            this,&#10;            accelerometer,&#10;            SensorManager.SENSOR_DELAY_GAME&#10;        ) ?: false&#10;&#10;        isListening = registered&#10;    }&#10;&#10;    /**&#10;     * Detiene la detección de shake&#10;     */&#10;    fun stop() {&#10;        sensorManager?.unregisterListener(this)&#10;        isListening = false&#10;    }&#10;&#10;    /**&#10;     * Reinicia el detector con la configuración actual&#10;     */&#10;    fun restart() {&#10;        stop()&#10;        start()&#10;    }&#10;&#10;    override fun onSensorChanged(event: SensorEvent?) {&#10;        if (event?.sensor?.type != Sensor.TYPE_ACCELEROMETER) return&#10;&#10;        val currentTime = System.currentTimeMillis()&#10;&#10;        // Solo procesar si ha pasado suficiente tiempo desde la última actualización&#10;        if ((currentTime - lastUpdate) &lt; UPDATE_INTERVAL_MS) return&#10;&#10;        val diffTime = currentTime - lastUpdate&#10;        lastUpdate = currentTime&#10;&#10;        val x = event.values[0]&#10;        val y = event.values[1]&#10;        val z = event.values[2]&#10;&#10;        val deltaX = x - lastX&#10;        val deltaY = y - lastY&#10;        val deltaZ = z - lastZ&#10;&#10;        lastX = x&#10;        lastY = y&#10;        lastZ = z&#10;&#10;        // Calcular la velocidad del movimiento&#10;        val speed = sqrt((deltaX * deltaX + deltaY * deltaY + deltaZ * deltaZ).toDouble()) / diffTime * 10000&#10;&#10;        if (speed &gt; SHAKE_THRESHOLD) {&#10;            val timeSinceLastShake = currentTime - lastShakeTime&#10;&#10;            // Verificar cooldown para evitar múltiples detecciones&#10;            if (timeSinceLastShake &gt; SHAKE_COOLDOWN_MS) {&#10;                lastShakeTime = currentTime&#10;&#10;                val action = Config.getShakeAction(context)&#10;&#10;                if (action != ACTION_OFF) {&#10;                    onShakeDetected(action)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onAccuracyChanged(sensor: Sensor?, accuracy: Int) {&#10;        // No action needed&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>