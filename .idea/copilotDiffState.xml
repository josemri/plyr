<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt" />
              <option name="originalContent" value="package com.plyr&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.ExoPlyrScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTokens&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.model.AudioItem&#10;import com.plyr.database.TrackEntity&#10;import android.net.Uri&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * MainActivity - Actividad principal de la aplicación&#10; * &#10; * Esta actividad maneja:&#10; * - Conexión con el MusicService para reproducción en segundo plano&#10; * - Navegación entre pantallas (lista de audio, reproductor, configuración)&#10; * - Callbacks de OAuth de Spotify para autenticación&#10; * - Configuración del tema de la aplicación&#10; * - Coordinación entre UI y PlayerViewModel&#10; * &#10; * La aplicación usa un diseño modular con:&#10; * - PlayerViewModel para lógica de reproducción&#10; * - MusicService para reproducción en segundo plano&#10; * - Componentes UI independientes y reutilizables&#10; */&#10;class MainActivity : ComponentActivity() {&#10;    &#10;    // === PROPIEDADES ===&#10;    &#10;    /** Referencia al servicio de música para reproducción en segundo plano */&#10;    private var musicService: MusicService? = null&#10;    &#10;    /** Indica si el servicio está conectado */&#10;    private var bound = false&#10;    &#10;    /** Indica si la aplicación está siendo cerrada intencionalmente */&#10;    private var isAppClosing = false&#10;&#10;    // === CONFIGURACIÓN DEL SERVICIO ===&#10;    &#10;    /**&#10;     * Conexión con el MusicService para comunicación bidireccional.&#10;     */&#10;    private val connection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            bound = true&#10;            println(&quot;MainActivity: Servicio de música conectado&quot;)&#10;        }&#10;        &#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            bound = false&#10;            println(&quot;MainActivity: Servicio de música desconectado&quot;)&#10;        }&#10;    }    &#10;    // === CICLO DE VIDA DE LA ACTIVIDAD ===&#10;    &#10;    /**&#10;     * Inicializa la actividad, configura el servicio de música y establece el contenido UI.&#10;     */&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Procesar callback de Spotify OAuth si existe&#10;        handleSpotifyCallback(intent)&#10;        &#10;        // Configurar UI edge-to-edge&#10;        enableEdgeToEdge()&#10;        &#10;        // Configurar servicio de música&#10;        setupMusicService()&#10;        &#10;        // Configurar contenido UI&#10;        setupUIContent()&#10;    }&#10;    &#10;    /**&#10;     * Configura e inicia el servicio de música.&#10;     */&#10;    private fun setupMusicService() {&#10;        Intent(this, MusicService::class.java).also { intent -&gt;&#10;            startService(intent)&#10;            bindService(intent, connection, Context.BIND_AUTO_CREATE)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura el contenido principal de la UI.&#10;     */&#10;    private fun setupUIContent() {&#10;        setContent {&#10;            var playerViewModel = (application as PlyrApp).playerViewModel&#10;            //val playerViewModel: PlayerViewModel = viewModel()&#10;            var currentScreen by remember { mutableStateOf(&quot;list&quot;) }&#10;            var selectedVideoId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;            // Gestión del tema&#10;            val selectedTheme = remember { mutableStateOf(Config.getTheme(this@MainActivity)) }&#10;            val isDarkTheme = selectedTheme.value == &quot;dark&quot;&#10;&#10;            TerminalTheme(isDark = isDarkTheme) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainScreenContainer(&#10;                        currentScreen = currentScreen,&#10;                        onScreenChange = { currentScreen = it },&#10;                        selectedVideoId = selectedVideoId,&#10;                        onVideoIdChange = { selectedVideoId = it },&#10;                        playerViewModel = playerViewModel,&#10;                        selectedTheme = selectedTheme&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Contenedor principal que organiza las pantallas y controles flotantes.&#10;     */&#10;    @Composable&#10;    private fun MainScreenContainer(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        selectedVideoId: String?,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .statusBarsPadding()&#10;        ) {&#10;            // Área de contenido principal con padding para controles flotantes&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(bottom = 140.dp)&#10;            ) {&#10;                ScreenContent(&#10;                    currentScreen = currentScreen,&#10;                    onScreenChange = onScreenChange,&#10;                    onVideoIdChange = onVideoIdChange,&#10;                    playerViewModel = playerViewModel,&#10;                    selectedTheme = selectedTheme&#10;                )&#10;            }&#10;&#10;            // Controles flotantes de música&#10;            FloatingMusicControls(&#10;                playerViewModel = playerViewModel,&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(bottom = 48.dp)&#10;            )&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja el contenido de las diferentes pantallas.&#10;     */&#10;    @Composable&#10;    private fun ScreenContent(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        when (currentScreen) {&#10;            &quot;player&quot; -&gt; {&#10;                playerViewModel.exoPlayer?.let { player -&gt;&#10;                    ExoPlyrScreen(&#10;                        player = player,&#10;                        onBack = { onScreenChange(&quot;list&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                AudioListScreen(&#10;                    context = this@MainActivity,&#10;                    onVideoSelected = { videoId, title -&gt;&#10;                        handleVideoSelection(videoId, title, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onVideoSelectedFromSearch = { videoId, title, searchResults, selectedIndex -&gt;&#10;                        handleVideoSelectionFromSearch(videoId, title, searchResults, selectedIndex, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onThemeChanged = { newTheme -&gt;&#10;                        selectedTheme.value = newTheme&#10;                    },&#10;                    playerViewModel = playerViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video para reproducir.&#10;     * Si el video viene de una búsqueda, configura toda la lista como playlist.&#10;     */&#10;    private fun handleVideoSelection(&#10;        videoId: String,&#10;        title: String,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Si hay una playlist activa, pasarla al servicio para reproducción en background&#10;        val playlist = playerViewModel.currentPlaylist.value&#10;        val currentIndex = playerViewModel.currentTrackIndex.value ?: 0&#10;        if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;            // Obtener las URLs de audio para cada track&#10;            // NOTA: Esto requiere que los YouTube IDs ya estén resueltos o que el servicio pueda resolverlos&#10;            val audioUrls = playlist.mapNotNull { track -&gt;&#10;                // Usar el YouTube ID del track para obtener la URL de audio&#10;                track.youtubeVideoId ?: track.spotifyTrackId&#10;            }&#10;            if (audioUrls.isNotEmpty()) {&#10;                musicService?.playPlaylist(audioUrls, currentIndex)&#10;            }&#10;        } else {&#10;            // Si no hay playlist, reproducir solo el videoId&#10;            musicService?.playAudio(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video desde resultados de búsqueda.&#10;     * Configura toda la lista de resultados como playlist temporal.&#10;     */&#10;    private fun handleVideoSelectionFromSearch(&#10;        videoId: String,&#10;        title: String,&#10;        searchResults: List&lt;AudioItem&gt;,&#10;        selectedIndex: Int,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        &#10;        // Convertir los resultados de búsqueda a TrackEntity para crear una playlist temporal&#10;        val searchPlaylist = searchResults.mapIndexed { index, audioItem -&gt;&#10;            TrackEntity(&#10;                id = &quot;search_${audioItem.videoId ?: audioItem.title}_$index&quot;,&#10;                playlistId = &quot;search_results_${System.currentTimeMillis()}&quot;,&#10;                spotifyTrackId = &quot;&quot;, // Empty string for YouTube tracks&#10;                name = audioItem.title,&#10;                artists = audioItem.channel ?: &quot;Desconocido&quot;,&#10;                youtubeVideoId = audioItem.videoId,&#10;                audioUrl = null,&#10;                position = index,&#10;                lastSyncTime = System.currentTimeMillis()&#10;            )&#10;        }&#10;        &#10;        // Establecer la playlist de búsqueda en el PlayerViewModel&#10;        playerViewModel.setCurrentPlaylist(searchPlaylist, selectedIndex)&#10;        &#10;        // Cargar el video seleccionado&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Configurar el servicio para reproducción en background&#10;        val audioUrls = searchPlaylist.mapNotNull { it.youtubeVideoId }&#10;        if (audioUrls.isNotEmpty()) {&#10;            musicService?.playPlaylist(audioUrls, selectedIndex)&#10;        }&#10;    }    &#10;    /**&#10;     * Limpia recursos al destruir la actividad.&#10;     */&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Si la aplicación se está cerrando, detener completamente el servicio&#10;        if (isAppClosing || isFinishing) {&#10;            stopMusicServiceCompletely()&#10;        } else {&#10;            // Solo desconectar el binding, pero mantener el servicio para reproducción en background&#10;            disconnectMusicService()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maneja el botón de back para cerrar la aplicación completamente&#10;     */&#10;    override fun onBackPressed() {&#10;        // Marcar que la aplicación se está cerrando intencionalmente&#10;        isAppClosing = true&#10;        super.onBackPressed()&#10;    }&#10;&#10;    /**&#10;     * Detiene completamente el servicio de música y cierra la aplicación&#10;     */&#10;    private fun stopMusicServiceCompletely() {&#10;        musicService?.let { service -&gt;&#10;            // Parar la reproducción&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            playerViewModel.pausePlayer()&#10;&#10;            // Detener el servicio foreground&#10;            service.stopForegroundService()&#10;        }&#10;&#10;        // Desconectar el binding&#10;        disconnectMusicService()&#10;&#10;        // Detener el servicio completamente&#10;        stopService(Intent(this, MusicService::class.java))&#10;    }&#10;    &#10;    // === MANEJO DE INTENTS ===&#10;    &#10;    /**&#10;     * Maneja nuevos intents, especialmente callbacks de Spotify OAuth.&#10;     */&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;        handleSpotifyCallback(intent)&#10;    }&#10;    &#10;    // === AUTENTICACIÓN DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Procesa callbacks de OAuth de Spotify cuando el usuario autoriza la aplicación.&#10;     * &#10;     * @param intent Intent que puede contener datos de callback de Spotify&#10;     */&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (isSpotifyCallback(uri)) {&#10;                processSpotifyAuthResult(uri)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el URI es un callback de Spotify OAuth.&#10;     * @param uri URI a verificar&#10;     * @return true si es un callback de Spotify&#10;     */&#10;    private fun isSpotifyCallback(uri: Uri): Boolean {&#10;        return uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;&#10;    }&#10;    &#10;    /**&#10;     * Procesa el resultado de la autorización de Spotify.&#10;     * @param uri URI con los parámetros de respuesta de OAuth&#10;     */&#10;    private fun processSpotifyAuthResult(uri: Uri) {&#10;        val code = uri.getQueryParameter(&quot;code&quot;)&#10;        val error = uri.getQueryParameter(&quot;error&quot;)&#10;        &#10;        when {&#10;            error != null -&gt; handleSpotifyAuthError(error)&#10;            code != null -&gt; handleSpotifyAuthSuccess(code)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la autorización de Spotify.&#10;     * @param error Código de error recibido&#10;     */&#10;    private fun handleSpotifyAuthError(error: String) {&#10;        println(&quot;MainActivity: Spotify OAuth error: $error&quot;)&#10;        SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Maneja la autorización exitosa de Spotify.&#10;     * @param code Código de autorización recibido&#10;     */&#10;    private fun handleSpotifyAuthSuccess(code: String) {&#10;        SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, tokenError -&gt;&#10;            if (tokens != null &amp;&amp; tokenError == null) {&#10;                saveSpotifyTokens(tokens)&#10;                println(&quot;MainActivity: Spotify OAuth success: Tokens guardados&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;            } else {&#10;                println(&quot;MainActivity: Error intercambiando tokens: $tokenError&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Guarda los tokens de Spotify en las preferencias.&#10;     * @param tokens Tokens de acceso y refresh recibidos&#10;     */&#10;    private fun saveSpotifyTokens(tokens: SpotifyTokens) {&#10;        Config.setSpotifyTokens(&#10;            this,&#10;            tokens.accessToken,&#10;            tokens.refreshToken,&#10;            tokens.expiresIn&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.ExoPlyrScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTokens&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.model.AudioItem&#10;import com.plyr.database.TrackEntity&#10;import android.net.Uri&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * MainActivity - Actividad principal de la aplicación&#10; * &#10; * Esta actividad maneja:&#10; * - Conexión con el MusicService para reproducción en segundo plano&#10; * - Navegación entre pantallas (lista de audio, reproductor, configuración)&#10; * - Callbacks de OAuth de Spotify para autenticación&#10; * - Configuración del tema de la aplicación&#10; * - Coordinación entre UI y PlayerViewModel&#10; * &#10; * La aplicación usa un diseño modular con:&#10; * - PlayerViewModel para lógica de reproducción&#10; * - MusicService para reproducción en segundo plano&#10; * - Componentes UI independientes y reutilizables&#10; */&#10;class MainActivity : ComponentActivity() {&#10;    &#10;    // === PROPIEDADES ===&#10;    &#10;    /** Referencia al servicio de música para reproducción en segundo plano */&#10;    private var musicService: MusicService? = null&#10;    &#10;    /** Indica si el servicio está conectado */&#10;    private var bound = false&#10;    &#10;    /** Indica si la aplicación está siendo cerrada intencionalmente */&#10;    private var isAppClosing = false&#10;&#10;    // === CONFIGURACIÓN DEL SERVICIO ===&#10;    &#10;    /**&#10;     * Conexión con el MusicService para comunicación bidireccional.&#10;     */&#10;    private val connection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            bound = true&#10;            println(&quot;MainActivity: Servicio de música conectado&quot;)&#10;        }&#10;        &#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            bound = false&#10;            println(&quot;MainActivity: Servicio de música desconectado&quot;)&#10;        }&#10;    }    &#10;    // === CICLO DE VIDA DE LA ACTIVIDAD ===&#10;    &#10;    /**&#10;     * Inicializa la actividad, configura el servicio de música y establece el contenido UI.&#10;     */&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Procesar callback de Spotify OAuth si existe&#10;        handleSpotifyCallback(intent)&#10;        &#10;        // Configurar UI edge-to-edge&#10;        enableEdgeToEdge()&#10;        &#10;        // Configurar servicio de música&#10;        setupMusicService()&#10;        &#10;        // Configurar contenido UI&#10;        setupUIContent()&#10;    }&#10;    &#10;    /**&#10;     * Configura e inicia el servicio de música.&#10;     */&#10;    private fun setupMusicService() {&#10;        Intent(this, MusicService::class.java).also { intent -&gt;&#10;            startService(intent)&#10;            bindService(intent, connection, Context.BIND_AUTO_CREATE)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura el contenido principal de la UI.&#10;     */&#10;    private fun setupUIContent() {&#10;        setContent {&#10;            var playerViewModel = (application as PlyrApp).playerViewModel&#10;            //val playerViewModel: PlayerViewModel = viewModel()&#10;            var currentScreen by remember { mutableStateOf(&quot;list&quot;) }&#10;            var selectedVideoId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;            // Gestión del tema&#10;            val selectedTheme = remember { mutableStateOf(Config.getTheme(this@MainActivity)) }&#10;            val isDarkTheme = selectedTheme.value == &quot;dark&quot;&#10;&#10;            TerminalTheme(isDark = isDarkTheme) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainScreenContainer(&#10;                        currentScreen = currentScreen,&#10;                        onScreenChange = { currentScreen = it },&#10;                        selectedVideoId = selectedVideoId,&#10;                        onVideoIdChange = { selectedVideoId = it },&#10;                        playerViewModel = playerViewModel,&#10;                        selectedTheme = selectedTheme&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Contenedor principal que organiza las pantallas y controles flotantes.&#10;     */&#10;    @Composable&#10;    private fun MainScreenContainer(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        selectedVideoId: String?,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .statusBarsPadding()&#10;        ) {&#10;            // Área de contenido principal con padding para controles flotantes&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(bottom = 140.dp)&#10;            ) {&#10;                ScreenContent(&#10;                    currentScreen = currentScreen,&#10;                    onScreenChange = onScreenChange,&#10;                    onVideoIdChange = onVideoIdChange,&#10;                    playerViewModel = playerViewModel,&#10;                    selectedTheme = selectedTheme&#10;                )&#10;            }&#10;&#10;            // Controles flotantes de música&#10;            FloatingMusicControls(&#10;                playerViewModel = playerViewModel,&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(bottom = 48.dp)&#10;            )&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja el contenido de las diferentes pantallas.&#10;     */&#10;    @Composable&#10;    private fun ScreenContent(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        when (currentScreen) {&#10;            &quot;player&quot; -&gt; {&#10;                playerViewModel.exoPlayer?.let { player -&gt;&#10;                    ExoPlyrScreen(&#10;                        player = player,&#10;                        onBack = { onScreenChange(&quot;list&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                AudioListScreen(&#10;                    context = this@MainActivity,&#10;                    onVideoSelected = { videoId, title -&gt;&#10;                        handleVideoSelection(videoId, title, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onVideoSelectedFromSearch = { videoId, title, searchResults, selectedIndex -&gt;&#10;                        handleVideoSelectionFromSearch(videoId, title, searchResults, selectedIndex, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onThemeChanged = { newTheme -&gt;&#10;                        selectedTheme.value = newTheme&#10;                    },&#10;                    playerViewModel = playerViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video para reproducir.&#10;     * Si el video viene de una búsqueda, configura toda la lista como playlist.&#10;     */&#10;    private fun handleVideoSelection(&#10;        videoId: String,&#10;        title: String,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Si hay una playlist activa, pasarla al servicio para reproducción en background&#10;        val playlist = playerViewModel.currentPlaylist.value&#10;        val currentIndex = playerViewModel.currentTrackIndex.value ?: 0&#10;        if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;            // Obtener las URLs de audio para cada track&#10;            // NOTA: Esto requiere que los YouTube IDs ya estén resueltos o que el servicio pueda resolverlos&#10;            val audioUrls = playlist.mapNotNull { track -&gt;&#10;                // Usar el YouTube ID del track para obtener la URL de audio&#10;                track.youtubeVideoId ?: track.spotifyTrackId&#10;            }&#10;            if (audioUrls.isNotEmpty()) {&#10;                musicService?.playPlaylist(audioUrls, currentIndex)&#10;            }&#10;        } else {&#10;            // Si no hay playlist, reproducir solo el videoId&#10;            musicService?.playAudio(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video desde resultados de búsqueda.&#10;     * Configura toda la lista de resultados como playlist temporal.&#10;     */&#10;    private fun handleVideoSelectionFromSearch(&#10;        videoId: String,&#10;        title: String,&#10;        searchResults: List&lt;AudioItem&gt;,&#10;        selectedIndex: Int,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        &#10;        // Convertir los resultados de búsqueda a TrackEntity para crear una playlist temporal&#10;        val searchPlaylist = searchResults.mapIndexed { index, audioItem -&gt;&#10;            TrackEntity(&#10;                id = &quot;search_${audioItem.videoId ?: audioItem.title}_$index&quot;,&#10;                playlistId = &quot;search_results_${System.currentTimeMillis()}&quot;,&#10;                spotifyTrackId = &quot;&quot;, // Empty string for YouTube tracks&#10;                name = audioItem.title,&#10;                artists = audioItem.channel ?: &quot;Desconocido&quot;,&#10;                youtubeVideoId = audioItem.videoId,&#10;                audioUrl = null,&#10;                position = index,&#10;                lastSyncTime = System.currentTimeMillis()&#10;            )&#10;        }&#10;        &#10;        // Establecer la playlist de búsqueda en el PlayerViewModel&#10;        playerViewModel.setCurrentPlaylist(searchPlaylist, selectedIndex)&#10;        &#10;        // Cargar el video seleccionado&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Configurar el servicio para reproducción en background&#10;        val audioUrls = searchPlaylist.mapNotNull { it.youtubeVideoId }&#10;        if (audioUrls.isNotEmpty()) {&#10;            musicService?.playPlaylist(audioUrls, selectedIndex)&#10;        }&#10;    }    &#10;    /**&#10;     * Limpia recursos al destruir la actividad.&#10;     */&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Si la aplicación se está cerrando, detener completamente el servicio&#10;        if (isAppClosing || isFinishing) {&#10;            stopMusicServiceCompletely()&#10;        } else {&#10;            // Solo desconectar el binding, pero mantener el servicio para reproducción en background&#10;            disconnectMusicService()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maneja el botón de back para cerrar la aplicación completamente&#10;     */&#10;    override fun onBackPressed() {&#10;        // Marcar que la aplicación se está cerrando intencionalmente&#10;        isAppClosing = true&#10;        super.onBackPressed()&#10;    }&#10;&#10;    /**&#10;     * Detiene completamente el servicio de música y cierra la aplicación&#10;     */&#10;    private fun stopMusicServiceCompletely() {&#10;        musicService?.let { service -&gt;&#10;            // Parar la reproducción&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            playerViewModel.pausePlayer()&#10;&#10;            // Detener el servicio foreground&#10;            service.stopForegroundService()&#10;        }&#10;&#10;        // Desconectar el binding&#10;        disconnectMusicService()&#10;&#10;        // Detener el servicio completamente&#10;        stopService(Intent(this, MusicService::class.java))&#10;    }&#10;    &#10;    /**&#10;     * Desconecta el servicio de música si está conectado.&#10;     */&#10;    private fun disconnectMusicService() {&#10;        if (bound) {&#10;            unbindService(connection)&#10;            bound = false&#10;        }&#10;    }&#10;    &#10;    // === MANEJO DE INTENTS ===&#10;    &#10;    /**&#10;     * Maneja nuevos intents, especialmente callbacks de Spotify OAuth.&#10;     */&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;        handleSpotifyCallback(intent)&#10;    }&#10;    &#10;    // === AUTENTICACIÓN DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Procesa callbacks de OAuth de Spotify cuando el usuario autoriza la aplicación.&#10;     * &#10;     * @param intent Intent que puede contener datos de callback de Spotify&#10;     */&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (isSpotifyCallback(uri)) {&#10;                processSpotifyAuthResult(uri)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el URI es un callback de Spotify OAuth.&#10;     * @param uri URI a verificar&#10;     * @return true si es un callback de Spotify&#10;     */&#10;    private fun isSpotifyCallback(uri: Uri): Boolean {&#10;        return uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;&#10;    }&#10;    &#10;    /**&#10;     * Procesa el resultado de la autorización de Spotify.&#10;     * @param uri URI con los parámetros de respuesta de OAuth&#10;     */&#10;    private fun processSpotifyAuthResult(uri: Uri) {&#10;        val code = uri.getQueryParameter(&quot;code&quot;)&#10;        val error = uri.getQueryParameter(&quot;error&quot;)&#10;        &#10;        when {&#10;            error != null -&gt; handleSpotifyAuthError(error)&#10;            code != null -&gt; handleSpotifyAuthSuccess(code)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la autorización de Spotify.&#10;     * @param error Código de error recibido&#10;     */&#10;    private fun handleSpotifyAuthError(error: String) {&#10;        println(&quot;MainActivity: Spotify OAuth error: $error&quot;)&#10;        SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Maneja la autorización exitosa de Spotify.&#10;     * @param code Código de autorización recibido&#10;     */&#10;    private fun handleSpotifyAuthSuccess(code: String) {&#10;        SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, tokenError -&gt;&#10;            if (tokens != null &amp;&amp; tokenError == null) {&#10;                saveSpotifyTokens(tokens)&#10;                println(&quot;MainActivity: Spotify OAuth success: Tokens guardados&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;            } else {&#10;                println(&quot;MainActivity: Error intercambiando tokens: $tokenError&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Guarda los tokens de Spotify en las preferencias.&#10;     * @param tokens Tokens de acceso y refresh recibidos&#10;     */&#10;    private fun saveSpotifyTokens(tokens: SpotifyTokens) {&#10;        Config.setSpotifyTokens(&#10;            this,&#10;            tokens.accessToken,&#10;            tokens.refreshToken,&#10;            tokens.expiresIn&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items.map { artistFull -&gt;&#10;                        SpotifyArtist(name = artistFull.name)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;}&#10;&#10;                    artists = searchResults.artists.items.map { artistFull -&gt;&#10;                        SpotifyArtist(name = artistFull.name)&#10;                    }&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 4.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Track icon&#10;                Text(&#10;                    text = &quot;♫&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        color = Color(0xFF1DB954),&#10;                        fontSize = 16.sp&#10;                    ),&#10;                    modifier = Modifier.padding(end = 12.dp)&#10;                )&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = track.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = track.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = album.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = album.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = playlist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtist&gt;&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;    artists: List&lt;SpotifyArtist&gt;&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(120.dp)&#10;                        .padding(8.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // SpotifyArtist doesn't have images, so we'll show a placeholder&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 24.sp&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    Text(&#10;                    // SpotifyArtist doesn't have images, so we'll show a placeholder&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 24.sp&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.shape.CircleShape&#10;&#10;@Composable&#10;fun SpotifySearchResults(&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Nuevo callback para artistas&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items, // Ahora son SpotifyArtistFull&#10;                    onArtistSelected = onArtistSelected&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyTracksSection(&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 4.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Track icon&#10;                Text(&#10;                    text = &quot;♫&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        color = Color(0xFF1DB954),&#10;                        fontSize = 16.sp&#10;                    ),&#10;                    modifier = Modifier.padding(end = 12.dp)&#10;                )&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = track.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = track.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = album.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = album.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = playlist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtistFull&gt;, // Cambiar de SpotifyArtist a SpotifyArtistFull&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(120.dp)&#10;                        .clickable { onArtistSelected(artist) } // Hacer clickeable&#10;                        .padding(8.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Usar imagen del artista si está disponible&#10;                    artist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = &quot;Imagen de ${artist.name}&quot;,&#10;                            modifier = Modifier&#10;                                .size(80.dp)&#10;                                .clip(CircleShape)&#10;                        )&#10;                    } ?: run {&#10;                        // Placeholder si no hay imagen&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(80.dp)&#10;                                .clip(CircleShape)&#10;                                .background(Color(0xFF1DB954).copy(alpha = 0.2f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;♫&quot;,&#10;                                style = MaterialTheme.typography.headlineMedium.copy(&#10;                                    color = Color(0xFF1DB954),&#10;                                    fontSize = 24.sp&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = artist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/SpotifyTokenManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/SpotifyTokenManager.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.plyr.network.SpotifyRepository&#10;import kotlinx.coroutines.*&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * SpotifyTokenManager - Gestor centralizado de tokens de Spotify&#10; * &#10; * Este manager se encarga de:&#10; * - Verificar automáticamente si los tokens han expirado&#10; * - Renovar tokens automáticamente cuando sea necesario&#10; * - Proporcionar tokens válidos para todas las llamadas a la API&#10; * - Manejar la renovación de forma thread-safe&#10; * - Evitar múltiples renovaciones simultáneas&#10; */&#10;object SpotifyTokenManager {&#10;    &#10;    private const val TAG = &quot;SpotifyTokenManager&quot;&#10;    &#10;    // Margen de seguridad: renovar 5 minutos antes de que expire&#10;    private const val EXPIRATION_BUFFER_MS = 5 * 60 * 1000L // 5 minutos&#10;    &#10;    // Control de renovación en progreso&#10;    private val isRefreshing = AtomicBoolean(false)&#10;    private var refreshDeferred: Deferred&lt;String?&gt;? = null&#10;    &#10;    /**&#10;     * Obtiene un token de acceso válido, renovándolo automáticamente si es necesario.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    suspend fun getValidAccessToken(context: Context): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // 1. Verificar si tenemos un token actual válido&#10;            val currentToken = Config.getSpotifyAccessToken(context)&#10;            if (currentToken != null &amp;&amp; !isTokenExpired(context)) {&#10;                Log.d(TAG, &quot;Token actual es válido&quot;)&#10;                return@withContext currentToken&#10;            }&#10;            &#10;            // 2. El token ha expirado o no existe, necesitamos renovarlo&#10;            Log.d(TAG, &quot;Token expirado o inexistente, iniciando renovación&quot;)&#10;            return@withContext refreshTokenSafely(context)&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error obteniendo token válido&quot;, e)&#10;            return@withContext null&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el token actual ha expirado o está cerca de expirar.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si el token ha expirado o está cerca de expirar&#10;     */&#10;    private fun isTokenExpired(context: Context): Boolean {&#10;        val tokenTimestamp = Config.getSpotifyTokenTimestamp(context)&#10;        val expiresIn = Config.getSpotifyTokenExpiresIn(context)&#10;        &#10;        if (tokenTimestamp == 0L || expiresIn == 0) {&#10;            Log.d(TAG, &quot;No hay información de expiración del token&quot;)&#10;            return true&#10;        }&#10;        &#10;        val expirationTime = tokenTimestamp + (expiresIn * 1000L)&#10;        val currentTime = System.currentTimeMillis()&#10;        val timeToExpiry = expirationTime - currentTime&#10;        &#10;        val isExpired = timeToExpiry &lt;= EXPIRATION_BUFFER_MS&#10;        &#10;        Log.d(TAG, &quot;Verificación de expiración: tiempo restante = ${timeToExpiry / 1000}s, expirado = $isExpired&quot;)&#10;        &#10;        return isExpired&#10;    }&#10;    &#10;    /**&#10;     * Renueva el token de forma thread-safe, evitando múltiples renovaciones simultáneas.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token renovado o null si falló&#10;     */&#10;    private suspend fun refreshTokenSafely(context: Context): String? = withContext(Dispatchers.IO) {&#10;        // Si ya hay una renovación en progreso, esperar a que termine&#10;        if (isRefreshing.get()) {&#10;            Log.d(TAG, &quot;Renovación ya en progreso, esperando...&quot;)&#10;            return@withContext refreshDeferred?.await()&#10;        }&#10;        &#10;        // Iniciar nueva renovación&#10;        if (isRefreshing.compareAndSet(false, true)) {&#10;            Log.d(TAG, &quot;Iniciando nueva renovación de token&quot;)&#10;            &#10;            refreshDeferred = async {&#10;                try {&#10;                    refreshTokenInternal(context)&#10;                } finally {&#10;                    isRefreshing.set(false)&#10;                    refreshDeferred = null&#10;                }&#10;            }&#10;            &#10;            return@withContext refreshDeferred!!.await()&#10;        } else {&#10;            // Otra corrutina ganó la carrera, esperar su resultado&#10;            return@withContext refreshDeferred?.await()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Realiza la renovación real del token.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token renovado o null si falló&#10;     */&#10;    private suspend fun refreshTokenInternal(context: Context): String? = suspendCoroutine { continuation -&gt;&#10;        val refreshToken = Config.getSpotifyRefreshToken(context)&#10;        &#10;        if (refreshToken == null) {&#10;            Log.e(TAG, &quot;No hay refresh token disponible&quot;)&#10;            continuation.resume(null)&#10;            return@suspendCoroutine&#10;        }&#10;        &#10;        Log.d(TAG, &quot;Enviando solicitud de renovación a Spotify...&quot;)&#10;        &#10;        SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;            if (error != null) {&#10;                Log.e(TAG, &quot;Error renovando token: $error&quot;)&#10;                continuation.resume(null)&#10;            } else if (newAccessToken != null) {&#10;                // Guardar el nuevo token con timestamp actual&#10;                val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                Config.setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                &#10;                Log.d(TAG, &quot;Token renovado exitosamente&quot;)&#10;                continuation.resume(newAccessToken)&#10;            } else {&#10;                Log.e(TAG, &quot;Respuesta inesperada al renovar token&quot;)&#10;                continuation.resume(null)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Invalida el token actual, forzando una renovación en la próxima solicitud.&#10;     * Útil cuando sabemos que el token ha sido revocado o es inválido.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun invalidateCurrentToken(context: Context) {&#10;        Log.d(TAG, &quot;Invalidando token actual&quot;)&#10;        Config.clearSpotifyAccessToken(context)&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay credenciales de Spotify configuradas.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay refresh token disponible&#10;     */&#10;    fun hasValidCredentials(context: Context): Boolean {&#10;        return Config.getSpotifyRefreshToken(context) != null&#10;    }&#10;    &#10;    /**&#10;     * Ejecuta una operación con un token válido, manejando automáticamente la renovación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param operation Operación a ejecutar con el token&#10;     * @return Resultado de la operación o null si no se pudo obtener token válido&#10;     */&#10;    suspend fun &lt;T&gt; withValidToken(&#10;        context: Context, &#10;        operation: suspend (token: String) -&gt; T?&#10;    ): T? {&#10;        val token = getValidAccessToken(context)&#10;        return if (token != null) {&#10;            try {&#10;                operation(token)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error ejecutando operación con token&quot;, e)&#10;                null&#10;            }&#10;        } else {&#10;            Log.e(TAG, &quot;No se pudo obtener token válido para la operación&quot;)&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>