<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SimpleDownloader.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SimpleDownloader.kt" />
              <option name="originalContent" value="package com.plyr.network&#10;&#10;import org.schabi.newpipe.extractor.downloader.Downloader&#10;import org.schabi.newpipe.extractor.downloader.Request&#10;import org.schabi.newpipe.extractor.downloader.Response&#10;import org.schabi.newpipe.extractor.exceptions.ReCaptchaException&#10;import java.io.IOException&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;&#10;class SimpleDownloader : Downloader() {&#10;&#10;    companion object {&#10;        private const val USER_AGENT = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36&quot;&#10;        private const val TIMEOUT = 30000 // 30 segundos&#10;    }&#10;&#10;    @Throws(IOException::class, ReCaptchaException::class)&#10;    override fun execute(request: Request): Response {&#10;        val connection = URL(request.url()).openConnection() as HttpURLConnection&#10;&#10;        return try {&#10;            // Configurar conexión&#10;            connection.connectTimeout = TIMEOUT&#10;            connection.readTimeout = TIMEOUT&#10;            connection.setRequestProperty(&quot;User-Agent&quot;, USER_AGENT)&#10;            connection.requestMethod = request.httpMethod()&#10;&#10;            // Agregar headers personalizados&#10;            request.headers()?.forEach { (key, values) -&gt;&#10;                values.forEach { value -&gt;&#10;                    connection.addRequestProperty(key, value)&#10;                }&#10;            }&#10;&#10;            // Enviar datos si es necesario (POST, PUT, etc.)&#10;            request.dataToSend()?.let { data -&gt;&#10;                connection.doOutput = true&#10;                connection.outputStream.use { it.write(data) }&#10;            }&#10;&#10;            // Obtener respuesta&#10;            val responseCode = connection.responseCode&#10;            val responseBody = try {&#10;                if (responseCode &lt; 400) {&#10;                    connection.inputStream.bufferedReader().readText()&#10;                } else {&#10;                    connection.errorStream?.bufferedReader()?.readText() ?: &quot;&quot;&#10;                }&#10;            } catch (_: Exception) {&#10;                &quot;&quot;&#10;            }&#10;&#10;            Response(&#10;                responseCode,&#10;                connection.responseMessage ?: &quot;&quot;,&#10;                connection.headerFields.filterKeys { it != null },&#10;                responseBody,&#10;                request.url()&#10;            )&#10;&#10;        } finally {&#10;            connection.disconnect()&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.plyr.network&#10;&#10;import android.util.Log&#10;import org.schabi.newpipe.extractor.downloader.Downloader&#10;import org.schabi.newpipe.extractor.downloader.Request&#10;import org.schabi.newpipe.extractor.downloader.Response&#10;import org.schabi.newpipe.extractor.exceptions.ReCaptchaException&#10;import java.io.IOException&#10;import java.util.concurrent.TimeUnit&#10;import okhttp3.OkHttpClient&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import okhttp3.ResponseBody&#10;&#10;class SimpleDownloader private constructor() : Downloader() {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;SimpleDownloader&quot;&#10;        private const val USER_AGENT = &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64; rv:140.0) Gecko/20100101 Firefox/140.0&quot;&#10;        private const val YOUTUBE_RESTRICTED_MODE_COOKIE = &quot;PREF=f2=8000000&quot;&#10;        private const val YOUTUBE_DOMAIN = &quot;youtube.com&quot;&#10;&#10;        @Volatile&#10;        private var instance: SimpleDownloader? = null&#10;&#10;        fun getInstance(): SimpleDownloader {&#10;            return instance ?: synchronized(this) {&#10;                instance ?: SimpleDownloader().also { instance = it }&#10;            }&#10;        }&#10;    }&#10;&#10;    private val cookies = mutableMapOf&lt;String, String&gt;()&#10;    private val client: OkHttpClient&#10;&#10;    init {&#10;        // Configurar OkHttp client como lo hace NewPipe&#10;        client = OkHttpClient.Builder()&#10;            .readTimeout(30, TimeUnit.SECONDS)&#10;            .connectTimeout(30, TimeUnit.SECONDS)&#10;            .followRedirects(true)&#10;            .followSslRedirects(true)&#10;            .build()&#10;&#10;        // Agregar cookie de modo restringido de YouTube por defecto&#10;        setCookie(&quot;youtube_restricted_mode_key&quot;, YOUTUBE_RESTRICTED_MODE_COOKIE)&#10;        Log.d(TAG, &quot;✅ SimpleDownloader inicializado con OkHttp&quot;)&#10;    }&#10;&#10;    fun setCookie(key: String, cookie: String) {&#10;        cookies[key] = cookie&#10;    }&#10;&#10;    fun getCookie(key: String): String? {&#10;        return cookies[key]&#10;    }&#10;&#10;    fun removeCookie(key: String) {&#10;        cookies.remove(key)&#10;    }&#10;&#10;    private fun getCookies(url: String): String {&#10;        val youtubeCookie = if (url.contains(YOUTUBE_DOMAIN)) {&#10;            getCookie(&quot;youtube_restricted_mode_key&quot;)&#10;        } else {&#10;            null&#10;        }&#10;&#10;        // Combinar todas las cookies relevantes&#10;        return listOfNotNull(youtubeCookie, getCookie(&quot;recaptcha_cookies_key&quot;))&#10;            .flatMap { it.split(&quot;; &quot;) }&#10;            .distinct()&#10;            .joinToString(&quot;; &quot;)&#10;    }&#10;&#10;    @Throws(IOException::class, ReCaptchaException::class)&#10;    override fun execute(request: Request): Response {&#10;        Log.d(TAG, &quot; Ejecutando petición: ${request.httpMethod()} ${request.url()}&quot;)&#10;&#10;        val httpMethod = request.httpMethod()&#10;        val url = request.url()&#10;        val headers = request.headers()&#10;        val dataToSend = request.dataToSend()&#10;&#10;        // Crear RequestBody si hay datos&#10;        val requestBody = if (dataToSend != null) {&#10;            dataToSend.toRequestBody(null)&#10;        } else {&#10;            null&#10;        }&#10;&#10;        // Construir request de OkHttp&#10;        val requestBuilder = okhttp3.Request.Builder()&#10;            .method(httpMethod, requestBody)&#10;            .url(url)&#10;            .addHeader(&quot;User-Agent&quot;, USER_AGENT)&#10;&#10;        // Agregar cookies&#10;        val cookiesString = getCookies(url)&#10;        if (cookiesString.isNotEmpty()) {&#10;            requestBuilder.addHeader(&quot;Cookie&quot;, cookiesString)&#10;            Log.d(TAG, &quot; Cookies: $cookiesString&quot;)&#10;        }&#10;&#10;        // Agregar headers personalizados&#10;        headers?.forEach { (headerName, headerValueList) -&gt;&#10;            requestBuilder.removeHeader(headerName)&#10;            headerValueList.forEach { headerValue -&gt;&#10;                requestBuilder.addHeader(headerName, headerValue)&#10;            }&#10;        }&#10;&#10;        // Log de headers&#10;        val builtRequest = requestBuilder.build()&#10;        Log.d(TAG, &quot; Headers enviados:&quot;)&#10;        builtRequest.headers.forEach { (name, value) -&gt;&#10;            Log.d(TAG, &quot;   $name: $value&quot;)&#10;        }&#10;&#10;        // Ejecutar petición&#10;        return try {&#10;            client.newCall(builtRequest).execute().use { response -&gt;&#10;                val responseCode = response.code&#10;                Log.d(TAG, &quot; Código de respuesta: $responseCode&quot;)&#10;&#10;                // Detectar reCaptcha challenge&#10;                if (responseCode == 429) {&#10;                    Log.e(TAG, &quot;⚠️ reCaptcha Challenge detectado (429)&quot;)&#10;                    throw ReCaptchaException(&quot;reCaptcha Challenge requested&quot;, url)&#10;                }&#10;&#10;                // Leer body&#10;                val responseBodyString: String = response.body?.use { body: ResponseBody -&gt;&#10;                    body.string()&#10;                } ?: &quot;&quot;&#10;&#10;                if (responseCode &lt; 400) {&#10;                    Log.d(TAG, &quot;✅ Respuesta exitosa: ${responseBodyString.length} caracteres&quot;)&#10;                    // Log adicional para peticiones del player de YouTube&#10;                    if (url.contains(&quot;/youtubei/v1/player&quot;)) {&#10;                        Log.d(TAG, &quot; Respuesta del Player API:&quot;)&#10;                        // Buscar playabilityStatus en la respuesta&#10;                        if (responseBodyString.contains(&quot;playabilityStatus&quot;)) {&#10;                            val statusStart = responseBodyString.indexOf(&quot;\&quot;playabilityStatus\&quot;&quot;)&#10;                            if (statusStart != -1) {&#10;                                val statusEnd = responseBodyString.indexOf(&quot;}&quot;, statusStart) + 1&#10;                                val status = responseBodyString.substring(statusStart, minOf(statusEnd + 200, responseBodyString.length))&#10;                                Log.d(TAG, &quot;   PlayabilityStatus: ${status.take(500)}&quot;)&#10;                            }&#10;                        }&#10;                    }&#10;                } else {&#10;                    Log.e(TAG, &quot;❌ Error ($responseCode): ${responseBodyString.take(500)}&quot;)&#10;                }&#10;&#10;                // Obtener URL final (después de redirecciones)&#10;                val latestUrl = response.request.url.toString()&#10;                if (latestUrl != url) {&#10;                    Log.d(TAG, &quot; Redirección: $latestUrl&quot;)&#10;                }&#10;&#10;                // Convertir headers de OkHttp a formato de NewPipe&#10;                val headersMap = mutableMapOf&lt;String, MutableList&lt;String&gt;&gt;()&#10;                response.headers.forEach { (name, value) -&gt;&#10;                    headersMap.getOrPut(name) { mutableListOf() }.add(value)&#10;                }&#10;&#10;                Response(&#10;                    responseCode,&#10;                    response.message,&#10;                    headersMap,&#10;                    responseBodyString,&#10;                    latestUrl&#10;                )&#10;            }&#10;        } catch (e: ReCaptchaException) {&#10;            Log.e(TAG, &quot; ReCaptcha Exception&quot;, e)&#10;            throw e&#10;        } catch (e: IOException) {&#10;            Log.e(TAG, &quot; IOException&quot;, e)&#10;            throw e&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Exception inesperada&quot;, e)&#10;            throw IOException(&quot;Error en petición HTTP&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/network/YouTubeManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/network/YouTubeManager.kt" />
              <option name="originalContent" value="package com.plyr.network&#10;&#10;import org.schabi.newpipe.extractor.NewPipe&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.localization.Localization&#10;&#10;/**&#10; * Gestor unificado de YouTube - Maneja búsqueda y extracción de audio&#10; */&#10;object YouTubeManager {&#10;    private var isInitialized = false&#10;&#10;    private fun ensureInitialized() {&#10;        if (isInitialized) return&#10;        try {&#10;            NewPipe.init(SimpleDownloader(), Localization(&quot;en&quot;, &quot;US&quot;))&#10;            isInitialized = true&#10;        } catch (e: Exception) {&#10;            throw e&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca un video en YouTube y devuelve su ID&#10;     */&#10;    fun searchVideoId(query: String): String? {&#10;        return try {&#10;            ensureInitialized()&#10;&#10;            val searchExtractor = ServiceList.YouTube.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;&#10;            searchExtractor.initialPage.items&#10;                .filterIsInstance&lt;org.schabi.newpipe.extractor.stream.StreamInfoItem&gt;()&#10;                .firstOrNull()?.url&#10;                ?.substringAfterLast(&quot;=&quot;)&#10;                ?.substringBefore(&quot;&amp;&quot;)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube&#10;     */&#10;    fun getAudioUrl(videoId: String): String? {&#10;        android.util.Log.d(&quot;YouTubeManager&quot;, &quot;Getting audio URL for video ID: $videoId&quot;)&#10;        return try {&#10;            ensureInitialized()&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;Initialized NewPipe for audio extraction&quot;)&#10;&#10;            val videoUrl = &quot;https://www.youtube.com/watch?v=$videoId&quot;&#10;            val extractor = ServiceList.YouTube.getStreamExtractor(videoUrl)&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;Created StreamExtractor for URL: $videoUrl&quot;)&#10;            extractor.fetchPage()&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;Extracted audio streams: ${extractor.audioStreams}&quot;)&#10;&#10;            extractor.audioStreams.firstOrNull()?.content&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.network&#10;&#10;import org.schabi.newpipe.extractor.NewPipe&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.localization.Localization&#10;&#10;/**&#10; * Gestor unificado de YouTube - Maneja búsqueda y extracción de audio&#10; */&#10;object YouTubeManager {&#10;    private var isInitialized = false&#10;&#10;    private fun ensureInitialized() {&#10;        if (isInitialized) return&#10;        try {&#10;            NewPipe.init(SimpleDownloader.getInstance(), Localization(&quot;en&quot;, &quot;US&quot;))&#10;            isInitialized = true&#10;        } catch (e: Exception) {&#10;            throw e&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Busca un video en YouTube y devuelve su ID&#10;     */&#10;    fun searchVideoId(query: String): String? {&#10;        return try {&#10;            ensureInitialized()&#10;&#10;            val searchExtractor = ServiceList.YouTube.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;&#10;            searchExtractor.initialPage.items&#10;                .filterIsInstance&lt;org.schabi.newpipe.extractor.stream.StreamInfoItem&gt;()&#10;                .firstOrNull()?.url&#10;                ?.substringAfterLast(&quot;=&quot;)&#10;                ?.substringBefore(&quot;&amp;&quot;)&#10;        } catch (_: Exception) {&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube&#10;     */&#10;    fun getAudioUrl(videoId: String): String? {&#10;        android.util.Log.d(&quot;YouTubeManager&quot;, &quot; Iniciando extracción de audio para video ID: $videoId&quot;)&#10;        return try {&#10;            ensureInitialized()&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;✅ NewPipe inicializado correctamente&quot;)&#10;&#10;            val videoUrl = &quot;https://www.youtube.com/watch?v=$videoId&quot;&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot; URL del video: $videoUrl&quot;)&#10;&#10;            val extractor = ServiceList.YouTube.getStreamExtractor(videoUrl)&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot; StreamExtractor creado, fetching page...&quot;)&#10;&#10;            extractor.fetchPage()&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;✅ Página fetched exitosamente&quot;)&#10;&#10;            // Log detallado de los streams de audio disponibles&#10;            val audioStreams = extractor.audioStreams&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot; Número de audio streams encontrados: ${audioStreams.size}&quot;)&#10;&#10;            if (audioStreams.isEmpty()) {&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ ERROR: No se encontraron audio streams&quot;)&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot; Video info - Nombre: ${extractor.name}&quot;)&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot; Video info - Duración: ${extractor.length}&quot;)&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot; Video info - Edad restringida: ${extractor.ageLimit}&quot;)&#10;                return null&#10;            }&#10;&#10;            // Log de cada stream disponible&#10;            audioStreams.forEachIndexed { index, stream -&gt;&#10;                android.util.Log.d(&quot;YouTubeManager&quot;, &quot; Stream #$index:&quot;)&#10;                android.util.Log.d(&quot;YouTubeManager&quot;, &quot;   - Format: ${stream.format}&quot;)&#10;                android.util.Log.d(&quot;YouTubeManager&quot;, &quot;   - Bitrate: ${stream.averageBitrate}&quot;)&#10;                android.util.Log.d(&quot;YouTubeManager&quot;, &quot;   - URL disponible: ${stream.content != null}&quot;)&#10;            }&#10;&#10;            val firstStream = audioStreams.firstOrNull()&#10;            if (firstStream == null) {&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ ERROR: No se pudo obtener el primer stream&quot;)&#10;                return null&#10;            }&#10;&#10;            val audioUrl = firstStream.content&#10;            if (audioUrl.isNullOrEmpty()) {&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ ERROR: URL de audio está vacía o es null&quot;)&#10;                android.util.Log.e(&quot;YouTubeManager&quot;, &quot; Intentando con URL property deprecated...&quot;)&#10;                @Suppress(&quot;DEPRECATION&quot;)&#10;                val deprecatedUrl = firstStream.url&#10;                if (deprecatedUrl != null) {&#10;                    android.util.Log.w(&quot;YouTubeManager&quot;, &quot;⚠️ Usando URL deprecated: $deprecatedUrl&quot;)&#10;                    return deprecatedUrl&#10;                }&#10;                return null&#10;            }&#10;&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot;✅ ¡URL de audio extraída exitosamente!&quot;)&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot; Audio URL: $audioUrl&quot;)&#10;            android.util.Log.d(&quot;YouTubeManager&quot;, &quot; Longitud URL: ${audioUrl.length} caracteres&quot;)&#10;&#10;            audioUrl&#10;&#10;        } catch (e: Exception) {&#10;            android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ EXCEPCIÓN capturada durante extracción de audio&quot;, e)&#10;            android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ Tipo de excepción: ${e.javaClass.simpleName}&quot;)&#10;            android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ Mensaje: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;YouTubeManager&quot;, &quot;❌ Stack trace:&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/network/YoutubeAudioExtractor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/network/YoutubeAudioExtractor.kt" />
              <option name="originalContent" value="package com.plyr.network&#10;&#10;import android.util.Log&#10;import org.schabi.newpipe.extractor.NewPipe&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.localization.Localization&#10;&#10;object YouTubeAudioExtractor {&#10;&#10;    private const val TAG = &quot;YouTubeExtractor&quot;&#10;    private var isInitialized = false&#10;&#10;    private fun initialize() {&#10;        if (!isInitialized) {&#10;            try {&#10;                val downloader = SimpleDownloader()&#10;                val localization = Localization(&quot;en&quot;, &quot;US&quot;)&#10;                NewPipe.init(downloader, localization)&#10;                isInitialized = true&#10;                Log.d(TAG, &quot;✅ NewPipe inicializado&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error al inicializar NewPipe&quot;, e)&#10;                throw e&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube&#10;     *&#10;     * @param videoId ID del video de YouTube (ej: &quot;dQw4w9WgXcQ&quot;)&#10;     * @return URL del stream de audio o null si hay error&#10;     */&#10;    fun getAudioUrl(videoId: String): String? {&#10;        return try {&#10;            initialize()&#10;&#10;            Log.d(TAG, &quot; Extrayendo audio para: $videoId&quot;)&#10;&#10;            val videoUrl = &quot;https://www.youtube.com/watch?v=$videoId&quot;&#10;            val extractor = ServiceList.YouTube.getStreamExtractor(videoUrl)&#10;            extractor.fetchPage()&#10;&#10;            Log.d(TAG, &quot; Video: ${extractor.name}&quot;)&#10;&#10;            val audioStreams = extractor.audioStreams&#10;            if (audioStreams.isNotEmpty()) {&#10;                val audioUrl = audioStreams[0].url&#10;                Log.d(TAG, &quot;✅ URL extraída exitosamente&quot;)&#10;                audioUrl&#10;            } else {&#10;                Log.w(TAG, &quot;⚠️ No se encontraron streams de audio&quot;)&#10;                null&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.plyr.network&#10;&#10;import android.util.Log&#10;import org.schabi.newpipe.extractor.NewPipe&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.localization.Localization&#10;&#10;object YouTubeAudioExtractor {&#10;&#10;    private const val TAG = &quot;YouTubeExtractor&quot;&#10;    private var isInitialized = false&#10;&#10;    private fun initialize() {&#10;        if (!isInitialized) {&#10;            try {&#10;                val downloader = SimpleDownloader.getInstance()&#10;                val localization = Localization(&quot;en&quot;, &quot;US&quot;)&#10;                NewPipe.init(downloader, localization)&#10;                isInitialized = true&#10;                Log.d(TAG, &quot;✅ NewPipe inicializado&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error al inicializar NewPipe&quot;, e)&#10;                throw e&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube&#10;     *&#10;     * @param videoId ID del video de YouTube (ej: &quot;dQw4w9WgXcQ&quot;)&#10;     * @return URL del stream de audio o null si hay error&#10;     */&#10;    fun getAudioUrl(videoId: String): String? {&#10;        return try {&#10;            initialize()&#10;&#10;            Log.d(TAG, &quot; Extrayendo audio para: $videoId&quot;)&#10;&#10;            val videoUrl = &quot;https://www.youtube.com/watch?v=$videoId&quot;&#10;            val extractor = ServiceList.YouTube.getStreamExtractor(videoUrl)&#10;            extractor.fetchPage()&#10;&#10;            Log.d(TAG, &quot; Video: ${extractor.name}&quot;)&#10;&#10;            val audioStreams = extractor.audioStreams&#10;            if (audioStreams.isNotEmpty()) {&#10;                val audioUrl = audioStreams[0].url&#10;                Log.d(TAG, &quot;✅ URL extraída exitosamente&quot;)&#10;                audioUrl&#10;            } else {&#10;                Log.w(TAG, &quot;⚠️ No se encontraron streams de audio&quot;)&#10;                null&#10;            }&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error: ${e.message}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/YouTubeSearchManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/YouTubeSearchManager.kt" />
              <option name="originalContent" value="package com.plyr.service&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.plyr.database.PlaylistLocalRepository&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SimpleDownloader&#10;import kotlinx.coroutines.*&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.stream.StreamInfoItem&#10;import androidx.core.net.toUri&#10;&#10;/**&#10; * Gestor de búsquedas de YouTube usando NewPipe Extractor&#10; * &#10; * Proporciona funcionalidades para:&#10; * - Búsqueda transparente de IDs de YouTube (con cache automático)&#10; * - Búsqueda de videos con información detallada&#10; * - Extracción de IDs desde URLs&#10; * - Gestión automática de inicialización de NewPipe&#10; * &#10; * @param context Contexto de la aplicación Android&#10; */&#10;class YouTubeSearchManager(private val context: Context) {&#10;    &#10;    // === DEPENDENCIES ===&#10;    private val localRepository = PlaylistLocalRepository(context)&#10;    &#10;    // === STATE ===&#10;    private var searchJob: Job? = null&#10;    private var isInitialized = false&#10;    &#10;    // === CONSTANTS ===&#10;    companion object {&#10;        private const val TAG = &quot;YouTubeSearchManager&quot;&#10;        private const val SEARCH_DELAY = 2000L // Delay entre búsquedas para evitar rate limits&#10;        private const val MAX_RESULTS_DEFAULT = 50&#10;    }&#10;    &#10;    // === INITIALIZATION ===&#10;    &#10;    /**&#10;     * Inicializa NewPipe Extractor de forma lazy&#10;     * Se ejecuta automáticamente en el primer uso&#10;     * &#10;     * @throws Exception Si falla la inicialización de NewPipe&#10;     */&#10;    private fun initialize() {&#10;        if (isInitialized) return&#10;        &#10;        try {&#10;            val downloader = SimpleDownloader()&#10;            val localization = org.schabi.newpipe.extractor.localization.Localization(&quot;en&quot;, &quot;US&quot;)&#10;            org.schabi.newpipe.extractor.NewPipe.init(downloader, localization)&#10;            isInitialized = true&#10;            Log.d(TAG, &quot;✅ NewPipe inicializado correctamente&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al inicializar NewPipe&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;    &#10;    // === CORE FUNCTIONALITY ===&#10;    &#10;    /**&#10;     * FUNCIONALIDAD PRINCIPAL: Obtención transparente de YouTube IDs&#10;     * &#10;     * Obtiene el YouTube ID de forma transparente para el usuario.&#10;     * Si el track ya tiene ID lo devuelve inmediatamente desde cache,&#10;     * si no lo busca automáticamente y lo guarda para uso futuro.&#10;     * &#10;     * Esta función hace que la obtención de IDs sea completamente invisible &#10;     * al usuario - no importa si el ID ya existe o hay que buscarlo.&#10;     * &#10;     * @param track El track para el cual obtener el YouTube ID&#10;     * @return El YouTube ID o null si no se encuentra&#10;     */&#10;    suspend fun getYouTubeIdTransparently(track: TrackEntity): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Cache hit: Si ya tiene YouTube ID, devolverlo directamente&#10;            if (!track.youtubeVideoId.isNullOrBlank()) {&#10;                Log.d(TAG, &quot; Cache hit: ${track.name} → ${track.youtubeVideoId}&quot;)&#10;                return@withContext track.youtubeVideoId&#10;            }&#10;            &#10;            // Cache miss: Buscar y guardar automáticamente&#10;            Log.d(TAG, &quot; Cache miss, buscando: ${track.name} - ${track.artists}&quot;)&#10;            &#10;            val searchQuery = buildSearchQuery(track)&#10;            val videoId = searchSingleVideoId(searchQuery)&#10;            &#10;            return@withContext if (videoId != null) {&#10;                // Guardar en cache para uso futuro&#10;                localRepository.updateTrackYoutubeId(track.id, videoId)&#10;                Log.d(TAG, &quot; ID encontrado y guardado: $videoId para ${track.name}&quot;)&#10;                videoId&#10;            } else {&#10;                Log.w(TAG, &quot;❌ No se encontró YouTube ID para: ${track.name} - ${track.artists}&quot;)&#10;                null&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error obteniendo YouTube ID para: ${track.name}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;    &#10;    // === SEARCH FUNCTIONALITY ===&#10;    &#10;    /**&#10;     * Busca videos de YouTube usando NewPipe Extractor&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @param maxResults Número máximo de resultados (default: 5)&#10;     * @return Lista de IDs de video encontrados&#10;     */&#10;    suspend fun searchYouTubeVideos(&#10;        query: String, &#10;        maxResults: Int = MAX_RESULTS_DEFAULT&#10;    ): List&lt;String&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Buscando: '$query' (máx $maxResults resultados)&quot;)&#10;            &#10;            val videoIds = performSearch(query, maxResults)&#10;            &#10;            Log.d(TAG, &quot; Extraídos ${videoIds.size} IDs válidos&quot;)&#10;            videoIds&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // === CONVENIENCE METHODS ===&#10;    &#10;    /**&#10;     * Busca solo un ID de video (método de conveniencia)&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @return El ID del primer video encontrado o null&#10;     */&#10;    suspend fun searchSingleVideoId(query: String): String? {&#10;        return searchYouTubeVideos(query, 1).firstOrNull()&#10;    }&#10;&#10;    // === PRIVATE HELPER METHODS ===&#10;    &#10;    /**&#10;     * Buscar IDs de YouTube para todos los tracks de una playlist que no los tengan&#10;     * @deprecated Este método es opcional ya que los IDs se obtienen bajo demanda cuando el usuario hace click en una canción.&#10;     * Usar getYouTubeIdTransparently() para obtener IDs de forma invisible al usuario.&#10;     */&#10;    @Deprecated(&quot;Use getYouTubeIdTransparently() for on-demand ID fetching&quot;, ReplaceWith(&quot;getYouTubeIdTransparently(track)&quot;))&#10;    fun searchYouTubeIdsForPlaylist(playlistId: String) {&#10;        searchJob?.cancel()&#10;        &#10;        searchJob = CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                Log.d(TAG, &quot;Iniciando búsqueda de YouTube IDs para playlist: $playlistId&quot;)&#10;                &#10;                val tracks = localRepository.getTracksWithAutoSync(playlistId)&#10;                val tracksWithoutYouTubeId = tracks.filter { it.youtubeVideoId == null }&#10;                &#10;                Log.d(TAG, &quot;Encontrados ${tracksWithoutYouTubeId.size} tracks sin YouTube ID&quot;)&#10;                &#10;                for ((index, track) in tracksWithoutYouTubeId.withIndex()) {&#10;                    if (!isActive) break // Verificar si la corrutina fue cancelada&#10;                    &#10;                    Log.d(TAG, &quot;Buscando YouTube ID para: ${track.name} - ${track.artists} (${index + 1}/${tracksWithoutYouTubeId.size})&quot;)&#10;                    &#10;                    val youtubeId = searchYouTubeId(track)&#10;                    if (youtubeId != null) {&#10;                        Log.d(TAG, &quot;YouTube ID encontrado: $youtubeId&quot;)&#10;                        localRepository.updateTrackYoutubeId(track.id, youtubeId)&#10;                    } else {&#10;                        Log.w(TAG, &quot;No se encontró YouTube ID para: ${track.name} - ${track.artists}&quot;)&#10;                    }&#10;                    &#10;                    // Esperar antes de la siguiente búsqueda&#10;                    delay(SEARCH_DELAY)&#10;                }&#10;                &#10;                Log.d(TAG, &quot;Búsqueda de YouTube IDs completada para playlist: $playlistId&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error en búsqueda de YouTube IDs&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Buscar ID de YouTube para un track específico usando solo NewPipe&#10;     */&#10;    private suspend fun searchYouTubeId(track: TrackEntity): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Construir query de búsqueda&#10;            val searchQuery = &quot;${track.name} ${track.artists}&quot;.trim()&#10;            Log.d(TAG, &quot;Query de búsqueda: $searchQuery&quot;)&#10;            &#10;            // Usar NewPipe para buscar&#10;            val videoId = searchSingleVideoId(searchQuery)&#10;            if (videoId != null) {&#10;                Log.d(TAG, &quot;Video ID encontrado con NewPipe: $videoId&quot;)&#10;                return@withContext videoId&#10;            }&#10;            &#10;            Log.w(TAG, &quot;No se encontró YouTube ID para: $searchQuery&quot;)&#10;            return@withContext null&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error buscando YouTube ID para track: ${track.name}&quot;, e)&#10;            return@withContext null&#10;        }&#10;    }&#10;    &#10;&#10;    &#10;    /**&#10;     * Información detallada de un video de YouTube&#10;     */&#10;    data class YouTubeVideoInfo(&#10;        val videoId: String,&#10;        val title: String,&#10;        val uploader: String,&#10;        val duration: Long, // en segundos&#10;        val viewCount: Long,&#10;        val thumbnailUrl: String?&#10;    ) {&#10;        /**&#10;         * Duración formateada en formato MM:SS o HH:MM:SS&#10;         */&#10;        fun getFormattedDuration(): String {&#10;            if (duration &lt;= 0) return &quot;En vivo&quot;&#10;            &#10;            val hours = duration / 3600&#10;            val minutes = (duration % 3600) / 60&#10;            val seconds = duration % 60&#10;            &#10;            return if (hours &gt; 0) {&#10;                &quot;%d:%02d:%02d&quot;.format(hours, minutes, seconds)&#10;            } else {&#10;                &quot;%d:%02d&quot;.format(minutes, seconds)&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;    /**&#10;     * Información detallada de una playlist de YouTube&#10;     */&#10;    data class YouTubePlaylistInfo(&#10;        val playlistId: String,&#10;        val title: String,&#10;        val uploader: String,&#10;        val videoCount: Int,&#10;        val thumbnailUrl: String?,&#10;        val description: String?,&#10;        val channel: String? = uploader&#10;    ) {&#10;        /**&#10;         * Número de videos formateado&#10;         */&#10;        fun getFormattedVideoCount(): String {&#10;            return when {&#10;                videoCount == 1 -&gt; &quot;1 video&quot;&#10;                videoCount &lt; 1000 -&gt; &quot;$videoCount videos&quot;&#10;                videoCount &gt;= 1000 -&gt; &quot;${(videoCount / 1000.0).format(1)}K videos&quot;&#10;                else -&gt; &quot;$videoCount videos&quot;&#10;            }&#10;        }&#10;&#10;        /**&#10;         * Obtiene la URL de la imagen de la playlist&#10;         */&#10;        fun getImageUrl(): String? {&#10;            return thumbnailUrl&#10;        }&#10;&#10;        private fun Double.format(digits: Int) = &quot;%.${digits}f&quot;.format(this).removeSuffix(&quot;0&quot;).removeSuffix(&quot;.&quot;)&#10;    }&#10;&#10;    /**&#10;     * Resultado combinado de búsqueda de YouTube (videos y playlists)&#10;     */&#10;    data class YouTubeSearchAllResult(&#10;        val videos: List&lt;YouTubeVideoInfo&gt;,&#10;        val playlists: List&lt;YouTubePlaylistInfo&gt;&#10;    )&#10;&#10;    // === NUEVAS FUNCIONES PARA PLAYLISTS ===&#10;&#10;    /**&#10;     * Busca tanto videos como playlists de YouTube&#10;     *&#10;     * @param query Cadena de búsqueda&#10;     * @param maxVideos Número máximo de videos&#10;     * @param maxPlaylists Número máximo de playlists&#10;     * @return Resultado combinado con videos y playlists&#10;     */&#10;    suspend fun searchYouTubeAll(&#10;        query: String,&#10;        maxVideos: Int = 25,&#10;        maxPlaylists: Int = 10&#10;    ): YouTubeSearchAllResult = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Búsqueda completa YouTube: '$query' (videos: $maxVideos, playlists: $maxPlaylists)&quot;)&#10;&#10;            val service = ServiceList.YouTube&#10;            val searchExtractor = service.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;&#10;            val videos = mutableListOf&lt;YouTubeVideoInfo&gt;()&#10;            val playlists = mutableListOf&lt;YouTubePlaylistInfo&gt;()&#10;            val items = searchExtractor.initialPage.items&#10;&#10;            for (item in items) {&#10;                when (item) {&#10;                    is StreamInfoItem -&gt; {&#10;                        if (videos.size &lt; maxVideos) {&#10;                            val videoId = extractVideoIdFromUrl(item.url)&#10;                            if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                                videos.add(YouTubeVideoInfo(&#10;                                    videoId = videoId,&#10;                                    title = item.name,&#10;                                    uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                                    duration = item.duration,&#10;                                    viewCount = item.viewCount,&#10;                                    thumbnailUrl = getThumbnailUrl(videoId)&#10;                                ))&#10;                            }&#10;                        }&#10;                    }&#10;                    is org.schabi.newpipe.extractor.playlist.PlaylistInfoItem -&gt; {&#10;                        if (playlists.size &lt; maxPlaylists) {&#10;                            val playlistId = extractPlaylistIdFromUrl(item.url)&#10;                            if (playlistId != null) {&#10;                                playlists.add(YouTubePlaylistInfo(&#10;                                    playlistId = playlistId,&#10;                                    title = item.name,&#10;                                    uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                                    videoCount = item.streamCount.toInt(),&#10;                                    thumbnailUrl = getPlaylistThumbnailUrl(),&#10;                                    description = null&#10;                                ))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Parar si ya tenemos suficientes resultados&#10;                if (videos.size &gt;= maxVideos &amp;&amp; playlists.size &gt;= maxPlaylists) {&#10;                    break&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;✅ YouTube búsqueda completa: ${videos.size} videos, ${playlists.size} playlists&quot;)&#10;            YouTubeSearchAllResult(videos, playlists)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda completa YouTube: ${e.message}&quot;, e)&#10;            YouTubeSearchAllResult(emptyList(), emptyList())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los videos de una playlist de YouTube&#10;     *&#10;     * @param playlistId ID de la playlist&#10;     * @param maxVideos Número máximo de videos a obtener&#10;     * @return Lista de información de videos de la playlist&#10;     */&#10;    suspend fun getYouTubePlaylistVideos(&#10;        playlistId: String,&#10;        maxVideos: Int = 100&#10;    ): List&lt;YouTubeVideoInfo&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Obteniendo videos de playlist: $playlistId&quot;)&#10;&#10;            val service = ServiceList.YouTube&#10;            val playlistExtractor = service.getPlaylistExtractor(&quot;https://www.youtube.com/playlist?list=$playlistId&quot;)&#10;            playlistExtractor.fetchPage()&#10;&#10;            val videos = mutableListOf&lt;YouTubeVideoInfo&gt;()&#10;            val items = playlistExtractor.initialPage.items&#10;&#10;            for (item in items.take(maxVideos)) {&#10;                if (item is StreamInfoItem) {&#10;                    val videoId = extractVideoIdFromUrl(item.url)&#10;                    if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                        videos.add(YouTubeVideoInfo(&#10;                            videoId = videoId,&#10;                            title = item.name,&#10;                            uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                            duration = item.duration,&#10;                            viewCount = item.viewCount,&#10;                            thumbnailUrl = getThumbnailUrl(videoId)&#10;                        ))&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;✅ Obtenidos ${videos.size} videos de la playlist&quot;)&#10;            videos&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error obteniendo videos de playlist: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // === MÉTODOS UTILITARIOS PRIVADOS ADICIONALES ===&#10;&#10;    /**&#10;     * Extraer ID de video de una URL de YouTube&#10;     */&#10;    private fun extractVideoIdFromUrl(url: String): String? {&#10;        return try {&#10;            when {&#10;                url.contains(&quot;watch?v=&quot;) -&gt; {&#10;                    url.substringAfter(&quot;watch?v=&quot;).substringBefore(&quot;&amp;&quot;)&#10;                }&#10;                url.contains(&quot;youtu.be/&quot;) -&gt; {&#10;                    url.substringAfter(&quot;youtu.be/&quot;).substringBefore(&quot;?&quot;)&#10;                }&#10;                url.contains(&quot;/watch/&quot;) -&gt; {&#10;                    url.substringAfter(&quot;/watch/&quot;).substringBefore(&quot;?&quot;)&#10;                }&#10;                else -&gt; {&#10;                    // Fallback: usar el método anterior&#10;                    val uri = url.toUri()&#10;                    uri.getQueryParameter(&quot;v&quot;) ?: run {&#10;                        val segments = uri.pathSegments&#10;                        if (segments.isNotEmpty() &amp;&amp; segments.last().length == 11) {&#10;                            segments.last()&#10;                        } else {&#10;                            Log.w(TAG, &quot;Formato de URL no reconocido: $url&quot;)&#10;                            null&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error extrayendo video ID de URL: $url&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extraer ID de playlist de una URL de YouTube&#10;     */&#10;    private fun extractPlaylistIdFromUrl(url: String): String? {&#10;        return try {&#10;            when {&#10;                url.contains(&quot;list=&quot;) -&gt; {&#10;                    url.substringAfter(&quot;list=&quot;).substringBefore(&quot;&amp;&quot;)&#10;                }&#10;                url.contains(&quot;/playlist?&quot;) -&gt; {&#10;                    val uri = url.toUri()&#10;                    uri.getQueryParameter(&quot;list&quot;)&#10;                }&#10;                else -&gt; {&#10;                    Log.w(TAG, &quot;Formato de URL de playlist no reconocido: $url&quot;)&#10;                    null&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error extrayendo playlist ID de URL: $url&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cancelar búsquedas en curso&#10;     */&#10;    fun cancelSearch() {&#10;        searchJob?.cancel()&#10;        searchJob = null&#10;        Log.d(TAG, &quot;Búsqueda de YouTube IDs cancelada&quot;)&#10;    }&#10;&#10;    /**&#10;     * Limpiar recursos&#10;     */&#10;    fun cleanup() {&#10;        cancelSearch()&#10;    }&#10;    &#10;    // === MÉTODOS UTILITARIOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Realiza la búsqueda actual usando NewPipe Extractor&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @param maxResults Número máximo de resultados&#10;     * @return Lista de IDs de video&#10;     */&#10;    private fun performSearch(query: String, maxResults: Int): List&lt;String&gt; {&#10;        return try {&#10;            Log.d(TAG, &quot; Ejecutando búsqueda NewPipe: '$query'&quot;)&#10;            &#10;            val service = ServiceList.YouTube&#10;            val searchExtractor = service.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;            &#10;            val videoIds = mutableListOf&lt;String&gt;()&#10;            val items = searchExtractor.initialPage.items&#10;            &#10;            for (item in items.take(maxResults)) {&#10;                if (item is StreamInfoItem) {&#10;                    val videoId = extractVideoIdFromUrl(item.url)&#10;                    if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                        videoIds.add(videoId)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Log.d(TAG, &quot;✅ NewPipe encontró ${videoIds.size} IDs válidos&quot;)&#10;            videoIds&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda NewPipe: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Construye una query de búsqueda optimizada para un track.&#10;     * Combina el nombre del track con los artistas de manera eficiente.&#10;     * &#10;     * @param track El track para el cual construir la query&#10;     * @return Query de búsqueda optimizada&#10;     */&#10;    private fun buildSearchQuery(track: TrackEntity): String {&#10;        return &quot;${track.name} ${track.artists}&quot;.trim()&#10;    }&#10;&#10;    /**&#10;     * Genera URL de thumbnail para un video de YouTube&#10;     */&#10;    private fun getThumbnailUrl(videoId: String): String {&#10;        return &quot;https://img.youtube.com/vi/$videoId/hqdefault.jpg&quot;&#10;    }&#10;&#10;    /**&#10;     * Genera URL de thumbnail para una playlist de YouTube&#10;     */&#10;    private fun getPlaylistThumbnailUrl(): String {&#10;        return &quot;https://img.youtube.com/vi/undefined/hqdefault.jpg&quot; // Placeholder&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.plyr.database.PlaylistLocalRepository&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SimpleDownloader&#10;import kotlinx.coroutines.*&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.stream.StreamInfoItem&#10;import androidx.core.net.toUri&#10;&#10;/**&#10; * Gestor de búsquedas de YouTube usando NewPipe Extractor&#10; * &#10; * Proporciona funcionalidades para:&#10; * - Búsqueda transparente de IDs de YouTube (con cache automático)&#10; * - Búsqueda de videos con información detallada&#10; * - Extracción de IDs desde URLs&#10; * - Gestión automática de inicialización de NewPipe&#10; * &#10; * @param context Contexto de la aplicación Android&#10; */&#10;class YouTubeSearchManager(private val context: Context) {&#10;    &#10;    // === DEPENDENCIES ===&#10;    private val localRepository = PlaylistLocalRepository(context)&#10;    &#10;    // === STATE ===&#10;    private var searchJob: Job? = null&#10;    private var isInitialized = false&#10;    &#10;    // === CONSTANTS ===&#10;    companion object {&#10;        private const val TAG = &quot;YouTubeSearchManager&quot;&#10;        private const val SEARCH_DELAY = 2000L // Delay entre búsquedas para evitar rate limits&#10;        private const val MAX_RESULTS_DEFAULT = 50&#10;    }&#10;    &#10;    // === INITIALIZATION ===&#10;    &#10;    /**&#10;     * Inicializa NewPipe Extractor de forma lazy&#10;     * Se ejecuta automáticamente en el primer uso&#10;     * &#10;     * @throws Exception Si falla la inicialización de NewPipe&#10;     */&#10;    private fun initialize() {&#10;        if (isInitialized) return&#10;        &#10;        try {&#10;            val downloader = SimpleDownloader.getInstance()&#10;            val localization = org.schabi.newpipe.extractor.localization.Localization(&quot;en&quot;, &quot;US&quot;)&#10;            org.schabi.newpipe.extractor.NewPipe.init(downloader, localization)&#10;            isInitialized = true&#10;            Log.d(TAG, &quot;✅ NewPipe inicializado correctamente&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error al inicializar NewPipe&quot;, e)&#10;            throw e&#10;        }&#10;    }&#10;    &#10;    // === CORE FUNCTIONALITY ===&#10;    &#10;    /**&#10;     * FUNCIONALIDAD PRINCIPAL: Obtención transparente de YouTube IDs&#10;     * &#10;     * Obtiene el YouTube ID de forma transparente para el usuario.&#10;     * Si el track ya tiene ID lo devuelve inmediatamente desde cache,&#10;     * si no lo busca automáticamente y lo guarda para uso futuro.&#10;     * &#10;     * Esta función hace que la obtención de IDs sea completamente invisible &#10;     * al usuario - no importa si el ID ya existe o hay que buscarlo.&#10;     * &#10;     * @param track El track para el cual obtener el YouTube ID&#10;     * @return El YouTube ID o null si no se encuentra&#10;     */&#10;    suspend fun getYouTubeIdTransparently(track: TrackEntity): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Cache hit: Si ya tiene YouTube ID, devolverlo directamente&#10;            if (!track.youtubeVideoId.isNullOrBlank()) {&#10;                Log.d(TAG, &quot; Cache hit: ${track.name} → ${track.youtubeVideoId}&quot;)&#10;                return@withContext track.youtubeVideoId&#10;            }&#10;            &#10;            // Cache miss: Buscar y guardar automáticamente&#10;            Log.d(TAG, &quot; Cache miss, buscando: ${track.name} - ${track.artists}&quot;)&#10;            &#10;            val searchQuery = buildSearchQuery(track)&#10;            val videoId = searchSingleVideoId(searchQuery)&#10;            &#10;            return@withContext if (videoId != null) {&#10;                // Guardar en cache para uso futuro&#10;                localRepository.updateTrackYoutubeId(track.id, videoId)&#10;                Log.d(TAG, &quot; ID encontrado y guardado: $videoId para ${track.name}&quot;)&#10;                videoId&#10;            } else {&#10;                Log.w(TAG, &quot;❌ No se encontró YouTube ID para: ${track.name} - ${track.artists}&quot;)&#10;                null&#10;            }&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error obteniendo YouTube ID para: ${track.name}&quot;, e)&#10;            null&#10;        }&#10;    }&#10;    &#10;    // === SEARCH FUNCTIONALITY ===&#10;    &#10;    /**&#10;     * Busca videos de YouTube usando NewPipe Extractor&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @param maxResults Número máximo de resultados (default: 5)&#10;     * @return Lista de IDs de video encontrados&#10;     */&#10;    suspend fun searchYouTubeVideos(&#10;        query: String, &#10;        maxResults: Int = MAX_RESULTS_DEFAULT&#10;    ): List&lt;String&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Buscando: '$query' (máx $maxResults resultados)&quot;)&#10;            &#10;            val videoIds = performSearch(query, maxResults)&#10;            &#10;            Log.d(TAG, &quot; Extraídos ${videoIds.size} IDs válidos&quot;)&#10;            videoIds&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // === CONVENIENCE METHODS ===&#10;    &#10;    /**&#10;     * Busca solo un ID de video (método de conveniencia)&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @return El ID del primer video encontrado o null&#10;     */&#10;    suspend fun searchSingleVideoId(query: String): String? {&#10;        return searchYouTubeVideos(query, 1).firstOrNull()&#10;    }&#10;&#10;    // === PRIVATE HELPER METHODS ===&#10;    &#10;    /**&#10;     * Buscar IDs de YouTube para todos los tracks de una playlist que no los tengan&#10;     * @deprecated Este método es opcional ya que los IDs se obtienen bajo demanda cuando el usuario hace click en una canción.&#10;     * Usar getYouTubeIdTransparently() para obtener IDs de forma invisible al usuario.&#10;     */&#10;    @Deprecated(&quot;Use getYouTubeIdTransparently() for on-demand ID fetching&quot;, ReplaceWith(&quot;getYouTubeIdTransparently(track)&quot;))&#10;    fun searchYouTubeIdsForPlaylist(playlistId: String) {&#10;        searchJob?.cancel()&#10;        &#10;        searchJob = CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                Log.d(TAG, &quot;Iniciando búsqueda de YouTube IDs para playlist: $playlistId&quot;)&#10;                &#10;                val tracks = localRepository.getTracksWithAutoSync(playlistId)&#10;                val tracksWithoutYouTubeId = tracks.filter { it.youtubeVideoId == null }&#10;                &#10;                Log.d(TAG, &quot;Encontrados ${tracksWithoutYouTubeId.size} tracks sin YouTube ID&quot;)&#10;                &#10;                for ((index, track) in tracksWithoutYouTubeId.withIndex()) {&#10;                    if (!isActive) break // Verificar si la corrutina fue cancelada&#10;                    &#10;                    Log.d(TAG, &quot;Buscando YouTube ID para: ${track.name} - ${track.artists} (${index + 1}/${tracksWithoutYouTubeId.size})&quot;)&#10;                    &#10;                    val youtubeId = searchYouTubeId(track)&#10;                    if (youtubeId != null) {&#10;                        Log.d(TAG, &quot;YouTube ID encontrado: $youtubeId&quot;)&#10;                        localRepository.updateTrackYoutubeId(track.id, youtubeId)&#10;                    } else {&#10;                        Log.w(TAG, &quot;No se encontró YouTube ID para: ${track.name} - ${track.artists}&quot;)&#10;                    }&#10;                    &#10;                    // Esperar antes de la siguiente búsqueda&#10;                    delay(SEARCH_DELAY)&#10;                }&#10;                &#10;                Log.d(TAG, &quot;Búsqueda de YouTube IDs completada para playlist: $playlistId&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error en búsqueda de YouTube IDs&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Buscar ID de YouTube para un track específico usando solo NewPipe&#10;     */&#10;    private suspend fun searchYouTubeId(track: TrackEntity): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // Construir query de búsqueda&#10;            val searchQuery = &quot;${track.name} ${track.artists}&quot;.trim()&#10;            Log.d(TAG, &quot;Query de búsqueda: $searchQuery&quot;)&#10;            &#10;            // Usar NewPipe para buscar&#10;            val videoId = searchSingleVideoId(searchQuery)&#10;            if (videoId != null) {&#10;                Log.d(TAG, &quot;Video ID encontrado con NewPipe: $videoId&quot;)&#10;                return@withContext videoId&#10;            }&#10;            &#10;            Log.w(TAG, &quot;No se encontró YouTube ID para: $searchQuery&quot;)&#10;            return@withContext null&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error buscando YouTube ID para track: ${track.name}&quot;, e)&#10;            return@withContext null&#10;        }&#10;    }&#10;    &#10;&#10;    &#10;    /**&#10;     * Información detallada de un video de YouTube&#10;     */&#10;    data class YouTubeVideoInfo(&#10;        val videoId: String,&#10;        val title: String,&#10;        val uploader: String,&#10;        val duration: Long, // en segundos&#10;        val viewCount: Long,&#10;        val thumbnailUrl: String?&#10;    ) {&#10;        /**&#10;         * Duración formateada en formato MM:SS o HH:MM:SS&#10;         */&#10;        fun getFormattedDuration(): String {&#10;            if (duration &lt;= 0) return &quot;En vivo&quot;&#10;            &#10;            val hours = duration / 3600&#10;            val minutes = (duration % 3600) / 60&#10;            val seconds = duration % 60&#10;            &#10;            return if (hours &gt; 0) {&#10;                &quot;%d:%02d:%02d&quot;.format(hours, minutes, seconds)&#10;            } else {&#10;                &quot;%d:%02d&quot;.format(minutes, seconds)&#10;            }&#10;        }&#10;&#10;    }&#10;&#10;    /**&#10;     * Información detallada de una playlist de YouTube&#10;     */&#10;    data class YouTubePlaylistInfo(&#10;        val playlistId: String,&#10;        val title: String,&#10;        val uploader: String,&#10;        val videoCount: Int,&#10;        val thumbnailUrl: String?,&#10;        val description: String?,&#10;        val channel: String? = uploader&#10;    ) {&#10;        /**&#10;         * Número de videos formateado&#10;         */&#10;        fun getFormattedVideoCount(): String {&#10;            return when {&#10;                videoCount == 1 -&gt; &quot;1 video&quot;&#10;                videoCount &lt; 1000 -&gt; &quot;$videoCount videos&quot;&#10;                videoCount &gt;= 1000 -&gt; &quot;${(videoCount / 1000.0).format(1)}K videos&quot;&#10;                else -&gt; &quot;$videoCount videos&quot;&#10;            }&#10;        }&#10;&#10;        /**&#10;         * Obtiene la URL de la imagen de la playlist&#10;         */&#10;        fun getImageUrl(): String? {&#10;            return thumbnailUrl&#10;        }&#10;&#10;        private fun Double.format(digits: Int) = &quot;%.${digits}f&quot;.format(this).removeSuffix(&quot;0&quot;).removeSuffix(&quot;.&quot;)&#10;    }&#10;&#10;    /**&#10;     * Resultado combinado de búsqueda de YouTube (videos y playlists)&#10;     */&#10;    data class YouTubeSearchAllResult(&#10;        val videos: List&lt;YouTubeVideoInfo&gt;,&#10;        val playlists: List&lt;YouTubePlaylistInfo&gt;&#10;    )&#10;&#10;    // === NUEVAS FUNCIONES PARA PLAYLISTS ===&#10;&#10;    /**&#10;     * Busca tanto videos como playlists de YouTube&#10;     *&#10;     * @param query Cadena de búsqueda&#10;     * @param maxVideos Número máximo de videos&#10;     * @param maxPlaylists Número máximo de playlists&#10;     * @return Resultado combinado con videos y playlists&#10;     */&#10;    suspend fun searchYouTubeAll(&#10;        query: String,&#10;        maxVideos: Int = 25,&#10;        maxPlaylists: Int = 10&#10;    ): YouTubeSearchAllResult = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Búsqueda completa YouTube: '$query' (videos: $maxVideos, playlists: $maxPlaylists)&quot;)&#10;&#10;            val service = ServiceList.YouTube&#10;            val searchExtractor = service.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;&#10;            val videos = mutableListOf&lt;YouTubeVideoInfo&gt;()&#10;            val playlists = mutableListOf&lt;YouTubePlaylistInfo&gt;()&#10;            val items = searchExtractor.initialPage.items&#10;&#10;            for (item in items) {&#10;                when (item) {&#10;                    is StreamInfoItem -&gt; {&#10;                        if (videos.size &lt; maxVideos) {&#10;                            val videoId = extractVideoIdFromUrl(item.url)&#10;                            if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                                videos.add(YouTubeVideoInfo(&#10;                                    videoId = videoId,&#10;                                    title = item.name,&#10;                                    uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                                    duration = item.duration,&#10;                                    viewCount = item.viewCount,&#10;                                    thumbnailUrl = getThumbnailUrl(videoId)&#10;                                ))&#10;                            }&#10;                        }&#10;                    }&#10;                    is org.schabi.newpipe.extractor.playlist.PlaylistInfoItem -&gt; {&#10;                        if (playlists.size &lt; maxPlaylists) {&#10;                            val playlistId = extractPlaylistIdFromUrl(item.url)&#10;                            if (playlistId != null) {&#10;                                playlists.add(YouTubePlaylistInfo(&#10;                                    playlistId = playlistId,&#10;                                    title = item.name,&#10;                                    uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                                    videoCount = item.streamCount.toInt(),&#10;                                    thumbnailUrl = getPlaylistThumbnailUrl(),&#10;                                    description = null&#10;                                ))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Parar si ya tenemos suficientes resultados&#10;                if (videos.size &gt;= maxVideos &amp;&amp; playlists.size &gt;= maxPlaylists) {&#10;                    break&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;✅ YouTube búsqueda completa: ${videos.size} videos, ${playlists.size} playlists&quot;)&#10;            YouTubeSearchAllResult(videos, playlists)&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda completa YouTube: ${e.message}&quot;, e)&#10;            YouTubeSearchAllResult(emptyList(), emptyList())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los videos de una playlist de YouTube&#10;     *&#10;     * @param playlistId ID de la playlist&#10;     * @param maxVideos Número máximo de videos a obtener&#10;     * @return Lista de información de videos de la playlist&#10;     */&#10;    suspend fun getYouTubePlaylistVideos(&#10;        playlistId: String,&#10;        maxVideos: Int = 100&#10;    ): List&lt;YouTubeVideoInfo&gt; = withContext(Dispatchers.IO) {&#10;        try {&#10;            initialize()&#10;            Log.d(TAG, &quot; Obteniendo videos de playlist: $playlistId&quot;)&#10;&#10;            val service = ServiceList.YouTube&#10;            val playlistExtractor = service.getPlaylistExtractor(&quot;https://www.youtube.com/playlist?list=$playlistId&quot;)&#10;            playlistExtractor.fetchPage()&#10;&#10;            val videos = mutableListOf&lt;YouTubeVideoInfo&gt;()&#10;            val items = playlistExtractor.initialPage.items&#10;&#10;            for (item in items.take(maxVideos)) {&#10;                if (item is StreamInfoItem) {&#10;                    val videoId = extractVideoIdFromUrl(item.url)&#10;                    if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                        videos.add(YouTubeVideoInfo(&#10;                            videoId = videoId,&#10;                            title = item.name,&#10;                            uploader = item.uploaderName ?: &quot;Desconocido&quot;,&#10;                            duration = item.duration,&#10;                            viewCount = item.viewCount,&#10;                            thumbnailUrl = getThumbnailUrl(videoId)&#10;                        ))&#10;                    }&#10;                }&#10;            }&#10;&#10;            Log.d(TAG, &quot;✅ Obtenidos ${videos.size} videos de la playlist&quot;)&#10;            videos&#10;&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error obteniendo videos de playlist: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    // === MÉTODOS UTILITARIOS PRIVADOS ADICIONALES ===&#10;&#10;    /**&#10;     * Extraer ID de video de una URL de YouTube&#10;     */&#10;    private fun extractVideoIdFromUrl(url: String): String? {&#10;        return try {&#10;            when {&#10;                url.contains(&quot;watch?v=&quot;) -&gt; {&#10;                    url.substringAfter(&quot;watch?v=&quot;).substringBefore(&quot;&amp;&quot;)&#10;                }&#10;                url.contains(&quot;youtu.be/&quot;) -&gt; {&#10;                    url.substringAfter(&quot;youtu.be/&quot;).substringBefore(&quot;?&quot;)&#10;                }&#10;                url.contains(&quot;/watch/&quot;) -&gt; {&#10;                    url.substringAfter(&quot;/watch/&quot;).substringBefore(&quot;?&quot;)&#10;                }&#10;                else -&gt; {&#10;                    // Fallback: usar el método anterior&#10;                    val uri = url.toUri()&#10;                    uri.getQueryParameter(&quot;v&quot;) ?: run {&#10;                        val segments = uri.pathSegments&#10;                        if (segments.isNotEmpty() &amp;&amp; segments.last().length == 11) {&#10;                            segments.last()&#10;                        } else {&#10;                            Log.w(TAG, &quot;Formato de URL no reconocido: $url&quot;)&#10;                            null&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error extrayendo video ID de URL: $url&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Extraer ID de playlist de una URL de YouTube&#10;     */&#10;    private fun extractPlaylistIdFromUrl(url: String): String? {&#10;        return try {&#10;            when {&#10;                url.contains(&quot;list=&quot;) -&gt; {&#10;                    url.substringAfter(&quot;list=&quot;).substringBefore(&quot;&amp;&quot;)&#10;                }&#10;                url.contains(&quot;/playlist?&quot;) -&gt; {&#10;                    val uri = url.toUri()&#10;                    uri.getQueryParameter(&quot;list&quot;)&#10;                }&#10;                else -&gt; {&#10;                    Log.w(TAG, &quot;Formato de URL de playlist no reconocido: $url&quot;)&#10;                    null&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error extrayendo playlist ID de URL: $url&quot;, e)&#10;            null&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Cancelar búsquedas en curso&#10;     */&#10;    fun cancelSearch() {&#10;        searchJob?.cancel()&#10;        searchJob = null&#10;        Log.d(TAG, &quot;Búsqueda de YouTube IDs cancelada&quot;)&#10;    }&#10;&#10;    /**&#10;     * Limpiar recursos&#10;     */&#10;    fun cleanup() {&#10;        cancelSearch()&#10;    }&#10;    &#10;    // === MÉTODOS UTILITARIOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Realiza la búsqueda actual usando NewPipe Extractor&#10;     * &#10;     * @param query Cadena de búsqueda&#10;     * @param maxResults Número máximo de resultados&#10;     * @return Lista de IDs de video&#10;     */&#10;    private fun performSearch(query: String, maxResults: Int): List&lt;String&gt; {&#10;        return try {&#10;            Log.d(TAG, &quot; Ejecutando búsqueda NewPipe: '$query'&quot;)&#10;            &#10;            val service = ServiceList.YouTube&#10;            val searchExtractor = service.getSearchExtractor(query)&#10;            searchExtractor.fetchPage()&#10;            &#10;            val videoIds = mutableListOf&lt;String&gt;()&#10;            val items = searchExtractor.initialPage.items&#10;            &#10;            for (item in items.take(maxResults)) {&#10;                if (item is StreamInfoItem) {&#10;                    val videoId = extractVideoIdFromUrl(item.url)&#10;                    if (videoId != null &amp;&amp; videoId.length == 11) {&#10;                        videoIds.add(videoId)&#10;                    }&#10;                }&#10;            }&#10;            &#10;            Log.d(TAG, &quot;✅ NewPipe encontró ${videoIds.size} IDs válidos&quot;)&#10;            videoIds&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;❌ Error en búsqueda NewPipe: ${e.message}&quot;, e)&#10;            emptyList()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Construye una query de búsqueda optimizada para un track.&#10;     * Combina el nombre del track con los artistas de manera eficiente.&#10;     * &#10;     * @param track El track para el cual construir la query&#10;     * @return Query de búsqueda optimizada&#10;     */&#10;    private fun buildSearchQuery(track: TrackEntity): String {&#10;        return &quot;${track.name} ${track.artists}&quot;.trim()&#10;    }&#10;&#10;    /**&#10;     * Genera URL de thumbnail para un video de YouTube&#10;     */&#10;    private fun getThumbnailUrl(videoId: String): String {&#10;        return &quot;https://img.youtube.com/vi/$videoId/hqdefault.jpg&quot;&#10;    }&#10;&#10;    /**&#10;     * Genera URL de thumbnail para una playlist de YouTube&#10;     */&#10;    private fun getPlaylistThumbnailUrl(): String {&#10;        return &quot;https://img.youtube.com/vi/undefined/hqdefault.jpg&quot; // Placeholder&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/MediaMetadataExtractor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/MediaMetadataExtractor.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#10;import org.schabi.newpipe.extractor.NewPipe&#10;import org.schabi.newpipe.extractor.ServiceList&#10;import org.schabi.newpipe.extractor.localization.Localization&#10;import com.plyr.network.SpotifyRepository&#10;import kotlin.coroutines.resume&#10;&#10;data class MediaMetadata(&#10;    val title: String,&#10;    val author: String? = null,&#10;    val thumbnailUrl: String? = null,&#10;    val type: MediaType&#10;)&#10;&#10;enum class MediaType {&#10;    YOUTUBE_VIDEO,&#10;    YOUTUBE_PLAYLIST,&#10;    SPOTIFY_TRACK,&#10;    SPOTIFY_PLAYLIST,&#10;    SPOTIFY_ALBUM,&#10;    SPOTIFY_ARTIST,&#10;    UNKNOWN&#10;}&#10;&#10;object MediaMetadataExtractor {&#10;    private var isInitialized = false&#10;&#10;    private fun ensureInitialized() {&#10;        if (isInitialized) return&#10;        try {&#10;            NewPipe.init(com.plyr.network.SimpleDownloader(), Localization(&quot;en&quot;, &quot;US&quot;))&#10;            isInitialized = true&#10;        } catch (_: Exception) {&#10;            // Already initialized&#10;        }&#10;    }&#10;&#10;    suspend fun extractMetadata(url: String, context: Context? = null): MediaMetadata = withContext(Dispatchers.IO) {&#10;        when {&#10;            isYouTubeUrl(url) -&gt; extractYouTubeMetadata(url)&#10;            isSpotifyUrl(url) -&gt; {&#10;                if (context != null &amp;&amp; Config.isSpotifyConnected(context)) {&#10;                    extractSpotifyMetadata(url, context)&#10;                } else {&#10;                    extractSpotifyMetadataFallback(url)&#10;                }&#10;            }&#10;            else -&gt; MediaMetadata(url, null, null, MediaType.UNKNOWN)&#10;        }&#10;    }&#10;&#10;    private fun isYouTubeUrl(url: String): Boolean {&#10;        return url.contains(&quot;youtube.com&quot;) || url.contains(&quot;youtu.be&quot;)&#10;    }&#10;&#10;    private fun isSpotifyUrl(url: String): Boolean {&#10;        return url.contains(&quot;spotify.com&quot;)&#10;    }&#10;&#10;    private suspend fun extractYouTubeMetadata(url: String): MediaMetadata = withContext(Dispatchers.IO) {&#10;        try {&#10;            ensureInitialized()&#10;&#10;            // Detectar si es una playlist&#10;            val isPlaylist = url.contains(&quot;list=&quot;) ||&#10;                            url.contains(&quot;/playlist&quot;) ||&#10;                            // Detectar IDs de playlist mal formateados en parámetro v=&#10;                            (url.contains(&quot;v=PL&quot;) || url.contains(&quot;v=UU&quot;) || url.contains(&quot;v=FL&quot;) || url.contains(&quot;v=RD&quot;))&#10;&#10;            if (isPlaylist) {&#10;                // Extraer el ID de la playlist&#10;                val playlistId = when {&#10;                    url.contains(&quot;list=&quot;) -&gt; url.substringAfter(&quot;list=&quot;).substringBefore(&quot;&amp;&quot;)&#10;                    // Si el ID está en v= y empieza con PL/UU/FL/RD, es una playlist malformada&#10;                    url.contains(&quot;v=PL&quot;) -&gt; url.substringAfter(&quot;v=PL&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;PL$it&quot; }&#10;                    url.contains(&quot;v=UU&quot;) -&gt; url.substringAfter(&quot;v=UU&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;UU$it&quot; }&#10;                    url.contains(&quot;v=FL&quot;) -&gt; url.substringAfter(&quot;v=FL&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;FL$it&quot; }&#10;                    url.contains(&quot;v=RD&quot;) -&gt; url.substringAfter(&quot;v=RD&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;RD$it&quot; }&#10;                    else -&gt; url.substringAfterLast(&quot;/&quot;).substringBefore(&quot;?&quot;)&#10;                }&#10;&#10;                val playlistUrl = &quot;https://www.youtube.com/playlist?list=$playlistId&quot;&#10;                val extractor = ServiceList.YouTube.getPlaylistExtractor(playlistUrl)&#10;                extractor.fetchPage()&#10;&#10;                MediaMetadata(&#10;                    title = extractor.name,&#10;                    author = extractor.uploaderName,&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#10;                    type = MediaType.YOUTUBE_PLAYLIST&#10;                )&#10;            } else {&#10;                // Es un video&#10;                val extractor = ServiceList.YouTube.getStreamExtractor(url)&#10;                extractor.fetchPage()&#10;&#10;                MediaMetadata(&#10;                    title = extractor.name,&#10;                    author = extractor.uploaderName,&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#10;                    type = MediaType.YOUTUBE_VIDEO&#10;                )&#10;            }&#10;        } catch (e: Exception) {&#10;            // Si falla, intentar como video antes de dar up&#10;            try {&#10;                ensureInitialized()&#10;                val extractor = ServiceList.YouTube.getStreamExtractor(url)&#10;                extractor.fetchPage()&#10;&#10;                MediaMetadata(&#10;                    title = extractor.name,&#10;                    author = extractor.uploaderName,&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#10;                    type = MediaType.YOUTUBE_VIDEO&#10;                )&#10;            } catch (_: Exception) {&#10;                MediaMetadata(url, null, null, MediaType.UNKNOWN)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun extractSpotifyMetadata(url: String, context: Context): MediaMetadata = withContext(Dispatchers.IO) {&#10;        try {&#10;            val accessToken = Config.getSpotifyAccessToken(context) ?: return@withContext extractSpotifyMetadataFallback(url)&#10;&#10;            when {&#10;                url.contains(&quot;/track/&quot;) -&gt; {&#10;                    val trackId = extractSpotifyId(url)&#10;                    suspendCancellableCoroutine { continuation -&gt;&#10;                        SpotifyRepository.getTrack(accessToken, trackId) { track, error -&gt;&#10;                            if (track != null) {&#10;                                continuation.resume(&#10;                                    MediaMetadata(&#10;                                        title = track.name,&#10;                                        author = track.getArtistNames(),&#10;                                        thumbnailUrl = track.album?.images?.firstOrNull()?.url,&#10;                                        type = MediaType.SPOTIFY_TRACK&#10;                                    )&#10;                                )&#10;                            } else {&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                url.contains(&quot;/playlist/&quot;) -&gt; {&#10;                    val playlistId = extractSpotifyId(url)&#10;                    suspendCancellableCoroutine { continuation -&gt;&#10;                        SpotifyRepository.getPlaylist(accessToken, playlistId) { playlist, error -&gt;&#10;                            if (playlist != null) {&#10;                                continuation.resume(&#10;                                    MediaMetadata(&#10;                                        title = playlist.name,&#10;                                        author = playlist.description,&#10;                                        thumbnailUrl = playlist.getImageUrl(),&#10;                                        type = MediaType.SPOTIFY_PLAYLIST&#10;                                    )&#10;                                )&#10;                            } else {&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                url.contains(&quot;/album/&quot;) -&gt; {&#10;                    val albumId = extractSpotifyId(url)&#10;                    suspendCancellableCoroutine { continuation -&gt;&#10;                        SpotifyRepository.getAlbum(accessToken, albumId) { album, error -&gt;&#10;                            if (album != null) {&#10;                                continuation.resume(&#10;                                    MediaMetadata(&#10;                                        title = album.name,&#10;                                        author = album.getArtistNames(),&#10;                                        thumbnailUrl = album.getImageUrl(),&#10;                                        type = MediaType.SPOTIFY_ALBUM&#10;                                    )&#10;                                )&#10;                            } else {&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                url.contains(&quot;/artist/&quot;) -&gt; {&#10;                    val artistId = extractSpotifyId(url)&#10;                    suspendCancellableCoroutine { continuation -&gt;&#10;                        SpotifyRepository.getArtist(accessToken, artistId) { artist, error -&gt;&#10;                            if (artist != null) {&#10;                                continuation.resume(&#10;                                    MediaMetadata(&#10;                                        title = artist.name,&#10;                                        author = artist.genres?.joinToString(&quot;, &quot;),&#10;                                        thumbnailUrl = artist.getImageUrl(),&#10;                                        type = MediaType.SPOTIFY_ARTIST&#10;                                    )&#10;                                )&#10;                            } else {&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;                else -&gt; extractSpotifyMetadataFallback(url)&#10;            }&#10;        } catch (_: Exception) {&#10;            extractSpotifyMetadataFallback(url)&#10;        }&#10;    }&#10;&#10;    private fun extractSpotifyMetadataFallback(url: String): MediaMetadata {&#10;        val type = when {&#10;            url.contains(&quot;/track/&quot;) -&gt; MediaType.SPOTIFY_TRACK&#10;            url.contains(&quot;/playlist/&quot;) -&gt; MediaType.SPOTIFY_PLAYLIST&#10;            url.contains(&quot;/album/&quot;) -&gt; MediaType.SPOTIFY_ALBUM&#10;            url.contains(&quot;/artist/&quot;) -&gt; MediaType.SPOTIFY_ARTIST&#10;            else -&gt; MediaType.UNKNOWN&#10;        }&#10;&#10;        val title = when (type) {&#10;            MediaType.SPOTIFY_TRACK -&gt; &quot;Spotify Track&quot;&#10;            MediaType.SPOTIFY_PLAYLIST -&gt; &quot;Spotify Playlist&quot;&#10;            MediaType.SPOTIFY_ALBUM -&gt; &quot;Spotify Album&quot;&#10;            MediaType.SPOTIFY_ARTIST -&gt; &quot;Spotify Artist&quot;&#10;            else -&gt; &quot;Spotify Content&quot;&#10;        }&#10;&#10;        return MediaMetadata(&#10;            title = title,&#10;            author = null,&#10;            thumbnailUrl = null,&#10;            type = type&#10;        )&#10;    }&#10;&#10;    private fun extractSpotifyId(url: String): String {&#10;        // Extract ID from URLs like: https://open.spotify.com/track/ID?si=...&#10;        return when {&#10;            url.contains(&quot;/track/&quot;) -&gt; url.substringAfter(&quot;/track/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#10;            url.contains(&quot;/playlist/&quot;) -&gt; url.substringAfter(&quot;/playlist/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#10;            url.contains(&quot;/album/&quot;) -&gt; url.substringAfter(&quot;/album/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#10;            url.contains(&quot;/artist/&quot;) -&gt; url.substringAfter(&quot;/artist/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#10;            else -&gt; &quot;&quot;&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import kotlinx.coroutines.suspendCancellableCoroutine&#13;&#10;import org.schabi.newpipe.extractor.NewPipe&#13;&#10;import org.schabi.newpipe.extractor.ServiceList&#13;&#10;import org.schabi.newpipe.extractor.localization.Localization&#13;&#10;import com.plyr.network.SpotifyRepository&#13;&#10;import kotlin.coroutines.resume&#13;&#10;&#13;&#10;data class MediaMetadata(&#13;&#10;    val title: String,&#13;&#10;    val author: String? = null,&#13;&#10;    val thumbnailUrl: String? = null,&#13;&#10;    val type: MediaType&#13;&#10;)&#13;&#10;&#13;&#10;enum class MediaType {&#13;&#10;    YOUTUBE_VIDEO,&#13;&#10;    YOUTUBE_PLAYLIST,&#13;&#10;    SPOTIFY_TRACK,&#13;&#10;    SPOTIFY_PLAYLIST,&#13;&#10;    SPOTIFY_ALBUM,&#13;&#10;    SPOTIFY_ARTIST,&#13;&#10;    UNKNOWN&#13;&#10;}&#13;&#10;&#13;&#10;object MediaMetadataExtractor {&#13;&#10;    private var isInitialized = false&#13;&#10;&#13;&#10;    private fun ensureInitialized() {&#13;&#10;        if (isInitialized) return&#13;&#10;        try {&#13;&#10;            NewPipe.init(com.plyr.network.SimpleDownloader.getInstance(), Localization(&quot;en&quot;, &quot;US&quot;))&#13;&#10;            isInitialized = true&#13;&#10;        } catch (_: Exception) {&#13;&#10;            // Already initialized&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    suspend fun extractMetadata(url: String, context: Context? = null): MediaMetadata = withContext(Dispatchers.IO) {&#13;&#10;        when {&#13;&#10;            isYouTubeUrl(url) -&gt; extractYouTubeMetadata(url)&#13;&#10;            isSpotifyUrl(url) -&gt; {&#13;&#10;                if (context != null &amp;&amp; Config.isSpotifyConnected(context)) {&#13;&#10;                    extractSpotifyMetadata(url, context)&#13;&#10;                } else {&#13;&#10;                    extractSpotifyMetadataFallback(url)&#13;&#10;                }&#13;&#10;            }&#13;&#10;            else -&gt; MediaMetadata(url, null, null, MediaType.UNKNOWN)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun isYouTubeUrl(url: String): Boolean {&#13;&#10;        return url.contains(&quot;youtube.com&quot;) || url.contains(&quot;youtu.be&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun isSpotifyUrl(url: String): Boolean {&#13;&#10;        return url.contains(&quot;spotify.com&quot;)&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun extractYouTubeMetadata(url: String): MediaMetadata = withContext(Dispatchers.IO) {&#13;&#10;        try {&#13;&#10;            ensureInitialized()&#13;&#10;&#13;&#10;            // Detectar si es una playlist&#13;&#10;            val isPlaylist = url.contains(&quot;list=&quot;) ||&#13;&#10;                            url.contains(&quot;/playlist&quot;) ||&#13;&#10;                            // Detectar IDs de playlist mal formateados en parámetro v=&#13;&#10;                            (url.contains(&quot;v=PL&quot;) || url.contains(&quot;v=UU&quot;) || url.contains(&quot;v=FL&quot;) || url.contains(&quot;v=RD&quot;))&#13;&#10;&#13;&#10;            if (isPlaylist) {&#13;&#10;                // Extraer el ID de la playlist&#13;&#10;                val playlistId = when {&#13;&#10;                    url.contains(&quot;list=&quot;) -&gt; url.substringAfter(&quot;list=&quot;).substringBefore(&quot;&amp;&quot;)&#13;&#10;                    // Si el ID está en v= y empieza con PL/UU/FL/RD, es una playlist malformada&#13;&#10;                    url.contains(&quot;v=PL&quot;) -&gt; url.substringAfter(&quot;v=PL&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;PL$it&quot; }&#13;&#10;                    url.contains(&quot;v=UU&quot;) -&gt; url.substringAfter(&quot;v=UU&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;UU$it&quot; }&#13;&#10;                    url.contains(&quot;v=FL&quot;) -&gt; url.substringAfter(&quot;v=FL&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;FL$it&quot; }&#13;&#10;                    url.contains(&quot;v=RD&quot;) -&gt; url.substringAfter(&quot;v=RD&quot;).substringBefore(&quot;&amp;&quot;).let { &quot;RD$it&quot; }&#13;&#10;                    else -&gt; url.substringAfterLast(&quot;/&quot;).substringBefore(&quot;?&quot;)&#13;&#10;                }&#13;&#10;&#13;&#10;                val playlistUrl = &quot;https://www.youtube.com/playlist?list=$playlistId&quot;&#13;&#10;                val extractor = ServiceList.YouTube.getPlaylistExtractor(playlistUrl)&#13;&#10;                extractor.fetchPage()&#13;&#10;&#13;&#10;                MediaMetadata(&#13;&#10;                    title = extractor.name,&#13;&#10;                    author = extractor.uploaderName,&#13;&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#13;&#10;                    type = MediaType.YOUTUBE_PLAYLIST&#13;&#10;                )&#13;&#10;            } else {&#13;&#10;                // Es un video&#13;&#10;                val extractor = ServiceList.YouTube.getStreamExtractor(url)&#13;&#10;                extractor.fetchPage()&#13;&#10;&#13;&#10;                MediaMetadata(&#13;&#10;                    title = extractor.name,&#13;&#10;                    author = extractor.uploaderName,&#13;&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#13;&#10;                    type = MediaType.YOUTUBE_VIDEO&#13;&#10;                )&#13;&#10;            }&#13;&#10;        } catch (e: Exception) {&#13;&#10;            // Si falla, intentar como video antes de dar up&#13;&#10;            try {&#13;&#10;                ensureInitialized()&#13;&#10;                val extractor = ServiceList.YouTube.getStreamExtractor(url)&#13;&#10;                extractor.fetchPage()&#13;&#10;&#13;&#10;                MediaMetadata(&#13;&#10;                    title = extractor.name,&#13;&#10;                    author = extractor.uploaderName,&#13;&#10;                    thumbnailUrl = extractor.thumbnails.maxByOrNull { it.height }?.url,&#13;&#10;                    type = MediaType.YOUTUBE_VIDEO&#13;&#10;                )&#13;&#10;            } catch (_: Exception) {&#13;&#10;                MediaMetadata(url, null, null, MediaType.UNKNOWN)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private suspend fun extractSpotifyMetadata(url: String, context: Context): MediaMetadata = withContext(Dispatchers.IO) {&#13;&#10;        try {&#13;&#10;            val accessToken = Config.getSpotifyAccessToken(context) ?: return@withContext extractSpotifyMetadataFallback(url)&#13;&#10;&#13;&#10;            when {&#13;&#10;                url.contains(&quot;/track/&quot;) -&gt; {&#13;&#10;                    val trackId = extractSpotifyId(url)&#13;&#10;                    suspendCancellableCoroutine { continuation -&gt;&#13;&#10;                        SpotifyRepository.getTrack(accessToken, trackId) { track, error -&gt;&#13;&#10;                            if (track != null) {&#13;&#10;                                continuation.resume(&#13;&#10;                                    MediaMetadata(&#13;&#10;                                        title = track.name,&#13;&#10;                                        author = track.getArtistNames(),&#13;&#10;                                        thumbnailUrl = track.album?.images?.firstOrNull()?.url,&#13;&#10;                                        type = MediaType.SPOTIFY_TRACK&#13;&#10;                                    )&#13;&#10;                                )&#13;&#10;                            } else {&#13;&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                url.contains(&quot;/playlist/&quot;) -&gt; {&#13;&#10;                    val playlistId = extractSpotifyId(url)&#13;&#10;                    suspendCancellableCoroutine { continuation -&gt;&#13;&#10;                        SpotifyRepository.getPlaylist(accessToken, playlistId) { playlist, error -&gt;&#13;&#10;                            if (playlist != null) {&#13;&#10;                                continuation.resume(&#13;&#10;                                    MediaMetadata(&#13;&#10;                                        title = playlist.name,&#13;&#10;                                        author = playlist.description,&#13;&#10;                                        thumbnailUrl = playlist.getImageUrl(),&#13;&#10;                                        type = MediaType.SPOTIFY_PLAYLIST&#13;&#10;                                    )&#13;&#10;                                )&#13;&#10;                            } else {&#13;&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                url.contains(&quot;/album/&quot;) -&gt; {&#13;&#10;                    val albumId = extractSpotifyId(url)&#13;&#10;                    suspendCancellableCoroutine { continuation -&gt;&#13;&#10;                        SpotifyRepository.getAlbum(accessToken, albumId) { album, error -&gt;&#13;&#10;                            if (album != null) {&#13;&#10;                                continuation.resume(&#13;&#10;                                    MediaMetadata(&#13;&#10;                                        title = album.name,&#13;&#10;                                        author = album.getArtistNames(),&#13;&#10;                                        thumbnailUrl = album.getImageUrl(),&#13;&#10;                                        type = MediaType.SPOTIFY_ALBUM&#13;&#10;                                    )&#13;&#10;                                )&#13;&#10;                            } else {&#13;&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                url.contains(&quot;/artist/&quot;) -&gt; {&#13;&#10;                    val artistId = extractSpotifyId(url)&#13;&#10;                    suspendCancellableCoroutine { continuation -&gt;&#13;&#10;                        SpotifyRepository.getArtist(accessToken, artistId) { artist, error -&gt;&#13;&#10;                            if (artist != null) {&#13;&#10;                                continuation.resume(&#13;&#10;                                    MediaMetadata(&#13;&#10;                                        title = artist.name,&#13;&#10;                                        author = artist.genres?.joinToString(&quot;, &quot;),&#13;&#10;                                        thumbnailUrl = artist.getImageUrl(),&#13;&#10;                                        type = MediaType.SPOTIFY_ARTIST&#13;&#10;                                    )&#13;&#10;                                )&#13;&#10;                            } else {&#13;&#10;                                continuation.resume(extractSpotifyMetadataFallback(url))&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                else -&gt; extractSpotifyMetadataFallback(url)&#13;&#10;            }&#13;&#10;        } catch (_: Exception) {&#13;&#10;            extractSpotifyMetadataFallback(url)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun extractSpotifyMetadataFallback(url: String): MediaMetadata {&#13;&#10;        val type = when {&#13;&#10;            url.contains(&quot;/track/&quot;) -&gt; MediaType.SPOTIFY_TRACK&#13;&#10;            url.contains(&quot;/playlist/&quot;) -&gt; MediaType.SPOTIFY_PLAYLIST&#13;&#10;            url.contains(&quot;/album/&quot;) -&gt; MediaType.SPOTIFY_ALBUM&#13;&#10;            url.contains(&quot;/artist/&quot;) -&gt; MediaType.SPOTIFY_ARTIST&#13;&#10;            else -&gt; MediaType.UNKNOWN&#13;&#10;        }&#13;&#10;&#13;&#10;        val title = when (type) {&#13;&#10;            MediaType.SPOTIFY_TRACK -&gt; &quot;Spotify Track&quot;&#13;&#10;            MediaType.SPOTIFY_PLAYLIST -&gt; &quot;Spotify Playlist&quot;&#13;&#10;            MediaType.SPOTIFY_ALBUM -&gt; &quot;Spotify Album&quot;&#13;&#10;            MediaType.SPOTIFY_ARTIST -&gt; &quot;Spotify Artist&quot;&#13;&#10;            else -&gt; &quot;Spotify Content&quot;&#13;&#10;        }&#13;&#10;&#13;&#10;        return MediaMetadata(&#13;&#10;            title = title,&#13;&#10;            author = null,&#13;&#10;            thumbnailUrl = null,&#13;&#10;            type = type&#13;&#10;        )&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun extractSpotifyId(url: String): String {&#13;&#10;        // Extract ID from URLs like: https://open.spotify.com/track/ID?si=...&#13;&#10;        return when {&#13;&#10;            url.contains(&quot;/track/&quot;) -&gt; url.substringAfter(&quot;/track/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#13;&#10;            url.contains(&quot;/playlist/&quot;) -&gt; url.substringAfter(&quot;/playlist/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#13;&#10;            url.contains(&quot;/album/&quot;) -&gt; url.substringAfter(&quot;/album/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#13;&#10;            url.contains(&quot;/artist/&quot;) -&gt; url.substringAfter(&quot;/artist/&quot;).substringBefore(&quot;?&quot;).substringBefore(&quot;/&quot;)&#13;&#10;            else -&gt; &quot;&quot;&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>