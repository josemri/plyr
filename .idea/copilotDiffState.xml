<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicService.kt" />
              <option name="originalContent" value="package com.plyr.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.media3.common.Player&#10;import androidx.media3.session.MediaSession&#10;import com.plyr.MainActivity&#10;import com.plyr.PlyrApp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MusicService : Service() {&#10;&#10;    // === PROPIEDADES ===&#10;    private var mediaSession: MediaSession? = null&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private var playlist: List&lt;String&gt; = emptyList()&#10;    private var currentIndex: Int = 0&#10;&#10;    // === CONSTANTES ===&#10;    companion object {&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val CHANNEL_ID = &quot;music_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;Music Playback&quot;&#10;        private const val CHANNEL_DESCRIPTION = &quot;Controls for music playback&quot;&#10;    }&#10;&#10;    // === CICLO DE VIDA DEL SERVICIO ===&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;MusicService::WakeLock&quot;)&#10;        wakeLock.acquire()&#10;&#10;        createNotificationChannel()&#10;        setupPlayerListener()&#10;        createMediaSession()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        when (intent?.action) {&#10;            &quot;ACTION_PLAY&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot; ACTION_PLAY recibido&quot;)&#10;                plyr.playPlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_PAUSE&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏸️ ACTION_PAUSE recibido&quot;)&#10;                plyr.pausePlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_NEXT&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏭️ ACTION_NEXT recibido&quot;)&#10;                if (plyr.hasNext.value) {&#10;                    println(&quot;⏭️ NAVEGANDO: Siguiente canción...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToNext()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No next track available&quot;)&#10;                }&#10;            }&#10;            &quot;ACTION_PREV&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏮️ ACTION_PREV recibido&quot;)&#10;                if (plyr.hasPrevious.value) {&#10;                    println(&quot;⏮️ NAVEGANDO: Canción anterior...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToPrevious()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No previous track available&quot;)&#10;                }&#10;            }&#10;            else -&gt; {&#10;                val audioUrl = intent?.getStringExtra(&quot;AUDIO_URL&quot;)&#10;                if (audioUrl != null) playAudio(audioUrl)&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE COMPONENTES ===&#10;    private fun createMediaSession() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        if (sharedPlayer != null) {&#10;            mediaSession = MediaSession.Builder(this, sharedPlayer).build()&#10;            Log.d(&quot;MusicService&quot;, &quot;✅ MediaSession creada correctamente&quot;)&#10;        } else {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ No se pudo obtener el player de PlayerViewModel&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupPlayerListener() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        sharedPlayer?.addListener(object : Player.Listener {&#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(&quot;MusicService&quot;, &quot; onIsPlayingChanged: isPlaying = $isPlaying&quot;)&#10;&#10;                // Printear el estado actual&#10;                if (isPlaying) {&#10;                    println(&quot; ESTADO: PLAYING - La canción está reproduciéndose&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot; ESTADO: PLAYING&quot;)&#10;                } else {&#10;                    println(&quot;⏸️ ESTADO: PAUSED - La canción está pausada&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot;⏸️ ESTADO: PAUSED&quot;)&#10;                }&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlaybackStateChange(isPlaying)&#10;                }&#10;            }&#10;&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                val stateName = when (playbackState) {&#10;                    Player.STATE_IDLE -&gt; &quot;IDLE&quot;&#10;                    Player.STATE_BUFFERING -&gt; &quot;BUFFERING&quot;&#10;                    Player.STATE_READY -&gt; &quot;READY&quot;&#10;                    Player.STATE_ENDED -&gt; &quot;ENDED&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;&#10;                // Printear los cambios de estado&#10;                when (playbackState) {&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        println(&quot;⏳ ESTADO: LOADING - Cargando canción...&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;⏳ ESTADO: LOADING - Buffering&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        println(&quot;✅ ESTADO: READY - Canción lista para reproducir&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;✅ ESTADO: READY&quot;)&#10;&#10;                        // Verificar si debe empezar a reproducir automáticamente (en hilo principal)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            val player = plyr.getPlayer()&#10;                            if (player?.playWhenReady == true &amp;&amp; !player.isPlaying) {&#10;                                println(&quot; INICIANDO REPRODUCCIÓN AUTOMÁTICA&quot;)&#10;                                Log.d(&quot;MusicService&quot;, &quot; Iniciando reproducción automática&quot;)&#10;                                player.play()&#10;                            }&#10;                            updateNotification()&#10;                        }&#10;                    }&#10;                    Player.STATE_ENDED -&gt; {&#10;                        println(&quot; ESTADO: ENDED - Canción terminada&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: ENDED&quot;)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            handleTrackEnded()&#10;                        }&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        println(&quot; ESTADO: IDLE - Player inactivo&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: IDLE&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; onPlaybackStateChanged: state = $stateName ($playbackState)&quot;)&#10;            }&#10;&#10;            override fun onPlayerError(error: androidx.media3.common.PlaybackException) {&#10;                println(&quot;❌ ESTADO: ERROR - ${error.message}&quot;)&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Player error: ${error.message}&quot;, error)&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlayerError(error)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // === MÉTODOS DE REPRODUCCIÓN ===&#10;    fun playAudio(audioUrl: String) {&#10;        Log.d(&quot;MusicService&quot;, &quot; playAudio llamado con: $audioUrl&quot;)&#10;        println(&quot; INICIANDO CARGA: $audioUrl&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;&#10;        try {&#10;            plyr.loadAudio(audioUrl, &quot;Audio Track&quot;)&#10;&#10;            // Asegurar que se reproduce cuando esté listo (en hilo principal)&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                val player = plyr.getPlayer()&#10;                player?.playWhenReady = true&#10;&#10;                kotlinx.coroutines.delay(500)&#10;                startForeground(NOTIFICATION_ID, createNotification())&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;❌ ERROR AL CARGAR: ${e.message}&quot;)&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al reproducir audio: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;    fun playPlaylist(urls: List&lt;String&gt;, startIndex: Int = 0) {&#10;        playlist = urls&#10;        currentIndex = startIndex.coerceIn(0, urls.size - 1)&#10;&#10;        if (playlist.isNotEmpty()) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playing playlist: ${playlist.size} tracks, starting at index $currentIndex&quot;)&#10;            playAudio(playlist[currentIndex])&#10;        } else {&#10;            Log.w(&quot;MusicService&quot;, &quot;⚠️ Attempted to play empty playlist&quot;)&#10;        }&#10;    }&#10;&#10;    // === MANEJO DE ESTADOS ===&#10;    private fun handlePlaybackStateChange(isPlaying: Boolean) {&#10;        Log.d(&quot;MusicService&quot;, &quot; handlePlaybackStateChange: isPlaying = $isPlaying&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val hasMedia = plyr.getPlayer()?.currentMediaItem != null&#10;&#10;        if (hasMedia || isPlaying) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Actualizando notificación - isPlaying: $isPlaying&quot;)&#10;            try {&#10;                // Para la primera vez, usar startForeground&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                    updateNotification()&#10;                } else {&#10;                    startForeground(NOTIFICATION_ID, createNotification())&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error al mostrar notificación: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot;⏸️ Sin contenido, deteniendo servicio en primer plano&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handleTrackEnded() {&#10;        if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size - 1) {&#10;            currentIndex++&#10;            val nextUrl = playlist[currentIndex]&#10;            Log.d(&quot;MusicService&quot;, &quot;⏭️ Track ended, playing next: $nextUrl&quot;)&#10;            playAudio(nextUrl)&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playlist ended&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerError(error: androidx.media3.common.PlaybackException) {&#10;        Log.e(&quot;MusicService&quot;, &quot;❌ Manejando error del player: ${error.message}&quot;)&#10;&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Limpiar MediaSession&#10;                cleanupResources()&#10;&#10;                // Esperar un momento antes de reintentar&#10;                kotlinx.coroutines.delay(1000)&#10;&#10;                // Recrear MediaSession con el player existente&#10;                createMediaSession()&#10;&#10;                // Reintentar la reproducción si hay un track actual&#10;                if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size) {&#10;                    Log.d(&quot;MusicService&quot;, &quot; Reintentando reproducción del track actual&quot;)&#10;                    playAudio(playlist[currentIndex])&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; Recuperación de error completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error durante la recuperación: ${e.message}&quot;, e)&#10;&#10;                // Si falla todo, detener el servicio&#10;                stopForeground(STOP_FOREGROUND_DETACH)&#10;                stopSelf()&#10;            }&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE NOTIFICACIONES ===&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = CHANNEL_DESCRIPTION&#10;                setShowBadge(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;                setSound(null, null) // Sin sonido para la notificación&#10;            }&#10;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    private fun createNotification(): Notification {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val player = plyr.getPlayer()&#10;        val currentMediaItem = player?.currentMediaItem&#10;        val title = currentMediaItem?.mediaMetadata?.title?.toString() ?: &quot;Music Player&quot;&#10;&#10;        // Obtener el estado correcto del player&#10;        val isCurrentlyPlaying = player?.isPlaying == true&#10;&#10;        Log.d(&quot;MusicService&quot;, &quot; Creando notificación - Playing: $isCurrentlyPlaying, Title: $title&quot;)&#10;&#10;        val playIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PLAY&quot; }&#10;        val pauseIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PAUSE&quot; }&#10;        val nextIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_NEXT&quot; }&#10;        val prevIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PREV&quot; }&#10;&#10;        val playPendingIntent = PendingIntent.getService(this, 0, playIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val pausePendingIntent = PendingIntent.getService(this, 1, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val nextPendingIntent = PendingIntent.getService(this, 2, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val prevPendingIntent = PendingIntent.getService(this, 3, prevIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(title)&#10;            .setContentText(if (isCurrentlyPlaying) &quot;Reproduciendo...&quot; else &quot;En pausa&quot;)&#10;            .setSmallIcon(if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play)&#10;            .setContentIntent(createMainActivityPendingIntent())&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setOngoing(true)&#10;            .setShowWhen(false)&#10;&#10;        val compactActions = mutableListOf&lt;Int&gt;()&#10;        var actionIndex = 0&#10;&#10;        // Botón anterior (si hay pista anterior)&#10;        if (plyr.hasPrevious.value) {&#10;            builder.addAction(android.R.drawable.ic_media_previous, &quot;Previous&quot;, prevPendingIntent)&#10;            compactActions.add(actionIndex)&#10;            actionIndex++&#10;        }&#10;&#10;        // Botón play/pause (siempre presente)&#10;        val playPauseIcon = if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play&#10;        val playPauseText = if (isCurrentlyPlaying) &quot;Pause&quot; else &quot;Play&quot;&#10;        val playPauseIntent = if (isCurrentlyPlaying) pausePendingIntent else playPendingIntent&#10;&#10;        builder.addAction(playPauseIcon, playPauseText, playPauseIntent)&#10;        compactActions.add(actionIndex)&#10;        actionIndex++&#10;&#10;        // Botón siguiente (si hay pista siguiente)&#10;        if (plyr.hasNext.value) {&#10;            builder.addAction(android.R.drawable.ic_media_next, &quot;Next&quot;, nextPendingIntent)&#10;            compactActions.add(actionIndex)&#10;        }&#10;&#10;        // MediaStyle simplificado sin MediaSession token&#10;        builder.setStyle(androidx.media.app.NotificationCompat.MediaStyle()&#10;            .setShowActionsInCompactView(*compactActions.toIntArray())&#10;        )&#10;&#10;        return builder.build()&#10;    }&#10;&#10;    private fun createMainActivityPendingIntent(): PendingIntent {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        return PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;    /**&#10;     * Actualiza la notificación existente&#10;     */&#10;    private fun updateNotification() {&#10;        try {&#10;            val notification = createNotification()&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;            Log.d(&quot;MusicService&quot;, &quot; Notificación actualizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al actualizar notificación: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // === BINDING ===&#10;    inner class MusicBinder : Binder() {&#10;        fun getService(): MusicService = this@MusicService&#10;    }&#10;&#10;    private val binder = MusicBinder()&#10;&#10;    override fun onBind(intent: Intent): IBinder {&#10;        return binder&#10;    }&#10;&#10;    // === LIMPIEZA DE RECURSOS ===&#10;    override fun onDestroy() {&#10;        Log.d(&quot;MusicService&quot;, &quot;️ Destruyendo MusicService&quot;)&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;        cleanupResources()&#10;        super.onDestroy()&#10;    }&#10;&#10;    private fun cleanupResources() {&#10;        mediaSession?.run {&#10;            release()&#10;            mediaSession = null&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.media3.common.Player&#10;import androidx.media3.session.MediaSession&#10;import com.plyr.MainActivity&#10;import com.plyr.PlyrApp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MusicService : Service() {&#10;&#10;    // === PROPIEDADES ===&#10;    private var mediaSession: MediaSession? = null&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private var playlist: List&lt;String&gt; = emptyList()&#10;    private var currentIndex: Int = 0&#10;&#10;    // === CONSTANTES ===&#10;    companion object {&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val CHANNEL_ID = &quot;music_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;Music Playback&quot;&#10;        private const val CHANNEL_DESCRIPTION = &quot;Controls for music playback&quot;&#10;    }&#10;&#10;    // === CICLO DE VIDA DEL SERVICIO ===&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;MusicService::WakeLock&quot;)&#10;        wakeLock.acquire(10 * 60 * 1000L /* 10 minutos */)&#10;&#10;        createNotificationChannel()&#10;        // Iniciar foreground service con notificación persistente&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        setupPlayerListener()&#10;        createMediaSession()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        when (intent?.action) {&#10;            &quot;ACTION_PLAY&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot; ACTION_PLAY recibido&quot;)&#10;                plyr.playPlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_PAUSE&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏸️ ACTION_PAUSE recibido&quot;)&#10;                plyr.pausePlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_NEXT&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏭️ ACTION_NEXT recibido&quot;)&#10;                if (plyr.hasNext.value == true) {&#10;                    println(&quot;⏭️ NAVEGANDO: Siguiente canción...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToNext()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No next track available&quot;)&#10;                }&#10;            }&#10;            &quot;ACTION_PREV&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏮️ ACTION_PREV recibido&quot;)&#10;                if (plyr.hasPrevious.value == true) {&#10;                    println(&quot;⏮️ NAVEGANDO: Canción anterior...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToPrevious()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No previous track available&quot;)&#10;                }&#10;            }&#10;            else -&gt; {&#10;                val audioUrl = intent?.getStringExtra(&quot;AUDIO_URL&quot;)&#10;                if (audioUrl != null) playAudio(audioUrl)&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE COMPONENTES ===&#10;    private fun createMediaSession() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        if (sharedPlayer != null) {&#10;            mediaSession = MediaSession.Builder(this, sharedPlayer).build()&#10;            Log.d(&quot;MusicService&quot;, &quot;✅ MediaSession creada correctamente&quot;)&#10;        } else {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ No se pudo obtener el player de PlayerViewModel&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupPlayerListener() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        sharedPlayer?.addListener(object : Player.Listener {&#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(&quot;MusicService&quot;, &quot; onIsPlayingChanged: isPlaying = $isPlaying&quot;)&#10;&#10;                // Printear el estado actual&#10;                if (isPlaying) {&#10;                    println(&quot; ESTADO: PLAYING - La canción está reproduciéndose&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot; ESTADO: PLAYING&quot;)&#10;                } else {&#10;                    println(&quot;⏸️ ESTADO: PAUSED - La canción está pausada&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot;⏸️ ESTADO: PAUSED&quot;)&#10;                }&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlaybackStateChange(isPlaying)&#10;                }&#10;            }&#10;&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                val stateName = when (playbackState) {&#10;                    Player.STATE_IDLE -&gt; &quot;IDLE&quot;&#10;                    Player.STATE_BUFFERING -&gt; &quot;BUFFERING&quot;&#10;                    Player.STATE_READY -&gt; &quot;READY&quot;&#10;                    Player.STATE_ENDED -&gt; &quot;ENDED&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;&#10;                // Printear los cambios de estado&#10;                when (playbackState) {&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        println(&quot;⏳ ESTADO: LOADING - Cargando canción...&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;⏳ ESTADO: LOADING - Buffering&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        println(&quot;✅ ESTADO: READY - Canción lista para reproducir&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;✅ ESTADO: READY&quot;)&#10;&#10;                        // Verificar si debe empezar a reproducir automáticamente (en hilo principal)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            val player = plyr.getPlayer()&#10;                            if (player?.playWhenReady == true &amp;&amp; !player.isPlaying) {&#10;                                println(&quot; INICIANDO REPRODUCCIÓN AUTOMÁTICA&quot;)&#10;                                Log.d(&quot;MusicService&quot;, &quot; Iniciando reproducción automática&quot;)&#10;                                player.play()&#10;                            }&#10;                            updateNotification()&#10;                        }&#10;                    }&#10;                    Player.STATE_ENDED -&gt; {&#10;                        println(&quot; ESTADO: ENDED - Canción terminada&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: ENDED&quot;)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            handleTrackEnded()&#10;                        }&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        println(&quot; ESTADO: IDLE - Player inactivo&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: IDLE&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; onPlaybackStateChanged: state = $stateName ($playbackState)&quot;)&#10;            }&#10;&#10;            override fun onPlayerError(error: androidx.media3.common.PlaybackException) {&#10;                println(&quot;❌ ESTADO: ERROR - ${error.message}&quot;)&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Player error: ${error.message}&quot;, error)&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlayerError(error)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // === MÉTODOS DE REPRODUCCIÓN ===&#10;    fun playAudio(audioUrl: String) {&#10;        Log.d(&quot;MusicService&quot;, &quot; playAudio llamado con: $audioUrl&quot;)&#10;        println(&quot; INICIANDO CARGA: $audioUrl&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;&#10;        try {&#10;            plyr.loadAudio(audioUrl, &quot;Audio Track&quot;)&#10;&#10;            // Asegurar que se reproduce cuando esté listo (en hilo principal)&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                val player = plyr.getPlayer()&#10;                player?.playWhenReady = true&#10;&#10;                kotlinx.coroutines.delay(500)&#10;                startForeground(NOTIFICATION_ID, createNotification())&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;❌ ERROR AL CARGAR: ${e.message}&quot;)&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al reproducir audio: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;    fun playPlaylist(urls: List&lt;String&gt;, startIndex: Int = 0) {&#10;        playlist = urls&#10;        currentIndex = startIndex.coerceIn(0, urls.size - 1)&#10;&#10;        if (playlist.isNotEmpty()) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playing playlist: ${playlist.size} tracks, starting at index $currentIndex&quot;)&#10;            playAudio(playlist[currentIndex])&#10;        } else {&#10;            Log.w(&quot;MusicService&quot;, &quot;⚠️ Attempted to play empty playlist&quot;)&#10;        }&#10;    }&#10;&#10;    // === MANEJO DE ESTADOS ===&#10;    private fun handlePlaybackStateChange(isPlaying: Boolean) {&#10;        Log.d(&quot;MusicService&quot;, &quot; handlePlaybackStateChange: isPlaying = $isPlaying&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val hasMedia = plyr.getPlayer()?.currentMediaItem != null&#10;&#10;        if (hasMedia || isPlaying) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Actualizando notificación - isPlaying: $isPlaying&quot;)&#10;            try {&#10;                // Para la primera vez, usar startForeground&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                    updateNotification()&#10;                } else {&#10;                    startForeground(NOTIFICATION_ID, createNotification())&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error al mostrar notificación: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot;⏸️ Sin contenido, deteniendo servicio en primer plano&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handleTrackEnded() {&#10;        if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size - 1) {&#10;            currentIndex++&#10;            val nextUrl = playlist[currentIndex]&#10;            Log.d(&quot;MusicService&quot;, &quot;⏭️ Track ended, playing next: $nextUrl&quot;)&#10;            playAudio(nextUrl)&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playlist ended&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerError(error: androidx.media3.common.PlaybackException) {&#10;        Log.e(&quot;MusicService&quot;, &quot;❌ Manejando error del player: ${error.message}&quot;)&#10;&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Limpiar MediaSession&#10;                cleanupResources()&#10;&#10;                // Esperar un momento antes de reintentar&#10;                kotlinx.coroutines.delay(1000)&#10;&#10;                // Recrear MediaSession con el player existente&#10;                createMediaSession()&#10;&#10;                // Reintentar la reproducción si hay un track actual&#10;                if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size) {&#10;                    Log.d(&quot;MusicService&quot;, &quot; Reintentando reproducción del track actual&quot;)&#10;                    playAudio(playlist[currentIndex])&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; Recuperación de error completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error durante la recuperación: ${e.message}&quot;, e)&#10;&#10;                // Si falla todo, detener el servicio&#10;                stopForeground(STOP_FOREGROUND_DETACH)&#10;                stopSelf()&#10;            }&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE NOTIFICACIONES ===&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = CHANNEL_DESCRIPTION&#10;                setShowBadge(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;                setSound(null, null) // Sin sonido para la notificación&#10;            }&#10;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    private fun createNotification(): Notification {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val player = plyr.getPlayer()&#10;        val currentMediaItem = player?.currentMediaItem&#10;        val title = currentMediaItem?.mediaMetadata?.title?.toString() ?: &quot;Music Player&quot;&#10;&#10;        // Obtener el estado correcto del player&#10;        val isCurrentlyPlaying = player?.isPlaying == true&#10;&#10;        Log.d(&quot;MusicService&quot;, &quot; Creando notificación - Playing: $isCurrentlyPlaying, Title: $title&quot;)&#10;&#10;        val playIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PLAY&quot; }&#10;        val pauseIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PAUSE&quot; }&#10;        val nextIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_NEXT&quot; }&#10;        val prevIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PREV&quot; }&#10;&#10;        val playPendingIntent = PendingIntent.getService(this, 0, playIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val pausePendingIntent = PendingIntent.getService(this, 1, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val nextPendingIntent = PendingIntent.getService(this, 2, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val prevPendingIntent = PendingIntent.getService(this, 3, prevIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(title)&#10;            .setContentText(if (isCurrentlyPlaying) &quot;Reproduciendo...&quot; else &quot;En pausa&quot;)&#10;            .setSmallIcon(if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play)&#10;            .setContentIntent(createMainActivityPendingIntent())&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setOngoing(true) // Notificación persistente&#10;            .setShowWhen(false)&#10;            .setOnlyAlertOnce(true) // Evita alertas repetidas&#10;&#10;        val compactActions = mutableListOf&lt;Int&gt;()&#10;        var actionIndex = 0&#10;&#10;        // Botón anterior (si hay pista anterior)&#10;        if (plyr.hasPrevious.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_previous, &quot;Previous&quot;, prevPendingIntent)&#10;            compactActions.add(actionIndex)&#10;            actionIndex++&#10;        }&#10;&#10;        // Botón play/pause (siempre presente)&#10;        val playPauseIcon = if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play&#10;        val playPauseText = if (isCurrentlyPlaying) &quot;Pause&quot; else &quot;Play&quot;&#10;        val playPauseIntent = if (isCurrentlyPlaying) pausePendingIntent else playPendingIntent&#10;&#10;        builder.addAction(playPauseIcon, playPauseText, playPauseIntent)&#10;        compactActions.add(actionIndex)&#10;        actionIndex++&#10;&#10;        // Botón siguiente (si hay pista siguiente)&#10;        if (plyr.hasNext.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_next, &quot;Next&quot;, nextPendingIntent)&#10;            compactActions.add(actionIndex)&#10;        }&#10;&#10;        // MediaStyle simplificado sin MediaSession token&#10;        builder.setStyle(androidx.media.app.NotificationCompat.MediaStyle()&#10;            .setShowActionsInCompactView(*compactActions.toIntArray())&#10;        )&#10;&#10;        return builder.build()&#10;    }&#10;&#10;    private fun createMainActivityPendingIntent(): PendingIntent {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        return PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;    /**&#10;     * Actualiza la notificación existente&#10;     */&#10;    private fun updateNotification() {&#10;        try {&#10;            val notification = createNotification()&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;            Log.d(&quot;MusicService&quot;, &quot; Notificación actualizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al actualizar notificación: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // === BINDING ===&#10;    inner class MusicBinder : Binder() {&#10;        fun getService(): MusicService = this@MusicService&#10;    }&#10;&#10;    private val binder = MusicBinder()&#10;&#10;    override fun onBind(intent: Intent): IBinder {&#10;        return binder&#10;    }&#10;&#10;    // === LIMPIEZA DE RECURSOS ===&#10;    override fun onDestroy() {&#10;        Log.d(&quot;MusicService&quot;, &quot;️ Destruyendo MusicService&quot;)&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;        cleanupResources()&#10;        super.onDestroy()&#10;    }&#10;&#10;    private fun cleanupResources() {&#10;        mediaSession?.run {&#10;            release()&#10;            mediaSession = null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>