<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import androidx.compose.ui.graphics.Color&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.Titulo&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option2 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = selectedTheme == &quot;dark&quot;,&#10;                onChange = { isDark -&gt;&#10;                    selectedTheme = if (isDark) &quot;dark&quot; else &quot;light&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;lang_spanish&quot;),&#10;                option2 = Translations.get(context, &quot;lang_english&quot;),&#10;                option3 = Translations.get(context, &quot;lang_catalan&quot;),&#10;                initialValue = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;&#9;&#9;&#9;&#9;&#9;Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    connectionMessage = message ?: if (success) Translations.get(context, &quot;connected&quot;) else &quot;error&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;sptfy_status&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                // Estado de Spotify (clickeable)&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                            haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                        }&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;client&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Estado de conexión&#10;                        Text(&#10;                            text = when {&#10;                                connectionMessage == &quot;credentials_required&quot; -&gt; Translations.get(context, &quot;configure_credentials_first&quot;)&#10;                                connectionMessage.isNotEmpty() -&gt; connectionMessage&#10;                                isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; Translations.get(context, &quot;connected&quot;)&#10;                                Config.hasSpotifyCredentials(context) -&gt; Translations.get(context, &quot;disconnected&quot;)&#10;                                else -&gt; Translations.get(context, &quot;credentials_required&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = when {&#10;                                    connectionMessage == &quot;credentials_required&quot; -&gt; Color(0xFFE74C3C)&#10;                                    !Config.hasSpotifyCredentials(context) -&gt; Color(0xFFE74C3C)&#10;                                    isSpotifyConnected -&gt; Color(0xFF1DB954)&#10;                                    else -&gt; Color(0xFF95A5A6)&#10;                                }&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context, languageKey = selectedLanguage)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context, languageKey: String) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;api&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) Color(0xFF1DB954) else Color(0xFFE74C3C)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF1DB954),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6),&#10;                        focusedTextColor = Color(0xFFECF0F1),&#10;                        unfocusedTextColor = Color(0xFFBDC3C7)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = Color(0xFF7F8C8D)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF1DB954),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6),&#10;                        focusedTextColor = Color(0xFFECF0F1),&#10;                        unfocusedTextColor = Color(0xFFBDC3C7)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = Color(0xFF7F8C8D)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = Color(0xFF3498DB)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF7F8C8D)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import androidx.compose.ui.graphics.Color&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.Titulo&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option2 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = selectedTheme == &quot;dark&quot;,&#10;                onChange = { isDark -&gt;&#10;                    selectedTheme = if (isDark) &quot;dark&quot; else &quot;light&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;lang_spanish&quot;),&#10;                option2 = Translations.get(context, &quot;lang_english&quot;),&#10;                option3 = Translations.get(context, &quot;lang_catalan&quot;),&#10;                initialValue = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;&#9;&#9;&#9;&#9;&#9;Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    // If message is null, use a canonical key; otherwise store the raw message (which may be a key)&#10;                    connectionMessage = message ?: if (success) &quot;connected_successfully&quot; else &quot;error_starting_oauth&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;sptfy_status&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                // Estado de Spotify (clickeable)&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                            haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                        }&#10;                        .padding(vertical = 4.dp),&#10;                    horizontalArrangement = Arrangement.SpaceBetween&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;client&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;&#10;                    Row(&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        // Estado de conexión&#10;                        Text(&#10;                            text = when {&#10;                                connectionMessage == &quot;credentials_required&quot; -&gt; Translations.get(context, &quot;configure_credentials_first&quot;)&#10;                                // If the message corresponds to a translation key -&gt; translate it&#10;                                Translations.exists(context, connectionMessage) -&gt; Translations.get(context, connectionMessage)&#10;                                // If it's a raw (already translated) message or an error string, show it directly&#10;                                connectionMessage.isNotEmpty() -&gt; connectionMessage&#10;                                isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; Translations.get(context, &quot;connected&quot;)&#10;                                Config.hasSpotifyCredentials(context) -&gt; Translations.get(context, &quot;disconnected&quot;)&#10;                                else -&gt; Translations.get(context, &quot;credentials_required&quot;)&#10;                            },&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = when {&#10;                                    connectionMessage == &quot;credentials_required&quot; -&gt; Color(0xFFE74C3C)&#10;                                    !Config.hasSpotifyCredentials(context) -&gt; Color(0xFFE74C3C)&#10;                                    isSpotifyConnected -&gt; Color(0xFF1DB954)&#10;                                    else -&gt; Color(0xFF95A5A6)&#10;                                }&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;api&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) Color(0xFF1DB954) else Color(0xFFE74C3C)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF1DB954),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6),&#10;                        focusedTextColor = Color(0xFFECF0F1),&#10;                        unfocusedTextColor = Color(0xFFBDC3C7)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = Color(0xFF7F8C8D)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF1DB954),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6),&#10;                        focusedTextColor = Color(0xFFECF0F1),&#10;                        unfocusedTextColor = Color(0xFFBDC3C7)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = Color(0xFF7F8C8D)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = Color(0xFF3498DB)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF7F8C8D)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import com.plyr.ui.components.search.YouTubePlaylistDetailView&#10;import com.plyr.ui.components.search.YouTubeSearchResults&#10;import com.plyr.ui.components.QrScannerDialog&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Detección de cambio de idioma para actualizar la UI&#10;    var currentLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            delay(100)&#10;            val newLanguage = Config.getLanguage(context)&#10;            if (newLanguage != currentLanguage) {&#10;                currentLanguage = newLanguage&#10;            }&#10;        }&#10;    }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para resultados de YouTube (NUEVOS)&#10;    var youtubeAllResults by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubeSearchAllResult?&gt;(null) }&#10;    var showYouTubeAllResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist de YouTube (NUEVOS)&#10;    var selectedYouTubePlaylist by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubePlaylistInfo?&gt;(null) }&#10;&#10;    // Estados para añadir canciones a playlist&#10;    var showPlaylistSelectionDialog by remember { mutableStateOf(false) }&#10;    var selectedTrackToAdd by remember { mutableStateOf&lt;SpotifyTrack?&gt;(null) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Definir el estado en el composable principal&#10;    var showQrScanner by remember { mutableStateOf(false) }&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoading = true&#10;            } else {&#10;                isLoading = true&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                youtubeAllResults = null&#10;                showYouTubeAllResults = false&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        error = Translations.get(context, &quot;search_query_empty_after_prefix&quot;)&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Limpiar resultados anteriores de YouTube&#10;                            youtubeAllResults = null&#10;                            showYouTubeAllResults = false&#10;&#10;                            // Usar la nueva búsqueda completa de YouTube (videos + playlists)&#10;                            val searchResults = youtubeSearchManager.searchYouTubeAll(finalQuery)&#10;&#10;                            // Establecer los nuevos resultados&#10;                            youtubeAllResults = searchResults&#10;                            showYouTubeAllResults = true&#10;&#10;                            // Mantener compatibilidad con el sistema legacy de videos&#10;                            val newResults = searchResults.videos.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            results = newResults&#10;&#10;                            isLoading = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                error = &quot;${Translations.get(context, &quot;search_error&quot;)}: $searchError&quot;&#10;                                            } else if (searchResults != null) {&#10;&#10;&#10;                                                // Filtrar playlists nulas antes de procesar&#10;                                                val validPlaylists = searchResults.playlists.items&#10;                                                searchResults.playlists.items.size - validPlaylists.size&#10;&#10;                                                // Crear un nuevo objeto de resultados con las playlists filtradas&#10;                                                val filteredResults = SpotifySearchAllResponse(&#10;                                                    tracks = searchResults.tracks,&#10;                                                    albums = searchResults.albums,&#10;                                                    artists = searchResults.artists,&#10;                                                    playlists = SpotifyPlaylistsSearchResult(&#10;                                                        items = validPlaylists,&#10;                                                        total = searchResults.playlists.total,&#10;                                                        limit = searchResults.playlists.limit,&#10;                                                        offset = searchResults.playlists.offset,&#10;                                                        next = searchResults.playlists.next&#10;                                                    )&#10;                                                )&#10;&#10;                                                spotifyResults = filteredResults&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                isLoading = false&#10;                                                showSpotifyResults = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                error = Translations.get(context, &quot;search_spotify_not_connected&quot;)&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            error = &quot;${Translations.get(context, &quot;search_engine_not_recognized&quot;)}: $finalSearchEngine&quot;&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    error = &quot;${Translations.get(context, &quot;search_error&quot;)}: ${e.message}&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;${Translations.get(context, &quot;search_error_loading_tracks&quot;)}: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Volver de la vista detallada de playlist de YouTube&#10;                selectedYouTubePlaylist = null&#10;            }&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Nueva vista detallada para playlists de YouTube&#10;                YouTubePlaylistDetailView(&#10;                    playlist = selectedYouTubePlaylist!!,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                val album = selectedSpotifyAlbum!!&#10;                var showShareDialog by remember { mutableStateOf(false) }&#10;                var saveStatus by remember { mutableStateOf&lt;String?&gt;(null) }&#10;                var isAlbumSaved by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;                var isCheckingStatus by remember { mutableStateOf(false) }&#10;&#10;                // Verificar si el álbum está guardado al cargar la vista&#10;                LaunchedEffect(album.id) {&#10;                    isCheckingStatus = true&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.checkIfAlbumSaved(accessToken, album.id) { isSaved, errorMsg -&gt;&#10;                            isCheckingStatus = false&#10;                            if (isSaved != null) {&#10;                                isAlbumSaved = isSaved&#10;                            }&#10;                        }&#10;                    } else {&#10;                        isCheckingStatus = false&#10;                    }&#10;                }&#10;&#10;                Column(&#10;                    modifier = Modifier.fillMaxSize().padding(16.dp)&#10;                ) {&#10;                    // Album header&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        AsyncImage(&#10;                            model = album.getImageUrl(),&#10;                            contentDescription = Translations.get(context, &quot;album_cover&quot;),&#10;                            modifier = Modifier.size(80.dp).clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 20.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                    // Action buttons&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_start&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback from first track&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(4.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_random&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFFFD93D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback with shuffled tracks&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val shuffledTracks = selectedItemTracks.shuffled()&#10;                                    val trackEntities = shuffledTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(4.dp)&#10;                        )&#10;                        // Botón dinámico save/unsave&#10;                        if (isCheckingStatus) {&#10;                            Text(&#10;                                text = &quot;&lt;...&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.padding(4.dp)&#10;                            )&#10;                        } else {&#10;                            Text(&#10;                                text = if (isAlbumSaved == true) &quot;&lt;${Translations.get(context, &quot;search_unsave&quot;)}&gt;&quot; else &quot;&lt;${Translations.get(context, &quot;search_save&quot;)}&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isAlbumSaved == true) Color(0xFFFF6B6B) else Color(0xFF6BCF7F)&#10;                                ),&#10;                                modifier = Modifier.clickable {&#10;                                    coroutineScope.launch {&#10;                                        try {&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                if (isAlbumSaved == true) {&#10;                                                    // Eliminar álbum&#10;                                                    saveStatus = Translations.get(context, &quot;search_removing&quot;)&#10;                                                    SpotifyRepository.removeAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                                                        saveStatus = if (success) {&#10;                                                            isAlbumSaved = false&#10;                                                            Translations.get(context, &quot;search_removed&quot;)&#10;                                                        } else {&#10;                                                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $errorMsg&quot;&#10;                                                        }&#10;                                                        // Clear status after 2 seconds&#10;                                                        coroutineScope.launch {&#10;                                                            kotlinx.coroutines.delay(2000)&#10;                                                            saveStatus = null&#10;                                                        }&#10;                                                    }&#10;                                                } else {&#10;                                                    // Guardar álbum&#10;                                                    saveStatus = Translations.get(context, &quot;search_saving_status&quot;)&#10;                                                    SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                                                        saveStatus = if (success) {&#10;                                                            isAlbumSaved = true&#10;                                                            Translations.get(context, &quot;search_saved&quot;)&#10;                                                        } else {&#10;                                                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $errorMsg&quot;&#10;                                                        }&#10;                                                        // Clear status after 2 seconds&#10;                                                        coroutineScope.launch {&#10;                                                            kotlinx.coroutines.delay(2000)&#10;                                                            saveStatus = null&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                saveStatus = Translations.get(context, &quot;search_error_no_token&quot;)&#10;                                            }&#10;                                        } catch (e: Exception) {&#10;                                            saveStatus = &quot;${Translations.get(context, &quot;search_error&quot;)}: ${e.message}&quot;&#10;                                        }&#10;                                    }&#10;                                }.padding(4.dp)&#10;                            )&#10;                        }&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_share&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                showShareDialog = true&#10;                            }.padding(4.dp)&#10;                        )&#10;                    }&#10;                    // Save status message&#10;                    saveStatus?.let { status -&gt;&#10;                        Text(&#10;                            text = &quot;$ $status&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = if (status.startsWith(&quot;error&quot;)) Color(0xFFFF6B6B) else Color(0xFF6BCF7F)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Loading and error states&#10;                    if (isLoadingTracks) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = Translations.get(context, &quot;search_loading_tracks&quot;),&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFFFD93D)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    error?.let {&#10;                        Text(&#10;                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $it&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Track list&#10;                    if (selectedItemTracks.isNotEmpty()) {&#10;                        val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                            TrackEntity(&#10;                                id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                playlistId = album.id,&#10;                                spotifyTrackId = spotifyTrack.id,&#10;                                name = spotifyTrack.name,&#10;                                artists = spotifyTrack.getArtistNames(),&#10;                                youtubeVideoId = null,&#10;                                audioUrl = null,&#10;                                position = trackIndex,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        }&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp)&#10;                        ) {&#10;                            items(selectedItemTracks.size) { index -&gt;&#10;                                val track = selectedItemTracks[index]&#10;                                val song = Song(&#10;                                    number = index + 1,&#10;                                    title = track.name,&#10;                                    artist = track.getArtistNames(),&#10;                                    spotifyId = track.id,&#10;                                    spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                )&#10;                                SongListItem(&#10;                                    song = song,&#10;                                    trackEntities = trackEntities,&#10;                                    index = index,&#10;                                    playerViewModel = playerViewModel,&#10;                                    coroutineScope = coroutineScope,&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showShareDialog) {&#10;                    ShareDialog(&#10;                        item = ShareableItem(&#10;                            spotifyId = album.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/album/${album.id}&quot;,&#10;                            youtubeId = null,&#10;                            title = album.name,&#10;                            artist = album.getArtistNames(),&#10;                            type = ShareType.ALBUM&#10;                        ),&#10;                        onDismiss = { showShareDialog = false }&#10;                    )&#10;                }&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    context = context,&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums,&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    youtubeAllResults = youtubeAllResults,&#10;                    showYouTubeAllResults = showYouTubeAllResults,&#10;                    onYouTubePlaylistSelected = { playlist -&gt;&#10;                        selectedYouTubePlaylist = playlist&#10;                    },&#10;                    onShowQrScannerChange = { showQrScanner = it }&#10;                )&#10;                if (showQrScanner) {&#10;                    QrScannerDialog(&#10;                        onDismiss = { showQrScanner = false },&#10;                        onQrScanned = { qrResult -&gt;&#10;                            showQrScanner = false&#10;                            if (qrResult != null) {&#10;                                // Procesar el resultado del QR escaneado&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        when (qrResult.source) {&#10;                                            &quot;spotify&quot; -&gt; {&#10;                                                if (Config.isSpotifyConnected(context)) {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        isLoading = true&#10;                                                        when (qrResult.type) {&#10;                                                            &quot;track&quot; -&gt; {&#10;                                                                SpotifyRepository.getTrack(accessToken, qrResult.id) { track, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (track != null) {&#10;                                                                        // Buscar este track específico&#10;                                                                        searchQuery = &quot;${track.name} ${track.getArtistNames()}&quot;&#10;                                                                        performSearch(searchQuery, false)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_track&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;playlist&quot; -&gt; {&#10;                                                                SpotifyRepository.getPlaylist(accessToken, qrResult.id) { playlist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (playlist != null) {&#10;                                                                        loadSpotifyPlaylistTracks(playlist)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_playlist&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;album&quot; -&gt; {&#10;                                                                SpotifyRepository.getAlbum(accessToken, qrResult.id) { album, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (album != null) {&#10;                                                                        loadSpotifyAlbumTracks(album)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_album&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;artist&quot; -&gt; {&#10;                                                                SpotifyRepository.getArtist(accessToken, qrResult.id) { artist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (artist != null) {&#10;                                                                        loadArtistAlbums(artist)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_artist&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                                    }&#10;                                                } else {&#10;                                                    error = Translations.get(context, &quot;search_spotify_not_connected&quot;)&#10;                                                }&#10;                                            }&#10;                                            &quot;youtube&quot; -&gt; {&#10;                                                // Buscar directamente el video ID en YouTube&#10;                                                val videoUrl = &quot;https://www.youtube.com/watch?v=${qrResult.id}&quot;&#10;                                                searchQuery = videoUrl&#10;                                                performSearch(videoUrl, false)&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        error = &quot;${Translations.get(context, &quot;search_error_processing_qr&quot;)}: ${e.message}&quot;&#10;                                        isLoading = false&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Diálogo para selección de playlist&#10;        if (showPlaylistSelectionDialog &amp;&amp; selectedTrackToAdd != null) {&#10;            AlertDialog(&#10;                onDismissRequest = { showPlaylistSelectionDialog = false },&#10;                title = { Text(Translations.get(context, &quot;search_select_playlist&quot;)) },&#10;                text = {&#10;                    Column {&#10;                        if (isLoadingPlaylists) {&#10;                            // Indicador de carga&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator()&#10;                            }&#10;                        } else {&#10;                            // Lista de playlists del usuario&#10;                            LazyColumn {&#10;                                items(userPlaylists) { playlist -&gt;&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Añadir la canción a la playlist seleccionada&#10;                                                coroutineScope.launch {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        SpotifyRepository.addTrackToPlaylist(accessToken, playlist.id, selectedTrackToAdd!!.id) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Cerrar diálogo y mostrar mensaje de éxito&#10;                                                                showPlaylistSelectionDialog = false&#10;                                                            } else {&#10;                                                                // Mostrar error&#10;                                                                error = &quot;${Translations.get(context, &quot;search_adding_to_playlist&quot;)}: $errorMsg&quot;&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            // Cerrar diálogo sin acción&#10;                            showPlaylistSelectionDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(Translations.get(context, &quot;search_cancel&quot;))&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(0.9f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    context: Context,&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    youtubeAllResults: YouTubeSearchManager.YouTubeSearchAllResult?,&#10;    showYouTubeAllResults: Boolean,&#10;    onYouTubePlaylistSelected: (YouTubeSearchManager.YouTubePlaylistInfo) -&gt; Unit,&#10;    onShowQrScannerChange: (Boolean) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Titulo(Translations.get(context, &quot;search_title&quot;))&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    Translations.get(context, &quot;search_placeholder&quot;),&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                Row {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = {&#10;                            onSearchQueryChange(&quot;&quot;)&#10;                        }) {&#10;                            Text(&#10;                                text = &quot;x&quot;,&#10;                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    IconButton(onClick = { onShowQrScannerChange(true) }) {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;search_scan_qr&quot;),&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ ${Translations.get(context, &quot;search_loading&quot;)}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;${Translations.get(context, &quot;search_error&quot;)}: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                context = context,&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                onArtistSelected = onArtistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE CON PLAYLISTS (NUEVO) ===&#10;        if (showYouTubeAllResults &amp;&amp; youtubeAllResults != null) {&#10;            YouTubeSearchResults(&#10;                results = null, // Legacy results&#10;                youtubeAllResults = youtubeAllResults,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onPlaylistSelected = onYouTubePlaylistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE LEGACY ===&#10;        if (results.isNotEmpty() &amp;&amp; !showYouTubeAllResults) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                context = context,&#10;                results = results,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    context: Context,&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(false) }&#10;    var albumsExpanded by remember { mutableStateOf(false) }&#10;    var playlistsExpanded by remember { mutableStateOf(false) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    // Labels localizados&#10;    val tracksLabel = Translations.get(context, &quot;search_tracks&quot;)&#10;    val albumsLabel = Translations.get(context, &quot;search_albums&quot;)&#10;    val playlistsLabel = Translations.get(context, &quot;search_playlists&quot;)&#10;    val artistsLabel = Translations.get(context, &quot;search_artists&quot;)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (tracksExpanded) &quot;v $tracksLabel&quot; else &quot;&gt; $tracksLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                val trackEntities = results.tracks.items.take(5).mapIndexed { trackIndex, track -&gt;&#10;                    TrackEntity(&#10;                        id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                        playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                        spotifyTrackId = track.id,&#10;                        name = track.name,&#10;                        artists = track.getArtistNames(),&#10;                        youtubeVideoId = null,&#10;                        audioUrl = null,&#10;                        position = trackIndex,&#10;                        lastSyncTime = System.currentTimeMillis()&#10;                    )&#10;                }&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(1.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        val song = Song(&#10;                            number = index + 1,&#10;                            title = track.name,&#10;                            artist = track.getArtistNames(),&#10;                            spotifyId = track.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                        )&#10;                        SongListItem(&#10;                            song = song,&#10;                            trackEntities = trackEntities,&#10;                            index = index,&#10;                            playerViewModel = playerViewModel,&#10;                            coroutineScope = coroutineScope,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (albumsExpanded) &quot;v $albumsLabel&quot; else &quot;&gt; $albumsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;album_cover&quot;),&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (playlistsExpanded) &quot;v $playlistsLabel&quot; else &quot;&gt; $playlistsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                val nonNullPlaylists = results.playlists.items.filterNotNull()&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(nonNullPlaylists) { playlist -&gt;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;playlist_cover&quot;),&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (artistsExpanded) &quot;v $artistsLabel&quot; else &quot;&gt; $artistsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;artist_image&quot;),&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    context: Context,&#10;    results: List&lt;AudioItem&gt;,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var videosExpanded by remember { mutableStateOf(true) }&#10;&#10;    // Labels localizados&#10;    val youtubeLabel = Translations.get(context, &quot;search_youtube_results&quot;)&#10;    val loadMoreLabel = Translations.get(context, &quot;search_load_more&quot;)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Videos section header&#10;        Text(&#10;            text = if (videosExpanded) &quot;v $youtubeLabel [${results.size}]&quot; else &quot;&gt; $youtubeLabel [${results.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { videosExpanded = !videosExpanded }&#10;                .padding(4.dp)&#10;        )&#10;&#10;        if (videosExpanded) {&#10;            val trackEntities = results.mapIndexed { trackIndex, item -&gt;&#10;                TrackEntity(&#10;                    id = &quot;youtube_${item.videoId}&quot;,&#10;                    playlistId = &quot;youtube_search&quot;,&#10;                    spotifyTrackId = item.videoId,&#10;                    name = item.title,&#10;                    artists = item.channel,&#10;                    youtubeVideoId = item.videoId,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                results.forEachIndexed { index, item -&gt;&#10;                    val song = Song(&#10;                        number = index + 1,&#10;                        title = item.title,&#10;                        artist = item.channel,&#10;                        youtubeId = item.videoId,&#10;                        spotifyUrl = &quot;https://www.youtube.com/watch?v=${item.videoId}&quot;&#10;                    )&#10;                    SongListItem(&#10;                        song = song,&#10;                        trackEntities = trackEntities,&#10;                        index = index,&#10;                        playerViewModel = playerViewModel,&#10;                        coroutineScope = coroutineScope,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Load more button if there are more results&#10;                if (results.size &gt;= 10) {&#10;                    Text(&#10;                        text = &quot;&gt; $loadMoreLabel&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF4ECDC4)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { onLoadMore() }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import com.plyr.ui.components.search.YouTubePlaylistDetailView&#10;import com.plyr.ui.components.search.YouTubeSearchResults&#10;import com.plyr.ui.components.QrScannerDialog&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Detección de cambio de idioma para actualizar la UI&#10;    var currentLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    LaunchedEffect(Unit) {&#10;        while (true) {&#10;            delay(100)&#10;            val newLanguage = Config.getLanguage(context)&#10;            if (newLanguage != currentLanguage) {&#10;                currentLanguage = newLanguage&#10;            }&#10;        }&#10;    }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para resultados de YouTube (NUEVOS)&#10;    var youtubeAllResults by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubeSearchAllResult?&gt;(null) }&#10;    var showYouTubeAllResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist de YouTube (NUEVOS)&#10;    var selectedYouTubePlaylist by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubePlaylistInfo?&gt;(null) }&#10;&#10;    // Estados para añadir canciones a playlist&#10;    var showPlaylistSelectionDialog by remember { mutableStateOf(false) }&#10;    var selectedTrackToAdd by remember { mutableStateOf&lt;SpotifyTrack?&gt;(null) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Definir el estado en el composable principal&#10;    var showQrScanner by remember { mutableStateOf(false) }&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoading = true&#10;            } else {&#10;                isLoading = true&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                youtubeAllResults = null&#10;                showYouTubeAllResults = false&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        error = Translations.get(context, &quot;search_query_empty_after_prefix&quot;)&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Limpiar resultados anteriores de YouTube&#10;                            youtubeAllResults = null&#10;                            showYouTubeAllResults = false&#10;&#10;                            // Usar la nueva búsqueda completa de YouTube (videos + playlists)&#10;                            val searchResults = youtubeSearchManager.searchYouTubeAll(finalQuery)&#10;&#10;                            // Establecer los nuevos resultados&#10;                            youtubeAllResults = searchResults&#10;                            showYouTubeAllResults = true&#10;&#10;                            // Mantener compatibilidad con el sistema legacy de videos&#10;                            val newResults = searchResults.videos.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            results = newResults&#10;&#10;                            isLoading = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                error = &quot;${Translations.get(context, &quot;search_error&quot;)}: $searchError&quot;&#10;                                            } else if (searchResults != null) {&#10;&#10;&#10;                                                // Filtrar playlists nulas antes de procesar&#10;                                                val validPlaylists = searchResults.playlists.items&#10;                                                searchResults.playlists.items.size - validPlaylists.size&#10;&#10;                                                // Crear un nuevo objeto de resultados con las playlists filtradas&#10;                                                val filteredResults = SpotifySearchAllResponse(&#10;                                                    tracks = searchResults.tracks,&#10;                                                    albums = searchResults.albums,&#10;                                                    artists = searchResults.artists,&#10;                                                    playlists = SpotifyPlaylistsSearchResult(&#10;                                                        items = validPlaylists,&#10;                                                        total = searchResults.playlists.total,&#10;                                                        limit = searchResults.playlists.limit,&#10;                                                        offset = searchResults.playlists.offset,&#10;                                                        next = searchResults.playlists.next&#10;                                                    )&#10;                                                )&#10;&#10;                                                spotifyResults = filteredResults&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                isLoading = false&#10;                                                showSpotifyResults = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                error = Translations.get(context, &quot;search_spotify_not_connected&quot;)&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            error = &quot;${Translations.get(context, &quot;search_engine_not_recognized&quot;)}: $finalSearchEngine&quot;&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    error = &quot;${Translations.get(context, &quot;search_error&quot;)}: ${e.message}&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;${Translations.get(context, &quot;search_error_loading_tracks&quot;)}: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Volver de la vista detallada de playlist de YouTube&#10;                selectedYouTubePlaylist = null&#10;            }&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Nueva vista detallada para playlists de YouTube&#10;                YouTubePlaylistDetailView(&#10;                    playlist = selectedYouTubePlaylist!!,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                val album = selectedSpotifyAlbum!!&#10;                var showShareDialog by remember { mutableStateOf(false) }&#10;                var saveStatus by remember { mutableStateOf&lt;String?&gt;(null) }&#10;                var isAlbumSaved by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;                var isCheckingStatus by remember { mutableStateOf(false) }&#10;&#10;                // Verificar si el álbum está guardado al cargar la vista&#10;                LaunchedEffect(album.id) {&#10;                    isCheckingStatus = true&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.checkIfAlbumSaved(accessToken, album.id) { isSaved, errorMsg -&gt;&#10;                            isCheckingStatus = false&#10;                            if (isSaved != null) {&#10;                                isAlbumSaved = isSaved&#10;                            }&#10;                        }&#10;                    } else {&#10;                        isCheckingStatus = false&#10;                    }&#10;                }&#10;&#10;                Column(&#10;                    modifier = Modifier.fillMaxSize().padding(16.dp)&#10;                ) {&#10;                    // Album header&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        AsyncImage(&#10;                            model = album.getImageUrl(),&#10;                            contentDescription = Translations.get(context, &quot;album_cover&quot;),&#10;                            modifier = Modifier.size(80.dp).clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 20.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                    // Action buttons&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_start&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback from first track&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(4.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_random&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFFFD93D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback with shuffled tracks&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val shuffledTracks = selectedItemTracks.shuffled()&#10;                                    val trackEntities = shuffledTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(4.dp)&#10;                        )&#10;                        // Botón dinámico save/unsave&#10;                        if (isCheckingStatus) {&#10;                            Text(&#10;                                text = &quot;&lt;...&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.padding(4.dp)&#10;                            )&#10;                        } else {&#10;                            Text(&#10;                                text = if (isAlbumSaved == true) &quot;&lt;${Translations.get(context, &quot;search_unsave&quot;)}&gt;&quot; else &quot;&lt;${Translations.get(context, &quot;search_save&quot;)}&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isAlbumSaved == true) Color(0xFFFF6B6B) else Color(0xFF6BCF7F)&#10;                                ),&#10;                                modifier = Modifier.clickable {&#10;                                    coroutineScope.launch {&#10;                                        try {&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                if (isAlbumSaved == true) {&#10;                                                    // Eliminar álbum&#10;                                                    saveStatus = Translations.get(context, &quot;search_removing&quot;)&#10;                                                    SpotifyRepository.removeAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                                                        saveStatus = if (success) {&#10;                                                            isAlbumSaved = false&#10;                                                            Translations.get(context, &quot;search_removed&quot;)&#10;                                                        } else {&#10;                                                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $errorMsg&quot;&#10;                                                        }&#10;                                                        // Clear status after 2 seconds&#10;                                                        coroutineScope.launch {&#10;                                                            kotlinx.coroutines.delay(2000)&#10;                                                            saveStatus = null&#10;                                                        }&#10;                                                    }&#10;                                                } else {&#10;                                                    // Guardar álbum&#10;                                                    saveStatus = Translations.get(context, &quot;search_saving_status&quot;)&#10;                                                    SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                                                        saveStatus = if (success) {&#10;                                                            isAlbumSaved = true&#10;                                                            Translations.get(context, &quot;search_saved&quot;)&#10;                                                        } else {&#10;                                                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $errorMsg&quot;&#10;                                                        }&#10;                                                        // Clear status after 2 seconds&#10;                                                        coroutineScope.launch {&#10;                                                            kotlinx.coroutines.delay(2000)&#10;                                                            saveStatus = null&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                saveStatus = Translations.get(context, &quot;search_error_no_token&quot;)&#10;                                            }&#10;                                        } catch (e: Exception) {&#10;                                            saveStatus = &quot;${Translations.get(context, &quot;search_error&quot;)}: ${e.message}&quot;&#10;                                        }&#10;                                    }&#10;                                }.padding(4.dp)&#10;                            )&#10;                        }&#10;                        Text(&#10;                            text = &quot;&lt;${Translations.get(context, &quot;search_share&quot;)}&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                showShareDialog = true&#10;                            }.padding(4.dp)&#10;                        )&#10;                    }&#10;                    // Save status message&#10;                    saveStatus?.let { status -&gt;&#10;                        Text(&#10;                            text = &quot;$ $status&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = if (status.startsWith(&quot;error&quot;)) Color(0xFFFF6B6B) else Color(0xFF6BCF7F)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Loading and error states&#10;                    if (isLoadingTracks) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = Translations.get(context, &quot;search_loading_tracks&quot;),&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFFFD93D)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    error?.let {&#10;                        Text(&#10;                            &quot;${Translations.get(context, &quot;search_error&quot;)}: $it&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Track list&#10;                    if (selectedItemTracks.isNotEmpty()) {&#10;                        val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                            TrackEntity(&#10;                                id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                playlistId = album.id,&#10;                                spotifyTrackId = spotifyTrack.id,&#10;                                name = spotifyTrack.name,&#10;                                artists = spotifyTrack.getArtistNames(),&#10;                                youtubeVideoId = null,&#10;                                audioUrl = null,&#10;                                position = trackIndex,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        }&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp)&#10;                        ) {&#10;                            items(selectedItemTracks.size) { index -&gt;&#10;                                val track = selectedItemTracks[index]&#10;                                val song = Song(&#10;                                    number = index + 1,&#10;                                    title = track.name,&#10;                                    artist = track.getArtistNames(),&#10;                                    spotifyId = track.id,&#10;                                    spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                )&#10;                                SongListItem(&#10;                                    song = song,&#10;                                    trackEntities = trackEntities,&#10;                                    index = index,&#10;                                    playerViewModel = playerViewModel,&#10;                                    coroutineScope = coroutineScope,&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showShareDialog) {&#10;                    ShareDialog(&#10;                        item = ShareableItem(&#10;                            spotifyId = album.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/album/${album.id}&quot;,&#10;                            youtubeId = null,&#10;                            title = album.name,&#10;                            artist = album.getArtistNames(),&#10;                            type = ShareType.ALBUM&#10;                        ),&#10;                        onDismiss = { showShareDialog = false }&#10;                    )&#10;                }&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    context = context,&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums,&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    youtubeAllResults = youtubeAllResults,&#10;                    showYouTubeAllResults = showYouTubeAllResults,&#10;                    onYouTubePlaylistSelected = { playlist -&gt;&#10;                        selectedYouTubePlaylist = playlist&#10;                    },&#10;                    onShowQrScannerChange = { showQrScanner = it }&#10;                )&#10;                if (showQrScanner) {&#10;                    QrScannerDialog(&#10;                        onDismiss = { showQrScanner = false },&#10;                        onQrScanned = { qrResult -&gt;&#10;                            showQrScanner = false&#10;                            if (qrResult != null) {&#10;                                // Procesar el resultado del QR escaneado&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        when (qrResult.source) {&#10;                                            &quot;spotify&quot; -&gt; {&#10;                                                if (Config.isSpotifyConnected(context)) {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        isLoading = true&#10;                                                        when (qrResult.type) {&#10;                                                            &quot;track&quot; -&gt; {&#10;                                                                SpotifyRepository.getTrack(accessToken, qrResult.id) { track, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (track != null) {&#10;                                                                        // Buscar este track específico&#10;                                                                        searchQuery = &quot;${track.name} ${track.getArtistNames()}&quot;&#10;                                                                        performSearch(searchQuery, false)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_track&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;playlist&quot; -&gt; {&#10;                                                                SpotifyRepository.getPlaylist(accessToken, qrResult.id) { playlist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (playlist != null) {&#10;                                                                        loadSpotifyPlaylistTracks(playlist)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_playlist&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;album&quot; -&gt; {&#10;                                                                SpotifyRepository.getAlbum(accessToken, qrResult.id) { album, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (album != null) {&#10;                                                                        loadSpotifyAlbumTracks(album)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_album&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;artist&quot; -&gt; {&#10;                                                                SpotifyRepository.getArtist(accessToken, qrResult.id) { artist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (artist != null) {&#10;                                                                        loadArtistAlbums(artist)&#10;                                                                    } else {&#10;                                                                        error = &quot;${Translations.get(context, &quot;search_error_getting_artist&quot;)}: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                                    }&#10;                                                } else {&#10;                                                    error = Translations.get(context, &quot;search_spotify_not_connected&quot;)&#10;                                                }&#10;                                            }&#10;                                            &quot;youtube&quot; -&gt; {&#10;                                                // Buscar directamente el video ID en YouTube&#10;                                                val videoUrl = &quot;https://www.youtube.com/watch?v=${qrResult.id}&quot;&#10;                                                searchQuery = videoUrl&#10;                                                performSearch(videoUrl, false)&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        error = &quot;${Translations.get(context, &quot;search_error_processing_qr&quot;)}: ${e.message}&quot;&#10;                                        isLoading = false&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Diálogo para selección de playlist&#10;        if (showPlaylistSelectionDialog &amp;&amp; selectedTrackToAdd != null) {&#10;            AlertDialog(&#10;                onDismissRequest = { showPlaylistSelectionDialog = false },&#10;                title = { Text(Translations.get(context, &quot;search_select_playlist&quot;)) },&#10;                text = {&#10;                    Column {&#10;                        if (isLoadingPlaylists) {&#10;                            // Indicador de carga&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator()&#10;                            }&#10;                        } else {&#10;                            // Lista de playlists del usuario&#10;                            LazyColumn {&#10;                                items(userPlaylists) { playlist -&gt;&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Añadir la canción a la playlist seleccionada&#10;                                                coroutineScope.launch {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        SpotifyRepository.addTrackToPlaylist(accessToken, playlist.id, selectedTrackToAdd!!.id) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Cerrar diálogo y mostrar mensaje de éxito&#10;                                                                showPlaylistSelectionDialog = false&#10;                                                            } else {&#10;                                                                // Mostrar error&#10;                                                                error = &quot;${Translations.get(context, &quot;search_adding_to_playlist&quot;)}: $errorMsg&quot;&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = Translations.get(context, &quot;search_token_not_available&quot;)&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            // Cerrar diálogo sin acción&#10;                            showPlaylistSelectionDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(Translations.get(context, &quot;search_cancel&quot;))&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(0.9f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    context: Context,&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    youtubeAllResults: YouTubeSearchManager.YouTubeSearchAllResult?,&#10;    showYouTubeAllResults: Boolean,&#10;    onYouTubePlaylistSelected: (YouTubeSearchManager.YouTubePlaylistInfo) -&gt; Unit,&#10;    onShowQrScannerChange: (Boolean) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Titulo(Translations.get(context, &quot;search_title&quot;))&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    Translations.get(context, &quot;search_placeholder&quot;),&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                Row {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = {&#10;                            onSearchQueryChange(&quot;&quot;)&#10;                        }) {&#10;                            Text(&#10;                                text = &quot;x&quot;,&#10;                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    IconButton(onClick = { onShowQrScannerChange(true) }) {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;search_scan_qr&quot;),&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ ${Translations.get(context, &quot;search_loading&quot;)}&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;${Translations.get(context, &quot;search_error&quot;)}: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                context = context,&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                onArtistSelected = onArtistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE CON PLAYLISTS (NUEVO) ===&#10;        if (showYouTubeAllResults &amp;&amp; youtubeAllResults != null) {&#10;            YouTubeSearchResults(&#10;                results = null, // Legacy results&#10;                youtubeAllResults = youtubeAllResults,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onPlaylistSelected = onYouTubePlaylistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE LEGACY ===&#10;        if (results.isNotEmpty() &amp;&amp; !showYouTubeAllResults) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                context = context,&#10;                results = results,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    context: Context,&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(false) }&#10;    var albumsExpanded by remember { mutableStateOf(false) }&#10;    var playlistsExpanded by remember { mutableStateOf(false) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    // Labels localizados&#10;    val tracksLabel = Translations.get(context, &quot;search_tracks&quot;)&#10;    val albumsLabel = Translations.get(context, &quot;search_albums&quot;)&#10;    val playlistsLabel = Translations.get(context, &quot;search_playlists&quot;)&#10;    val artistsLabel = Translations.get(context, &quot;search_artists&quot;)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (tracksExpanded) &quot;v $tracksLabel&quot; else &quot;&gt; $tracksLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                val trackEntities = results.tracks.items.take(5).mapIndexed { trackIndex, track -&gt;&#10;                    TrackEntity(&#10;                        id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                        playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                        spotifyTrackId = track.id,&#10;                        name = track.name,&#10;                        artists = track.getArtistNames(),&#10;                        youtubeVideoId = null,&#10;                        audioUrl = null,&#10;                        position = trackIndex,&#10;                        lastSyncTime = System.currentTimeMillis()&#10;                    )&#10;                }&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(1.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        val song = Song(&#10;                            number = index + 1,&#10;                            title = track.name,&#10;                            artist = track.getArtistNames(),&#10;                            spotifyId = track.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                        )&#10;                        SongListItem(&#10;                            song = song,&#10;                            trackEntities = trackEntities,&#10;                            index = index,&#10;                            playerViewModel = playerViewModel,&#10;                            coroutineScope = coroutineScope,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (albumsExpanded) &quot;v $albumsLabel&quot; else &quot;&gt; $albumsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;album_cover&quot;),&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (playlistsExpanded) &quot;v $playlistsLabel&quot; else &quot;&gt; $playlistsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                val nonNullPlaylists = results.playlists.items.filterNotNull()&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(nonNullPlaylists) { playlist -&gt;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;playlist_cover&quot;),&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (artistsExpanded) &quot;v $artistsLabel&quot; else &quot;&gt; $artistsLabel&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = Translations.get(context, &quot;artist_image&quot;),&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    context: Context,&#10;    results: List&lt;AudioItem&gt;,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var videosExpanded by remember { mutableStateOf(true) }&#10;&#10;    // Labels localizados&#10;    val youtubeLabel = Translations.get(context, &quot;search_youtube_results&quot;)&#10;    val loadMoreLabel = Translations.get(context, &quot;search_load_more&quot;)&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Videos section header&#10;        Text(&#10;            text = if (videosExpanded) &quot;v $youtubeLabel [${results.size}]&quot; else &quot;&gt; $youtubeLabel [${results.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { videosExpanded = !videosExpanded }&#10;                .padding(4.dp)&#10;        )&#10;&#10;        if (videosExpanded) {&#10;            val trackEntities = results.mapIndexed { trackIndex, item -&gt;&#10;                TrackEntity(&#10;                    id = &quot;youtube_${item.videoId}&quot;,&#10;                    playlistId = &quot;youtube_search&quot;,&#10;                    spotifyTrackId = item.videoId,&#10;                    name = item.title,&#10;                    artists = item.channel,&#10;                    youtubeVideoId = item.videoId,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                results.forEachIndexed { index, item -&gt;&#10;                    val song = Song(&#10;                        number = index + 1,&#10;                        title = item.title,&#10;                        artist = item.channel,&#10;                        youtubeId = item.videoId,&#10;                        spotifyUrl = &quot;https://www.youtube.com/watch?v=${item.videoId}&quot;&#10;                    )&#10;                    SongListItem(&#10;                        song = song,&#10;                        trackEntities = trackEntities,&#10;                        index = index,&#10;                        playerViewModel = playerViewModel,&#10;                        coroutineScope = coroutineScope,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Load more button if there are more results&#10;                if (results.size &gt;= 10) {&#10;                    Text(&#10;                        text = &quot;&gt; $loadMoreLabel&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF4ECDC4)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { onLoadMore() }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Translations.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Translations.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;&#10;/**&#10; * Sistema de traducciones para la aplicación plyr&#10; * Maneja las traducciones para Español, English y Català&#10; */&#10;object Translations {&#10;&#10;    // Mapa de traducciones por idioma&#10;    private val translations = mapOf(&#10;        // ESPAÑOL&#10;        &quot;español&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_ajustes&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;oscuro&quot;,&#10;            &quot;theme_light&quot; to &quot;claro&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_de_búsqueda&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; calidad_de_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baja&quot;,&#10;            &quot;quality_med&quot; to &quot;media&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; información&quot;,&#10;            &quot;info_text&quot; to &quot;    ● ¡no piratees música!\n    ● cambia el motor con yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; estado_sptfy&quot;,&#10;            &quot;client&quot; to &quot;    ● cliente:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;conectado&quot;,&#10;            &quot;disconnected&quot; to &quot;desconectado&quot;,&#10;            &quot;configured&quot; to &quot;configurado&quot;,&#10;            &quot;not_configured&quot; to &quot;no configurado&quot;,&#10;            &quot;credentials_required&quot; to &quot;se requieren credenciales&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura las credenciales primero&quot;,&#10;            &quot;opening_browser&quot; to &quot;abriendo navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;revisa el navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error al iniciar oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      id del client:&quot;,&#10;            &quot;client_secret&quot; to &quot;      secreto del client:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introduce tu id del cliente de spotify&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introduce tu secreto del cliente de spotify &quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; cómo obtener credenciales de la api de spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ve a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sesión con tu cuenta de spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. selecciona 'crear aplicación'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. rellena el nombre (por ejemplo, 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. establece el redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' y 'web  pi'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. haz clic en 'guardar'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia el client_id y el client_secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. pegalos en los campos de arriba&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: estas credenciales se guardan localmente&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;, //QUITAR EL TITLE GENERAL&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;buscar&quot;,&#10;            &quot;home_playlists&quot; to &quot;listas&quot;,&#10;            &quot;home_queue&quot; to &quot;cola&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustes&quot;,&#10;            &quot;exit_message&quot; to &quot;Presiona de nuevo para salir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;buscar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;buscar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;cargando...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no se encontraron resultados&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no está conectado&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de búsqueda no reconocido&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error cargando canciones&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;cargando canciones...&quot;,&#10;            &quot;search_tracks&quot; to &quot;canciones&quot;,&#10;            &quot;search_albums&quot; to &quot;álbumes&quot;,&#10;            &quot;search_artists&quot; to &quot;artistas&quot;,&#10;            &quot;search_playlists&quot; to &quot;listas&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;listas youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatorio&quot;,&#10;            &quot;search_save&quot; to &quot;guardar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;guardado&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al guardar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidores&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oyentes mensuales&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imagen del artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry vacía después del prefijo&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminando...&quot;,&#10;            &quot;search_removed&quot; to &quot;¡eliminado!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;guardando...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hay token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obteniendo track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obteniendo playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obteniendo álbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obteniendo artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error procesando QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;añadiendo canción a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;siguiente&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;mezclar&quot;,&#10;&#10;&#9;&#9;&#9;// Local Screen&#10;&#9;&#9;&#9;&quot;plyr_local&quot; to &quot;plyr_local&quot;,&#10;&#9;&#9;&#9;&quot;unknown error&quot; to &quot;error desconocido&quot;,&#10;&#9;&#9;&#9;&quot;No tracks downloaded&quot; to &quot;Ninguna canción descargada&quot;,&#10;&#9;&#9;&#9;&quot;delete track&quot; to &quot;eliminar canción&quot;,&#10;&#9;&#9;&#9;&quot;Song {{track_name}} will be removed permanently&quot; to &quot;La canción {{track_name}} será eliminada permanentemente&quot;,&#10;&#9;&#9;&#9;&quot;delete&quot; to &quot;eliminar&quot;,&#10;&#9;&#9;&#9;&quot;cancel&quot; to &quot;cancelar&quot;,&#10;&#10;&#9;&#9;&#9;// Queue Screen&#10;&#9;&#9;&#9;&quot;plyr_queue&quot; to &quot;plyr_cola&quot;,&#10;&#9;&#9;&#9;&quot;No tracks loaded&quot; to &quot;Ninguna lista cargada&quot;,&#10;&#9;&#9;&#9;&quot;Play a track to start a playlist&quot; to &quot;Reproduce una canción para iniciar una lista&quot;,&#10;&#9;&#9;    &quot;player_not_available&quot; to &quot;reproductor_no_disponible&quot;,&#10;&#10;&#9;&#9;&#9;//Playlists Screen&#10;&#9;&#9;&#9;&quot;plyr_lists&quot; to &quot;plyr_listas&quot;,&#10;&#9;&#9;&#9;&quot;&lt;syncing...&gt;&quot; to &quot;&lt;sincronizando...&gt;&quot;,&#10;&#9;&#9;&#9;&quot;&lt;sync&gt;&quot; to &quot;&lt;sincronizar&gt;&quot;,&#10;&#9;&#9;&#9;&quot;&lt;new&gt;&quot; to &quot;&lt;crear&gt;&quot;,&#10;&#9;&#9;&#9;&quot;Spotify not connected&quot; to &quot;Spotify no conectado&quot;,&#10;&#9;&#9;&#9;&quot;Loading tracks...&quot; to &quot;Cargando canciones...&quot;,&#10;&#9;&#9;    &#10;        ),&#10;&#10;        // ENGLISH&#10;        &quot;english&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_config&quot;,&#10;            &quot;theme&quot; to &quot;&gt; theme&quot;,&#10;            &quot;theme_dark&quot; to &quot;dark&quot;,&#10;            &quot;theme_light&quot; to &quot;light&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; search_engine&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; audio_quality&quot;,&#10;            &quot;quality_low&quot; to &quot;low&quot;,&#10;            &quot;quality_med&quot; to &quot;med&quot;,&#10;            &quot;quality_high&quot; to &quot;high&quot;,&#10;            &quot;language&quot; to &quot;&gt; language&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;info_text&quot; to &quot;    ● don't pirate music!\n    ● Change engine with yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; sptfy_status&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connected&quot;,&#10;            &quot;disconnected&quot; to &quot;disconnected&quot;,&#10;            &quot;configured&quot; to &quot;configured&quot;,&#10;            &quot;not_configured&quot; to &quot;not_configured&quot;,&#10;            &quot;credentials_required&quot; to &quot;credentials required&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configure credentials first&quot;,&#10;            &quot;opening_browser&quot; to &quot;opening_browser...&quot;,&#10;            &quot;check_browser&quot; to &quot;check_browser&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_starting_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;enter your spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;enter your spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; how to get spotify api credentials:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. go to https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. log in with your spotify account&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. click 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. fill app name (e.g., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. set redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. select 'mobile' and 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. click 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copy client id and client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. paste them in the fields above&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      note: these credentials are stored locally&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;search&quot;,&#10;            &quot;home_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;home_queue&quot; to &quot;queue&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;settings&quot;,&#10;            &quot;exit_message&quot; to &quot;Press back again to exit&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_search&quot;,&#10;            &quot;search_placeholder&quot; to &quot;search music...&quot;,&#10;            &quot;search_loading&quot; to &quot;loading...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no results found&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify is not connected&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Spotify token not available&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Search engine not recognized&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error loading tracks&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;loading tracks...&quot;,&#10;            &quot;search_tracks&quot; to &quot;tracks&quot;,&#10;            &quot;search_albums&quot; to &quot;albums&quot;,&#10;            &quot;search_artists&quot; to &quot;artists&quot;,&#10;            &quot;search_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;youtube playlists&quot;,&#10;            &quot;search_start&quot; to &quot;start&quot;,&#10;            &quot;search_random&quot; to &quot;random&quot;,&#10;            &quot;search_save&quot; to &quot;save&quot;,&#10;            &quot;search_share&quot; to &quot;share&quot;,&#10;            &quot;search_saved&quot; to &quot;saved&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error saving&quot;,&#10;            &quot;search_followers&quot; to &quot;followers&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;monthly listeners&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Playlist cover&quot;,&#10;            &quot;artist_image&quot; to &quot;Artist image&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Query empty after prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Album cover&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Select playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancel&quot;,&#10;            &quot;search_removing&quot; to &quot;removing...&quot;,&#10;            &quot;search_removed&quot; to &quot;removed!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;saving...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no token&quot;,&#10;            &quot;search_unsave&quot; to &quot;unsave&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error getting track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error getting playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error getting album&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error getting artist&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processing QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;adding song to playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;next&quot;,&#10;            &quot;previous&quot; to &quot;previous&quot;,&#10;            &quot;repeat&quot; to &quot;repeat&quot;,&#10;            &quot;shuffle&quot; to &quot;shuffle&quot;&#10;        ),&#10;&#10;        // CATALÀ&#10;        &quot;català&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_configuració&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;fosc&quot;,&#10;            &quot;theme_light&quot; to &quot;clar&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_cerca&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; qualitat_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baixa&quot;,&#10;            &quot;quality_med&quot; to &quot;mitjana&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;info_text&quot; to &quot;    ● no piratejis música!\n    ● Canvia motor amb yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; estat_sptfy&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connectat&quot;,&#10;            &quot;disconnected&quot; to &quot;desconnectat&quot;,&#10;            &quot;configured&quot; to &quot;configurat&quot;,&#10;            &quot;not_configured&quot; to &quot;no_configurat&quot;,&#10;            &quot;credentials_required&quot; to &quot;credencials requerides&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura les credencials primer&quot;,&#10;            &quot;opening_browser&quot; to &quot;obrint_navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;comprova_navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_iniciant_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introdueix el teu spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introdueix el teu spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; com obtenir credencials api spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ves a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sessió amb el teu compte spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. clica 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. omple el nom app (ex., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. estableix redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' i 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. clica 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia client id i client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. enganxa'ls als camps de dalt&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: aquestes credencials es guarden localment&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;cercar...&quot;,&#10;            &quot;no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;loading&quot; to &quot;carregant...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;cercar&quot;,&#10;            &quot;home_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;home_queue&quot; to &quot;cua&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustos&quot;,&#10;            &quot;exit_message&quot; to &quot;Prem de nou per sortir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_cercar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;cercar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;carregant...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no està connectat&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de cerca no reconegut&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error carregant cançons&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;carregant cançons...&quot;,&#10;            &quot;search_tracks&quot; to &quot;cançons&quot;,&#10;            &quot;search_albums&quot; to &quot;àlbums&quot;,&#10;            &quot;search_artists&quot; to &quot;artistes&quot;,&#10;            &quot;search_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;search_videos&quot; to &quot;vídeos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;llistes youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatori&quot;,&#10;            &quot;search_save&quot; to &quot;desar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;desat&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al desar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidors&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oients mensuals&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imatge de l'artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry buida després del prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminant...&quot;,&#10;            &quot;search_removed&quot; to &quot;eliminat!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;desant...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hi ha token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obtenint track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obtenint playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obtenint àlbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obtenint artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processant QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;afegint cançó a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;reproduint ara&quot;,&#10;            &quot;play&quot; to &quot;reproduir&quot;,&#10;            &quot;pause&quot; to &quot;pausa&quot;,&#10;            &quot;next&quot; to &quot;següent&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;aleatori&quot;,&#10;&#10;&#9;&#9;    // Local Screen&#10;&#9;&#9;&#9;&quot;plyr_local&quot; to &quot;plyr_local&quot;,&#10;&#9;&#9;&#9;&quot;unknown error&quot; to &quot;error desconegut&quot;,&#10;&#9;&#9;&#9;&quot;No tracks downloaded&quot; to &quot;Ninguna cançó descarregada&quot;,&#10;&#9;&#9;&#9;&quot;delete track&quot; to &quot;eliminar cançó&quot;,&#10;&#9;&#9;&#9;&quot;Song {{track_name}} will be removed permanently&quot; to &quot;La canció {{track_name}} serà eliminada permanentment&quot;,&#10;&#9;&#9;&#9;&quot;delete&quot; to &quot;eliminar&quot;,&#10;&#9;&#9;&#9;&quot;cancel&quot; to &quot;cancelar&quot;,&#10;&#10;&#9;&#9;&#9;// Queue Screen&#10;&#9;&#9;&#9;&quot;plyr_queue&quot; to &quot;plyr_cua&quot;,&#10;&#9;&#9;&#9;&quot;No tracks loaded&quot; to &quot;Ninguna llista carregada&quot;,&#10;&#9;&#9;&#9;&quot;Play a track to start a playlist&quot; to &quot;Reprodueix una cançó per iniciar una llista&quot;,&#10;&#9;&#9;    &quot;player_not_available&quot; to &quot;reproductor_no_disponible&quot;,&#10;&#10;&#9;&#9;&#9;//Playlists Screen&#10;&#9;&#9;&#9;&quot;plyr_lists&quot; to &quot;plyr_llistes&quot;,&#10;&#9;&#9;&#9;&quot;&lt;syncing...&gt;&quot; to &quot;&lt;sincronitzant...&gt;&quot;,&#10;&#9;&#9;&#9;&quot;&lt;sync&gt;&quot; to &quot;&lt;sincronitzar&gt;&quot;,&#10;&#9;&#9;&#9;&quot;&lt;new&gt;&quot; to &quot;&lt;crear&gt;&quot;,&#10;&#9;&#9;    &quot;Spotify not connected&quot; to &quot;Spotify no connectat&quot;,&#10;&#9;&#9;&#9;&quot;Loading tracks...&quot; to &quot;Carregant cançons...&quot;&#10;&#10;        )&#10;    )&#10;&#10;    /**&#10;     * Obtiene una traducción para una clave específica según el idioma actual&#10;     * @param context Contexto de la aplicación&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(context: Context, key: String): String {&#10;        val language = Config.getLanguage(context)&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;&#10;    /**&#10;     * Obtiene una traducción para una clave específica según un idioma específico&#10;     * @param language Idioma deseado&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(language: String, key: String): String {&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;&#10;    /**&#10;     * Verifica si existe una traducción para una clave específica&#10;     * @param context Contexto de la aplicación&#10;     * @param key Clave de la traducción&#10;     * @return true si existe, false en caso contrario&#10;     */&#10;    fun exists(context: Context, key: String): Boolean {&#10;        val language = Config.getLanguage(context)&#10;        return translations[language]?.containsKey(key) ?: false&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;&#10;/**&#10; * Sistema de traducciones para la aplicación plyr&#10; * Maneja las traducciones para Español, English y Català&#10; */&#10;object Translations {&#10;&#10;    // Mapa de traducciones por idioma&#10;    private val translations = mapOf(&#10;        // ESPAÑOL&#10;        &quot;español&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_ajustes&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;oscuro&quot;,&#10;            &quot;theme_light&quot; to &quot;claro&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_de_búsqueda&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; calidad_de_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baja&quot;,&#10;            &quot;quality_med&quot; to &quot;media&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; información&quot;,&#10;            &quot;info_text&quot; to &quot;    ● ¡no piratees música!\n    ● cambia el motor con yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; estado_sptfy&quot;,&#10;            &quot;client&quot; to &quot;    ● cliente:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;conectado&quot;,&#10;            &quot;disconnected&quot; to &quot;desconectado&quot;,&#10;            &quot;configured&quot; to &quot;configurado&quot;,&#10;            &quot;not_configured&quot; to &quot;no configurado&quot;,&#10;            &quot;credentials_required&quot; to &quot;se requieren credenciales&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura las credenciales primero&quot;,&#10;            &quot;opening_browser&quot; to &quot;abriendo navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;revisa el navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error al iniciar oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      id del client:&quot;,&#10;            &quot;client_secret&quot; to &quot;      secreto del client:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introduce tu id del cliente de spotify&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introduce tu secreto del cliente de spotify &quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; cómo obtener credenciales de la api de spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ve a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sesión con tu cuenta de spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. selecciona 'crear aplicación'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. rellena el nombre (por ejemplo, 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. establece el redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' y 'web  pi'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. haz clic en 'guardar'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia el client_id y el client_secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. pegalos en los campos de arriba&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: estas credenciales se guardan localmente&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;, //QUITAR EL TITLE GENERAL&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;buscar&quot;,&#10;            &quot;home_playlists&quot; to &quot;listas&quot;,&#10;            &quot;home_queue&quot; to &quot;cola&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustes&quot;,&#10;            &quot;exit_message&quot; to &quot;Presiona de nuevo para salir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;buscar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;buscar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;cargando...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no se encontraron resultados&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no está conectado&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de búsqueda no reconocido&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error cargando canciones&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;cargando canciones...&quot;,&#10;            &quot;search_tracks&quot; to &quot;canciones&quot;,&#10;            &quot;search_albums&quot; to &quot;álbumes&quot;,&#10;            &quot;search_artists&quot; to &quot;artistas&quot;,&#10;            &quot;search_playlists&quot; to &quot;listas&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;listas youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatorio&quot;,&#10;            &quot;search_save&quot; to &quot;guardar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;guardado&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al guardar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidores&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oyentes mensuales&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imagen del artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry vacía después del prefijo&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminando...&quot;,&#10;            &quot;search_removed&quot; to &quot;¡eliminado!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;guardando...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hay token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obteniendo track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obteniendo playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obteniendo álbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obteniendo artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error procesando QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;añadiendo canción a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;siguiente&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;mezclar&quot;,&#10;&#10;            // Local Screen&#10;            &quot;plyr_local&quot; to &quot;plyr_local&quot;,&#10;            &quot;unknown error&quot; to &quot;error desconocido&quot;,&#10;            &quot;No tracks downloaded&quot; to &quot;Ninguna canción descargada&quot;,&#10;            &quot;delete track&quot; to &quot;eliminar canción&quot;,&#10;            &quot;Song {{track_name}} will be removed permanently&quot; to &quot;La canción {{track_name}} será eliminada permanentemente&quot;,&#10;            &quot;delete&quot; to &quot;eliminar&quot;,&#10;            &quot;cancel&quot; to &quot;cancelar&quot;,&#10;&#10;            // Queue Screen&#10;            &quot;plyr_queue&quot; to &quot;plyr_cola&quot;,&#10;            &quot;No tracks loaded&quot; to &quot;Ninguna lista cargada&quot;,&#10;            &quot;Play a track to start a playlist&quot; to &quot;Reproduce una canción para iniciar una lista&quot;,&#10;            &quot;player_not_available&quot; to &quot;reproductor_no_disponible&quot;,&#10;&#10;            //Playlists Screen&#10;            &quot;plyr_lists&quot; to &quot;plyr_listas&quot;,&#10;            &quot;&lt;syncing...&gt;&quot; to &quot;&lt;sincronizando...&gt;&quot;,&#10;            &quot;&lt;sync&gt;&quot; to &quot;&lt;sincronizar&gt;&quot;,&#10;            &quot;&lt;new&gt;&quot; to &quot;&lt;crear&gt;&quot;,&#10;            &quot;Spotify not connected&quot; to &quot;Spotify no conectado&quot;,&#10;            &quot;Loading tracks...&quot; to &quot;Cargando canciones...&quot;,&#10;&#10;            // ADDITIONAL KEYS (SPANISH)&#10;            &quot;connected_successfully&quot; to &quot;conectado correctamente&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;intercambio de token fallido&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;cancelado por el usuario&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;No se pudo obtener audio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;&#10;&#10;        ),&#10;&#10;        // ENGLISH&#10;        &quot;english&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_config&quot;,&#10;            &quot;theme&quot; to &quot;&gt; theme&quot;,&#10;            &quot;theme_dark&quot; to &quot;dark&quot;,&#10;            &quot;theme_light&quot; to &quot;light&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; search_engine&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; audio_quality&quot;,&#10;            &quot;quality_low&quot; to &quot;low&quot;,&#10;            &quot;quality_med&quot; to &quot;med&quot;,&#10;            &quot;quality_high&quot; to &quot;high&quot;,&#10;            &quot;language&quot; to &quot;&gt; language&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;info_text&quot; to &quot;    ● don't pirate music!\n    ● Change engine with yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; sptfy_status&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connected&quot;,&#10;            &quot;disconnected&quot; to &quot;disconnected&quot;,&#10;            &quot;configured&quot; to &quot;configured&quot;,&#10;            &quot;not_configured&quot; to &quot;not_configured&quot;,&#10;            &quot;credentials_required&quot; to &quot;credentials required&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configure credentials first&quot;,&#10;            &quot;opening_browser&quot; to &quot;opening_browser...&quot;,&#10;            &quot;check_browser&quot; to &quot;check_browser&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_starting_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;enter your spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;enter your spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; how to get spotify api credentials:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. go to https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. log in with your spotify account&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. click 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. fill app name (e.g., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. set redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. select 'mobile' and 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. click 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copy client id and client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. paste them in the fields above&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      note: these credentials are stored locally&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;search&quot;,&#10;            &quot;home_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;home_queue&quot; to &quot;queue&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;settings&quot;,&#10;            &quot;exit_message&quot; to &quot;Press back again to exit&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_search&quot;,&#10;            &quot;search_placeholder&quot; to &quot;search music...&quot;,&#10;            &quot;search_loading&quot; to &quot;loading...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no results found&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify is not connected&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Spotify token not available&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Search engine not recognized&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error loading tracks&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;loading tracks...&quot;,&#10;            &quot;search_tracks&quot; to &quot;tracks&quot;,&#10;            &quot;search_albums&quot; to &quot;albums&quot;,&#10;            &quot;search_artists&quot; to &quot;artists&quot;,&#10;            &quot;search_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;youtube playlists&quot;,&#10;            &quot;search_start&quot; to &quot;start&quot;,&#10;            &quot;search_random&quot; to &quot;random&quot;,&#10;            &quot;search_save&quot; to &quot;save&quot;,&#10;            &quot;search_share&quot; to &quot;share&quot;,&#10;            &quot;search_saved&quot; to &quot;saved&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error saving&quot;,&#10;            &quot;search_followers&quot; to &quot;followers&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;monthly listeners&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Playlist cover&quot;,&#10;            &quot;artist_image&quot; to &quot;Artist image&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Query empty after prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Album cover&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Select playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancel&quot;,&#10;            &quot;search_removing&quot; to &quot;removing...&quot;,&#10;            &quot;search_removed&quot; to &quot;removed!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;saving...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no token&quot;,&#10;            &quot;search_unsave&quot; to &quot;unsave&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error getting track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error getting playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error getting album&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error getting artist&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processing QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;adding song to playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;next&quot;,&#10;            &quot;previous&quot; to &quot;previous&quot;,&#10;            &quot;repeat&quot; to &quot;repeat&quot;,&#10;            &quot;shuffle&quot; to &quot;shuffle&quot;,&#10;&#10;            // ADDITIONAL KEYS (ENGLISH)&#10;            &quot;connected_successfully&quot; to &quot;Connected successfully&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;Token exchange failed&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;Cancelled by user&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;Could not obtain audio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;&#10;&#10;        ),&#10;&#10;        // CATALÀ&#10;        &quot;català&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_configuració&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;fosc&quot;,&#10;            &quot;theme_light&quot; to &quot;clar&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_cerca&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; qualitat_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baixa&quot;,&#10;            &quot;quality_med&quot; to &quot;mitjana&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;español&quot;,&#10;            &quot;lang_english&quot; to &quot;english&quot;,&#10;            &quot;lang_catalan&quot; to &quot;català&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;info_text&quot; to &quot;    ● no piratejis música!\n    ● Canvia motor amb yt: / sp:&quot;,&#10;            &quot;sptfy_status&quot; to &quot;&gt; estat_sptfy&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connectat&quot;,&#10;            &quot;disconnected&quot; to &quot;desconnectat&quot;,&#10;            &quot;configured&quot; to &quot;configurat&quot;,&#10;            &quot;not_configured&quot; to &quot;no_configurat&quot;,&#10;            &quot;credentials_required&quot; to &quot;credencials requerides&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura les credencials primer&quot;,&#10;            &quot;opening_browser&quot; to &quot;obrint_navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;comprova_navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_iniciant_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introdueix el teu spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introdueix el teu spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; com obtenir credencials api spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ves a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sessió amb el teu compte spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. clica 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. omple el nom app (ex., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. estableix redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' i 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. clica 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia client id i client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. enganxa'ls als camps de dalt&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: aquestes credencials es guarden localment&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;cercar...&quot;,&#10;            &quot;no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;loading&quot; to &quot;carregant...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;cercar&quot;,&#10;            &quot;home_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;home_queue&quot; to &quot;cua&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustos&quot;,&#10;            &quot;exit_message&quot; to &quot;Prem de nou per sortir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_cercar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;cercar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;carregant...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no està connectat&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de cerca no reconegut&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error carregant cançons&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;carregant cançons...&quot;,&#10;            &quot;search_tracks&quot; to &quot;cançons&quot;,&#10;            &quot;search_albums&quot; to &quot;àlbums&quot;,&#10;            &quot;search_artists&quot; to &quot;artistes&quot;,&#10;            &quot;search_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;search_videos&quot; to &quot;vídeos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;llistes youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatori&quot;,&#10;            &quot;search_save&quot; to &quot;desar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;desat&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al desar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidors&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oients mensuals&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imatge de l'artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry buida després del prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminant...&quot;,&#10;            &quot;search_removed&quot; to &quot;eliminat!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;desant...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hi ha token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obtenint track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obtenint playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obtenint àlbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obtenint artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processant QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;afegint cançó a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;reproduint ara&quot;,&#10;            &quot;play&quot; to &quot;reproduir&quot;,&#10;            &quot;pause&quot; to &quot;pausa&quot;,&#10;            &quot;next&quot; to &quot;següent&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;aleatori&quot;,&#10;&#10;            // ADDITIONAL KEYS (CATALAN)&#10;            &quot;connected_successfully&quot; to &quot;connectat correctament&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;intercanvi de token fallit&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;cancel·lat per l'usuari&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;No s'ha pogut obtenir l'àudio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;&#10;&#10;        )&#10;    )&#10;&#10;    /**&#10;     * Obtiene una traducción para una clave específica según el idioma actual&#10;     * @param context Contexto de la aplicación&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(context: Context, key: String): String {&#10;        val language = Config.getLanguage(context)&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;&#10;    /**&#10;     * Obtiene una traducción para una clave específica según un idioma específico&#10;     * @param language Idioma deseado&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(language: String, key: String): String {&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;&#10;    /**&#10;     * Verifica si existe una traducción para una clave específica&#10;     * @param context Contexto de la aplicación&#10;     * @param key Clave de la traducción&#10;     * @return true si existe, false en caso contrario&#10;     */&#10;    fun exists(context: Context, key: String): Boolean {&#10;        val language = Config.getLanguage(context)&#10;        return translations[language]?.containsKey(key) ?: false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt" />
              <option name="originalContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import androidx.annotation.OptIn&#10;import androidx.media3.common.util.UnstableApi&#10;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;&#10;    // Queue management&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#10;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#10;&#10;    private var loadingJobsActive = false&#10;&#10;    fun initializePlayer() {&#10;        if (_exoPlayer == null) {&#10;            _exoPlayer = buildPlayer()&#10;        }&#10;    }&#10;&#10;    @OptIn(UnstableApi::class)&#10;    private fun buildPlayer(): ExoPlayer =&#10;        ExoPlayer.Builder(getApplication())&#10;            .setSeekBackIncrementMs(10_000)&#10;            .setSeekForwardIncrementMs(10_000)&#10;            .setHandleAudioBecomingNoisy(true)&#10;            .setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true&#10;            )&#10;            .build().apply {&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#10;                }&#10;&#10;                addListener(object : Player.Listener {&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#10;                    }&#10;&#10;                    override fun onPlayerError(error: PlaybackException) {&#10;                        _isLoading.postValue(false)&#10;                        _error.postValue(&quot;Error: ${error.message}&quot;)&#10;                    }&#10;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#10;                        updateCurrentTrackFromPlayer()&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#10;                    }&#10;                })&#10;            }&#10;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; LOAD AUDIO FROM TRACK&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track name: ${track.name}&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track audioUrl: ${track.audioUrl}&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track youtubeVideoId: ${track.youtubeVideoId}&quot;)&#10;&#10;            _isLoading.postValue(true)&#10;            _error.postValue(null)&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#10;                // Verificar si audioUrl es una ruta de archivo local&#10;                if (track.audioUrl != null &amp;&amp; (track.audioUrl.startsWith(&quot;/&quot;) || track.audioUrl.startsWith(&quot;file://&quot;))) {&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Detectado archivo local&quot;)&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Ruta: ${track.audioUrl}&quot;)&#10;&#10;                    val localFile = java.io.File(track.audioUrl.removePrefix(&quot;file://&quot;))&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Archivo: ${localFile.absolutePath}&quot;)&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Existe: ${localFile.exists()}&quot;)&#10;&#10;                    if (localFile.exists()) {&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Tamaño: ${localFile.length()} bytes&quot;)&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Legible: ${localFile.canRead()}&quot;)&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Archivo local válido - usando para reproducción&quot;)&#10;                        return@withContext track.audioUrl&#10;                    } else {&#10;                        android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Archivo local NO existe: ${localFile.absolutePath}&quot;)&#10;                    }&#10;                }&#10;&#10;                // Si no es archivo local, obtener de YouTube&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Obteniendo audio de YouTube...&quot;)&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                videoId?.let {&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   YouTube ID: $it&quot;)&#10;                    YouTubeManager.getAudioUrl(it)&#10;                }&#10;            }&#10;&#10;            if (audioUrl == null) {&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ No se pudo obtener audioUrl&quot;)&#10;                _isLoading.postValue(false)&#10;                _error.postValue(&quot;No se pudo obtener audio&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ AudioUrl obtenida: $audioUrl&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Inicializando reproductor...&quot;)&#10;&#10;            initializePlayer()&#10;            _exoPlayer?.let { player -&gt;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#10;                player.prepare()&#10;                player.play()&#10;                _isLoading.postValue(false)&#10;                onMediaSessionUpdate?.invoke(player)&#10;&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Reproducción iniciada&quot;)&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;&#10;                // Iniciar carga concurrente de las siguientes canciones&#10;                startLoadingRemainingTracks()&#10;                true&#10;            } ?: false&#10;        } catch (e: Exception) {&#10;            _isLoading.postValue(false)&#10;            _error.postValue(&quot;Error: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Error reproduciendo track&quot;, e)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#10;        MediaItem.Builder()&#10;            .setUri(audioUrl)&#10;            .setMediaId(track.id)&#10;            .setMediaMetadata(&#10;                androidx.media3.common.MediaMetadata.Builder()&#10;                    .setTitle(track.name)&#10;                    .setArtist(track.artists)&#10;                    .build()&#10;            )&#10;            .build()&#10;&#10;    private fun startLoadingRemainingTracks() {&#10;        if (loadingJobsActive) return&#10;        loadingJobsActive = true&#10;&#10;        val playlist = _currentPlaylist.value ?: return&#10;        val currentIndex = _currentTrackIndex.value ?: return&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            for (i in currentIndex + 1 until playlist.size) {&#10;                val track = playlist[i]&#10;                try {&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                } catch (_: Exception) {&#10;                    // Continuar con la siguiente canción si hay error&#10;                }&#10;            }&#10;            loadingJobsActive = false&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentTrackFromPlayer() {&#10;        val player = _exoPlayer ?: return&#10;        val playlist = _currentPlaylist.value ?: return&#10;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#10;&#10;        if (newIndex &gt;= 0) {&#10;            _currentTrackIndex.postValue(newIndex)&#10;            _currentTrack.postValue(playlist[newIndex])&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#10;        }&#10;    }&#10;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#10;&#10;    fun playPlayer() = _exoPlayer?.play()&#10;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        _currentPlaylist.postValue(playlist)&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#10;        _currentTrackIndex.postValue(validIndex)&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[validIndex])&#10;        }&#10;    }&#10;&#10;    fun navigateToNext() {&#10;        _exoPlayer?.seekToNextMediaItem()&#10;    }&#10;&#10;    fun navigateToPrevious() {&#10;        _exoPlayer?.seekToPreviousMediaItem()&#10;    }&#10;&#10;    fun updateRepeatMode() {&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;            else -&gt; Player.REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // Queue functionality&#10;    fun addToQueue(track: TrackEntity) {&#10;        // Añadir a la lista interna de queue&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#10;        updatedQueue.add(track)&#10;        _queueTracks.postValue(updatedQueue)&#10;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#10;        currentPlaylist.add(track)&#10;        _currentPlaylist.postValue(currentPlaylist)&#10;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;&#10;                if (audioUrl != null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;Error loading track to queue: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.viewmodel&#13;&#10;&#13;&#10;import android.app.Application&#13;&#10;import androidx.lifecycle.AndroidViewModel&#13;&#10;import androidx.lifecycle.LiveData&#13;&#10;import androidx.lifecycle.MutableLiveData&#13;&#10;import androidx.lifecycle.viewModelScope&#13;&#10;import androidx.media3.common.MediaItem&#13;&#10;import androidx.media3.common.Player&#13;&#10;import androidx.media3.common.PlaybackException&#13;&#10;import androidx.media3.common.AudioAttributes&#13;&#10;import androidx.media3.common.C&#13;&#10;import androidx.media3.exoplayer.ExoPlayer&#13;&#10;import com.plyr.network.YouTubeManager&#13;&#10;import com.plyr.utils.Config&#13;&#10;import com.plyr.database.TrackEntity&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import androidx.annotation.OptIn&#13;&#10;import androidx.media3.common.util.UnstableApi&#13;&#10;&#13;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#13;&#10;    private var _exoPlayer: ExoPlayer? = null&#13;&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#13;&#10;&#13;&#10;    private val _isLoading = MutableLiveData(false)&#13;&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#13;&#10;&#13;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#13;&#10;    val error: LiveData&lt;String?&gt; = _error&#13;&#10;&#13;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#13;&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#13;&#10;&#13;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#13;&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#13;&#10;&#13;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#13;&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#13;&#10;&#13;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#13;&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#13;&#10;&#13;&#10;    // Queue management&#13;&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#13;&#10;&#13;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#13;&#10;&#13;&#10;    private var loadingJobsActive = false&#13;&#10;&#13;&#10;    fun initializePlayer() {&#13;&#10;        if (_exoPlayer == null) {&#13;&#10;            _exoPlayer = buildPlayer()&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    @OptIn(UnstableApi::class)&#13;&#10;    private fun buildPlayer(): ExoPlayer =&#13;&#10;        ExoPlayer.Builder(getApplication())&#13;&#10;            .setSeekBackIncrementMs(10_000)&#13;&#10;            .setSeekForwardIncrementMs(10_000)&#13;&#10;            .setHandleAudioBecomingNoisy(true)&#13;&#10;            .setAudioAttributes(&#13;&#10;                AudioAttributes.Builder()&#13;&#10;                    .setUsage(C.USAGE_MEDIA)&#13;&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#13;&#10;                    .build(),&#13;&#10;                true&#13;&#10;            )&#13;&#10;            .build().apply {&#13;&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#13;&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#13;&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#13;&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#13;&#10;                }&#13;&#10;&#13;&#10;                addListener(object : Player.Listener {&#13;&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#13;&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    override fun onPlayerError(error: PlaybackException) {&#13;&#10;                        _isLoading.postValue(false)&#13;&#10;                        val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#13;&#10;                        val msg = error.message ?: &quot;&quot;&#13;&#10;                        _error.postValue(prefix + msg)&#13;&#10;                    }&#13;&#10;&#13;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#13;&#10;                        updateCurrentTrackFromPlayer()&#13;&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#13;&#10;                    }&#13;&#10;                })&#13;&#10;            }&#13;&#10;&#13;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#13;&#10;        try {&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; LOAD AUDIO FROM TRACK&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track name: ${track.name}&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track audioUrl: ${track.audioUrl}&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track youtubeVideoId: ${track.youtubeVideoId}&quot;)&#13;&#10;&#13;&#10;            _isLoading.postValue(true)&#13;&#10;            _error.postValue(null)&#13;&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#13;&#10;&#13;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#13;&#10;                // Verificar si audioUrl es una ruta de archivo local&#13;&#10;                if (track.audioUrl != null &amp;&amp; (track.audioUrl.startsWith(&quot;/&quot;) || track.audioUrl.startsWith(&quot;file://&quot;))) {&#13;&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Detectado archivo local&quot;)&#13;&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Ruta: ${track.audioUrl}&quot;)&#13;&#10;&#13;&#10;                    val localFile = java.io.File(track.audioUrl.removePrefix(&quot;file://&quot;))&#13;&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Archivo: ${localFile.absolutePath}&quot;)&#13;&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Existe: ${localFile.exists()}&quot;)&#13;&#10;&#13;&#10;                    if (localFile.exists()) {&#13;&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Tamaño: ${localFile.length()} bytes&quot;)&#13;&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Legible: ${localFile.canRead()}&quot;)&#13;&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Archivo local válido - usando para reproducción&quot;)&#13;&#10;                        return@withContext track.audioUrl&#13;&#10;                    } else {&#13;&#10;                        android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Archivo local NO existe: ${localFile.absolutePath}&quot;)&#13;&#10;                    }&#13;&#10;                }&#13;&#10;&#13;&#10;                // Si no es archivo local, obtener de YouTube&#13;&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Obteniendo audio de YouTube...&quot;)&#13;&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#13;&#10;                videoId?.let {&#13;&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   YouTube ID: $it&quot;)&#13;&#10;                    YouTubeManager.getAudioUrl(it)&#13;&#10;                }&#13;&#10;            }&#13;&#10;&#13;&#10;            if (audioUrl == null) {&#13;&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ No se pudo obtener audioUrl&quot;)&#13;&#10;                _isLoading.postValue(false)&#13;&#10;                _error.postValue(com.plyr.utils.Translations.get(getApplication(), &quot;error_obtaining_audio&quot;))&#13;&#10;                return@withContext false&#13;&#10;            }&#13;&#10;&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ AudioUrl obtenida: $audioUrl&quot;)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Inicializando reproductor...&quot;)&#13;&#10;&#13;&#10;            initializePlayer()&#13;&#10;            _exoPlayer?.let { player -&gt;&#13;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#13;&#10;                player.prepare()&#13;&#10;                player.play()&#13;&#10;                _isLoading.postValue(false)&#13;&#10;                onMediaSessionUpdate?.invoke(player)&#13;&#10;&#13;&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Reproducción iniciada&quot;)&#13;&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;&#13;&#10;                // Iniciar carga concurrente de las siguientes canciones&#13;&#10;                startLoadingRemainingTracks()&#13;&#10;                true&#13;&#10;            } ?: false&#13;&#10;        } catch (e: Exception) {&#13;&#10;            _isLoading.postValue(false)&#13;&#10;            val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#13;&#10;            _error.postValue(prefix + (e.message ?: &quot;&quot;))&#13;&#10;            android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Error reproduciendo track&quot;, e)&#13;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;            false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#13;&#10;        MediaItem.Builder()&#13;&#10;            .setUri(audioUrl)&#13;&#10;            .setMediaId(track.id)&#13;&#10;            .setMediaMetadata(&#13;&#10;                androidx.media3.common.MediaMetadata.Builder()&#13;&#10;                    .setTitle(track.name)&#13;&#10;                    .setArtist(track.artists)&#13;&#10;                    .build()&#13;&#10;            )&#13;&#10;            .build()&#13;&#10;&#13;&#10;    private fun startLoadingRemainingTracks() {&#13;&#10;        if (loadingJobsActive) return&#13;&#10;        loadingJobsActive = true&#13;&#10;&#13;&#10;        val playlist = _currentPlaylist.value ?: return&#13;&#10;        val currentIndex = _currentTrackIndex.value ?: return&#13;&#10;&#13;&#10;        viewModelScope.launch(Dispatchers.IO) {&#13;&#10;            for (i in currentIndex + 1 until playlist.size) {&#13;&#10;                val track = playlist[i]&#13;&#10;                try {&#13;&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#13;&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#13;&#10;&#13;&#10;                    withContext(Dispatchers.Main) {&#13;&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#13;&#10;                    }&#13;&#10;                } catch (_: Exception) {&#13;&#10;                    // Continuar con la siguiente canción si hay error&#13;&#10;                }&#13;&#10;            }&#13;&#10;            loadingJobsActive = false&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    private fun updateCurrentTrackFromPlayer() {&#13;&#10;        val player = _exoPlayer ?: return&#13;&#10;        val playlist = _currentPlaylist.value ?: return&#13;&#10;&#13;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#13;&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#13;&#10;&#13;&#10;        if (newIndex &gt;= 0) {&#13;&#10;            _currentTrackIndex.postValue(newIndex)&#13;&#10;            _currentTrack.postValue(playlist[newIndex])&#13;&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#13;&#10;&#13;&#10;    fun playPlayer() = _exoPlayer?.play()&#13;&#10;&#13;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#13;&#10;        _currentPlaylist.postValue(playlist)&#13;&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#13;&#10;        _currentTrackIndex.postValue(validIndex)&#13;&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#13;&#10;            _currentTrack.postValue(playlist[validIndex])&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    fun navigateToNext() {&#13;&#10;        _exoPlayer?.seekToNextMediaItem()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun navigateToPrevious() {&#13;&#10;        _exoPlayer?.seekToPreviousMediaItem()&#13;&#10;    }&#13;&#10;&#13;&#10;    fun updateRepeatMode() {&#13;&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#13;&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#13;&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#13;&#10;            else -&gt; Player.REPEAT_MODE_OFF&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Queue functionality&#13;&#10;    fun addToQueue(track: TrackEntity) {&#13;&#10;        // Añadir a la lista interna de queue&#13;&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#13;&#10;        updatedQueue.add(track)&#13;&#10;        _queueTracks.postValue(updatedQueue)&#13;&#10;&#13;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#13;&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#13;&#10;        currentPlaylist.add(track)&#13;&#10;        _currentPlaylist.postValue(currentPlaylist)&#13;&#10;&#13;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#13;&#10;        viewModelScope.launch(Dispatchers.IO) {&#13;&#10;            try {&#13;&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#13;&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#13;&#10;&#13;&#10;                if (audioUrl != null) {&#13;&#10;                    withContext(Dispatchers.Main) {&#13;&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } catch (e: Exception) {&#13;&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;Error loading track to queue: ${e.message}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    override fun onCleared() {&#13;&#10;        super.onCleared()&#13;&#10;        _exoPlayer?.release()&#13;&#10;        _exoPlayer = null&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>