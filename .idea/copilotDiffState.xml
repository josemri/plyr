<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/AudioListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/AudioListScreen.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.runtime.*&#10;import com.plyr.model.AudioItem&#10;import com.plyr.ui.navigation.Screen&#10;import com.plyr.ui.screens.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;@Composable&#10;fun AudioListScreen(&#10;    context: Context,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onThemeChanged: (String) -&gt; Unit = {},&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var currentScreen by remember { mutableStateOf(Screen.HOME) }&#10;&#10;    // Handle back button - always go to HOME, never exit app&#10;    BackHandler(enabled = currentScreen != Screen.HOME) {&#10;        currentScreen = Screen.HOME&#10;    }&#10;&#10;    when (currentScreen) {&#10;        Screen.HOME -&gt; HomeScreen(&#10;            context = context,&#10;            onNavigateToScreen = { screen -&gt; currentScreen = screen }&#10;        )&#10;        Screen.SEARCH -&gt; SearchScreen(&#10;            context = context,&#10;            onVideoSelected = onVideoSelected,&#10;            onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.QUEUE -&gt; QueueScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.CONFIG -&gt; ConfigScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            onThemeChanged = onThemeChanged&#10;        )&#10;        Screen.PLAYLISTS -&gt; PlaylistsScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/MarqueeText.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/MarqueeText.kt" />
              <option name="originalContent" value="&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components&#10;&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.BasicText&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clipToBounds&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntOffset&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun MarqueeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: TextStyle = TextStyle(),&#10;    delayMillis: Int = 1000,&#10;    velocity: Float = 30f&#10;) {&#10;    val density = LocalDensity.current&#10;    var textWidth by remember { mutableStateOf(0) }&#10;    var containerWidth by remember { mutableStateOf(0) }&#10;    &#10;    val shouldMarquee = textWidth &gt; containerWidth &amp;&amp; containerWidth &gt; 0&#10;    &#10;    val animationSpec = infiniteRepeatable&lt;Float&gt;(&#10;        animation = tween(&#10;            durationMillis = if (shouldMarquee) ((textWidth - containerWidth) / velocity * 1000).toInt() else 0,&#10;            easing = LinearEasing&#10;        ),&#10;        repeatMode = RepeatMode.Restart&#10;    )&#10;    &#10;    val animatedOffset by animateFloatAsState(&#10;        targetValue = if (shouldMarquee) -(textWidth - containerWidth).toFloat() else 0f,&#10;        animationSpec = animationSpec,&#10;        label = &quot;marquee&quot;&#10;    )&#10;    &#10;    var startAnimation by remember { mutableStateOf(false) }&#10;    &#10;    LaunchedEffect(shouldMarquee) {&#10;        if (shouldMarquee) {&#10;            delay(delayMillis.toLong())&#10;            startAnimation = true&#10;        } else {&#10;            startAnimation = false&#10;        }&#10;    }&#10;    &#10;    Box(&#10;        modifier = modifier&#10;            .clipToBounds()&#10;            .onSizeChanged { size -&gt;&#10;                containerWidth = size.width&#10;            }&#10;    ) {&#10;        BasicText(&#10;            text = text,&#10;            style = style,&#10;            maxLines = 1,&#10;            overflow = TextOverflow.Visible,&#10;            modifier = Modifier&#10;                .onSizeChanged { size -&gt;&#10;                    textWidth = size.width&#10;                }&#10;                .offset {&#10;                    IntOffset(&#10;                        x = if (startAnimation) animatedOffset.toInt() else 0,&#10;                        y = 0&#10;                    )&#10;                }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SearchMainView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SearchMainView.kt" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifySearchAllResponse&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;&#10;@Composable&#10;fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        // Search header&#10;        Text(&#10;            text = &quot;$ search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Search input&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = { &#10;                Text(&#10;                    &quot;Search (prefix: yt: youtube, sp: spotify)&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace&#10;                    )&#10;                ) &#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = { &#10;                    onSearchTriggered(searchQuery, false)&#10;                }&#10;            ),&#10;            singleLine = true,&#10;            textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;        &#10;        Spacer(modifier = Modifier.height(16.dp))&#10;        &#10;        // Loading indicator&#10;        if (isLoading) {&#10;            Text(&#10;                text = &quot;&gt; searching...&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFFFD93D)&#10;                )&#10;            )&#10;        }&#10;        &#10;        // Error message&#10;        error?.let { errorMessage -&gt;&#10;            Text(&#10;                text = &quot;&gt; error: $errorMessage&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(vertical = 8.dp)&#10;            )&#10;        }&#10;        &#10;        // Search results&#10;        when {&#10;            showSpotifyResults &amp;&amp; spotifyResults != null -&gt; {&#10;                SpotifySearchResults(&#10;                    searchResults = spotifyResults,&#10;                    onAlbumSelected = onAlbumSelected,&#10;                    onPlaylistSelected = onPlaylistSelected,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            results.isNotEmpty() -&gt; {&#10;                YouTubeSearchResults(&#10;                    results = results,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch&#10;                )&#10;            }&#10;            !isLoading &amp;&amp; searchQuery.isNotBlank() -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no results found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyAlbumDetailView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyAlbumDetailView.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyAlbumDetailView(&#10;    album: SpotifyAlbum,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with album info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Album image&#10;            album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ album_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = album.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = album.getArtistNames(),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${album.total_tracks} tracks • ${album.release_date}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from album&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = album.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = &quot;${track.duration_ms / 1000 / 60}:${String.format(&quot;%02d&quot;, (track.duration_ms / 1000) % 60)}&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyAlbumDetailView(&#10;    album: SpotifyAlbum,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with album info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Album image&#10;            album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ album_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = album.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = album.getArtistNames(),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${album.total_tracks} tracks • ${album.release_date}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from album&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = album.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = track.getDurationText(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyPlaylistDetailView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyPlaylistDetailView.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with playlist info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Playlist image&#10;            playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ playlist_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = playlist.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from playlist&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${playlist.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = playlist.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = track.getDurationText(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with playlist info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Playlist image&#10;            playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ playlist_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = playlist.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from playlist&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${playlist.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = playlist.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = track.getDurationText(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifySearchResults(&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyTracksSection(&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 2.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .size(48.dp)&#10;                                .clip(RoundedCornerShape(4.dp))&#10;                        )&#10;                        Spacer(modifier = Modifier.width(12.dp))&#10;                    }&#10;&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = track.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = track.getArtistNames(),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = track.getFormattedDuration(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Card(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(modifier = Modifier.padding(8.dp)) {&#10;                        album.images.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                            AsyncImage(&#10;                                model = imageUrl,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .aspectRatio(1f)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = album.getArtistNames(),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Card(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(modifier = Modifier.padding(8.dp)) {&#10;                        playlist.images.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                            AsyncImage(&#10;                                model = imageUrl,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .aspectRatio(1f)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = playlist.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = &quot;${playlist.tracks.total} tracks&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtist&gt;&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Card(&#10;                    modifier = Modifier.width(120.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(8.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        artist.images.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                            AsyncImage(&#10;                                model = imageUrl,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .size(80.dp)&#10;                                    .clip(RoundedCornerShape(40.dp))&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = artist.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifySearchResults(&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items.map { artistFull -&gt;&#10;                        SpotifyArtist(name = artistFull.name)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyTracksSection(&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Card(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 2.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                colors = CardDefaults.cardColors(&#10;                    containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                )&#10;            ) {&#10;                Row(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(12.dp),&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Column(modifier = Modifier.weight(1f)) {&#10;                        Text(&#10;                            text = track.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = track.getArtistNames(),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;&#10;                    Text(&#10;                        text = track.getDurationText(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Card(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(modifier = Modifier.padding(8.dp)) {&#10;                        album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                            AsyncImage(&#10;                                model = imageUrl,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .aspectRatio(1f)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = album.getArtistNames(),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Card(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(modifier = Modifier.padding(8.dp)) {&#10;                        playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                            AsyncImage(&#10;                                model = imageUrl,&#10;                                contentDescription = null,&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .aspectRatio(1f)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = playlist.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;&#10;                        Text(&#10;                            text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtist&gt;&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Card(&#10;                    modifier = Modifier.width(120.dp),&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(8.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        // SpotifyArtist doesn't have images, so we'll show a placeholder&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(80.dp)&#10;                                .clip(RoundedCornerShape(40.dp)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;♫&quot;,&#10;                                style = MaterialTheme.typography.headlineMedium.copy(&#10;                                    color = Color(0xFF1DB954)&#10;                                )&#10;                            )&#10;                        }&#10;&#10;                        Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                        Text(&#10;                            text = artist.name,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 12.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/YouTubeSearchResults.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/YouTubeSearchResults.kt" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.model.AudioItem&#10;&#10;@Composable&#10;fun YouTubeSearchResults(&#10;    results: List&lt;AudioItem&gt;,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; youtube results [${results.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;        &#10;        LazyColumn(&#10;            modifier = Modifier.fillMaxWidth(),&#10;            contentPadding = PaddingValues(bottom = 16.dp)&#10;        ) {&#10;            items(&#10;                count = results.size,&#10;                key = { index -&gt; results[index].videoId }&#10;            ) { index -&gt;&#10;                val item = results[index]&#10;                &#10;                Card(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(vertical = 2.dp)&#10;                        .clickable {&#10;                            onVideoSelectedFromSearch(&#10;                                item.videoId,&#10;                                item.title,&#10;                                results,&#10;                                index&#10;                            )&#10;                        },&#10;                    colors = CardDefaults.cardColors(&#10;                        containerColor = Color(0xFF2C3E50).copy(alpha = 0.3f)&#10;                    )&#10;                ) {&#10;                    Column(&#10;                        modifier = Modifier.padding(12.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = item.title,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 14.sp,&#10;                                color = Color.White&#10;                            ),&#10;                            maxLines = 2,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(top = 4.dp),&#10;                            horizontalArrangement = Arrangement.SpaceBetween&#10;                        ) {&#10;                            Text(&#10;                                text = item.channel,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 12.sp,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            item.duration?.let { duration -&gt;&#10;                                Text(&#10;                                    text = duration,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.padding(start = 8.dp)&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/ConfigScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/ConfigScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var showSpotifyConfig by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_config&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 24.dp)&#10;        )&#10;&#10;        // Search Engine&#10;        val currentEngine = Config.getSearchEngine(context)&#10;        val engines = listOf(&quot;spotify&quot;, &quot;youtube&quot;)&#10;&#10;        Text(&#10;            text = &quot;search_engine:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 24.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            engines.forEachIndexed { index, engine -&gt;&#10;                Text(&#10;                    text = engine,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentEngine == engine) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setSearchEngine(context, engine)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;&#10;                if (index &lt; engines.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme&#10;        val currentTheme = Config.getTheme(context)&#10;        val themes = listOf(&quot;dark&quot;, &quot;light&quot;, &quot;default&quot;)&#10;&#10;        Text(&#10;            text = &quot;theme:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 24.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            themes.forEachIndexed { index, theme -&gt;&#10;                Text(&#10;                    text = theme,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentTheme == theme) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setTheme(context, theme)&#10;                            onThemeChanged(theme)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;&#10;                if (index &lt; themes.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Audio Quality&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        val qualities = listOf(&quot;best&quot;, &quot;medium&quot;, &quot;worst&quot;)&#10;&#10;        Text(&#10;            text = &quot;audio_quality:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 24.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            qualities.forEachIndexed { index, quality -&gt;&#10;                Text(&#10;                    text = quality,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentQuality == quality) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setAudioQuality(context, quality)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;&#10;                if (index &lt; qualities.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spotify Configuration&#10;        val isSpotifyConnected = Config.isSpotifyConnected(context)&#10;        val hasCredentials = Config.hasSpotifyCredentials(context)&#10;&#10;        Text(&#10;            text = &quot;spotify_config:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        // Status - clickeable para login&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;status: &quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;            Text(&#10;                text = if (isSpotifyConnected) &quot;connected&quot; else &quot;disconnected&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = if (isSpotifyConnected) Color(0xFF1DB954) else Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.clickable {&#10;                    // TODO: Implementar redirección a login de Spotify&#10;                    // Por ahora solo limpia tokens para forzar re-login&#10;                    if (hasCredentials) {&#10;                        Config.clearSpotifyTokens(context)&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        // API - desplegable&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;api: &quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;            Text(&#10;                text = &quot;${if (showSpotifyConfig) &quot;▼&quot; else &quot;▶&quot;} ${if (hasCredentials) &quot;configured&quot; else &quot;setup&quot;}&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { showSpotifyConfig = !showSpotifyConfig }&#10;                    .padding(4.dp)&#10;            )&#10;        }&#10;&#10;        if (showSpotifyConfig) {&#10;            Column(&#10;                modifier = Modifier.padding(start = 32.dp, bottom = 16.dp)&#10;            ) {&#10;                // Client ID&#10;                Text(&#10;                    text = &quot;client_id:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = { clientId = it },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    textStyle = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF4ECDC4),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6)&#10;                    ),&#10;                    singleLine = true&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Client Secret&#10;                Text(&#10;                    text = &quot;client_secret:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = { clientSecret = it },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    textStyle = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF4ECDC4),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    singleLine = true&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Save/Clear buttons&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;[save]&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF1DB954)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable {&#10;                                if (clientId.isNotBlank() &amp;&amp; clientSecret.isNotBlank()) {&#10;                                    Config.setSpotifyCredentials(context, clientId, clientSecret)&#10;                                }&#10;                            }&#10;                            .padding(4.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;[clear]&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFFE74C3C)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable {&#10;                                Config.clearSpotifyCredentials(context)&#10;                                Config.clearSpotifyTokens(context)&#10;                                clientId = &quot;&quot;&#10;                                clientSecret = &quot;&quot;&#10;                            }&#10;                            .padding(4.dp)&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Explicación en inglés&#10;                Text(&#10;                    text = &quot;How to get your Spotify API credentials:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF7F8C8D)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                val instructions = listOf(&#10;                    &quot;1. Go to developer.spotify.com/dashboard&quot;,&#10;                    &quot;2. Log in with your Spotify account&quot;,&#10;                    &quot;3. Click 'Create an App'&quot;,&#10;                    &quot;4. Fill in app name and description&quot;,&#10;                    &quot;5. Copy the Client ID and Client Secret&quot;,&#10;                    &quot;6. In app settings, add redirect URI:&quot;,&#10;                    &quot;   plyr://spotify/callback&quot;&#10;                )&#10;&#10;                instructions.forEach { instruction -&gt;&#10;                    Text(&#10;                        text = instruction,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (isSpotifyConnected) {&#10;            Text(&#10;                text = &quot;    [disconnect]&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable {&#10;                        Config.clearSpotifyTokens(context)&#10;                    }&#10;                    .padding(4.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var showSpotifyConfig by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    &#10;    // Estados reactivos para actualización inmediata&#10;    var currentEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var currentTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var currentQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var hasCredentials by remember { mutableStateOf(Config.hasSpotifyCredentials(context)) }&#10;&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_config&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 24.dp)&#10;        )&#10;&#10;        // Search Engine - CENTRADO&#10;        val engines = listOf(&quot;spotify&quot;, &quot;youtube&quot;)&#10;&#10;        Text(&#10;            text = &quot;search_engine:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;        &#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 24.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            engines.forEachIndexed { index, engine -&gt;&#10;                Text(&#10;                    text = engine,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentEngine == engine) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setSearchEngine(context, engine)&#10;                            currentEngine = engine // Actualización inmediata&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;                &#10;                if (index &lt; engines.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Theme - CENTRADO&#10;        val themes = listOf(&quot;dark&quot;, &quot;light&quot;, &quot;default&quot;)&#10;&#10;        Text(&#10;            text = &quot;theme:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 24.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            themes.forEachIndexed { index, theme -&gt;&#10;                Text(&#10;                    text = theme,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentTheme == theme) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setTheme(context, theme)&#10;                            currentTheme = theme // Actualización inmediata&#10;                            onThemeChanged(theme)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;                &#10;                if (index &lt; themes.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Audio Quality - CENTRADO&#10;        val qualities = listOf(&quot;best&quot;, &quot;medium&quot;, &quot;worst&quot;)&#10;&#10;        Text(&#10;            text = &quot;audio_quality:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 24.dp),&#10;            horizontalArrangement = Arrangement.Center,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            qualities.forEachIndexed { index, quality -&gt;&#10;                Text(&#10;                    text = quality,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = if (currentQuality == quality) Color.White else Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            Config.setAudioQuality(context, quality)&#10;                            currentQuality = quality // Actualización inmediata&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;                &#10;                if (index &lt; qualities.size - 1) {&#10;                    Text(&#10;                        text = &quot; / &quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 16.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Spotify Configuration&#10;        Text(&#10;            text = &quot;spotify_config:&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 18.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        // Status - clickeable para abrir Spotify OAuth&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;status: &quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;            Text(&#10;                text = if (isSpotifyConnected) &quot;connected&quot; else &quot;click_to_login&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = if (isSpotifyConnected) Color(0xFF1DB954) else Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier.clickable {&#10;                    if (hasCredentials) {&#10;                        // Construir URL de autorización de Spotify&#10;                        val clientId = Config.getSpotifyClientId(context)&#10;                        val redirectUri = Config.SPOTIFY_REDIRECT_URI&#10;                        val scopes = Config.SPOTIFY_SCOPES&#10;                        &#10;                        val authUrl = &quot;https://accounts.spotify.com/authorize?&quot; +&#10;                                &quot;client_id=$clientId&quot; +&#10;                                &quot;&amp;response_type=code&quot; +&#10;                                &quot;&amp;redirect_uri=${java.net.URLEncoder.encode(redirectUri, &quot;UTF-8&quot;)}&quot; +&#10;                                &quot;&amp;scope=${java.net.URLEncoder.encode(scopes, &quot;UTF-8&quot;)}&quot;&#10;                        &#10;                        // Abrir navegador con la URL de autorización&#10;                        try {&#10;                            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(authUrl))&#10;                            context.startActivity(intent)&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;ConfigScreen&quot;, &quot;Error opening Spotify OAuth URL&quot;, e)&#10;                        }&#10;                    } else {&#10;                        // Si no hay credenciales, mostrar el desplegable&#10;                        showSpotifyConfig = true&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        // API - desplegable&#10;        Row(&#10;            modifier = Modifier.padding(start = 16.dp, bottom = 8.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            Text(&#10;                text = &quot;api: &quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                )&#10;            )&#10;            Text(&#10;                text = &quot;${if (showSpotifyConfig) &quot;▼&quot; else &quot;▶&quot;} ${if (hasCredentials) &quot;configured&quot; else &quot;setup&quot;}&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { showSpotifyConfig = !showSpotifyConfig }&#10;                    .padding(4.dp)&#10;            )&#10;        }&#10;&#10;        if (showSpotifyConfig) {&#10;            Column(&#10;                modifier = Modifier.padding(start = 32.dp, bottom = 16.dp)&#10;            ) {&#10;                // Client ID&#10;                Text(&#10;                    text = &quot;client_id:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = { clientId = it },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    textStyle = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF4ECDC4),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6)&#10;                    ),&#10;                    singleLine = true&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                // Client Secret&#10;                Text(&#10;                    text = &quot;client_secret:&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = { clientSecret = it },&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    textStyle = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = Color(0xFF4ECDC4),&#10;                        unfocusedBorderColor = Color(0xFF95A5A6)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    singleLine = true&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Save/Clear buttons&#10;                Row(&#10;                    horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = &quot;[save]&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF1DB954)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable {&#10;                                if (clientId.isNotBlank() &amp;&amp; clientSecret.isNotBlank()) {&#10;                                    Config.setSpotifyCredentials(context, clientId, clientSecret)&#10;                                    hasCredentials = true // Actualización inmediata&#10;                                }&#10;                            }&#10;                            .padding(4.dp)&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;[clear]&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFFE74C3C)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable {&#10;                                Config.clearSpotifyCredentials(context)&#10;                                Config.clearSpotifyTokens(context)&#10;                                clientId = &quot;&quot;&#10;                                clientSecret = &quot;&quot;&#10;                                hasCredentials = false // Actualización inmediata&#10;                                isSpotifyConnected = false // Actualización inmediata&#10;                            }&#10;                            .padding(4.dp)&#10;                    )&#10;                }&#10;&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;&#10;                // Explicación en inglés&#10;                Text(&#10;                    text = &quot;How to get your Spotify API credentials:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = Color(0xFF7F8C8D)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                val instructions = listOf(&#10;                    &quot;1. Go to developer.spotify.com/dashboard&quot;,&#10;                    &quot;2. Log in with your Spotify account&quot;,&#10;                    &quot;3. Click 'Create an App'&quot;,&#10;                    &quot;4. Fill in app name and description&quot;,&#10;                    &quot;5. Copy the Client ID and Client Secret&quot;,&#10;                    &quot;6. In app settings, add redirect URI:&quot;,&#10;                    &quot;   plyr://spotify/callback&quot;&#10;                )&#10;&#10;                instructions.forEach { instruction -&gt;&#10;                    Text(&#10;                        text = instruction,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 2.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (isSpotifyConnected) {&#10;            Text(&#10;                text = &quot;    [disconnect]&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable {&#10;                        Config.clearSpotifyTokens(context)&#10;                        isSpotifyConnected = false // Actualización inmediata&#10;                    }&#10;                    .padding(4.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/CreateSpotifyPlaylistScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/CreateSpotifyPlaylistScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;&#10;@Composable&#10;fun CreateSpotifyPlaylistScreen(&#10;    onBack: () -&gt; Unit,&#10;    onPlaylistCreated: () -&gt; Unit&#10;) {&#10;    var playlistName by remember { mutableStateOf(&quot;&quot;) }&#10;    var playlistDesc by remember { mutableStateOf(&quot;&quot;) }&#10;    var isPublic by remember { mutableStateOf(true) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    val context = LocalContext.current&#10;    &#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        Text(&#10;            text = &quot;$ create_playlist&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 20.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        Spacer(Modifier.height(16.dp))&#10;        &#10;        OutlinedTextField(&#10;            value = playlistName,&#10;            onValueChange = { playlistName = it },&#10;            label = { Text(&quot;Playlist name&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;        &#10;        Spacer(Modifier.height(8.dp))&#10;        &#10;        OutlinedTextField(&#10;            value = playlistDesc,&#10;            onValueChange = { playlistDesc = it },&#10;            label = { Text(&quot;Description (optional)&quot;) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;        &#10;        Spacer(Modifier.height(8.dp))&#10;        &#10;        // Privacy selector&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(vertical = 8.dp),&#10;            horizontalArrangement = Arrangement.Center&#10;        ) {&#10;            // Public option&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                modifier = Modifier&#10;                    .clickable { isPublic = true }&#10;                    .padding(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;public&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = if (isPublic) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                )&#10;            }&#10;            &#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                modifier = Modifier.padding(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;/&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.secondary&#10;                    )&#10;                )&#10;            }&#10;            &#10;            // Private option&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically,&#10;                modifier = Modifier&#10;                    .clickable { isPublic = false }&#10;                    .padding(8.dp)&#10;            ) {&#10;                Text(&#10;                    text = &quot;private&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = if (!isPublic) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.secondary&#10;                    )&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(Modifier.height(16.dp))&#10;        &#10;        // Create button&#10;        Text(&#10;            text = if (isLoading) &quot;&lt;creating...&gt;&quot; else &quot;&lt;create&gt;&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (isLoading) Color(0xFFFFD93D) else Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable(enabled = !isLoading &amp;&amp; playlistName.isNotBlank()) {&#10;                    isLoading = true&#10;                    error = null&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.createPlaylist(&#10;                            accessToken,&#10;                            playlistName,&#10;                            playlistDesc,&#10;                            isPublic&#10;                        ) { success, errMsg -&gt;&#10;                            isLoading = false&#10;                            if (success) {&#10;                                onPlaylistCreated()&#10;                            } else {&#10;                                error = errMsg ?: &quot;Unknown error&quot;&#10;                            }&#10;                        }&#10;                    } else {&#10;                        isLoading = false&#10;                        error = &quot;Spotify not connected&quot;&#10;                    }&#10;                }&#10;                .padding(8.dp)&#10;        )&#10;        &#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;Error: $it&quot;, &#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                )&#10;            )&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;        &#10;        // Back button&#10;        Text(&#10;            text = &quot;&lt; cancel&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color(0xFF95A5A6)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { onBack() }&#10;                .padding(8.dp)&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/PlaylistsScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/PlaylistsScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.*&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun PlaylistsScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val coroutineScope = rememberCoroutineScope()&#10;    var showCreatePlaylist by remember { mutableStateOf(false) }&#10;    var playlists by remember { mutableStateOf&lt;List&lt;PlaylistEntity&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val playlistRepository = remember { PlaylistLocalRepository(context) }&#10;&#10;    // Load playlists&#10;    LaunchedEffect(Unit) {&#10;        isLoading = true&#10;        try {&#10;            playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;&#10;            // Also sync Spotify playlists if connected&#10;            if (Config.isSpotifyConnected(context)) {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getUserPlaylists(accessToken) { spotifyPlaylists, errorMsg -&gt;&#10;                        if (spotifyPlaylists != null) {&#10;                            coroutineScope.launch {&#10;                                spotifyPlaylists.forEach { spotifyPlaylist -&gt;&#10;                                    val playlistEntity = PlaylistEntity(&#10;                                        spotifyId = spotifyPlaylist.id,&#10;                                        name = spotifyPlaylist.name,&#10;                                        description = spotifyPlaylist.description,&#10;                                        trackCount = spotifyPlaylist.tracks?.total ?: 0,&#10;                                        imageUrl = spotifyPlaylist.images?.firstOrNull()?.url,&#10;                                        lastSyncTime = System.currentTimeMillis()&#10;                                    )&#10;                                    playlistRepository.insertPlaylist(playlistEntity)&#10;                                }&#10;                                playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;                            }&#10;                        } else {&#10;                            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading Spotify playlists: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            error = &quot;Error loading playlists: ${e.message}&quot;&#10;            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading playlists&quot;, e)&#10;        } finally {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    BackHandler {&#10;        if (showCreatePlaylist) {&#10;            showCreatePlaylist = false&#10;        } else {&#10;            onBack()&#10;        }&#10;    }&#10;&#10;    if (showCreatePlaylist) {&#10;        CreateSpotifyPlaylistScreen(&#10;            onBack = { showCreatePlaylist = false },&#10;            onPlaylistCreated = {&#10;                showCreatePlaylist = false&#10;                // Reload playlists&#10;                coroutineScope.launch {&#10;                    playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;                }&#10;            }&#10;        )&#10;    } else {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;$ plyr_playlists&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 24.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                if (Config.isSpotifyConnected(context)) {&#10;                    Text(&#10;                        text = &quot;+ create&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF1DB954)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { showCreatePlaylist = true }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; loading playlists...&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFFFFD93D)&#10;                        ),&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;&#10;                error != null -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; error: $error&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFFE74C3C)&#10;                        ),&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;&#10;                playlists.isNotEmpty() -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; your playlists [${playlists.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        contentPadding = PaddingValues(bottom = 16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(playlists.size) { index -&gt;&#10;                            val playlist = playlists[index]&#10;&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable {&#10;                                        // Load and play playlist&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                val tracks = playlistRepository.getTracksWithAutoSync(playlist.spotifyId)&#10;                                                if (tracks.isNotEmpty()) {&#10;                                                    playerViewModel?.setCurrentPlaylist(tracks, 0)&#10;                                                    playerViewModel?.loadAudioFromTrack(tracks.first())&#10;                                                    Log.d(&quot;PlaylistsScreen&quot;, &quot;Playing playlist: ${playlist.name}&quot;)&#10;                                                }&#10;                                            } catch (e: Exception) {&#10;                                                Log.e(&quot;PlaylistsScreen&quot;, &quot;Error playing playlist&quot;, e)&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                colors = CardDefaults.cardColors(&#10;                                    // All playlists are from Spotify since that's the only source&#10;                                    containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    // Playlist image or icon&#10;                                    if (playlist.imageUrl != null) {&#10;                                        AsyncImage(&#10;                                            model = playlist.imageUrl,&#10;                                            contentDescription = null,&#10;                                            modifier = Modifier&#10;                                                .size(56.dp)&#10;                                                .clip(RoundedCornerShape(8.dp))&#10;                                        )&#10;                                    } else {&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(56.dp)&#10;                                                .clip(RoundedCornerShape(8.dp)),&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;♫&quot;, // All playlists are from Spotify&#10;                                                style = MaterialTheme.typography.headlineMedium.copy(&#10;                                                    color = Color(0xFF1DB954)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                                    Column(modifier = Modifier.weight(1f)) {&#10;                                        Text(&#10;                                            text = playlist.name,&#10;                                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                fontSize = 16.sp,&#10;                                                color = Color.White&#10;                                            ),&#10;                                            maxLines = 1,&#10;                                            overflow = TextOverflow.Ellipsis&#10;                                        )&#10;&#10;                                        Row(&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;${playlist.trackCount} tracks&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    fontFamily = FontFamily.Monospace,&#10;                                                    fontSize = 12.sp,&#10;                                                    color = Color(0xFF95A5A6)&#10;                                                )&#10;                                            )&#10;                                        }&#10;&#10;                                        playlist.description?.let { description -&gt;&#10;                                            if (description.isNotBlank()) {&#10;                                                Text(&#10;                                                    text = description,&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        fontSize = 11.sp,&#10;                                                        color = Color(0xFF95A5A6)&#10;                                                    ),&#10;                                                    maxLines = 1,&#10;                                                    overflow = TextOverflow.Ellipsis&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                else -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(32.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&gt; no playlists found&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;&#10;                        if (!Config.isSpotifyConnected(context)) {&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = &quot;Connect to Spotify to see your playlists&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 12.sp,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.*&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun PlaylistsScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val coroutineScope = rememberCoroutineScope()&#10;    var showCreatePlaylist by remember { mutableStateOf(false) }&#10;    var playlists by remember { mutableStateOf&lt;List&lt;PlaylistEntity&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    val playlistRepository = remember { PlaylistLocalRepository(context) }&#10;&#10;    // Load playlists&#10;    LaunchedEffect(Unit) {&#10;        isLoading = true&#10;        try {&#10;            playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;&#10;            // Also sync Spotify playlists if connected&#10;            if (Config.isSpotifyConnected(context)) {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Trigger a sync instead of manually inserting playlists&#10;                    val syncSuccess = playlistRepository.syncPlaylistsFromSpotify()&#10;                    if (syncSuccess) {&#10;                        playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;                    } else {&#10;                        Log.e(&quot;PlaylistsScreen&quot;, &quot;Failed to sync playlists from Spotify&quot;)&#10;                        error = &quot;Failed to sync playlists from Spotify&quot;&#10;                    }&#10;                }&#10;            }&#10;        } catch (e: Exception) {&#10;            error = &quot;Error loading playlists: ${e.message}&quot;&#10;            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading playlists&quot;, e)&#10;        } finally {&#10;            isLoading = false&#10;        }&#10;    }&#10;&#10;    BackHandler {&#10;        if (showCreatePlaylist) {&#10;            showCreatePlaylist = false&#10;        } else {&#10;            onBack()&#10;        }&#10;    }&#10;&#10;    if (showCreatePlaylist) {&#10;        CreateSpotifyPlaylistScreen(&#10;            onBack = { showCreatePlaylist = false },&#10;            onPlaylistCreated = {&#10;                showCreatePlaylist = false&#10;                // Reload playlists&#10;                coroutineScope.launch {&#10;                    playlists = playlistRepository.getPlaylistsWithAutoSync()&#10;                }&#10;            }&#10;        )&#10;    } else {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(bottom = 16.dp),&#10;                horizontalArrangement = Arrangement.SpaceBetween,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    text = &quot;$ plyr_playlists&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 24.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                if (Config.isSpotifyConnected(context)) {&#10;                    Text(&#10;                        text = &quot;+ create&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color(0xFF1DB954)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { showCreatePlaylist = true }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;&#10;            when {&#10;                isLoading -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; loading playlists...&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFFFFD93D)&#10;                        ),&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;&#10;                error != null -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; error: $error&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFFE74C3C)&#10;                        ),&#10;                        modifier = Modifier.padding(16.dp)&#10;                    )&#10;                }&#10;&#10;                playlists.isNotEmpty() -&gt; {&#10;                    Text(&#10;                        text = &quot;&gt; your playlists [${playlists.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    LazyColumn(&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                        contentPadding = PaddingValues(bottom = 16.dp),&#10;                        verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                    ) {&#10;                        items(playlists.size) { index -&gt;&#10;                            val playlist = playlists[index]&#10;&#10;                            Card(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .clickable {&#10;                                        // Load and play playlist&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                val tracks = playlistRepository.getTracksWithAutoSync(playlist.spotifyId)&#10;                                                if (tracks.isNotEmpty()) {&#10;                                                    playerViewModel?.setCurrentPlaylist(tracks, 0)&#10;                                                    playerViewModel?.loadAudioFromTrack(tracks.first())&#10;                                                    Log.d(&quot;PlaylistsScreen&quot;, &quot;Playing playlist: ${playlist.name}&quot;)&#10;                                                }&#10;                                            } catch (e: Exception) {&#10;                                                Log.e(&quot;PlaylistsScreen&quot;, &quot;Error playing playlist&quot;, e)&#10;                                            }&#10;                                        }&#10;                                    },&#10;                                colors = CardDefaults.cardColors(&#10;                                    // All playlists are from Spotify since that's the only source&#10;                                    containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                                )&#10;                            ) {&#10;                                Row(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .padding(12.dp),&#10;                                    verticalAlignment = Alignment.CenterVertically&#10;                                ) {&#10;                                    // Playlist image or icon&#10;                                    if (playlist.imageUrl != null) {&#10;                                        AsyncImage(&#10;                                            model = playlist.imageUrl,&#10;                                            contentDescription = null,&#10;                                            modifier = Modifier&#10;                                                .size(56.dp)&#10;                                                .clip(RoundedCornerShape(8.dp))&#10;                                        )&#10;                                    } else {&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(56.dp)&#10;                                                .clip(RoundedCornerShape(8.dp)),&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;♫&quot;, // All playlists are from Spotify&#10;                                                style = MaterialTheme.typography.headlineMedium.copy(&#10;                                                    color = Color(0xFF1DB954)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;&#10;                                    Column(modifier = Modifier.weight(1f)) {&#10;                                        Text(&#10;                                            text = playlist.name,&#10;                                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                fontSize = 16.sp,&#10;                                                color = Color.White&#10;                                            ),&#10;                                            maxLines = 1,&#10;                                            overflow = TextOverflow.Ellipsis&#10;                                        )&#10;&#10;                                        Row(&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Text(&#10;                                                text = &quot;${playlist.trackCount} tracks&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    fontFamily = FontFamily.Monospace,&#10;                                                    fontSize = 12.sp,&#10;                                                    color = Color(0xFF95A5A6)&#10;                                                )&#10;                                            )&#10;                                        }&#10;&#10;                                        playlist.description?.let { description -&gt;&#10;                                            if (description.isNotBlank()) {&#10;                                                Text(&#10;                                                    text = description,&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        fontSize = 11.sp,&#10;                                                        color = Color(0xFF95A5A6)&#10;                                                    ),&#10;                                                    maxLines = 1,&#10;                                                    overflow = TextOverflow.Ellipsis&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                else -&gt; {&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .padding(32.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&gt; no playlists found&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;&#10;                        if (!Config.isSpotifyConnected(context)) {&#10;                            Spacer(modifier = Modifier.height(16.dp))&#10;                            Text(&#10;                                text = &quot;Connect to Spotify to see your playlists&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 12.sp,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/SearchScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.search.*&#10;import com.plyr.utils.Config&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    &#10;    // Spotify search results&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;    &#10;    // Pagination state&#10;    var currentOffset by remember { mutableStateOf(0) }&#10;    var isLoadingMore by remember { mutableStateOf(false) }&#10;    var hasMoreResults by remember { mutableStateOf(true) }&#10;    val itemsPerPage = 10&#10;&#10;    // Detailed view state for playlists/albums&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    &#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { query, isLoadMore -&gt;&#10;        if (query.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoadingMore = true&#10;            } else {&#10;                isLoading = true&#10;                currentOffset = 0&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                hasMoreResults = true&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;                    &#10;                    // Allow temporary override with prefixes&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        query.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to query.substring(3).trim()&#10;                        }&#10;                        query.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to query.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to query&#10;                    }&#10;                    &#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        isLoadingMore = false&#10;                        error = &quot;Empty query after processing prefix&quot;&#10;                        return@launch&#10;                    }&#10;                    &#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            val youtubeResults = youtubeSearchManager.searchYouTubeVideosDetailed(finalQuery)&#10;                            val newResults = youtubeResults.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;,&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            if (isLoadMore) {&#10;                                results = results + newResults&#10;                            } else {&#10;                                results = newResults&#10;                            }&#10;&#10;                            hasMoreResults = newResults.size &gt;= itemsPerPage&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                        }&#10;                        &#10;                        &quot;spotify&quot; -&gt; {&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    Log.d(&quot;SearchScreen&quot;, &quot; Starting Spotify search: '$finalQuery'&quot;)&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                error = &quot;Error searching Spotify: $searchError&quot;&#10;                                                Log.e(&quot;SearchScreen&quot;, &quot;Error searching Spotify: $searchError&quot;)&#10;                                            } else if (searchResults != null) {&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Results updated: ${searchResults.tracks.items.size} tracks, ${searchResults.albums.items.size} albums, ${searchResults.artists.items.size} artists, ${searchResults.playlists.items.size} playlists&quot;)&#10;&#10;                                                if (isLoadMore &amp;&amp; spotifyResults != null) {&#10;                                                    val combinedResults = SpotifySearchAllResponse(&#10;                                                        tracks = SpotifyTracksSearchResult(&#10;                                                            items = spotifyResults!!.tracks.items + searchResults.tracks.items,&#10;                                                            total = searchResults.tracks.total,&#10;                                                            limit = searchResults.tracks.limit,&#10;                                                            offset = searchResults.tracks.offset,&#10;                                                            next = searchResults.tracks.next&#10;                                                        ),&#10;                                                        albums = SpotifyAlbumsSearchResult(&#10;                                                            items = spotifyResults!!.albums.items + searchResults.albums.items,&#10;                                                            total = searchResults.albums.total,&#10;                                                            limit = searchResults.albums.limit,&#10;                                                            offset = searchResults.albums.offset,&#10;                                                            next = searchResults.albums.next&#10;                                                        ),&#10;                                                        artists = SpotifyArtistsSearchResult(&#10;                                                            items = spotifyResults!!.artists.items + searchResults.artists.items,&#10;                                                            total = searchResults.artists.total,&#10;                                                            limit = searchResults.artists.limit,&#10;                                                            offset = searchResults.artists.offset,&#10;                                                            next = searchResults.artists.next&#10;                                                        ),&#10;                                                        playlists = SpotifyPlaylistsSearchResult(&#10;                                                            items = spotifyResults!!.playlists.items + searchResults.playlists.items,&#10;                                                            total = searchResults.playlists.total,&#10;                                                            limit = searchResults.playlists.limit,&#10;                                                            offset = searchResults.playlists.offset,&#10;                                                            next = searchResults.playlists.next&#10;                                                        )&#10;                                                    )&#10;                                                    spotifyResults = combinedResults&#10;                                                } else {&#10;                                                    spotifyResults = searchResults&#10;                                                }&#10;&#10;                                                hasMoreResults = false&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                showSpotifyResults = true&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot; State updated - showSpotifyResults=$showSpotifyResults&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    isLoadingMore = false&#10;                                    error = &quot;Spotify token not available&quot;&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                isLoadingMore = false&#10;                                error = &quot;Spotify not connected&quot;&#10;                            }&#10;                        }&#10;                        &#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                            error = &quot;Unrecognized search engine: $finalSearchEngine&quot;&#10;                            Log.w(&quot;SearchScreen&quot;, &quot;Unrecognized search engine: $finalSearchEngine&quot;)&#10;                        }&#10;                    }&#10;                    &#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    isLoadingMore = false&#10;                    error = &quot;Search error: ${e.message}&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;Search error&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Helper functions for Spotify operations&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Saving playlist to Spotify library: ${playlist.name}&quot;)&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Playlist followed successfully: ${playlist.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error following playlist: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Spotify token not available&quot;)&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Saving album to Spotify library: ${album.name}&quot;)&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Album saved successfully: ${album.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error saving album: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Spotify token not available&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error saving to Spotify library&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;        &#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Loading playlist tracks: ${playlist.name}&quot;)&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks loaded for playlist: ${playlist.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error loading playlist tracks: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error loading playlist tracks: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Spotify token not available&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Spotify token not available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error loading playlist tracks: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error loading playlist tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;        &#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Loading album tracks: ${album.name}&quot;)&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks loaded for album: ${album.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error loading album tracks: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error loading album tracks: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Spotify token not available&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Spotify token not available&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error loading album tracks: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error loading album tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null -&gt; {&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedItemTracks = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        when {&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyPlaylist = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Starting playlist playback: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;                            &#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;                            &#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                            &#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error playing playlist&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Starting random playlist playback: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;                            &#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;                            &#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                            &#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error playing shuffled playlist&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                SpotifyAlbumDetailView(&#10;                    album = selectedSpotifyAlbum!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyAlbum = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Starting album playback: ${selectedSpotifyAlbum!!.name}&quot;)&#10;                            &#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;                            &#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                            &#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error playing album&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Starting random album playback: ${selectedSpotifyAlbum!!.name}&quot;)&#10;                            &#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;                            &#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                            &#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error playing shuffled album&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            else -&gt; {&#10;                SearchMainView(&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    &#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;dark&quot;&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    &#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;    &#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read&quot;&#10;    &#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;dark&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;    &#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Verifica automáticamente si el token ha expirado.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si expiró o no existe&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val token = getPrefs(context).getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;        &#10;        // Verificar que el token no haya expirado&#10;        return if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            token&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece las credenciales de Spotify API del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyCredentials(context: Context, clientId: String, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpia las credenciales de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyCredentials(context: Context) {&#10;        getPrefs(context).edit {&#10;            remove(KEY_SPOTIFY_CLIENT_ID)&#10;            remove(KEY_SPOTIFY_CLIENT_SECRET)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si Spotify está completamente configurado (credenciales + conexión).&#10;     * @param context Contexto de la aplicación&#10;     * @return true si está completamente configurado, false en caso contrario&#10;     */&#10;    fun isSpotifyFullyConfigured(context: Context): Boolean {&#10;        return hasSpotifyCredentials(context) &amp;&amp; isSpotifyConnected(context)&#10;    }&#10;    &#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;import android.content.SharedPreferences&#13;&#10;import androidx.core.content.edit&#13;&#10;&#13;&#10;/**&#13;&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#13;&#10; * &#13;&#10; * Maneja:&#13;&#10; * - Configuración de temas (claro/oscuro)&#13;&#10; * - Tokens y autenticación de Spotify&#13;&#10; * - Constantes de API de Spotify&#13;&#10; * - Persistencia de preferencias usando SharedPreferences&#13;&#10; * &#13;&#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#13;&#10; * y se accede a través de métodos thread-safe.&#13;&#10; */&#13;&#10;object Config {&#13;&#10;    &#13;&#10;    // === CONSTANTES PRIVADAS ===&#13;&#10;    &#13;&#10;    /** Nombre del archivo de preferencias */&#13;&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#13;&#10;    &#13;&#10;    // Claves para SharedPreferences&#13;&#10;    private const val KEY_THEME = &quot;theme&quot;&#13;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#13;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#13;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#13;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#13;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#13;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#13;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#13;&#10;    &#13;&#10;    // Valores por defecto&#13;&#10;    private const val DEFAULT_THEME = &quot;dark&quot;&#13;&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#13;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;best&quot;&#13;&#10;    &#13;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#13;&#10;    &#13;&#10;    /** URI de redirección para OAuth de Spotify */&#13;&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#13;&#10;    &#13;&#10;    /** Permisos solicitados a Spotify */&#13;&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read&quot;&#13;&#10;    &#13;&#10;    // === MÉTODOS PRIVADOS ===&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return SharedPreferences configurado con el nombre correcto&#13;&#10;     */&#13;&#10;    private fun getPrefs(context: Context): SharedPreferences {&#13;&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#13;&#10;    }&#13;&#10;    &#13;&#10;    // === GESTIÓN DE TEMAS ===&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece el tema de la aplicación.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#13;&#10;     */&#13;&#10;    fun setTheme(context: Context, theme: String) {&#13;&#10;        getPrefs(context).edit { &#13;&#10;            putString(KEY_THEME, theme) &#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el tema actual de la aplicación.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Tema actual (por defecto &quot;dark&quot;)&#13;&#10;     */&#13;&#10;    fun getTheme(context: Context): String {&#13;&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#13;&#10;    }&#13;&#10;    &#13;&#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Almacena los tokens de autenticación de Spotify.&#13;&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#13;&#10;     * &#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param accessToken Token de acceso para API calls&#13;&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#13;&#10;     * @param expiresIn Tiempo de vida del token en segundos&#13;&#10;     */&#13;&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#13;&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#13;&#10;        getPrefs(context).edit { &#13;&#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#13;&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#13;&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el token de acceso de Spotify si es válido.&#13;&#10;     * Verifica automáticamente si el token ha expirado.&#13;&#10;     * &#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Token de acceso válido o null si expiró o no existe&#13;&#10;     */&#13;&#10;    fun getSpotifyAccessToken(context: Context): String? {&#13;&#10;        val token = getPrefs(context).getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#13;&#10;        val expiryTime = getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#13;&#10;        &#13;&#10;        // Verificar que el token no haya expirado&#13;&#10;        return if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#13;&#10;            token&#13;&#10;        } else {&#13;&#10;            null&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el token de renovación de Spotify.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Token de renovación o null si no existe&#13;&#10;     */&#13;&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#13;&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Elimina todos los tokens de Spotify almacenados.&#13;&#10;     * Útil para cerrar sesión o limpiar autenticación.&#13;&#10;     * &#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     */&#13;&#10;    fun clearSpotifyTokens(context: Context) {&#13;&#10;        getPrefs(context).edit { &#13;&#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#13;&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#13;&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Verifica si hay una conexión válida con Spotify.&#13;&#10;     * Considera válida la conexión si existe un token de acceso válido&#13;&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#13;&#10;     * &#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#13;&#10;     */&#13;&#10;    fun isSpotifyConnected(context: Context): Boolean {&#13;&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#13;&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#13;&#10;        return hasValidAccessToken || hasRefreshToken&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Client ID del usuario o null si no está configurado&#13;&#10;     */&#13;&#10;    fun getSpotifyClientId(context: Context): String? {&#13;&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Client Secret del usuario o null si no está configurado&#13;&#10;     */&#13;&#10;    fun getSpotifyClientSecret(context: Context): String? {&#13;&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece el Client ID de Spotify del usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param clientId Client ID del usuario&#13;&#10;     */&#13;&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#13;&#10;        getPrefs(context).edit {&#13;&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece el Client Secret de Spotify del usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param clientSecret Client Secret del usuario&#13;&#10;     */&#13;&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#13;&#10;        getPrefs(context).edit {&#13;&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece las credenciales de Spotify API del usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param clientId Client ID del usuario&#13;&#10;     * @param clientSecret Client Secret del usuario&#13;&#10;     */&#13;&#10;    fun setSpotifyCredentials(context: Context, clientId: String, clientSecret: String) {&#13;&#10;        getPrefs(context).edit {&#13;&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#13;&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Limpia las credenciales de Spotify del usuario.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     */&#13;&#10;    fun clearSpotifyCredentials(context: Context) {&#13;&#10;        getPrefs(context).edit {&#13;&#10;            remove(KEY_SPOTIFY_CLIENT_ID)&#13;&#10;            remove(KEY_SPOTIFY_CLIENT_SECRET)&#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#13;&#10;     */&#13;&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#13;&#10;        val prefs = getPrefs(context)&#13;&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#13;&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#13;&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Verifica si Spotify está completamente configurado (credenciales + conexión).&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return true si está completamente configurado, false en caso contrario&#13;&#10;     */&#13;&#10;    fun isSpotifyFullyConfigured(context: Context): Boolean {&#13;&#10;        return hasSpotifyCredentials(context) &amp;&amp; isSpotifyConnected(context)&#13;&#10;    }&#13;&#10;    &#13;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece el motor de búsqueda predeterminado.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#13;&#10;     */&#13;&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#13;&#10;        getPrefs(context).edit { &#13;&#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#13;&#10;     */&#13;&#10;    fun getSearchEngine(context: Context): String {&#13;&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#13;&#10;    }&#13;&#10;    &#13;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Establece la calidad de audio predeterminada.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param quality Calidad de audio a establecer (&quot;low&quot;, &quot;normal&quot;, &quot;high&quot;, &quot;best&quot;)&#13;&#10;     */&#13;&#10;    fun setAudioQuality(context: Context, quality: String) {&#13;&#10;        getPrefs(context).edit { &#13;&#10;            putString(KEY_AUDIO_QUALITY, quality) &#13;&#10;        }&#13;&#10;    }&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Obtiene la calidad de audio actual de la aplicación.&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @return Calidad de audio actual (por defecto &quot;best&quot;)&#13;&#10;     */&#13;&#10;    fun getAudioQuality(context: Context): String {&#13;&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>