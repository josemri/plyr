<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/MainActivity.kt" />
              <option name="originalContent" value="package com.plyr&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.ExoPlyrScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTokens&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.model.AudioItem&#10;import com.plyr.database.TrackEntity&#10;import android.net.Uri&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * MainActivity - Actividad principal de la aplicación&#10; * &#10; * Esta actividad maneja:&#10; * - Conexión con el MusicService para reproducción en segundo plano&#10; * - Navegación entre pantallas (lista de audio, reproductor, configuración)&#10; * - Callbacks de OAuth de Spotify para autenticación&#10; * - Configuración del tema de la aplicación&#10; * - Coordinación entre UI y PlayerViewModel&#10; * &#10; * La aplicación usa un diseño modular con:&#10; * - PlayerViewModel para lógica de reproducción&#10; * - MusicService para reproducción en segundo plano&#10; * - Componentes UI independientes y reutilizables&#10; */&#10;class MainActivity : ComponentActivity() {&#10;    &#10;    // === PROPIEDADES ===&#10;    &#10;    /** Referencia al servicio de música para reproducción en segundo plano */&#10;    private var musicService: MusicService? = null&#10;    &#10;    /** Indica si el servicio está conectado */&#10;    private var bound = false&#10;    &#10;    /** Indica si la aplicación está siendo cerrada intencionalmente */&#10;    private var isAppClosing = false&#10;&#10;    // === CONFIGURACIÓN DEL SERVICIO ===&#10;    &#10;    /**&#10;     * Conexión con el MusicService para comunicación bidireccional.&#10;     */&#10;    private val connection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            bound = true&#10;            println(&quot;MainActivity: Servicio de música conectado&quot;)&#10;        }&#10;        &#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            bound = false&#10;            println(&quot;MainActivity: Servicio de música desconectado&quot;)&#10;        }&#10;    }    &#10;    // === CICLO DE VIDA DE LA ACTIVIDAD ===&#10;    &#10;    /**&#10;     * Inicializa la actividad, configura el servicio de música y establece el contenido UI.&#10;     */&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Procesar callback de Spotify OAuth si existe&#10;        handleSpotifyCallback(intent)&#10;        &#10;        // Configurar UI edge-to-edge&#10;        enableEdgeToEdge()&#10;        &#10;        // Configurar servicio de música&#10;        setupMusicService()&#10;        &#10;        // Configurar contenido UI&#10;        setupUIContent()&#10;    }&#10;    &#10;    /**&#10;     * Configura e inicia el servicio de música.&#10;     */&#10;    private fun setupMusicService() {&#10;        Intent(this, MusicService::class.java).also { intent -&gt;&#10;            startService(intent)&#10;            bindService(intent, connection, Context.BIND_AUTO_CREATE)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura el contenido principal de la UI.&#10;     */&#10;    private fun setupUIContent() {&#10;        setContent {&#10;            var playerViewModel = (application as PlyrApp).playerViewModel&#10;            //val playerViewModel: PlayerViewModel = viewModel()&#10;            var currentScreen by remember { mutableStateOf(&quot;list&quot;) }&#10;            var selectedVideoId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;            // Gestión del tema&#10;            val selectedTheme = remember { mutableStateOf(Config.getTheme(this@MainActivity)) }&#10;            val isDarkTheme = selectedTheme.value == &quot;dark&quot;&#10;&#10;            TerminalTheme(isDark = isDarkTheme) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainScreenContainer(&#10;                        currentScreen = currentScreen,&#10;                        onScreenChange = { currentScreen = it },&#10;                        selectedVideoId = selectedVideoId,&#10;                        onVideoIdChange = { selectedVideoId = it },&#10;                        playerViewModel = playerViewModel,&#10;                        selectedTheme = selectedTheme&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Contenedor principal que organiza las pantallas y controles flotantes.&#10;     */&#10;    @Composable&#10;    private fun MainScreenContainer(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        selectedVideoId: String?,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .statusBarsPadding()&#10;        ) {&#10;            // Área de contenido principal con padding para controles flotantes&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(bottom = 140.dp)&#10;            ) {&#10;                ScreenContent(&#10;                    currentScreen = currentScreen,&#10;                    onScreenChange = onScreenChange,&#10;                    onVideoIdChange = onVideoIdChange,&#10;                    playerViewModel = playerViewModel,&#10;                    selectedTheme = selectedTheme&#10;                )&#10;            }&#10;&#10;            // Controles flotantes de música&#10;            FloatingMusicControls(&#10;                playerViewModel = playerViewModel,&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(bottom = 48.dp)&#10;            )&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja el contenido de las diferentes pantallas.&#10;     */&#10;    @Composable&#10;    private fun ScreenContent(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        when (currentScreen) {&#10;            &quot;player&quot; -&gt; {&#10;                playerViewModel.exoPlayer?.let { player -&gt;&#10;                    ExoPlyrScreen(&#10;                        player = player,&#10;                        onBack = { onScreenChange(&quot;list&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                AudioListScreen(&#10;                    context = this@MainActivity,&#10;                    onVideoSelected = { videoId, title -&gt;&#10;                        handleVideoSelection(videoId, title, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onVideoSelectedFromSearch = { videoId, title, searchResults, selectedIndex -&gt;&#10;                        handleVideoSelectionFromSearch(videoId, title, searchResults, selectedIndex, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onThemeChanged = { newTheme -&gt;&#10;                        selectedTheme.value = newTheme&#10;                    },&#10;                    playerViewModel = playerViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video para reproducir.&#10;     * Si el video viene de una búsqueda, configura toda la lista como playlist.&#10;     */&#10;    private fun handleVideoSelection(&#10;        videoId: String,&#10;        title: String,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Si hay una playlist activa, pasarla al servicio para reproducción en background&#10;        val playlist = playerViewModel.currentPlaylist.value&#10;        val currentIndex = playerViewModel.currentTrackIndex.value ?: 0&#10;        if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;            // Obtener las URLs de audio para cada track&#10;            // NOTA: Esto requiere que los YouTube IDs ya estén resueltos o que el servicio pueda resolverlos&#10;            val audioUrls = playlist.mapNotNull { track -&gt;&#10;                // Usar el YouTube ID del track para obtener la URL de audio&#10;                track.youtubeVideoId ?: track.spotifyTrackId&#10;            }&#10;            if (audioUrls.isNotEmpty()) {&#10;                musicService?.playPlaylist(audioUrls, currentIndex)&#10;            }&#10;        } else {&#10;            // Si no hay playlist, reproducir solo el videoId&#10;            musicService?.playAudio(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video desde resultados de búsqueda.&#10;     * Configura toda la lista de resultados como playlist temporal.&#10;     */&#10;    private fun handleVideoSelectionFromSearch(&#10;        videoId: String,&#10;        title: String,&#10;        searchResults: List&lt;AudioItem&gt;,&#10;        selectedIndex: Int,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        &#10;        // Convertir los resultados de búsqueda a TrackEntity para crear una playlist temporal&#10;        val searchPlaylist = searchResults.mapIndexed { index, audioItem -&gt;&#10;            TrackEntity(&#10;                id = &quot;search_${audioItem.videoId ?: audioItem.title}_$index&quot;,&#10;                playlistId = &quot;search_results_${System.currentTimeMillis()}&quot;,&#10;                spotifyTrackId = &quot;&quot;, // Empty string for YouTube tracks&#10;                name = audioItem.title,&#10;                artists = audioItem.channel ?: &quot;Desconocido&quot;,&#10;                youtubeVideoId = audioItem.videoId,&#10;                audioUrl = null,&#10;                position = index,&#10;                lastSyncTime = System.currentTimeMillis()&#10;            )&#10;        }&#10;        &#10;        // Establecer la playlist de búsqueda en el PlayerViewModel&#10;        playerViewModel.setCurrentPlaylist(searchPlaylist, selectedIndex)&#10;        &#10;        // Cargar el video seleccionado&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Configurar el servicio para reproducción en background&#10;        val audioUrls = searchPlaylist.mapNotNull { it.youtubeVideoId }&#10;        if (audioUrls.isNotEmpty()) {&#10;            musicService?.playPlaylist(audioUrls, selectedIndex)&#10;        }&#10;    }    &#10;    /**&#10;     * Limpia recursos al destruir la actividad.&#10;     */&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Si la aplicación se está cerrando, detener completamente el servicio&#10;        if (isAppClosing || isFinishing) {&#10;            stopMusicServiceCompletely()&#10;        } else {&#10;            // Solo desconectar el binding, pero mantener el servicio para reproducción en background&#10;            disconnectMusicService()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maneja el botón de back para cerrar la aplicación completamente&#10;     */&#10;    override fun onBackPressed() {&#10;        // Marcar que la aplicación se está cerrando intencionalmente&#10;        isAppClosing = true&#10;        super.onBackPressed()&#10;    }&#10;&#10;    /**&#10;     * Detiene completamente el servicio de música y cierra la aplicación&#10;     */&#10;    private fun stopMusicServiceCompletely() {&#10;        musicService?.let { service -&gt;&#10;            // Parar la reproducción&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            playerViewModel.pausePlayer()&#10;&#10;            // Detener el servicio foreground&#10;            service.stopForegroundService()&#10;        }&#10;&#10;        // Desconectar el binding&#10;        disconnectMusicService()&#10;&#10;        // Detener el servicio completamente&#10;        stopService(Intent(this, MusicService::class.java))&#10;    }&#10;    &#10;    // === MANEJO DE INTENTS ===&#10;    &#10;    /**&#10;     * Maneja nuevos intents, especialmente callbacks de Spotify OAuth.&#10;     */&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;        handleSpotifyCallback(intent)&#10;    }&#10;    &#10;    // === AUTENTICACIÓN DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Procesa callbacks de OAuth de Spotify cuando el usuario autoriza la aplicación.&#10;     * &#10;     * @param intent Intent que puede contener datos de callback de Spotify&#10;     */&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (isSpotifyCallback(uri)) {&#10;                processSpotifyAuthResult(uri)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el URI es un callback de Spotify OAuth.&#10;     * @param uri URI a verificar&#10;     * @return true si es un callback de Spotify&#10;     */&#10;    private fun isSpotifyCallback(uri: Uri): Boolean {&#10;        return uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;&#10;    }&#10;    &#10;    /**&#10;     * Procesa el resultado de la autorización de Spotify.&#10;     * @param uri URI con los parámetros de respuesta de OAuth&#10;     */&#10;    private fun processSpotifyAuthResult(uri: Uri) {&#10;        val code = uri.getQueryParameter(&quot;code&quot;)&#10;        val error = uri.getQueryParameter(&quot;error&quot;)&#10;        &#10;        when {&#10;            error != null -&gt; handleSpotifyAuthError(error)&#10;            code != null -&gt; handleSpotifyAuthSuccess(code)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la autorización de Spotify.&#10;     * @param error Código de error recibido&#10;     */&#10;    private fun handleSpotifyAuthError(error: String) {&#10;        println(&quot;MainActivity: Spotify OAuth error: $error&quot;)&#10;        SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Maneja la autorización exitosa de Spotify.&#10;     * @param code Código de autorización recibido&#10;     */&#10;    private fun handleSpotifyAuthSuccess(code: String) {&#10;        SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, tokenError -&gt;&#10;            if (tokens != null &amp;&amp; tokenError == null) {&#10;                saveSpotifyTokens(tokens)&#10;                println(&quot;MainActivity: Spotify OAuth success: Tokens guardados&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;            } else {&#10;                println(&quot;MainActivity: Error intercambiando tokens: $tokenError&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Guarda los tokens de Spotify en las preferencias.&#10;     * @param tokens Tokens de acceso y refresh recibidos&#10;     */&#10;    private fun saveSpotifyTokens(tokens: SpotifyTokens) {&#10;        Config.setSpotifyTokens(&#10;            this,&#10;            tokens.accessToken,&#10;            tokens.refreshToken,&#10;            tokens.expiresIn&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.Bundle&#10;import android.os.IBinder&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.compose.setContent&#10;import androidx.activity.enableEdgeToEdge&#10;import androidx.compose.runtime.*&#10;import androidx.compose.foundation.layout.Box&#10;import androidx.compose.foundation.layout.fillMaxSize&#10;import androidx.compose.foundation.layout.padding&#10;import androidx.compose.foundation.layout.statusBarsPadding&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.Surface&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.unit.dp&#10;import androidx.lifecycle.viewmodel.compose.viewModel&#10;import com.plyr.service.MusicService&#10;import com.plyr.ui.AudioListScreen&#10;import com.plyr.ui.ExoPlyrScreen&#10;import com.plyr.ui.FloatingMusicControls&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTokens&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.model.AudioItem&#10;import com.plyr.database.TrackEntity&#10;import android.net.Uri&#10;import androidx.lifecycle.lifecycleScope&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * MainActivity - Actividad principal de la aplicación&#10; * &#10; * Esta actividad maneja:&#10; * - Conexión con el MusicService para reproducción en segundo plano&#10; * - Navegación entre pantallas (lista de audio, reproductor, configuración)&#10; * - Callbacks de OAuth de Spotify para autenticación&#10; * - Configuración del tema de la aplicación&#10; * - Coordinación entre UI y PlayerViewModel&#10; * &#10; * La aplicación usa un diseño modular con:&#10; * - PlayerViewModel para lógica de reproducción&#10; * - MusicService para reproducción en segundo plano&#10; * - Componentes UI independientes y reutilizables&#10; */&#10;class MainActivity : ComponentActivity() {&#10;    &#10;    // === PROPIEDADES ===&#10;    &#10;    /** Referencia al servicio de música para reproducción en segundo plano */&#10;    private var musicService: MusicService? = null&#10;    &#10;    /** Indica si el servicio está conectado */&#10;    private var bound = false&#10;    &#10;    /** Indica si la aplicación está siendo cerrada intencionalmente */&#10;    private var isAppClosing = false&#10;&#10;    // === CONFIGURACIÓN DEL SERVICIO ===&#10;    &#10;    /**&#10;     * Conexión con el MusicService para comunicación bidireccional.&#10;     */&#10;    private val connection = object : ServiceConnection {&#10;        override fun onServiceConnected(className: ComponentName, service: IBinder) {&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            bound = true&#10;            println(&quot;MainActivity: Servicio de música conectado&quot;)&#10;        }&#10;        &#10;        override fun onServiceDisconnected(arg0: ComponentName) {&#10;            bound = false&#10;            println(&quot;MainActivity: Servicio de música desconectado&quot;)&#10;        }&#10;    }    &#10;    // === CICLO DE VIDA DE LA ACTIVIDAD ===&#10;    &#10;    /**&#10;     * Inicializa la actividad, configura el servicio de música y establece el contenido UI.&#10;     */&#10;    override fun onCreate(savedInstanceState: Bundle?) {&#10;        super.onCreate(savedInstanceState)&#10;        &#10;        // Procesar callback de Spotify OAuth si existe&#10;        handleSpotifyCallback(intent)&#10;        &#10;        // Configurar UI edge-to-edge&#10;        enableEdgeToEdge()&#10;        &#10;        // Configurar servicio de música&#10;        setupMusicService()&#10;        &#10;        // Configurar contenido UI&#10;        setupUIContent()&#10;    }&#10;    &#10;    /**&#10;     * Configura e inicia el servicio de música.&#10;     */&#10;    private fun setupMusicService() {&#10;        Intent(this, MusicService::class.java).also { intent -&gt;&#10;            startService(intent)&#10;            bindService(intent, connection, Context.BIND_AUTO_CREATE)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura el contenido principal de la UI.&#10;     */&#10;    private fun setupUIContent() {&#10;        setContent {&#10;            var playerViewModel = (application as PlyrApp).playerViewModel&#10;            //val playerViewModel: PlayerViewModel = viewModel()&#10;            var currentScreen by remember { mutableStateOf(&quot;list&quot;) }&#10;            var selectedVideoId by remember { mutableStateOf&lt;String?&gt;(null) }&#10;            &#10;            // Gestión del tema&#10;            val selectedTheme = remember { mutableStateOf(Config.getTheme(this@MainActivity)) }&#10;            val isDarkTheme = selectedTheme.value == &quot;dark&quot;&#10;&#10;            TerminalTheme(isDark = isDarkTheme) {&#10;                Surface(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    color = MaterialTheme.colorScheme.background&#10;                ) {&#10;                    MainScreenContainer(&#10;                        currentScreen = currentScreen,&#10;                        onScreenChange = { currentScreen = it },&#10;                        selectedVideoId = selectedVideoId,&#10;                        onVideoIdChange = { selectedVideoId = it },&#10;                        playerViewModel = playerViewModel,&#10;                        selectedTheme = selectedTheme&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Contenedor principal que organiza las pantallas y controles flotantes.&#10;     */&#10;    @Composable&#10;    private fun MainScreenContainer(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        selectedVideoId: String?,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .statusBarsPadding()&#10;        ) {&#10;            // Área de contenido principal con padding para controles flotantes&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(bottom = 140.dp)&#10;            ) {&#10;                ScreenContent(&#10;                    currentScreen = currentScreen,&#10;                    onScreenChange = onScreenChange,&#10;                    onVideoIdChange = onVideoIdChange,&#10;                    playerViewModel = playerViewModel,&#10;                    selectedTheme = selectedTheme&#10;                )&#10;            }&#10;&#10;            // Controles flotantes de música&#10;            FloatingMusicControls(&#10;                playerViewModel = playerViewModel,&#10;                modifier = Modifier&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(bottom = 48.dp)&#10;            )&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja el contenido de las diferentes pantallas.&#10;     */&#10;    @Composable&#10;    private fun ScreenContent(&#10;        currentScreen: String,&#10;        onScreenChange: (String) -&gt; Unit,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel,&#10;        selectedTheme: MutableState&lt;String&gt;&#10;    ) {&#10;        when (currentScreen) {&#10;            &quot;player&quot; -&gt; {&#10;                playerViewModel.exoPlayer?.let { player -&gt;&#10;                    ExoPlyrScreen(&#10;                        player = player,&#10;                        onBack = { onScreenChange(&quot;list&quot;) }&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                AudioListScreen(&#10;                    context = this@MainActivity,&#10;                    onVideoSelected = { videoId, title -&gt;&#10;                        handleVideoSelection(videoId, title, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onVideoSelectedFromSearch = { videoId, title, searchResults, selectedIndex -&gt;&#10;                        handleVideoSelectionFromSearch(videoId, title, searchResults, selectedIndex, onVideoIdChange, playerViewModel)&#10;                    },&#10;                    onThemeChanged = { newTheme -&gt;&#10;                        selectedTheme.value = newTheme&#10;                    },&#10;                    playerViewModel = playerViewModel&#10;                )&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video para reproducir.&#10;     * Si el video viene de una búsqueda, configura toda la lista como playlist.&#10;     */&#10;    private fun handleVideoSelection(&#10;        videoId: String,&#10;        title: String,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Si hay una playlist activa, pasarla al servicio para reproducción en background&#10;        val playlist = playerViewModel.currentPlaylist.value&#10;        val currentIndex = playerViewModel.currentTrackIndex.value ?: 0&#10;        if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;            // Obtener las URLs de audio para cada track&#10;            // NOTA: Esto requiere que los YouTube IDs ya estén resueltos o que el servicio pueda resolverlos&#10;            val audioUrls = playlist.mapNotNull { track -&gt;&#10;                // Usar el YouTube ID del track para obtener la URL de audio&#10;                track.youtubeVideoId ?: track.spotifyTrackId&#10;            }&#10;            if (audioUrls.isNotEmpty()) {&#10;                musicService?.playPlaylist(audioUrls, currentIndex)&#10;            }&#10;        } else {&#10;            // Si no hay playlist, reproducir solo el videoId&#10;            musicService?.playAudio(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la selección de un video desde resultados de búsqueda.&#10;     * Configura toda la lista de resultados como playlist temporal.&#10;     */&#10;    private fun handleVideoSelectionFromSearch(&#10;        videoId: String,&#10;        title: String,&#10;        searchResults: List&lt;AudioItem&gt;,&#10;        selectedIndex: Int,&#10;        onVideoIdChange: (String?) -&gt; Unit,&#10;        playerViewModel: PlayerViewModel&#10;    ) {&#10;        onVideoIdChange(videoId)&#10;        playerViewModel.initializePlayer()&#10;        &#10;        // Convertir los resultados de búsqueda a TrackEntity para crear una playlist temporal&#10;        val searchPlaylist = searchResults.mapIndexed { index, audioItem -&gt;&#10;            TrackEntity(&#10;                id = &quot;search_${audioItem.videoId ?: audioItem.title}_$index&quot;,&#10;                playlistId = &quot;search_results_${System.currentTimeMillis()}&quot;,&#10;                spotifyTrackId = &quot;&quot;, // Empty string for YouTube tracks&#10;                name = audioItem.title,&#10;                artists = audioItem.channel ?: &quot;Desconocido&quot;,&#10;                youtubeVideoId = audioItem.videoId,&#10;                audioUrl = null,&#10;                position = index,&#10;                lastSyncTime = System.currentTimeMillis()&#10;            )&#10;        }&#10;        &#10;        // Establecer la playlist de búsqueda en el PlayerViewModel&#10;        playerViewModel.setCurrentPlaylist(searchPlaylist, selectedIndex)&#10;        &#10;        // Cargar el video seleccionado&#10;        playerViewModel.loadAudio(videoId, title)&#10;&#10;        // Configurar el servicio para reproducción en background&#10;        val audioUrls = searchPlaylist.mapNotNull { it.youtubeVideoId }&#10;        if (audioUrls.isNotEmpty()) {&#10;            musicService?.playPlaylist(audioUrls, selectedIndex)&#10;        }&#10;    }    &#10;    /**&#10;     * Limpia recursos al destruir la actividad.&#10;     */&#10;    override fun onDestroy() {&#10;        super.onDestroy()&#10;&#10;        // Si la aplicación se está cerrando, detener completamente el servicio&#10;        if (isAppClosing || isFinishing) {&#10;            stopMusicServiceCompletely()&#10;        } else {&#10;            // Solo desconectar el binding, pero mantener el servicio para reproducción en background&#10;            disconnectMusicService()&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Maneja el botón de back para cerrar la aplicación completamente&#10;     */&#10;    override fun onBackPressed() {&#10;        // Marcar que la aplicación se está cerrando intencionalmente&#10;        isAppClosing = true&#10;        super.onBackPressed()&#10;    }&#10;&#10;    /**&#10;     * Detiene completamente el servicio de música y cierra la aplicación&#10;     */&#10;    private fun stopMusicServiceCompletely() {&#10;        musicService?.let { service -&gt;&#10;            // Parar la reproducción&#10;            val playerViewModel = (application as PlyrApp).playerViewModel&#10;            playerViewModel.pausePlayer()&#10;&#10;            // Detener el servicio foreground&#10;            service.stopForegroundService()&#10;        }&#10;&#10;        // Desconectar el binding&#10;        disconnectMusicService()&#10;&#10;        // Detener el servicio completamente&#10;        stopService(Intent(this, MusicService::class.java))&#10;    }&#10;    &#10;    /**&#10;     * Desconecta el servicio de música si está conectado.&#10;     */&#10;    private fun disconnectMusicService() {&#10;        if (bound) {&#10;            unbindService(connection)&#10;            bound = false&#10;        }&#10;    }&#10;    &#10;    // === MANEJO DE INTENTS ===&#10;    &#10;    /**&#10;     * Maneja nuevos intents, especialmente callbacks de Spotify OAuth.&#10;     */&#10;    override fun onNewIntent(intent: Intent) {&#10;        super.onNewIntent(intent)&#10;        setIntent(intent)&#10;        handleSpotifyCallback(intent)&#10;    }&#10;    &#10;    // === AUTENTICACIÓN DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Procesa callbacks de OAuth de Spotify cuando el usuario autoriza la aplicación.&#10;     * &#10;     * @param intent Intent que puede contener datos de callback de Spotify&#10;     */&#10;    private fun handleSpotifyCallback(intent: Intent?) {&#10;        intent?.data?.let { uri -&gt;&#10;            if (isSpotifyCallback(uri)) {&#10;                processSpotifyAuthResult(uri)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el URI es un callback de Spotify OAuth.&#10;     * @param uri URI a verificar&#10;     * @return true si es un callback de Spotify&#10;     */&#10;    private fun isSpotifyCallback(uri: Uri): Boolean {&#10;        return uri.scheme == &quot;plyr&quot; &amp;&amp; uri.host == &quot;spotify&quot;&#10;    }&#10;    &#10;    /**&#10;     * Procesa el resultado de la autorización de Spotify.&#10;     * @param uri URI con los parámetros de respuesta de OAuth&#10;     */&#10;    private fun processSpotifyAuthResult(uri: Uri) {&#10;        val code = uri.getQueryParameter(&quot;code&quot;)&#10;        val error = uri.getQueryParameter(&quot;error&quot;)&#10;        &#10;        when {&#10;            error != null -&gt; handleSpotifyAuthError(error)&#10;            code != null -&gt; handleSpotifyAuthSuccess(code)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la autorización de Spotify.&#10;     * @param error Código de error recibido&#10;     */&#10;    private fun handleSpotifyAuthError(error: String) {&#10;        println(&quot;MainActivity: Spotify OAuth error: $error&quot;)&#10;        SpotifyAuthEvent.onAuthComplete(false, &quot;cancelled_by_user&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Maneja la autorización exitosa de Spotify.&#10;     * @param code Código de autorización recibido&#10;     */&#10;    private fun handleSpotifyAuthSuccess(code: String) {&#10;        SpotifyRepository.exchangeCodeForTokens(this, code) { tokens, tokenError -&gt;&#10;            if (tokens != null &amp;&amp; tokenError == null) {&#10;                saveSpotifyTokens(tokens)&#10;                println(&quot;MainActivity: Spotify OAuth success: Tokens guardados&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(true, &quot;connected_successfully&quot;)&#10;            } else {&#10;                println(&quot;MainActivity: Error intercambiando tokens: $tokenError&quot;)&#10;                SpotifyAuthEvent.onAuthComplete(false, &quot;token_exchange_failed&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Guarda los tokens de Spotify en las preferencias.&#10;     * @param tokens Tokens de acceso y refresh recibidos&#10;     */&#10;    private fun saveSpotifyTokens(tokens: SpotifyTokens) {&#10;        Config.setSpotifyTokens(&#10;            this,&#10;            tokens.accessToken,&#10;            tokens.refreshToken,&#10;            tokens.expiresIn&#10;        )&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/database/PlaylistLocalRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/database/PlaylistLocalRepository.kt" />
              <option name="originalContent" value="package com.plyr.database&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.asLiveData&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.utils.Config&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import android.util.Log&#10;&#10;/**&#10; * PlaylistLocalRepository - Repositorio para gestión local de playlists y tracks&#10; * &#10; * Esta clase maneja:&#10; * - Operaciones CRUD sobre playlists y tracks en base de datos local&#10; * - Sincronización automática con Spotify&#10; * - Caché inteligente para evitar consultas innecesarias&#10; * - Observación de cambios mediante LiveData/Flow&#10; * - Gestión de YouTube IDs para tracks&#10; * &#10; * Proporciona una capa de abstracción entre la UI y la base de datos,&#10; * asegurando que los datos estén siempre actualizados y sincronizados.&#10; */&#10;class PlaylistLocalRepository(context: Context) {&#10;&#10;    // === PROPIEDADES ===&#10;&#10;    /** Base de datos local para playlists y tracks */&#10;    private val database = PlaylistDatabase.getDatabase(context)&#10;&#10;    /** DAO para operaciones sobre playlists */&#10;    private val playlistDao = database.playlistDao()&#10;&#10;    /** DAO para operaciones sobre tracks */&#10;    private val trackDao = database.trackDao()&#10;&#10;    /** Contexto de aplicación para operaciones persistentes */&#10;    private val appContext = context.applicationContext&#10;&#10;    // === CONSTANTES ===&#10;&#10;    companion object {&#10;        private const val TAG = &quot;PlaylistLocalRepo&quot;&#10;&#10;        /** Intervalo de sincronización automática (24 horas) */&#10;        private const val SYNC_INTERVAL = 24 * 60 * 60 * 1000L&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - OBSERVACIÓN DE DATOS ===&#10;&#10;    /**&#10;     * Observa todas las playlists locales mediante LiveData.&#10;     * Los cambios se notifican automáticamente a los observadores.&#10;     *&#10;     * @return LiveData que emite la lista de playlists cuando cambian&#10;     */&#10;    fun getAllPlaylistsLiveData(): LiveData&lt;List&lt;PlaylistEntity&gt;&gt; {&#10;        return playlistDao.getAllPlaylists().asLiveData()&#10;    }&#10;&#10;    /**&#10;     * Observa los tracks de una playlist específica.&#10;     *&#10;     * @param playlistId ID de la playlist a observar&#10;     * @return LiveData que emite los tracks cuando cambian&#10;     */&#10;    fun getTracksByPlaylistLiveData(playlistId: String): LiveData&lt;List&lt;TrackEntity&gt;&gt; {&#10;        return trackDao.getTracksByPlaylist(playlistId).asLiveData()&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - SINCRONIZACIÓN AUTOMÁTICA ===&#10;&#10;    /**&#10;     * Obtiene todas las playlists con sincronización automática.&#10;     * Verifica si es necesario sincronizar con Spotify y lo hace automáticamente.&#10;     *&#10;     * @return Lista de playlists actualizadas&#10;     */&#10;    suspend fun getPlaylistsWithAutoSync(): List&lt;PlaylistEntity&gt; = withContext(Dispatchers.IO) {&#10;        Log.d(TAG, &quot;Obteniendo playlists con sincronización automática&quot;)&#10;&#10;        val localPlaylists = playlistDao.getAllPlaylistsSync()&#10;&#10;        // Verificar si necesita sincronización&#10;        val shouldSync = shouldSyncPlaylists(localPlaylists)&#10;&#10;        return@withContext if (shouldSync) {&#10;            Log.d(TAG, &quot;Iniciando sincronización de playlists&quot;)&#10;            syncPlaylistsFromSpotify()&#10;            playlistDao.getAllPlaylistsSync()&#10;        } else {&#10;            Log.d(TAG, &quot;Las playlists están actualizadas&quot;)&#10;            localPlaylists&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los tracks de una playlist con sincronización automática.&#10;     * Verifica si es necesario sincronizar con Spotify y lo hace automáticamente.&#10;     *&#10;     * @param playlistId ID de la playlist&#10;     * @return Lista de tracks actualizados&#10;     */&#10;    suspend fun getTracksWithAutoSync(playlistId: String): List&lt;TrackEntity&gt; =&#10;        withContext(Dispatchers.IO) {&#10;            Log.d(TAG, &quot;Obteniendo tracks para playlist $playlistId con sincronización automática&quot;)&#10;&#10;            val localTracks = trackDao.getTracksByPlaylistSync(playlistId)&#10;            val playlist = playlistDao.getPlaylistById(playlistId)&#10;&#10;            // Verificar si necesita sincronización&#10;            val shouldSync = shouldSyncTracks(playlist)&#10;&#10;            if (shouldSync) {&#10;                Log.d(TAG, &quot;Iniciando sincronización de tracks para playlist $playlistId&quot;)&#10;                syncTracksFromSpotify(playlistId)&#10;                trackDao.getTracksByPlaylistSync(playlistId)&#10;            } else {&#10;                Log.d(TAG, &quot;Los tracks están actualizados&quot;)&#10;                localTracks&#10;            }&#10;        }&#10;&#10;    // === MÉTODOS PÚBLICOS - SINCRONIZACIÓN MANUAL ===&#10;&#10;    /**&#10;     * Sincroniza todas las playlists desde Spotify de forma manual.&#10;     *&#10;     * @return true si la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun syncPlaylistsFromSpotify(): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            Log.d(TAG, &quot;Sincronizando playlists desde Spotify&quot;)&#10;&#10;            val accessToken = getValidAccessToken()&#10;            if (accessToken == null) {&#10;                Log.e(TAG, &quot;No se pudo obtener token de acceso válido&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            var success = false&#10;            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#10;                if (error != null) {&#10;                    Log.e(TAG, &quot;Error al obtener playlists: $error&quot;)&#10;                } else if (playlists != null) {&#10;                    Log.d(TAG, &quot;Recibidas ${playlists.size} playlists de Spotify&quot;)&#10;&#10;                    // Convertir y guardar playlists&#10;                    val playlistEntities = playlists.map { playlist -&gt;&#10;                        PlaylistEntity(&#10;                            spotifyId = playlist.id,&#10;                            name = playlist.name,&#10;                            description = playlist.description,&#10;                            trackCount = playlist.tracks?.total ?: 0,&#10;                            imageUrl = playlist.getImageUrl(),&#10;                            lastSyncTime = System.currentTimeMillis()&#10;                        )&#10;                    }&#10;&#10;                    // Usar runBlocking dentro del callback para operaciones suspend&#10;                    kotlinx.coroutines.runBlocking {&#10;                        playlistDao.insertPlaylists(playlistEntities)&#10;                        Log.d(&#10;                            TAG,&#10;                            &quot;Guardadas ${playlistEntities.size} playlists en base de datos local&quot;&#10;                        )&#10;                    }&#10;                    success = true&#10;                }&#10;            }&#10;&#10;            // Esperar a que termine el callback&#10;            var attempts = 0&#10;            while (!success &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                kotlinx.coroutines.delay(100)&#10;                attempts++&#10;            }&#10;&#10;            success&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error en sincronización de playlists&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sincroniza los tracks de una playlist específica desde Spotify.&#10;     *&#10;     * @param playlistId ID de la playlist a sincronizar&#10;     * @return true si la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun syncTracksFromSpotify(playlistId: String): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            Log.d(TAG, &quot;Sincronizando tracks para playlist $playlistId desde Spotify&quot;)&#10;&#10;            val accessToken = getValidAccessToken()&#10;            if (accessToken == null) {&#10;                Log.e(TAG, &quot;No se pudo obtener token de acceso válido&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            var success = false&#10;            SpotifyRepository.getPlaylistTracks(accessToken, playlistId) { tracks, error -&gt;&#10;                if (error != null) {&#10;                    Log.e(TAG, &quot;Error al obtener tracks: $error&quot;)&#10;                } else if (tracks != null) {&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Recibidos ${tracks.size} tracks de Spotify para playlist $playlistId&quot;&#10;                    )&#10;&#10;                    // Convertir y guardar tracks&#10;                    val trackEntities = tracks.mapIndexedNotNull { index, playlistTrack -&gt;&#10;                        val track = playlistTrack.track&#10;                        if (track != null) {&#10;                            TrackEntity(&#10;                                id = &quot;${playlistId}_${track.id}&quot;,&#10;                                playlistId = playlistId,&#10;                                spotifyTrackId = track.id,&#10;                                name = track.name,&#10;                                artists = track.getArtistNames(),&#10;                                youtubeVideoId = null, // Se llenará después si es necesario&#10;                                position = index,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        } else {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    // Usar runBlocking dentro del callback&#10;                    kotlinx.coroutines.runBlocking {&#10;                        // Eliminar tracks antiguos de esta playlist&#10;                        trackDao.deleteTracksByPlaylist(playlistId)&#10;                        // Insertar nuevos tracks&#10;                        trackDao.insertTracks(trackEntities)&#10;&#10;                        // Actualizar tiempo de sincronización de la playlist&#10;                        val playlist = playlistDao.getPlaylistById(playlistId)&#10;                        playlist?.let {&#10;                            playlistDao.updatePlaylist(it.copy(lastSyncTime = System.currentTimeMillis()))&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;Guardados ${trackEntities.size} tracks en base de datos local&quot;)&#10;                    }&#10;                    success = true&#10;                }&#10;            }&#10;&#10;            // Esperar a que termine el callback&#10;            var attempts = 0&#10;            while (!success &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                kotlinx.coroutines.delay(100)&#10;                attempts++&#10;            }&#10;&#10;            success&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error en sincronización de tracks&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el YouTube video ID para un track específico.&#10;     * Permite asociar un video de YouTube con un track de Spotify.&#10;     *&#10;     * @param trackId ID único del track&#10;     * @param youtubeVideoId ID del video de YouTube&#10;     */&#10;    suspend fun updateTrackYoutubeId(trackId: String, youtubeVideoId: String) =&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                trackDao.updateYoutubeVideoId(trackId, youtubeVideoId)&#10;                Log.d(TAG, &quot;YouTube ID actualizado para track $trackId: $youtubeVideoId&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error actualizando YouTube ID&quot;, e)&#10;            }&#10;        }&#10;&#10;    // === MÉTODOS PRIVADOS - VERIFICACIÓN DE SINCRONIZACIÓN ===&#10;&#10;    /**&#10;     * Verifica si las playlists necesitan sincronización con Spotify.&#10;     *&#10;     * @param localPlaylists Lista de playlists locales&#10;     * @return true si necesita sincronización, false en caso contrario&#10;     */&#10;    private suspend fun shouldSyncPlaylists(localPlaylists: List&lt;PlaylistEntity&gt;): Boolean {&#10;        if (localPlaylists.isEmpty()) {&#10;            Log.d(TAG, &quot;No hay playlists locales, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val oldestSync = localPlaylists.minOfOrNull { it.lastSyncTime } ?: 0L&#10;        val needsSync = (System.currentTimeMillis() - oldestSync) &gt; SYNC_INTERVAL&#10;&#10;        Log.d(TAG, &quot;Verificación de sincronización de playlists: needsSync=$needsSync&quot;)&#10;        return needsSync&#10;    }&#10;&#10;    /**&#10;     * Verifica si los tracks de una playlist necesitan sincronización.&#10;     *&#10;     * @param playlist Entidad de la playlist a verificar&#10;     * @return true si necesita sincronización, false en caso contrario&#10;     */&#10;    private suspend fun shouldSyncTracks(playlist: PlaylistEntity?): Boolean {&#10;        if (playlist == null) {&#10;            Log.d(TAG, &quot;Playlist no encontrada, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val localTracks = trackDao.getTracksByPlaylistSync(playlist.spotifyId)&#10;        if (localTracks.isEmpty()) {&#10;            Log.d(TAG, &quot;No hay tracks locales, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val needsSync = (System.currentTimeMillis() - playlist.lastSyncTime) &gt; SYNC_INTERVAL&#10;        Log.d(TAG, &quot;Verificación de sincronización de tracks: needsSync=$needsSync&quot;)&#10;        return needsSync&#10;    }&#10;&#10;    /**&#10;     * Obtiene un token de acceso válido para Spotify.&#10;     * Intenta usar el token actual o refrescarlo automáticamente.&#10;     *&#10;     * @return Token de acceso válido o null si no se pudo obtener&#10;     */&#10;    private suspend fun getValidAccessToken(): String? = withContext(Dispatchers.IO) {&#10;        val accessToken = Config.getSpotifyAccessToken(appContext)&#10;        if (accessToken != null) {&#10;            return@withContext accessToken&#10;        }&#10;&#10;        val refreshToken = Config.getSpotifyRefreshToken(appContext)&#10;        if (refreshToken != null) {&#10;            var newToken: String? = null&#10;            SpotifyRepository.refreshAccessToken(appContext, refreshToken) { token, error -&gt;&#10;                if (token != null) {&#10;                    Config.setSpotifyTokens(appContext, token, refreshToken, 3600)&#10;                    newToken = token&#10;                }&#10;            }&#10;&#10;            // Esperar respuesta&#10;            var attempts = 0&#10;            while (newToken == null &amp;&amp; attempts &lt; 30) {&#10;                kotlinx.coroutines.delay(100)&#10;                attempts++&#10;            }&#10;&#10;            return@withContext newToken&#10;        }&#10;&#10;        return@withContext null&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - OPERACIONES ESPECIALES ===&#10;&#10;    /**&#10;     * Fuerza una sincronización completa de todas las playlists y tracks.&#10;     * Útil para refrescar completamente los datos locales.&#10;     *&#10;     * @return true si toda la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun forceSyncAll(): Boolean = withContext(Dispatchers.IO) {&#10;        Log.d(TAG, &quot;Forzando sincronización completa&quot;)&#10;        val playlistsSuccess = syncPlaylistsFromSpotify()&#10;&#10;        if (playlistsSuccess) {&#10;            val playlists = playlistDao.getAllPlaylistsSync()&#10;            var allTracksSuccess = true&#10;&#10;            for (playlist in playlists) {&#10;                val tracksSuccess = syncTracksFromSpotify(playlist.spotifyId)&#10;                if (!tracksSuccess) {&#10;                    allTracksSuccess = false&#10;                }&#10;            }&#10;&#10;            return@withContext allTracksSuccess&#10;        }&#10;&#10;        return@withContext false&#10;    }&#10;&#10;    /**&#10;     * Limpia todos los datos locales de playlists y tracks.&#10;     * Útil para reset completo o troubleshooting.&#10;     */&#10;    suspend fun clearAllData() = withContext(Dispatchers.IO) {&#10;        try {&#10;            trackDao.deleteAllTracks()&#10;            playlistDao.deleteAllPlaylists()&#10;            Log.d(TAG, &quot;Datos locales limpiados&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error limpiando datos locales&quot;, e)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.database&#10;&#10;import android.content.Context&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.asLiveData&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyTokenManager&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import android.util.Log&#10;&#10;/**&#10; * PlaylistLocalRepository - Repositorio para gestión local de playlists y tracks&#10; * &#10; * Esta clase maneja:&#10; * - Operaciones CRUD sobre playlists y tracks en base de datos local&#10; * - Sincronización automática con Spotify&#10; * - Caché inteligente para evitar consultas innecesarias&#10; * - Observación de cambios mediante LiveData/Flow&#10; * - Gestión de YouTube IDs para tracks&#10; * &#10; * Proporciona una capa de abstracción entre la UI y la base de datos,&#10; * asegurando que los datos estén siempre actualizados y sincronizados.&#10; */&#10;class PlaylistLocalRepository(context: Context) {&#10;&#10;    // === PROPIEDADES ===&#10;&#10;    /** Base de datos local para playlists y tracks */&#10;    private val database = PlaylistDatabase.getDatabase(context)&#10;&#10;    /** DAO para operaciones sobre playlists */&#10;    private val playlistDao = database.playlistDao()&#10;&#10;    /** DAO para operaciones sobre tracks */&#10;    private val trackDao = database.trackDao()&#10;&#10;    /** Contexto de aplicación para operaciones persistentes */&#10;    private val appContext = context.applicationContext&#10;&#10;    // === CONSTANTES ===&#10;&#10;    companion object {&#10;        private const val TAG = &quot;PlaylistLocalRepo&quot;&#10;&#10;        /** Intervalo de sincronización automática (24 horas) */&#10;        private const val SYNC_INTERVAL = 24 * 60 * 60 * 1000L&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - OBSERVACIÓN DE DATOS ===&#10;&#10;    /**&#10;     * Observa todas las playlists locales mediante LiveData.&#10;     * Los cambios se notifican automáticamente a los observadores.&#10;     *&#10;     * @return LiveData que emite la lista de playlists cuando cambian&#10;     */&#10;    fun getAllPlaylistsLiveData(): LiveData&lt;List&lt;PlaylistEntity&gt;&gt; {&#10;        return playlistDao.getAllPlaylists().asLiveData()&#10;    }&#10;&#10;    /**&#10;     * Observa los tracks de una playlist específica.&#10;     *&#10;     * @param playlistId ID de la playlist a observar&#10;     * @return LiveData que emite los tracks cuando cambian&#10;     */&#10;    fun getTracksByPlaylistLiveData(playlistId: String): LiveData&lt;List&lt;TrackEntity&gt;&gt; {&#10;        return trackDao.getTracksByPlaylist(playlistId).asLiveData()&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - SINCRONIZACIÓN AUTOMÁTICA ===&#10;&#10;    /**&#10;     * Obtiene todas las playlists con sincronización automática.&#10;     * Verifica si es necesario sincronizar con Spotify y lo hace automáticamente.&#10;     *&#10;     * @return Lista de playlists actualizadas&#10;     */&#10;    suspend fun getPlaylistsWithAutoSync(): List&lt;PlaylistEntity&gt; = withContext(Dispatchers.IO) {&#10;        Log.d(TAG, &quot;Obteniendo playlists con sincronización automática&quot;)&#10;&#10;        val localPlaylists = playlistDao.getAllPlaylistsSync()&#10;&#10;        // Verificar si necesita sincronización&#10;        val shouldSync = shouldSyncPlaylists(localPlaylists)&#10;&#10;        return@withContext if (shouldSync) {&#10;            Log.d(TAG, &quot;Iniciando sincronización de playlists&quot;)&#10;            syncPlaylistsFromSpotify()&#10;            playlistDao.getAllPlaylistsSync()&#10;        } else {&#10;            Log.d(TAG, &quot;Las playlists están actualizadas&quot;)&#10;            localPlaylists&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene los tracks de una playlist con sincronización automática.&#10;     * Verifica si es necesario sincronizar con Spotify y lo hace automáticamente.&#10;     *&#10;     * @param playlistId ID de la playlist&#10;     * @return Lista de tracks actualizados&#10;     */&#10;    suspend fun getTracksWithAutoSync(playlistId: String): List&lt;TrackEntity&gt; =&#10;        withContext(Dispatchers.IO) {&#10;            Log.d(TAG, &quot;Obteniendo tracks para playlist $playlistId con sincronización automática&quot;)&#10;&#10;            val localTracks = trackDao.getTracksByPlaylistSync(playlistId)&#10;            val playlist = playlistDao.getPlaylistById(playlistId)&#10;&#10;            // Verificar si necesita sincronización&#10;            val shouldSync = shouldSyncTracks(playlist)&#10;&#10;            if (shouldSync) {&#10;                Log.d(TAG, &quot;Iniciando sincronización de tracks para playlist $playlistId&quot;)&#10;                syncTracksFromSpotify(playlistId)&#10;                trackDao.getTracksByPlaylistSync(playlistId)&#10;            } else {&#10;                Log.d(TAG, &quot;Los tracks están actualizados&quot;)&#10;                localTracks&#10;            }&#10;        }&#10;&#10;    // === MÉTODOS PÚBLICOS - SINCRONIZACIÓN MANUAL ===&#10;&#10;    /**&#10;     * Sincroniza todas las playlists desde Spotify de forma manual.&#10;     *&#10;     * @return true si la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun syncPlaylistsFromSpotify(): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            Log.d(TAG, &quot;Sincronizando playlists desde Spotify&quot;)&#10;&#10;            val accessToken = getValidAccessToken()&#10;            if (accessToken == null) {&#10;                Log.e(TAG, &quot;No se pudo obtener token de acceso válido&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            var success = false&#10;            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#10;                if (error != null) {&#10;                    Log.e(TAG, &quot;Error al obtener playlists: $error&quot;)&#10;                } else if (playlists != null) {&#10;                    Log.d(TAG, &quot;Recibidas ${playlists.size} playlists de Spotify&quot;)&#10;&#10;                    // Convertir y guardar playlists&#10;                    val playlistEntities = playlists.map { playlist -&gt;&#10;                        PlaylistEntity(&#10;                            spotifyId = playlist.id,&#10;                            name = playlist.name,&#10;                            description = playlist.description,&#10;                            trackCount = playlist.tracks?.total ?: 0,&#10;                            imageUrl = playlist.getImageUrl(),&#10;                            lastSyncTime = System.currentTimeMillis()&#10;                        )&#10;                    }&#10;&#10;                    // Usar runBlocking dentro del callback para operaciones suspend&#10;                    kotlinx.coroutines.runBlocking {&#10;                        playlistDao.insertPlaylists(playlistEntities)&#10;                        Log.d(&#10;                            TAG,&#10;                            &quot;Guardadas ${playlistEntities.size} playlists en base de datos local&quot;&#10;                        )&#10;                    }&#10;                    success = true&#10;                }&#10;            }&#10;&#10;            // Esperar a que termine el callback&#10;            var attempts = 0&#10;            while (!success &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                kotlinx.coroutines.delay(100)&#10;                attempts++&#10;            }&#10;&#10;            success&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error en sincronización de playlists&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Sincroniza los tracks de una playlist específica desde Spotify.&#10;     *&#10;     * @param playlistId ID de la playlist a sincronizar&#10;     * @return true si la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun syncTracksFromSpotify(playlistId: String): Boolean = withContext(Dispatchers.IO) {&#10;        try {&#10;            Log.d(TAG, &quot;Sincronizando tracks para playlist $playlistId desde Spotify&quot;)&#10;&#10;            val accessToken = getValidAccessToken()&#10;            if (accessToken == null) {&#10;                Log.e(TAG, &quot;No se pudo obtener token de acceso válido&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            var success = false&#10;            SpotifyRepository.getPlaylistTracks(accessToken, playlistId) { tracks, error -&gt;&#10;                if (error != null) {&#10;                    Log.e(TAG, &quot;Error al obtener tracks: $error&quot;)&#10;                } else if (tracks != null) {&#10;                    Log.d(&#10;                        TAG,&#10;                        &quot;Recibidos ${tracks.size} tracks de Spotify para playlist $playlistId&quot;&#10;                    )&#10;&#10;                    // Convertir y guardar tracks&#10;                    val trackEntities = tracks.mapIndexedNotNull { index, playlistTrack -&gt;&#10;                        val track = playlistTrack.track&#10;                        if (track != null) {&#10;                            TrackEntity(&#10;                                id = &quot;${playlistId}_${track.id}&quot;,&#10;                                playlistId = playlistId,&#10;                                spotifyTrackId = track.id,&#10;                                name = track.name,&#10;                                artists = track.getArtistNames(),&#10;                                youtubeVideoId = null, // Se llenará después si es necesario&#10;                                position = index,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        } else {&#10;                            null&#10;                        }&#10;                    }&#10;&#10;                    // Usar runBlocking dentro del callback&#10;                    kotlinx.coroutines.runBlocking {&#10;                        // Eliminar tracks antiguos de esta playlist&#10;                        trackDao.deleteTracksByPlaylist(playlistId)&#10;                        // Insertar nuevos tracks&#10;                        trackDao.insertTracks(trackEntities)&#10;&#10;                        // Actualizar tiempo de sincronización de la playlist&#10;                        val playlist = playlistDao.getPlaylistById(playlistId)&#10;                        playlist?.let {&#10;                            playlistDao.updatePlaylist(it.copy(lastSyncTime = System.currentTimeMillis()))&#10;                        }&#10;&#10;                        Log.d(TAG, &quot;Guardados ${trackEntities.size} tracks en base de datos local&quot;)&#10;                    }&#10;                    success = true&#10;                }&#10;            }&#10;&#10;            // Esperar a que termine el callback&#10;            var attempts = 0&#10;            while (!success &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                kotlinx.coroutines.delay(100)&#10;                attempts++&#10;            }&#10;&#10;            success&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error en sincronización de tracks&quot;, e)&#10;            false&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Actualiza el YouTube video ID para un track específico.&#10;     * Permite asociar un video de YouTube con un track de Spotify.&#10;     *&#10;     * @param trackId ID único del track&#10;     * @param youtubeVideoId ID del video de YouTube&#10;     */&#10;    suspend fun updateTrackYoutubeId(trackId: String, youtubeVideoId: String) =&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                trackDao.updateYoutubeVideoId(trackId, youtubeVideoId)&#10;                Log.d(TAG, &quot;YouTube ID actualizado para track $trackId: $youtubeVideoId&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error actualizando YouTube ID&quot;, e)&#10;            }&#10;        }&#10;&#10;    // === MÉTODOS PRIVADOS - VERIFICACIÓN DE SINCRONIZACIÓN ===&#10;&#10;    /**&#10;     * Verifica si las playlists necesitan sincronización con Spotify.&#10;     *&#10;     * @param localPlaylists Lista de playlists locales&#10;     * @return true si necesita sincronización, false en caso contrario&#10;     */&#10;    private suspend fun shouldSyncPlaylists(localPlaylists: List&lt;PlaylistEntity&gt;): Boolean {&#10;        if (localPlaylists.isEmpty()) {&#10;            Log.d(TAG, &quot;No hay playlists locales, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val oldestSync = localPlaylists.minOfOrNull { it.lastSyncTime } ?: 0L&#10;        val needsSync = (System.currentTimeMillis() - oldestSync) &gt; SYNC_INTERVAL&#10;&#10;        Log.d(TAG, &quot;Verificación de sincronización de playlists: needsSync=$needsSync&quot;)&#10;        return needsSync&#10;    }&#10;&#10;    /**&#10;     * Verifica si los tracks de una playlist necesitan sincronización.&#10;     *&#10;     * @param playlist Entidad de la playlist a verificar&#10;     * @return true si necesita sincronización, false en caso contrario&#10;     */&#10;    private suspend fun shouldSyncTracks(playlist: PlaylistEntity?): Boolean {&#10;        if (playlist == null) {&#10;            Log.d(TAG, &quot;Playlist no encontrada, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val localTracks = trackDao.getTracksByPlaylistSync(playlist.spotifyId)&#10;        if (localTracks.isEmpty()) {&#10;            Log.d(TAG, &quot;No hay tracks locales, necesita sincronización&quot;)&#10;            return true&#10;        }&#10;&#10;        val needsSync = (System.currentTimeMillis() - playlist.lastSyncTime) &gt; SYNC_INTERVAL&#10;        Log.d(TAG, &quot;Verificación de sincronización de tracks: needsSync=$needsSync&quot;)&#10;        return needsSync&#10;    }&#10;&#10;    /**&#10;     * Obtiene un token de acceso válido para Spotify.&#10;     * Usa el nuevo SpotifyTokenManager para renovación automática.&#10;     *&#10;     * @return Token de acceso válido o null si no se pudo obtener&#10;     */&#10;    private suspend fun getValidAccessToken(): String? = withContext(Dispatchers.IO) {&#10;        return@withContext SpotifyTokenManager.getValidAccessToken(appContext)&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS - OPERACIONES ESPECIALES ===&#10;&#10;    /**&#10;     * Fuerza una sincronización completa de todas las playlists y tracks.&#10;     * Útil para refrescar completamente los datos locales.&#10;     *&#10;     * @return true si toda la sincronización fue exitosa, false en caso contrario&#10;     */&#10;    suspend fun forceSyncAll(): Boolean = withContext(Dispatchers.IO) {&#10;        Log.d(TAG, &quot;Forzando sincronización completa&quot;)&#10;        val playlistsSuccess = syncPlaylistsFromSpotify()&#10;&#10;        if (playlistsSuccess) {&#10;            val playlists = playlistDao.getAllPlaylistsSync()&#10;            var allTracksSuccess = true&#10;&#10;            for (playlist in playlists) {&#10;                val tracksSuccess = syncTracksFromSpotify(playlist.spotifyId)&#10;                if (!tracksSuccess) {&#10;                    allTracksSuccess = false&#10;                }&#10;            }&#10;&#10;            return@withContext allTracksSuccess&#10;        }&#10;&#10;        return@withContext false&#10;    }&#10;&#10;    /**&#10;     * Limpia todos los datos locales de playlists y tracks.&#10;     * Útil para reset completo o troubleshooting.&#10;     */&#10;    suspend fun clearAllData() = withContext(Dispatchers.IO) {&#10;        try {&#10;            trackDao.deleteAllTracks()&#10;            playlistDao.deleteAllPlaylists()&#10;            Log.d(TAG, &quot;Datos locales limpiados&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error limpiando datos locales&quot;, e)&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SpotifyRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SpotifyRepository.kt" />
              <option name="originalContent" value="package com.plyr.network&#10;&#10;import com.google.gson.Gson&#10;import com.google.gson.annotations.SerializedName&#10;import okhttp3.*&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import android.util.Base64&#10;import android.content.Context&#10;import com.plyr.utils.Config&#10;&#10;object SpotifyRepository {&#10;    &#10;    private val client = OkHttpClient()&#10;    private val gson = Gson()&#10;    &#10;    // URLs de Spotify&#10;    private const val AUTH_URL = &quot;https://accounts.spotify.com/authorize&quot;&#10;    private const val TOKEN_URL = &quot;https://accounts.spotify.com/api/token&quot;&#10;    private const val API_BASE_URL = &quot;https://api.spotify.com/v1&quot;&#10;    &#10;    // Generar URL de autorización&#10;    fun getAuthorizationUrl(context: Context): String? {&#10;        val clientId = Config.getSpotifyClientId(context)&#10;        return if (clientId != null) {&#10;            &quot;$AUTH_URL?client_id=$clientId&amp;response_type=code&amp;redirect_uri=${Config.SPOTIFY_REDIRECT_URI}&amp;scope=${Config.SPOTIFY_SCOPES.replace(&quot; &quot;, &quot;%20&quot;)}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    &#10;    // Iniciar flujo OAuth (abrir browser)&#10;    fun startOAuthFlow(context: Context): Boolean {&#10;        val authUrl = getAuthorizationUrl(context)&#10;        return if (authUrl != null) {&#10;            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(authUrl))&#10;            context.startActivity(intent)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;    &#10;    // Intercambiar código de autorización por tokens&#10;    fun exchangeCodeForTokens(context: Context, authCode: String, callback: (SpotifyTokens?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        if (authHeader == null) {&#10;            callback(null, &quot;Failed to create auth header&quot;)&#10;            return&#10;        }&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;authorization_code&quot;)&#10;            .add(&quot;code&quot;, authCode)&#10;            .add(&quot;redirect_uri&quot;, Config.SPOTIFY_REDIRECT_URI)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing tokens: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Renovar access token usando refresh token&#10;    fun refreshAccessToken(context: Context, refreshToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        if (authHeader == null) {&#10;            callback(null, &quot;Failed to create auth header&quot;)&#10;            return&#10;        }&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;refresh_token&quot;)&#10;            .add(&quot;refresh_token&quot;, refreshToken)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens.accessToken, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing token: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Obtener playlists del usuario con paginación&#10;    fun getUserPlaylists(accessToken: String, callback: (List&lt;SpotifyPlaylist&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/playlists?limit=$maxLimit&amp;offset=$offset&amp;fields=items(id,name,description,tracks(total),images)&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User playlists response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val playlistResponse = gson.fromJson(body, SpotifyPlaylistResponse::class.java)&#10;                            &#10;                            // Debug: log tracks data for each playlist&#10;                            playlistResponse.items.forEachIndexed { index, playlist -&gt;&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist $index - '${playlist.name}': tracks=${playlist.tracks}, tracks.total=${playlist.tracks?.total}&quot;)&#10;                            }&#10;                            &#10;                            // Acumular resultados&#10;                            allPlaylists.addAll(playlistResponse.items)&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${playlistResponse.items.size} playlists, total accumulated: ${allPlaylists.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allPlaylists.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMorePlaylists = playlistResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMorePlaylists &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlists page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlists count: ${allPlaylists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de un álbum con paginación&#10;    fun getAlbumTracks(accessToken: String, albumId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/albums/$albumId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyTracksSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next album tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final album tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing album tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de una playlist con paginación&#10;    fun getPlaylistTracks(accessToken: String, playlistId: String, callback: (List&lt;SpotifyPlaylistTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allTracks = mutableListOf&lt;SpotifyPlaylistTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyPlaylistTracksResponseRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlist tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlist tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlist tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener álbumes de un artista con paginación&#10;    fun getArtistAlbums(accessToken: String, artistId: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/artists/$artistId/albums?include_groups=album,single&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val albumsResponse = gson.fromJson(body, SpotifyAlbumsSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allAlbums.addAll(albumsResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albumsResponse.items.filterNotNull().size} albums, total accumulated: ${allAlbums.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = albumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next artist albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final artist albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing artist albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Buscar todo tipo de contenido en Spotify (canciones, álbumes, artistas, playlists)&#10;    fun searchAll(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=50&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search all response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchAllResponse::class.java)&#10;                        callback(searchResponse, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Buscar canciones en Spotify (función mantenida para compatibilidad)&#10;    fun searchTracks(accessToken: String, query: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track&amp;limit=20&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchResponseRaw::class.java)&#10;                        callback(searchResponse.tracks.items.filterNotNull(), null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Seguir una playlist en Spotify&#10;    fun followPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(RequestBody.create(&quot;application/json&quot;.toMediaType(), &quot;{}&quot;))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body?.string()&#10;                    &#10;                    // Detectar error de scopes insuficientes&#10;                    if (response.code == 403 &amp;&amp; errorBody?.contains(&quot;Insufficient client scope&quot;) == true) {&#10;                        callback(false, &quot;Permisos insuficientes. Desconecta y vuelve a conectar Spotify para obtener todos los permisos necesarios.&quot;)&#10;                    } else {&#10;                        callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Guardar un álbum en la biblioteca de Spotify&#10;    fun saveAlbum(accessToken: String, albumId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/me/albums&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(RequestBody.create(&quot;application/json&quot;.toMediaType(), &quot;&quot;&quot;{&quot;ids&quot;:[&quot;$albumId&quot;]}&quot;&quot;&quot;))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body?.string()&#10;                    &#10;                    // Detectar error de scopes insuficientes&#10;                    if (response.code == 403 &amp;&amp; errorBody?.contains(&quot;Insufficient client scope&quot;) == true) {&#10;                        callback(false, &quot;Permisos insuficientes. Desconecta y vuelve a conectar Spotify para obtener todos los permisos necesarios.&quot;)&#10;                    } else {&#10;                        callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Buscar todo tipo de contenido en Spotify con paginación automática optimizada&#10;    fun searchAllWithPagination(&#10;        accessToken: String, &#10;        query: String, &#10;        callback: (SpotifySearchAllResponse?, String?) -&gt; Unit // Simplificamos el callback&#10;    ) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        &#10;        // Variables para acumular resultados&#10;        var allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var allArtists = mutableListOf&lt;SpotifyArtistFull&gt;()&#10;        var allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        &#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search paginated response (offset=$offset) body excerpt: ${body.take(500)}...&quot;)&#10;                            val searchResponseRaw = gson.fromJson(body, SpotifySearchAllResponseRaw::class.java)&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Parsed response - tracks: ${searchResponseRaw.tracks.items.size}, albums: ${searchResponseRaw.albums.items.size}, artists: ${searchResponseRaw.artists.items.size}, playlists: ${searchResponseRaw.playlists.items.size}&quot;)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(searchResponseRaw.tracks.items.filterNotNull())&#10;                            allAlbums.addAll(searchResponseRaw.albums.items.filterNotNull())&#10;                            allArtists.addAll(searchResponseRaw.artists.items.filterNotNull())&#10;                            allPlaylists.addAll(searchResponseRaw.playlists.items.filterNotNull())&#10;                            &#10;                            pageCount++&#10;                            &#10;                            // Enviar resultados después de cada página para mostrar progreso&#10;                            val currentResponse = SpotifySearchAllResponse(&#10;                                tracks = SpotifyTracksSearchResult(&#10;                                    items = allTracks.distinctBy { it.id },&#10;                                    total = searchResponseRaw.tracks.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.tracks.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                albums = SpotifyAlbumsSearchResult(&#10;                                    items = allAlbums.distinctBy { it.id },&#10;                                    total = searchResponseRaw.albums.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.albums.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                artists = SpotifyArtistsSearchResult(&#10;                                    items = allArtists.distinctBy { it.id },&#10;                                    total = searchResponseRaw.artists.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.artists.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                playlists = SpotifyPlaylistsSearchResult(&#10;                                    items = allPlaylists.distinctBy { it.id },&#10;                                    total = searchResponseRaw.playlists.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.playlists.items.size == maxLimit) &quot;more&quot; else null&#10;                                )&#10;                            )&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount sent: ${allTracks.size} tracks, ${allAlbums.size} albums, ${allArtists.size} artists, ${allPlaylists.size} playlists&quot;)&#10;                            callback(currentResponse, null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = searchResponseRaw.tracks.items.size == maxLimit &amp;&amp; allTracks.size &lt; (searchResponseRaw.tracks.total ?: 0)&#10;                            val hasMoreAlbums = searchResponseRaw.albums.items.size == maxLimit &amp;&amp; allAlbums.size &lt; (searchResponseRaw.albums.total ?: 0)&#10;                            val hasMoreArtists = searchResponseRaw.artists.items.size == maxLimit &amp;&amp; allArtists.size &lt; (searchResponseRaw.artists.total ?: 0)&#10;                            val hasMorePlaylists = searchResponseRaw.playlists.items.size == maxLimit &amp;&amp; allPlaylists.size &lt; (searchResponseRaw.playlists.total ?: 0)&#10;                            &#10;                            // Verificar si el próximo offset excedería el límite de Spotify (1000)&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido en cualquier categoría y no excedemos el límite, continuar paginando&#10;                            if ((hasMoreTracks || hasMoreAlbums || hasMoreArtists || hasMorePlaylists) &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next page: offset=$nextOffset&quot;)&#10;                                // Agregar un pequeño delay para no sobrecargar la API&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200) // 200ms de delay entre requests&#10;                            } else {&#10;                                // Paginación completada (por límite de API o porque no hay más resultados)&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Pagination stopped: reached Spotify API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final results: ${allTracks.size} tracks, ${allAlbums.size} albums, ${allArtists.size} artists, ${allPlaylists.size} playlists&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Obtener el user_id del usuario actual&#10;    fun getCurrentUserId(accessToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/me&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Network error: ${e.message}&quot;)&#10;            }&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val json = gson.fromJson(body, Map::class.java)&#10;                        val userId = json[&quot;id&quot;] as? String&#10;                        callback(userId, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing user id: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;HTTP error ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Crear playlist&#10;    fun createPlaylist(&#10;        accessToken: String,&#10;        name: String,&#10;        description: String,&#10;        isPublic: Boolean,&#10;        callback: (Boolean, String?) -&gt; Unit&#10;    ) {&#10;        getCurrentUserId(accessToken) { userId, error -&gt;&#10;            if (userId == null) {&#10;                callback(false, error ?: &quot;Could not get user id&quot;)&#10;                return@getCurrentUserId&#10;            }&#10;            val url = &quot;https://api.spotify.com/v1/users/$userId/playlists&quot;&#10;            val jsonBody = &quot;&quot;&quot;&#10;            {&#10;                &quot;name&quot;: &quot;$name&quot;,&#10;                &quot;description&quot;: &quot;$description&quot;,&#10;                &quot;public&quot;: $isPublic&#10;            }&#10;        &quot;&quot;&quot;.trimIndent()&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .post(jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;                .build()&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(false, &quot;Network error: ${e.message}&quot;)&#10;                }&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    if (response.isSuccessful) {&#10;                        callback(true, null)&#10;                    } else {&#10;                        val errorBody = response.body?.string()&#10;                        callback(false, &quot;HTTP error ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    private fun createBasicAuthHeader(context: Context): String {&#10;        val credentials = &quot;${Config.getSpotifyClientId(context)}:${Config.getSpotifyClientSecret(context)}&quot;&#10;        val encodedCredentials = Base64.encodeToString(credentials.toByteArray(), Base64.NO_WRAP)&#10;        return &quot;Basic $encodedCredentials&quot;&#10;    }&#10;}&#10;&#10;&#10;// Data classes para Spotify API&#10;data class SpotifyTokens(&#10;    @SerializedName(&quot;access_token&quot;) val accessToken: String,&#10;    @SerializedName(&quot;token_type&quot;) val tokenType: String,&#10;    @SerializedName(&quot;scope&quot;) val scope: String,&#10;    @SerializedName(&quot;expires_in&quot;) val expiresIn: Int,&#10;    @SerializedName(&quot;refresh_token&quot;) val refreshToken: String?&#10;)&#10;&#10;data class SpotifyPlaylistResponse(&#10;    val items: List&lt;SpotifyPlaylist&gt;&#10;)&#10;&#10;data class SpotifyPlaylist(&#10;    val id: String,&#10;    val name: String,&#10;    val description: String?,&#10;    val tracks: SpotifyPlaylistTracks?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;) {&#10;    fun getTrackCount(): String {&#10;        return tracks?.total?.let { &quot;$it songs&quot; } ?: &quot;0 songs&quot;&#10;    }&#10;    &#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyPlaylistTracks(&#10;    val href: String?,&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyImage(&#10;    val url: String,&#10;    val height: Int?,&#10;    val width: Int?&#10;)&#10;&#10;data class SpotifyTracksResponse(&#10;    val items: List&lt;SpotifyTrackItem&gt;&#10;)&#10;&#10;data class SpotifyTrackItem(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;data class SpotifyTrack(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    @SerializedName(&quot;duration_ms&quot;) val durationMs: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;    &#10;    fun getDurationText(): String {&#10;        return durationMs?.let {&#10;            val minutes = it / 60000&#10;            val seconds = (it % 60000) / 1000&#10;            &quot;${minutes}:${seconds.toString().padStart(2, '0')}&quot;&#10;        } ?: &quot;0:00&quot;&#10;    }&#10;}&#10;&#10;data class SpotifySearchResponse(&#10;    val tracks: SpotifyTracksSearchResult&#10;)&#10;&#10;data class SpotifySearchResponseRaw(&#10;    val tracks: SpotifyTracksSearchResultRaw&#10;)&#10;&#10;data class SpotifySearchAllResponse(&#10;    val tracks: SpotifyTracksSearchResult,&#10;    val albums: SpotifyAlbumsSearchResult,&#10;    val artists: SpotifyArtistsSearchResult,&#10;    val playlists: SpotifyPlaylistsSearchResult&#10;)&#10;&#10;data class SpotifyTracksSearchResult(&#10;    val items: List&lt;SpotifyTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResult(&#10;    val items: List&lt;SpotifyAlbum&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResult(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResult(&#10;    val items: List&lt;SpotifyPlaylist&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbum(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    @SerializedName(&quot;release_date&quot;) val release_date: String? = null,&#10;    @SerializedName(&quot;total_tracks&quot;) val total_tracks: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;    &#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyArtistFull(&#10;    val id: String,&#10;    val name: String,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    val followers: SpotifyFollowers?,&#10;    val genres: List&lt;String&gt;?&#10;) {&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;    &#10;    fun getFollowersCount(): String {&#10;        return followers?.total?.let { &quot;${it} seguidores&quot; } ?: &quot;0 seguidores&quot;&#10;    }&#10;    &#10;    fun getGenresText(): String {&#10;        return genres?.joinToString(&quot;, &quot;) ?: &quot;Sin géneros&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyFollowers(&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyArtist(&#10;    val name: String&#10;)&#10;&#10;// Data classes para contenido interno&#10;data class SpotifyPlaylistTracksResponse(&#10;    val items: List&lt;SpotifyPlaylistTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTracksResponseRaw(&#10;    val items: List&lt;SpotifyPlaylistTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTrack(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;// Data classes auxiliares para parsing (con nullable items)&#10;data class SpotifyTracksSearchResultRaw(&#10;    val items: List&lt;SpotifyTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResultRaw(&#10;    val items: List&lt;SpotifyAlbum?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResultRaw(&#10;    val items: List&lt;SpotifyArtistFull?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResultRaw(&#10;    val items: List&lt;SpotifyPlaylist?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySearchAllResponseRaw(&#10;    val tracks: SpotifyTracksSearchResultRaw,&#10;    val albums: SpotifyAlbumsSearchResultRaw,&#10;    val artists: SpotifyArtistsSearchResultRaw,&#10;    val playlists: SpotifyPlaylistsSearchResultRaw&#10;)&#10;" />
              <option name="updatedContent" value="package com.plyr.network&#10;&#10;import com.google.gson.Gson&#10;import com.google.gson.annotations.SerializedName&#10;import okhttp3.*&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import android.util.Base64&#10;import android.content.Context&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.SpotifyTokenManager&#10;&#10;object SpotifyRepository {&#10;    &#10;    private val client = OkHttpClient()&#10;    private val gson = Gson()&#10;    &#10;    // URLs de Spotify&#10;    private const val AUTH_URL = &quot;https://accounts.spotify.com/authorize&quot;&#10;    private const val TOKEN_URL = &quot;https://accounts.spotify.com/api/token&quot;&#10;    private const val API_BASE_URL = &quot;https://api.spotify.com/v1&quot;&#10;    &#10;    // Generar URL de autorización&#10;    fun getAuthorizationUrl(context: Context): String? {&#10;        val clientId = Config.getSpotifyClientId(context)&#10;        return if (clientId != null) {&#10;            &quot;$AUTH_URL?client_id=$clientId&amp;response_type=code&amp;redirect_uri=${Config.SPOTIFY_REDIRECT_URI}&amp;scope=${Config.SPOTIFY_SCOPES.replace(&quot; &quot;, &quot;%20&quot;)}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    &#10;    // Iniciar flujo OAuth (abrir browser)&#10;    fun startOAuthFlow(context: Context): Boolean {&#10;        val authUrl = getAuthorizationUrl(context)&#10;        return if (authUrl != null) {&#10;            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, android.net.Uri.parse(authUrl))&#10;            context.startActivity(intent)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;    &#10;    // Intercambiar código de autorización por tokens&#10;    fun exchangeCodeForTokens(context: Context, authCode: String, callback: (SpotifyTokens?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        if (authHeader == null) {&#10;            callback(null, &quot;Failed to create auth header&quot;)&#10;            return&#10;        }&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;authorization_code&quot;)&#10;            .add(&quot;code&quot;, authCode)&#10;            .add(&quot;redirect_uri&quot;, Config.SPOTIFY_REDIRECT_URI)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing tokens: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Renovar access token usando refresh token&#10;    fun refreshAccessToken(context: Context, refreshToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        if (authHeader == null) {&#10;            callback(null, &quot;Failed to create auth header&quot;)&#10;            return&#10;        }&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;refresh_token&quot;)&#10;            .add(&quot;refresh_token&quot;, refreshToken)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens.accessToken, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing token: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Obtener playlists del usuario con renovación automática de tokens&#10;    suspend fun getUserPlaylistsWithAutoRefresh(context: Context, callback: (List&lt;SpotifyPlaylist&gt;?, String?) -&gt; Unit) {&#10;        SpotifyTokenManager.withValidToken(context) { token -&gt;&#10;            getUserPlaylists(token, callback)&#10;        }&#10;    }&#10;    &#10;    // Obtener playlists del usuario con paginación (versión original para compatibilidad)&#10;    fun getUserPlaylists(accessToken: String, callback: (List&lt;SpotifyPlaylist&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/playlists?limit=$maxLimit&amp;offset=$offset&amp;fields=items(id,name,description,tracks(total),images)&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User playlists response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val playlistResponse = gson.fromJson(body, SpotifyPlaylistResponse::class.java)&#10;                            &#10;                            // Debug: log tracks data for each playlist&#10;                            playlistResponse.items.forEachIndexed { index, playlist -&gt;&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist $index - '${playlist.name}': tracks=${playlist.tracks}, tracks.total=${playlist.tracks?.total}&quot;)&#10;                            }&#10;                            &#10;                            // Acumular resultados&#10;                            allPlaylists.addAll(playlistResponse.items)&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${playlistResponse.items.size} playlists, total accumulated: ${allPlaylists.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allPlaylists.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMorePlaylists = playlistResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMorePlaylists &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlists page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlists count: ${allPlaylists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de un álbum con paginación&#10;    fun getAlbumTracks(accessToken: String, albumId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/albums/$albumId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyTracksSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next album tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final album tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing album tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de una playlist con paginación&#10;    fun getPlaylistTracks(accessToken: String, playlistId: String, callback: (List&lt;SpotifyPlaylistTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allTracks = mutableListOf&lt;SpotifyPlaylistTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyPlaylistTracksResponseRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlist tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlist tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlist tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener álbumes de un artista con paginación&#10;    fun getArtistAlbums(accessToken: String, artistId: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        var allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/artists/$artistId/albums?include_groups=album,single&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val albumsResponse = gson.fromJson(body, SpotifyAlbumsSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allAlbums.addAll(albumsResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albumsResponse.items.filterNotNull().size} albums, total accumulated: ${allAlbums.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = albumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next artist albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final artist albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing artist albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Buscar todo tipo de contenido en Spotify (canciones, álbumes, artistas, playlists)&#10;    fun searchAll(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=50&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search all response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchAllResponse::class.java)&#10;                        callback(searchResponse, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Buscar canciones en Spotify (función mantenida para compatibilidad)&#10;    fun searchTracks(accessToken: String, query: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track&amp;limit=20&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchResponseRaw::class.java)&#10;                        callback(searchResponse.tracks.items.filterNotNull(), null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Seguir una playlist en Spotify&#10;    fun followPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(RequestBody.create(&quot;application/json&quot;.toMediaType(), &quot;{}&quot;))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body?.string()&#10;                    &#10;                    // Detectar error de scopes insuficientes&#10;                    if (response.code == 403 &amp;&amp; errorBody?.contains(&quot;Insufficient client scope&quot;) == true) {&#10;                        callback(false, &quot;Permisos insuficientes. Desconecta y vuelve a conectar Spotify para obtener todos los permisos necesarios.&quot;)&#10;                    } else {&#10;                        callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Guardar un álbum en la biblioteca de Spotify&#10;    fun saveAlbum(accessToken: String, albumId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/me/albums&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(RequestBody.create(&quot;application/json&quot;.toMediaType(), &quot;&quot;&quot;{&quot;ids&quot;:[&quot;$albumId&quot;]}&quot;&quot;&quot;))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body?.string()&#10;                    &#10;                    // Detectar error de scopes insuficientes&#10;                    if (response.code == 403 &amp;&amp; errorBody?.contains(&quot;Insufficient client scope&quot;) == true) {&#10;                        callback(false, &quot;Permisos insuficientes. Desconecta y vuelve a conectar Spotify para obtener todos los permisos necesarios.&quot;)&#10;                    } else {&#10;                        callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Buscar todo tipo de contenido en Spotify con paginación automática optimizada&#10;    fun searchAllWithPagination(&#10;        accessToken: String, &#10;        query: String, &#10;        callback: (SpotifySearchAllResponse?, String?) -&gt; Unit // Simplificamos el callback&#10;    ) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        &#10;        // Variables para acumular resultados&#10;        var allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var allArtists = mutableListOf&lt;SpotifyArtistFull&gt;()&#10;        var allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        &#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body?.string()&#10;                    if (response.isSuccessful &amp;&amp; body != null) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search paginated response (offset=$offset) body excerpt: ${body.take(500)}...&quot;)&#10;                            val searchResponseRaw = gson.fromJson(body, SpotifySearchAllResponseRaw::class.java)&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Parsed response - tracks: ${searchResponseRaw.tracks.items.size}, albums: ${searchResponseRaw.albums.items.size}, artists: ${searchResponseRaw.artists.items.size}, playlists: ${searchResponseRaw.playlists.items.size}&quot;)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(searchResponseRaw.tracks.items.filterNotNull())&#10;                            allAlbums.addAll(searchResponseRaw.albums.items.filterNotNull())&#10;                            allArtists.addAll(searchResponseRaw.artists.items.filterNotNull())&#10;                            allPlaylists.addAll(searchResponseRaw.playlists.items.filterNotNull())&#10;                            &#10;                            pageCount++&#10;                            &#10;                            // Enviar resultados después de cada página para mostrar progreso&#10;                            val currentResponse = SpotifySearchAllResponse(&#10;                                tracks = SpotifyTracksSearchResult(&#10;                                    items = allTracks.distinctBy { it.id },&#10;                                    total = searchResponseRaw.tracks.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.tracks.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                albums = SpotifyAlbumsSearchResult(&#10;                                    items = allAlbums.distinctBy { it.id },&#10;                                    total = searchResponseRaw.albums.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.albums.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                artists = SpotifyArtistsSearchResult(&#10;                                    items = allArtists.distinctBy { it.id },&#10;                                    total = searchResponseRaw.artists.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.artists.items.size == maxLimit) &quot;more&quot; else null&#10;                                ),&#10;                                playlists = SpotifyPlaylistsSearchResult(&#10;                                    items = allPlaylists.distinctBy { it.id },&#10;                                    total = searchResponseRaw.playlists.total,&#10;                                    limit = maxLimit,&#10;                                    offset = 0,&#10;                                    next = if (searchResponseRaw.playlists.items.size == maxLimit) &quot;more&quot; else null&#10;                                )&#10;                            )&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount sent: ${allTracks.size} tracks, ${allAlbums.size} albums, ${allArtists.size} artists, ${allPlaylists.size} playlists&quot;)&#10;                            callback(currentResponse, null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = searchResponseRaw.tracks.items.size == maxLimit &amp;&amp; allTracks.size &lt; (searchResponseRaw.tracks.total ?: 0)&#10;                            val hasMoreAlbums = searchResponseRaw.albums.items.size == maxLimit &amp;&amp; allAlbums.size &lt; (searchResponseRaw.albums.total ?: 0)&#10;                            val hasMoreArtists = searchResponseRaw.artists.items.size == maxLimit &amp;&amp; allArtists.size &lt; (searchResponseRaw.artists.total ?: 0)&#10;                            val hasMorePlaylists = searchResponseRaw.playlists.items.size == maxLimit &amp;&amp; allPlaylists.size &lt; (searchResponseRaw.playlists.total ?: 0)&#10;                            &#10;                            // Verificar si el próximo offset excedería el límite de Spotify (1000)&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido en cualquier categoría y no excedemos el límite, continuar paginando&#10;                            if ((hasMoreTracks || hasMoreAlbums || hasMoreArtists || hasMorePlaylists) &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next page: offset=$nextOffset&quot;)&#10;                                // Agregar un pequeño delay para no sobrecargar la API&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200) // 200ms de delay entre requests&#10;                            } else {&#10;                                // Paginación completada (por límite de API o porque no hay más resultados)&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Pagination stopped: reached Spotify API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final results: ${allTracks.size} tracks, ${allAlbums.size} albums, ${allArtists.size} artists, ${allPlaylists.size} playlists&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Obtener el user_id del usuario actual&#10;    fun getCurrentUserId(accessToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/me&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Network error: ${e.message}&quot;)&#10;            }&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body?.string()&#10;                if (response.isSuccessful &amp;&amp; body != null) {&#10;                    try {&#10;                        val json = gson.fromJson(body, Map::class.java)&#10;                        val userId = json[&quot;id&quot;] as? String&#10;                        callback(userId, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing user id: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;HTTP error ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Crear playlist&#10;    fun createPlaylist(&#10;        accessToken: String,&#10;        name: String,&#10;        description: String,&#10;        isPublic: Boolean,&#10;        callback: (Boolean, String?) -&gt; Unit&#10;    ) {&#10;        getCurrentUserId(accessToken) { userId, error -&gt;&#10;            if (userId == null) {&#10;                callback(false, error ?: &quot;Could not get user id&quot;)&#10;                return@getCurrentUserId&#10;            }&#10;            val url = &quot;https://api.spotify.com/v1/users/$userId/playlists&quot;&#10;            val jsonBody = &quot;&quot;&quot;&#10;            {&#10;                &quot;name&quot;: &quot;$name&quot;,&#10;                &quot;description&quot;: &quot;$description&quot;,&#10;                &quot;public&quot;: $isPublic&#10;            }&#10;        &quot;&quot;&quot;.trimIndent()&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                .post(jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;                .build()&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(false, &quot;Network error: ${e.message}&quot;)&#10;                }&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    if (response.isSuccessful) {&#10;                        callback(true, null)&#10;                    } else {&#10;                        val errorBody = response.body?.string()&#10;                        callback(false, &quot;HTTP error ${response.code}: $errorBody&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;    }&#10;&#10;    private fun createBasicAuthHeader(context: Context): String {&#10;        val credentials = &quot;${Config.getSpotifyClientId(context)}:${Config.getSpotifyClientSecret(context)}&quot;&#10;        val encodedCredentials = Base64.encodeToString(credentials.toByteArray(), Base64.NO_WRAP)&#10;        return &quot;Basic $encodedCredentials&quot;&#10;    }&#10;}&#10;&#10;&#10;// Data classes para Spotify API&#10;data class SpotifyTokens(&#10;    @SerializedName(&quot;access_token&quot;) val accessToken: String,&#10;    @SerializedName(&quot;token_type&quot;) val tokenType: String,&#10;    @SerializedName(&quot;scope&quot;) val scope: String,&#10;    @SerializedName(&quot;expires_in&quot;) val expiresIn: Int,&#10;    @SerializedName(&quot;refresh_token&quot;) val refreshToken: String?&#10;)&#10;&#10;data class SpotifyPlaylistResponse(&#10;    val items: List&lt;SpotifyPlaylist&gt;&#10;)&#10;&#10;data class SpotifyPlaylist(&#10;    val id: String,&#10;    val name: String,&#10;    val description: String?,&#10;    val tracks: SpotifyPlaylistTracks?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;) {&#10;    fun getTrackCount(): String {&#10;        return tracks?.total?.let { &quot;$it songs&quot; } ?: &quot;0 songs&quot;&#10;    }&#10;    &#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyPlaylistTracks(&#10;    val href: String?,&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyImage(&#10;    val url: String,&#10;    val height: Int?,&#10;    val width: Int?&#10;)&#10;&#10;data class SpotifyTracksResponse(&#10;    val items: List&lt;SpotifyTrackItem&gt;&#10;)&#10;&#10;data class SpotifyTrackItem(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;data class SpotifyTrack(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    @SerializedName(&quot;duration_ms&quot;) val durationMs: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;    &#10;    fun getDurationText(): String {&#10;        return durationMs?.let {&#10;            val minutes = it / 60000&#10;            val seconds = (it % 60000) / 1000&#10;            &quot;${minutes}:${seconds.toString().padStart(2, '0')}&quot;&#10;        } ?: &quot;0:00&quot;&#10;    }&#10;}&#10;&#10;data class SpotifySearchResponse(&#10;    val tracks: SpotifyTracksSearchResult&#10;)&#10;&#10;data class SpotifySearchResponseRaw(&#10;    val tracks: SpotifyTracksSearchResultRaw&#10;)&#10;&#10;data class SpotifySearchAllResponse(&#10;    val tracks: SpotifyTracksSearchResult,&#10;    val albums: SpotifyAlbumsSearchResult,&#10;    val artists: SpotifyArtistsSearchResult,&#10;    val playlists: SpotifyPlaylistsSearchResult&#10;)&#10;&#10;data class SpotifyTracksSearchResult(&#10;    val items: List&lt;SpotifyTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResult(&#10;    val items: List&lt;SpotifyAlbum&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResult(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResult(&#10;    val items: List&lt;SpotifyPlaylist&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbum(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    @SerializedName(&quot;release_date&quot;) val release_date: String? = null,&#10;    @SerializedName(&quot;total_tracks&quot;) val total_tracks: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;    &#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyArtistFull(&#10;    val id: String,&#10;    val name: String,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    val followers: SpotifyFollowers?,&#10;    val genres: List&lt;String&gt;?&#10;) {&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;    &#10;    fun getFollowersCount(): String {&#10;        return followers?.total?.let { &quot;${it} seguidores&quot; } ?: &quot;0 seguidores&quot;&#10;    }&#10;    &#10;    fun getGenresText(): String {&#10;        return genres?.joinToString(&quot;, &quot;) ?: &quot;Sin géneros&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyFollowers(&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyArtist(&#10;    val name: String&#10;)&#10;&#10;// Data classes para contenido interno&#10;data class SpotifyPlaylistTracksResponse(&#10;    val items: List&lt;SpotifyPlaylistTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTracksResponseRaw(&#10;    val items: List&lt;SpotifyPlaylistTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTrack(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;// Data classes auxiliares para parsing (con nullable items)&#10;data class SpotifyTracksSearchResultRaw(&#10;    val items: List&lt;SpotifyTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResultRaw(&#10;    val items: List&lt;SpotifyAlbum?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResultRaw(&#10;    val items: List&lt;SpotifyArtistFull?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResultRaw(&#10;    val items: List&lt;SpotifyPlaylist?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySearchAllResponseRaw(&#10;    val tracks: SpotifyTracksSearchResultRaw,&#10;    val albums: SpotifyAlbumsSearchResultRaw,&#10;    val artists: SpotifyArtistsSearchResultRaw,&#10;    val playlists: SpotifyPlaylistsSearchResultRaw&#10;)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicService.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicService.kt" />
              <option name="originalContent" value="package com.plyr.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.media3.common.Player&#10;import androidx.media3.session.MediaSession&#10;import com.plyr.MainActivity&#10;import com.plyr.PlyrApp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MusicService : Service() {&#10;&#10;    // === PROPIEDADES ===&#10;    private var mediaSession: MediaSession? = null&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private var playlist: List&lt;String&gt; = emptyList()&#10;    private var currentIndex: Int = 0&#10;&#10;    // === CONSTANTES ===&#10;    companion object {&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val CHANNEL_ID = &quot;music_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;Music Playback&quot;&#10;        private const val CHANNEL_DESCRIPTION = &quot;Controls for music playback&quot;&#10;    }&#10;&#10;    // === CICLO DE VIDA DEL SERVICIO ===&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;MusicService::WakeLock&quot;)&#10;        wakeLock.acquire(10 * 60 * 1000L /* 10 minutos */)&#10;&#10;        createNotificationChannel()&#10;        // Iniciar foreground service con notificación persistente&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        setupPlayerListener()&#10;        createMediaSession()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        when (intent?.action) {&#10;            &quot;ACTION_PLAY&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot; ACTION_PLAY recibido&quot;)&#10;                plyr.playPlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_PAUSE&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏸️ ACTION_PAUSE recibido&quot;)&#10;                plyr.pausePlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_NEXT&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏭️ ACTION_NEXT recibido&quot;)&#10;                if (plyr.hasNext.value == true) {&#10;                    println(&quot;⏭️ NAVEGANDO: Siguiente canción...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToNext()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No next track available&quot;)&#10;                }&#10;            }&#10;            &quot;ACTION_PREV&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏮️ ACTION_PREV recibido&quot;)&#10;                if (plyr.hasPrevious.value == true) {&#10;                    println(&quot;⏮️ NAVEGANDO: Canción anterior...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToPrevious()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No previous track available&quot;)&#10;                }&#10;            }&#10;            else -&gt; {&#10;                val audioUrl = intent?.getStringExtra(&quot;AUDIO_URL&quot;)&#10;                if (audioUrl != null) playAudio(audioUrl)&#10;            }&#10;        }&#10;        return START_STICKY&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE COMPONENTES ===&#10;    private fun createMediaSession() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        if (sharedPlayer != null) {&#10;            mediaSession = MediaSession.Builder(this, sharedPlayer).build()&#10;            Log.d(&quot;MusicService&quot;, &quot;✅ MediaSession creada correctamente&quot;)&#10;        } else {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ No se pudo obtener el player de PlayerViewModel&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupPlayerListener() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        sharedPlayer?.addListener(object : Player.Listener {&#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(&quot;MusicService&quot;, &quot; onIsPlayingChanged: isPlaying = $isPlaying&quot;)&#10;&#10;                // Printear el estado actual&#10;                if (isPlaying) {&#10;                    println(&quot; ESTADO: PLAYING - La canción está reproduciéndose&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot; ESTADO: PLAYING&quot;)&#10;                } else {&#10;                    println(&quot;⏸️ ESTADO: PAUSED - La canción está pausada&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot;⏸️ ESTADO: PAUSED&quot;)&#10;                }&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlaybackStateChange(isPlaying)&#10;                }&#10;            }&#10;&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                val stateName = when (playbackState) {&#10;                    Player.STATE_IDLE -&gt; &quot;IDLE&quot;&#10;                    Player.STATE_BUFFERING -&gt; &quot;BUFFERING&quot;&#10;                    Player.STATE_READY -&gt; &quot;READY&quot;&#10;                    Player.STATE_ENDED -&gt; &quot;ENDED&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;&#10;                // Printear los cambios de estado&#10;                when (playbackState) {&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        println(&quot;⏳ ESTADO: LOADING - Cargando canción...&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;⏳ ESTADO: LOADING - Buffering&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        println(&quot;✅ ESTADO: READY - Canción lista para reproducir&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;✅ ESTADO: READY&quot;)&#10;&#10;                        // Verificar si debe empezar a reproducir automáticamente (en hilo principal)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            val player = plyr.getPlayer()&#10;                            if (player?.playWhenReady == true &amp;&amp; !player.isPlaying) {&#10;                                println(&quot; INICIANDO REPRODUCCIÓN AUTOMÁTICA&quot;)&#10;                                Log.d(&quot;MusicService&quot;, &quot; Iniciando reproducción automática&quot;)&#10;                                player.play()&#10;                            }&#10;                            updateNotification()&#10;                        }&#10;                    }&#10;                    Player.STATE_ENDED -&gt; {&#10;                        println(&quot; ESTADO: ENDED - Canción terminada&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: ENDED&quot;)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            handleTrackEnded()&#10;                        }&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        println(&quot; ESTADO: IDLE - Player inactivo&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: IDLE&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; onPlaybackStateChanged: state = $stateName ($playbackState)&quot;)&#10;            }&#10;&#10;            override fun onPlayerError(error: androidx.media3.common.PlaybackException) {&#10;                println(&quot;❌ ESTADO: ERROR - ${error.message}&quot;)&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Player error: ${error.message}&quot;, error)&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlayerError(error)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // === MÉTODOS DE REPRODUCCIÓN ===&#10;    fun playAudio(audioUrl: String) {&#10;        Log.d(&quot;MusicService&quot;, &quot; playAudio llamado con: $audioUrl&quot;)&#10;        println(&quot; INICIANDO CARGA: $audioUrl&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;&#10;        try {&#10;            plyr.loadAudio(audioUrl, &quot;Audio Track&quot;)&#10;&#10;            // Asegurar que se reproduce cuando esté listo (en hilo principal)&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                val player = plyr.getPlayer()&#10;                player?.playWhenReady = true&#10;&#10;                kotlinx.coroutines.delay(500)&#10;                startForeground(NOTIFICATION_ID, createNotification())&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;❌ ERROR AL CARGAR: ${e.message}&quot;)&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al reproducir audio: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;    fun playPlaylist(urls: List&lt;String&gt;, startIndex: Int = 0) {&#10;        playlist = urls&#10;        currentIndex = startIndex.coerceIn(0, urls.size - 1)&#10;&#10;        if (playlist.isNotEmpty()) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playing playlist: ${playlist.size} tracks, starting at index $currentIndex&quot;)&#10;            playAudio(playlist[currentIndex])&#10;        } else {&#10;            Log.w(&quot;MusicService&quot;, &quot;⚠️ Attempted to play empty playlist&quot;)&#10;        }&#10;    }&#10;&#10;    // === MANEJO DE ESTADOS ===&#10;    private fun handlePlaybackStateChange(isPlaying: Boolean) {&#10;        Log.d(&quot;MusicService&quot;, &quot; handlePlaybackStateChange: isPlaying = $isPlaying&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val hasMedia = plyr.getPlayer()?.currentMediaItem != null&#10;&#10;        if (hasMedia || isPlaying) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Actualizando notificación - isPlaying: $isPlaying&quot;)&#10;            try {&#10;                // Para la primera vez, usar startForeground&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                    updateNotification()&#10;                } else {&#10;                    startForeground(NOTIFICATION_ID, createNotification())&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error al mostrar notificación: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot;⏸️ Sin contenido, deteniendo servicio en primer plano&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handleTrackEnded() {&#10;        if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size - 1) {&#10;            currentIndex++&#10;            val nextUrl = playlist[currentIndex]&#10;            Log.d(&quot;MusicService&quot;, &quot;⏭️ Track ended, playing next: $nextUrl&quot;)&#10;            playAudio(nextUrl)&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playlist ended&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerError(error: androidx.media3.common.PlaybackException) {&#10;        Log.e(&quot;MusicService&quot;, &quot;❌ Manejando error del player: ${error.message}&quot;)&#10;&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Limpiar MediaSession&#10;                cleanupResources()&#10;&#10;                // Esperar un momento antes de reintentar&#10;                kotlinx.coroutines.delay(1000)&#10;&#10;                // Recrear MediaSession con el player existente&#10;                createMediaSession()&#10;&#10;                // Reintentar la reproducción si hay un track actual&#10;                if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size) {&#10;                    Log.d(&quot;MusicService&quot;, &quot; Reintentando reproducción del track actual&quot;)&#10;                    playAudio(playlist[currentIndex])&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; Recuperación de error completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error durante la recuperación: ${e.message}&quot;, e)&#10;&#10;                // Si falla todo, detener el servicio&#10;                stopForeground(STOP_FOREGROUND_DETACH)&#10;                stopSelf()&#10;            }&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE NOTIFICACIONES ===&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = CHANNEL_DESCRIPTION&#10;                setShowBadge(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;                setSound(null, null) // Sin sonido para la notificación&#10;            }&#10;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    private fun createNotification(): Notification {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val player = plyr.getPlayer()&#10;        val currentMediaItem = player?.currentMediaItem&#10;        val title = currentMediaItem?.mediaMetadata?.title?.toString() ?: &quot;Music Player&quot;&#10;&#10;        // Obtener el estado correcto del player&#10;        val isCurrentlyPlaying = player?.isPlaying == true&#10;&#10;        Log.d(&quot;MusicService&quot;, &quot; Creando notificación - Playing: $isCurrentlyPlaying, Title: $title&quot;)&#10;&#10;        val playIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PLAY&quot; }&#10;        val pauseIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PAUSE&quot; }&#10;        val nextIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_NEXT&quot; }&#10;        val prevIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PREV&quot; }&#10;&#10;        val playPendingIntent = PendingIntent.getService(this, 0, playIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val pausePendingIntent = PendingIntent.getService(this, 1, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val nextPendingIntent = PendingIntent.getService(this, 2, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val prevPendingIntent = PendingIntent.getService(this, 3, prevIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(title)&#10;            .setContentText(if (isCurrentlyPlaying) &quot;Reproduciendo...&quot; else &quot;En pausa&quot;)&#10;            .setSmallIcon(if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play)&#10;            .setContentIntent(createMainActivityPendingIntent())&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setOngoing(true) // Notificación persistente&#10;            .setShowWhen(false)&#10;            .setOnlyAlertOnce(true) // Evita alertas repetidas&#10;&#10;        val compactActions = mutableListOf&lt;Int&gt;()&#10;        var actionIndex = 0&#10;&#10;        // Botón anterior (si hay pista anterior)&#10;        if (plyr.hasPrevious.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_previous, &quot;Previous&quot;, prevPendingIntent)&#10;            compactActions.add(actionIndex)&#10;            actionIndex++&#10;        }&#10;&#10;        // Botón play/pause (siempre presente)&#10;        val playPauseIcon = if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play&#10;        val playPauseText = if (isCurrentlyPlaying) &quot;Pause&quot; else &quot;Play&quot;&#10;        val playPauseIntent = if (isCurrentlyPlaying) pausePendingIntent else playPendingIntent&#10;&#10;        builder.addAction(playPauseIcon, playPauseText, playPauseIntent)&#10;        compactActions.add(actionIndex)&#10;        actionIndex++&#10;&#10;        // Botón siguiente (si hay pista siguiente)&#10;        if (plyr.hasNext.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_next, &quot;Next&quot;, nextPendingIntent)&#10;            compactActions.add(actionIndex)&#10;        }&#10;&#10;        // MediaStyle simplificado sin MediaSession token&#10;        builder.setStyle(androidx.media.app.NotificationCompat.MediaStyle()&#10;            .setShowActionsInCompactView(*compactActions.toIntArray())&#10;        )&#10;&#10;        return builder.build()&#10;    }&#10;&#10;    private fun createMainActivityPendingIntent(): PendingIntent {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        return PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;    /**&#10;     * Actualiza la notificación existente&#10;     */&#10;    private fun updateNotification() {&#10;        try {&#10;            val notification = createNotification()&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;            Log.d(&quot;MusicService&quot;, &quot; Notificación actualizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al actualizar notificación: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // === BINDING ===&#10;    inner class MusicBinder : Binder() {&#10;        fun getService(): MusicService = this@MusicService&#10;    }&#10;&#10;    private val binder = MusicBinder()&#10;&#10;    override fun onBind(intent: Intent): IBinder {&#10;        return binder&#10;    }&#10;&#10;    // === LIMPIEZA DE RECURSOS ===&#10;    override fun onDestroy() {&#10;        Log.d(&quot;MusicService&quot;, &quot;️ Destruyendo MusicService&quot;)&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;        cleanupResources()&#10;        super.onDestroy()&#10;    }&#10;&#10;    private fun cleanupResources() {&#10;        mediaSession?.run {&#10;            release()&#10;            mediaSession = null&#10;        }&#10;    }&#10;}" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.app.Notification&#10;import android.app.NotificationChannel&#10;import android.app.NotificationManager&#10;import android.app.PendingIntent&#10;import android.app.Service&#10;import android.content.Intent&#10;import android.os.Binder&#10;import android.os.Build&#10;import android.os.IBinder&#10;import android.os.PowerManager&#10;import android.util.Log&#10;import androidx.core.app.NotificationCompat&#10;import androidx.media3.common.Player&#10;import androidx.media3.session.MediaSession&#10;import com.plyr.MainActivity&#10;import com.plyr.PlyrApp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;&#10;class MusicService : Service() {&#10;&#10;    // === PROPIEDADES ===&#10;    private var mediaSession: MediaSession? = null&#10;    private lateinit var wakeLock: PowerManager.WakeLock&#10;    private var playlist: List&lt;String&gt; = emptyList()&#10;    private var currentIndex: Int = 0&#10;&#10;    // === CONSTANTES ===&#10;    companion object {&#10;        private const val NOTIFICATION_ID = 1&#10;        private const val CHANNEL_ID = &quot;music_channel&quot;&#10;        private const val CHANNEL_NAME = &quot;Music Playback&quot;&#10;        private const val CHANNEL_DESCRIPTION = &quot;Controls for music playback&quot;&#10;    }&#10;&#10;    // === CICLO DE VIDA DEL SERVICIO ===&#10;    override fun onCreate() {&#10;        super.onCreate()&#10;        val powerManager = getSystemService(POWER_SERVICE) as PowerManager&#10;        wakeLock = powerManager.newWakeLock(PowerManager.PARTIAL_WAKE_LOCK, &quot;MusicService::WakeLock&quot;)&#10;        wakeLock.acquire(10 * 60 * 1000L /* 10 minutos */)&#10;&#10;        createNotificationChannel()&#10;        // Iniciar foreground service con notificación persistente&#10;        startForeground(NOTIFICATION_ID, createNotification())&#10;        setupPlayerListener()&#10;        createMediaSession()&#10;    }&#10;&#10;    override fun onStartCommand(intent: Intent?, flags: Int, startId: Int): Int {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        when (intent?.action) {&#10;            &quot;ACTION_PLAY&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot; ACTION_PLAY recibido&quot;)&#10;                plyr.playPlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_PAUSE&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏸️ ACTION_PAUSE recibido&quot;)&#10;                plyr.pausePlayer()&#10;&#10;                // Actualizar notificación después de un breve delay&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    kotlinx.coroutines.delay(200)&#10;                    updateNotification()&#10;                }&#10;            }&#10;            &quot;ACTION_NEXT&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏭️ ACTION_NEXT recibido&quot;)&#10;                if (plyr.hasNext.value == true) {&#10;                    println(&quot;⏭️ NAVEGANDO: Siguiente canción...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToNext()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No next track available&quot;)&#10;                }&#10;            }&#10;            &quot;ACTION_PREV&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot;⏮️ ACTION_PREV recibido&quot;)&#10;                if (plyr.hasPrevious.value == true) {&#10;                    println(&quot;⏮️ NAVEGANDO: Canción anterior...&quot;)&#10;&#10;                    // Ejecutar en el hilo principal&#10;                    CoroutineScope(Dispatchers.Main).launch {&#10;                        plyr.navigateToPrevious()&#10;                        val player = plyr.getPlayer()&#10;                        player?.playWhenReady = true&#10;&#10;                        kotlinx.coroutines.delay(300)&#10;                        updateNotification()&#10;                    }&#10;                } else {&#10;                    Log.d(&quot;MusicService&quot;, &quot;No previous track available&quot;)&#10;                }&#10;            }&#10;            &quot;ACTION_STOP&quot; -&gt; {&#10;                Log.d(&quot;MusicService&quot;, &quot; ACTION_STOP recibido - Deteniendo servicio&quot;)&#10;                stopForegroundService()&#10;                return START_NOT_STICKY&#10;            }&#10;            else -&gt; {&#10;                val audioUrl = intent?.getStringExtra(&quot;AUDIO_URL&quot;)&#10;                if (audioUrl != null) playAudio(audioUrl)&#10;            }&#10;        }&#10;        // Cambiar a START_NOT_STICKY para que no se reinicie automáticamente&#10;        return START_NOT_STICKY&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE COMPONENTES ===&#10;    private fun createMediaSession() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        if (sharedPlayer != null) {&#10;            mediaSession = MediaSession.Builder(this, sharedPlayer).build()&#10;            Log.d(&quot;MusicService&quot;, &quot;✅ MediaSession creada correctamente&quot;)&#10;        } else {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ No se pudo obtener el player de PlayerViewModel&quot;)&#10;        }&#10;    }&#10;&#10;    private fun setupPlayerListener() {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val sharedPlayer = plyr.getPlayer()&#10;&#10;        sharedPlayer?.addListener(object : Player.Listener {&#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(&quot;MusicService&quot;, &quot; onIsPlayingChanged: isPlaying = $isPlaying&quot;)&#10;&#10;                // Printear el estado actual&#10;                if (isPlaying) {&#10;                    println(&quot; ESTADO: PLAYING - La canción está reproduciéndose&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot; ESTADO: PLAYING&quot;)&#10;                } else {&#10;                    println(&quot;⏸️ ESTADO: PAUSED - La canción está pausada&quot;)&#10;                    Log.d(&quot;MusicService&quot;, &quot;⏸️ ESTADO: PAUSED&quot;)&#10;                }&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlaybackStateChange(isPlaying)&#10;                }&#10;            }&#10;&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                val stateName = when (playbackState) {&#10;                    Player.STATE_IDLE -&gt; &quot;IDLE&quot;&#10;                    Player.STATE_BUFFERING -&gt; &quot;BUFFERING&quot;&#10;                    Player.STATE_READY -&gt; &quot;READY&quot;&#10;                    Player.STATE_ENDED -&gt; &quot;ENDED&quot;&#10;                    else -&gt; &quot;UNKNOWN&quot;&#10;                }&#10;&#10;                // Printear los cambios de estado&#10;                when (playbackState) {&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        println(&quot;⏳ ESTADO: LOADING - Cargando canción...&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;⏳ ESTADO: LOADING - Buffering&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        println(&quot;✅ ESTADO: READY - Canción lista para reproducir&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot;✅ ESTADO: READY&quot;)&#10;&#10;                        // Verificar si debe empezar a reproducir automáticamente (en hilo principal)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            val player = plyr.getPlayer()&#10;                            if (player?.playWhenReady == true &amp;&amp; !player.isPlaying) {&#10;                                println(&quot; INICIANDO REPRODUCCIÓN AUTOMÁTICA&quot;)&#10;                                Log.d(&quot;MusicService&quot;, &quot; Iniciando reproducción automática&quot;)&#10;                                player.play()&#10;                            }&#10;                            updateNotification()&#10;                        }&#10;                    }&#10;                    Player.STATE_ENDED -&gt; {&#10;                        println(&quot; ESTADO: ENDED - Canción terminada&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: ENDED&quot;)&#10;                        CoroutineScope(Dispatchers.Main).launch {&#10;                            handleTrackEnded()&#10;                        }&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        println(&quot; ESTADO: IDLE - Player inactivo&quot;)&#10;                        Log.d(&quot;MusicService&quot;, &quot; ESTADO: IDLE&quot;)&#10;                    }&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; onPlaybackStateChanged: state = $stateName ($playbackState)&quot;)&#10;            }&#10;&#10;            override fun onPlayerError(error: androidx.media3.common.PlaybackException) {&#10;                println(&quot;❌ ESTADO: ERROR - ${error.message}&quot;)&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Player error: ${error.message}&quot;, error)&#10;&#10;                // Ejecutar en el hilo principal&#10;                CoroutineScope(Dispatchers.Main).launch {&#10;                    handlePlayerError(error)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // === MÉTODOS DE REPRODUCCIÓN ===&#10;    fun playAudio(audioUrl: String) {&#10;        Log.d(&quot;MusicService&quot;, &quot; playAudio llamado con: $audioUrl&quot;)&#10;        println(&quot; INICIANDO CARGA: $audioUrl&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;&#10;        try {&#10;            plyr.loadAudio(audioUrl, &quot;Audio Track&quot;)&#10;&#10;            // Asegurar que se reproduce cuando esté listo (en hilo principal)&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                val player = plyr.getPlayer()&#10;                player?.playWhenReady = true&#10;&#10;                kotlinx.coroutines.delay(500)&#10;                startForeground(NOTIFICATION_ID, createNotification())&#10;            }&#10;        } catch (e: Exception) {&#10;            println(&quot;❌ ERROR AL CARGAR: ${e.message}&quot;)&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al reproducir audio: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;    fun playPlaylist(urls: List&lt;String&gt;, startIndex: Int = 0) {&#10;        playlist = urls&#10;        currentIndex = startIndex.coerceIn(0, urls.size - 1)&#10;&#10;        if (playlist.isNotEmpty()) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playing playlist: ${playlist.size} tracks, starting at index $currentIndex&quot;)&#10;            playAudio(playlist[currentIndex])&#10;        } else {&#10;            Log.w(&quot;MusicService&quot;, &quot;⚠️ Attempted to play empty playlist&quot;)&#10;        }&#10;    }&#10;&#10;    // === MANEJO DE ESTADOS ===&#10;    private fun handlePlaybackStateChange(isPlaying: Boolean) {&#10;        Log.d(&quot;MusicService&quot;, &quot; handlePlaybackStateChange: isPlaying = $isPlaying&quot;)&#10;&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val hasMedia = plyr.getPlayer()?.currentMediaItem != null&#10;&#10;        if (hasMedia || isPlaying) {&#10;            Log.d(&quot;MusicService&quot;, &quot; Actualizando notificación - isPlaying: $isPlaying&quot;)&#10;            try {&#10;                // Para la primera vez, usar startForeground&#10;                if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.Q) {&#10;                    updateNotification()&#10;                } else {&#10;                    startForeground(NOTIFICATION_ID, createNotification())&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error al mostrar notificación: ${e.message}&quot;, e)&#10;            }&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot;⏸️ Sin contenido, deteniendo servicio en primer plano&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handleTrackEnded() {&#10;        if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size - 1) {&#10;            currentIndex++&#10;            val nextUrl = playlist[currentIndex]&#10;            Log.d(&quot;MusicService&quot;, &quot;⏭️ Track ended, playing next: $nextUrl&quot;)&#10;            playAudio(nextUrl)&#10;        } else {&#10;            Log.d(&quot;MusicService&quot;, &quot; Playlist ended&quot;)&#10;            stopForeground(STOP_FOREGROUND_DETACH)&#10;        }&#10;    }&#10;&#10;    private fun handlePlayerError(error: androidx.media3.common.PlaybackException) {&#10;        Log.e(&quot;MusicService&quot;, &quot;❌ Manejando error del player: ${error.message}&quot;)&#10;&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Limpiar MediaSession&#10;                cleanupResources()&#10;&#10;                // Esperar un momento antes de reintentar&#10;                kotlinx.coroutines.delay(1000)&#10;&#10;                // Recrear MediaSession con el player existente&#10;                createMediaSession()&#10;&#10;                // Reintentar la reproducción si hay un track actual&#10;                if (playlist.isNotEmpty() &amp;&amp; currentIndex &lt; playlist.size) {&#10;                    Log.d(&quot;MusicService&quot;, &quot; Reintentando reproducción del track actual&quot;)&#10;                    playAudio(playlist[currentIndex])&#10;                }&#10;&#10;                Log.d(&quot;MusicService&quot;, &quot; Recuperación de error completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;MusicService&quot;, &quot;❌ Error durante la recuperación: ${e.message}&quot;, e)&#10;&#10;                // Si falla todo, detener el servicio&#10;                stopForeground(STOP_FOREGROUND_DETACH)&#10;                stopSelf()&#10;            }&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DE NOTIFICACIONES ===&#10;    private fun createNotificationChannel() {&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.O) {&#10;            val channel = NotificationChannel(&#10;                CHANNEL_ID,&#10;                CHANNEL_NAME,&#10;                NotificationManager.IMPORTANCE_LOW&#10;            ).apply {&#10;                description = CHANNEL_DESCRIPTION&#10;                setShowBadge(false)&#10;                lockscreenVisibility = Notification.VISIBILITY_PUBLIC&#10;                setSound(null, null) // Sin sonido para la notificación&#10;            }&#10;&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.createNotificationChannel(channel)&#10;        }&#10;    }&#10;    private fun createNotification(): Notification {&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        val player = plyr.getPlayer()&#10;        val currentMediaItem = player?.currentMediaItem&#10;        val title = currentMediaItem?.mediaMetadata?.title?.toString() ?: &quot;Music Player&quot;&#10;&#10;        // Obtener el estado correcto del player&#10;        val isCurrentlyPlaying = player?.isPlaying == true&#10;&#10;        Log.d(&quot;MusicService&quot;, &quot; Creando notificación - Playing: $isCurrentlyPlaying, Title: $title&quot;)&#10;&#10;        val playIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PLAY&quot; }&#10;        val pauseIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PAUSE&quot; }&#10;        val nextIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_NEXT&quot; }&#10;        val prevIntent = Intent(this, MusicService::class.java).apply { action = &quot;ACTION_PREV&quot; }&#10;&#10;        val playPendingIntent = PendingIntent.getService(this, 0, playIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val pausePendingIntent = PendingIntent.getService(this, 1, pauseIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val nextPendingIntent = PendingIntent.getService(this, 2, nextIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;        val prevPendingIntent = PendingIntent.getService(this, 3, prevIntent, PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE)&#10;&#10;        val builder = NotificationCompat.Builder(this, CHANNEL_ID)&#10;            .setContentTitle(title)&#10;            .setContentText(if (isCurrentlyPlaying) &quot;Reproduciendo...&quot; else &quot;En pausa&quot;)&#10;            .setSmallIcon(if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play)&#10;            .setContentIntent(createMainActivityPendingIntent())&#10;            .setVisibility(NotificationCompat.VISIBILITY_PUBLIC)&#10;            .setPriority(NotificationCompat.PRIORITY_LOW)&#10;            .setOngoing(true) // Notificación persistente&#10;            .setShowWhen(false)&#10;            .setOnlyAlertOnce(true) // Evita alertas repetidas&#10;&#10;        val compactActions = mutableListOf&lt;Int&gt;()&#10;        var actionIndex = 0&#10;&#10;        // Botón anterior (si hay pista anterior)&#10;        if (plyr.hasPrevious.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_previous, &quot;Previous&quot;, prevPendingIntent)&#10;            compactActions.add(actionIndex)&#10;            actionIndex++&#10;        }&#10;&#10;        // Botón play/pause (siempre presente)&#10;        val playPauseIcon = if (isCurrentlyPlaying) android.R.drawable.ic_media_pause else android.R.drawable.ic_media_play&#10;        val playPauseText = if (isCurrentlyPlaying) &quot;Pause&quot; else &quot;Play&quot;&#10;        val playPauseIntent = if (isCurrentlyPlaying) pausePendingIntent else playPendingIntent&#10;&#10;        builder.addAction(playPauseIcon, playPauseText, playPauseIntent)&#10;        compactActions.add(actionIndex)&#10;        actionIndex++&#10;&#10;        // Botón siguiente (si hay pista siguiente)&#10;        if (plyr.hasNext.value == true) {&#10;            builder.addAction(android.R.drawable.ic_media_next, &quot;Next&quot;, nextPendingIntent)&#10;            compactActions.add(actionIndex)&#10;        }&#10;&#10;        // MediaStyle simplificado sin MediaSession token&#10;        builder.setStyle(androidx.media.app.NotificationCompat.MediaStyle()&#10;            .setShowActionsInCompactView(*compactActions.toIntArray())&#10;        )&#10;&#10;        return builder.build()&#10;    }&#10;&#10;    private fun createMainActivityPendingIntent(): PendingIntent {&#10;        val intent = Intent(this, MainActivity::class.java)&#10;        return PendingIntent.getActivity(&#10;            this, 0, intent,&#10;            PendingIntent.FLAG_UPDATE_CURRENT or PendingIntent.FLAG_IMMUTABLE&#10;        )&#10;    }&#10;    /**&#10;     * Actualiza la notificación existente&#10;     */&#10;    private fun updateNotification() {&#10;        try {&#10;            val notification = createNotification()&#10;            val notificationManager = getSystemService(NotificationManager::class.java)&#10;            notificationManager.notify(NOTIFICATION_ID, notification)&#10;            Log.d(&quot;MusicService&quot;, &quot; Notificación actualizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;MusicService&quot;, &quot;❌ Error al actualizar notificación: ${e.message}&quot;, e)&#10;        }&#10;    }&#10;&#10;    // === BINDING ===&#10;    inner class MusicBinder : Binder() {&#10;        fun getService(): MusicService = this@MusicService&#10;    }&#10;&#10;    private val binder = MusicBinder()&#10;&#10;    override fun onBind(intent: Intent): IBinder {&#10;        return binder&#10;    }&#10;&#10;    // === LIMPIEZA DE RECURSOS ===&#10;    &#10;    /**&#10;     * Detiene el servicio foreground y limpia todos los recursos&#10;     */&#10;    fun stopForegroundService() {&#10;        Log.d(&quot;MusicService&quot;, &quot; Deteniendo servicio foreground&quot;)&#10;        &#10;        // Pausar la reproducción&#10;        val plyr = (application as PlyrApp).playerViewModel&#10;        plyr.pausePlayer()&#10;        &#10;        // Detener el servicio foreground&#10;        stopForeground(STOP_FOREGROUND_REMOVE)&#10;        &#10;        // Limpiar recursos&#10;        cleanupResources()&#10;        &#10;        // Detener el servicio completamente&#10;        stopSelf()&#10;    }&#10;    &#10;    override fun onDestroy() {&#10;        Log.d(&quot;MusicService&quot;, &quot;️ Destruyendo MusicService&quot;)&#10;        if (::wakeLock.isInitialized &amp;&amp; wakeLock.isHeld) {&#10;            wakeLock.release()&#10;        }&#10;        cleanupResources()&#10;        super.onDestroy()&#10;    }&#10;&#10;    private fun cleanupResources() {&#10;        mediaSession?.run {&#10;            release()&#10;            mediaSession = null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/FloatingMusicControls.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/FloatingMusicControls.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.livedata.observeAsState&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.clipToBounds&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.border&#10;import androidx.compose.animation.core.*&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import android.util.Log&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.IntOffset&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.utils.formatTime&#10;import com.plyr.utils.Config&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.delay&#10;import androidx.compose.foundation.background&#10;&#10;/**&#10; * FloatingMusicControls - Controles flotantes de música que aparecen en la parte inferior&#10; * &#10; * Este composable proporciona:&#10; * - Controles de reproducción (play/pause, seek)&#10; * - Información de la canción actual con texto en marquesina&#10; * - Barra de progreso interactiva&#10; * - Indicadores de carga y error&#10; * - Diseño terminal-style consistente con el tema de la app&#10; * &#10; * Se posiciona como overlay flotante que no interfiere con el contenido principal.&#10; */&#10;&#10;/**&#10; * Componente de texto con efecto marquesina para textos largos.&#10; * &#10; * @param text Texto a mostrar&#10; * @param modifier Modificadores de Compose&#10; * @param style Estilo del texto&#10; * @param color Color del texto&#10; * @param maxLines Número máximo de líneas&#10; */&#10;@Composable&#10;fun MarqueeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: androidx.compose.ui.text.TextStyle = MaterialTheme.typography.bodyMedium,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    maxLines: Int = 1&#10;) {&#10;    val density = LocalDensity.current&#10;    var textWidth by remember { mutableStateOf(0) }&#10;    var containerWidth by remember { mutableStateOf(0) }&#10;    val shouldAnimate = textWidth &gt; containerWidth &amp;&amp; containerWidth &gt; 0&#10;    &#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;marquee&quot;)&#10;    &#10;    val animatedOffset by infiniteTransition.animateFloat(&#10;        initialValue = 0f,&#10;        targetValue = if (shouldAnimate) -(textWidth - containerWidth).toFloat() else 0f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(&#10;                durationMillis = if (shouldAnimate) maxOf(text.length * 100, 3000) else 0,&#10;                easing = LinearEasing,&#10;                delayMillis = 1500 // Pausa al inicio&#10;            ),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;marquee_animation&quot;&#10;    )&#10;    &#10;    Box(&#10;        modifier = modifier&#10;            .clipToBounds()&#10;            .onSizeChanged { size -&gt;&#10;                containerWidth = size.width&#10;            }&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            style = style,&#10;            color = color,&#10;            maxLines = maxLines,&#10;            overflow = TextOverflow.Visible,&#10;            softWrap = false,&#10;            modifier = Modifier&#10;                .onSizeChanged { size -&gt;&#10;                    textWidth = size.width&#10;                }&#10;                .offset(x = with(density) { animatedOffset.toDp() })&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Controles flotantes principales de música.&#10; * &#10; * @param playerViewModel ViewModel que maneja la lógica de reproducción&#10; * @param modifier Modificadores de Compose para personalización&#10; */&#10;@Composable&#10;fun FloatingMusicControls(&#10;    playerViewModel: PlayerViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Observar estados del PlayerViewModel&#10;    val audioUrl by playerViewModel.audioUrl.observeAsState()&#10;    val currentTitle by playerViewModel.currentTitle.observeAsState()&#10;    val isLoading by playerViewModel.isLoading.observeAsState(false)&#10;    val error by playerViewModel.error.observeAsState()&#10;    &#10;    // Observar estados de navegación de playlist&#10;    val hasPrevious by playerViewModel.hasPrevious.observeAsState(false)&#10;    val hasNext by playerViewModel.hasNext.observeAsState(false)&#10;    val observedCurrentTrack by playerViewModel.currentTrack.observeAsState()&#10;    val observedCurrentPlaylist by playerViewModel.currentPlaylist.observeAsState()&#10;    val observedCurrentTrackIndex by playerViewModel.currentTrackIndex.observeAsState()&#10;    &#10;    // Observar estados de cola&#10;    val isQueueMode by playerViewModel.isQueueMode.observeAsState(false)&#10;    val playbackQueue by playerViewModel.playbackQueue.observeAsState(mutableListOf())&#10;    &#10;    // Debug: Log de estados de navegación&#10;    LaunchedEffect(hasPrevious, hasNext, observedCurrentPlaylist?.size, observedCurrentTrackIndex, isQueueMode, playbackQueue.size) {&#10;        Log.d(&quot;FloatingControls&quot;, &quot;Navigation states: hasPrevious=$hasPrevious, hasNext=$hasNext, playlistSize=${observedCurrentPlaylist?.size}, currentIndex=$observedCurrentTrackIndex, isQueue=$isQueueMode, queueSize=${playbackQueue.size}&quot;)&#10;    }&#10;    &#10;    // Estados locales del reproductor&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;    var duration by remember { mutableLongStateOf(0L) }&#10;    var position by remember { mutableLongStateOf(0L) }&#10;    var progress by remember { mutableFloatStateOf(0f) }&#10;&#10;    &#10;    // === EFECTOS Y ACTUALIZACIONES DE ESTADO ===&#10;    &#10;    /**&#10;     * Actualiza el estado del reproductor de forma periódica.&#10;     * Obtiene información de posición, duración y estado de reproducción.&#10;     */&#10;    LaunchedEffect(playerViewModel.exoPlayer) {&#10;        while (true) {&#10;            updatePlayerState(playerViewModel) { newIsPlaying, newDuration, newPosition, newProgress -&gt;&#10;                isPlaying = newIsPlaying&#10;                duration = newDuration&#10;                position = newPosition&#10;                progress = newProgress&#10;            }&#10;            delay(500) // Actualizar cada 500ms&#10;        }&#10;    }&#10;&#10;    // Mostrar controles solo si hay contenido o estado relevante&#10;    if (shouldShowControls(audioUrl, isLoading, error)) {&#10;        FloatingControlsCard(&#10;            modifier = modifier,&#10;            isLoading = isLoading,&#10;            error = error,&#10;            audioUrl = audioUrl,&#10;            currentTitle = currentTitle,&#10;            currentTrack = observedCurrentTrack,&#10;            currentPlaylist = observedCurrentPlaylist,&#10;            currentTrackIndex = observedCurrentTrackIndex,&#10;            position = position,&#10;            duration = duration,&#10;            progress = progress,&#10;            isPlaying = isPlaying,&#10;            hasPrevious = hasPrevious,&#10;            hasNext = hasNext,&#10;            isQueueMode = isQueueMode,&#10;            queueSize = playbackQueue.size,&#10;            playerViewModel = playerViewModel&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Actualiza los estados del reproductor desde ExoPlayer.&#10; */&#10;private suspend fun updatePlayerState(&#10;    playerViewModel: PlayerViewModel,&#10;    onUpdate: (Boolean, Long, Long, Float) -&gt; Unit&#10;) {&#10;    playerViewModel.exoPlayer?.let { player -&gt;&#10;        val currentIsPlaying = player.isPlaying&#10;        val currentDuration = if (player.duration &gt; 0) player.duration else 1L&#10;        val currentPosition = player.currentPosition&#10;        val currentProgress = if (currentDuration &gt; 0) currentPosition.toFloat() / currentDuration.toFloat() else 0f&#10;        &#10;        onUpdate(currentIsPlaying, currentDuration, currentPosition, currentProgress)&#10;    }&#10;}&#10;&#10;/**&#10; * Determina si los controles deben mostrarse.&#10; */&#10;private fun shouldShowControls(audioUrl: String?, isLoading: Boolean, error: String?): Boolean {&#10;    return audioUrl != null || isLoading || error != null&#10;}&#10;&#10;/**&#10; * Card principal que contiene todos los controles flotantes.&#10; */&#10;@Composable&#10;private fun FloatingControlsCard(&#10;    modifier: Modifier,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    audioUrl: String?,&#10;    currentTitle: String?,&#10;    currentTrack: TrackEntity?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?,&#10;    position: Long,&#10;    duration: Long,&#10;    progress: Float,&#10;    isPlaying: Boolean,&#10;    hasPrevious: Boolean,&#10;    hasNext: Boolean,&#10;    isQueueMode: Boolean,&#10;    queueSize: Int,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(horizontal = 16.dp, vertical = 6.dp)&#10;        ) {&#10;            // Línea de estado y título&#10;            StatusAndTitleRow(&#10;                isLoading = isLoading,&#10;                error = error,&#10;                audioUrl = audioUrl,&#10;                currentTitle = currentTitle,&#10;                currentTrack = currentTrack,&#10;                currentPlaylist = currentPlaylist,&#10;                currentTrackIndex = currentTrackIndex,&#10;                position = position,&#10;                duration = duration&#10;            )&#10;            &#10;            // Barra de progreso/loading&#10;            ProgressSection(&#10;                isLoading = isLoading,&#10;                audioUrl = audioUrl,&#10;                progress = progress,&#10;                duration = duration,&#10;                playerViewModel = playerViewModel&#10;            )&#10;            &#10;            // Controles de reproducción&#10;            PlaybackControlsRow(&#10;                audioUrl = audioUrl,&#10;                isLoading = isLoading,&#10;                isPlaying = isPlaying,&#10;                hasPrevious = hasPrevious,&#10;                hasNext = hasNext,&#10;                playerViewModel = playerViewModel&#10;            )&#10;            &#10;            // Indicador de cola si está activa&#10;            if (isQueueMode &amp;&amp; queueSize &gt; 0) {&#10;                QueueIndicator(queueSize = queueSize)&#10;            }&#10;            &#10;            // Mensaje de error si existe&#10;            error?.let {&#10;                ErrorMessage(it)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Fila que muestra el estado y título de la canción.&#10; */&#10;@Composable&#10;private fun StatusAndTitleRow(&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    audioUrl: String?,&#10;    currentTitle: String?,&#10;    currentTrack: TrackEntity?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?,&#10;    position: Long,&#10;    duration: Long&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(bottom = 4.dp),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Estado y título&#10;        Row(&#10;            modifier = Modifier.weight(1f),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            StatusIndicator(isLoading, error, audioUrl, currentPlaylist, currentTrackIndex)&#10;            &#10;            if (audioUrl != null &amp;&amp; !isLoading) {&#10;                TitleWithMarquee(currentTitle, currentTrack)&#10;            }&#10;        }&#10;        &#10;        // Información de tiempo y playlist&#10;        Column(&#10;            horizontalAlignment = Alignment.End&#10;        ) {&#10;            if (audioUrl != null &amp;&amp; !isLoading) {&#10;                TimeDisplay(position, duration)&#10;                &#10;                // Mostrar información de playlist si está disponible&#10;                PlaylistInfoDisplay(currentPlaylist, currentTrackIndex)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Indicador de estado del reproductor.&#10; */&#10;@Composable&#10;private fun StatusIndicator(&#10;    isLoading: Boolean, &#10;    error: String?, &#10;    audioUrl: String?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?&#10;) {&#10;    val hasPlaylist = currentPlaylist != null &amp;&amp; currentPlaylist.isNotEmpty()&#10;    &#10;    Text(&#10;        text = when {&#10;            isLoading -&gt; &quot;$ loading&quot;&#10;            error != null -&gt; &quot;$ error&quot;&#10;            audioUrl != null &amp;&amp; hasPlaylist -&gt; &quot;$ &quot;&#10;            audioUrl != null -&gt; &quot;$ &quot;&#10;            else -&gt; &quot;$ ready&quot;&#10;        },&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp,&#10;            color = when {&#10;                error != null -&gt; MaterialTheme.colorScheme.error&#10;                isLoading -&gt; Color(0xFFFFD93D)&#10;                audioUrl != null -&gt; MaterialTheme.colorScheme.primary&#10;                else -&gt; MaterialTheme.colorScheme.secondary&#10;            }&#10;        )&#10;    )&#10;}&#10;&#10;/**&#10; * Título con efecto marquesina.&#10; */&#10;@Composable&#10;private fun RowScope.TitleWithMarquee(currentTitle: String?, currentTrack: TrackEntity?) {&#10;    val displayTitle = when {&#10;        currentTrack != null -&gt; &quot;${currentTrack.name} - ${currentTrack.artists}&quot;&#10;        currentTitle != null -&gt; currentTitle&#10;        else -&gt; &quot;Playing audio...&quot;&#10;    }&#10;    &#10;    MarqueeText(&#10;        text = displayTitle,&#10;        modifier = Modifier.weight(1f),&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp&#10;        ),&#10;        color = MaterialTheme.colorScheme.primary&#10;    )&#10;}&#10;&#10;/**&#10; * Display de tiempo actual y duración.&#10; */&#10;@Composable&#10;private fun TimeDisplay(position: Long, duration: Long) {&#10;    Text(&#10;        text = &quot;${formatTime(position)}/${formatTime(duration)}&quot;,&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp,&#10;            color = MaterialTheme.colorScheme.secondary&#10;        )&#10;    )&#10;}&#10;&#10;/**&#10; * Display de información de playlist.&#10; */&#10;@Composable&#10;private fun PlaylistInfoDisplay(currentPlaylist: List&lt;TrackEntity&gt;?, currentTrackIndex: Int?) {&#10;    if (currentPlaylist != null &amp;&amp; currentTrackIndex != null &amp;&amp; currentPlaylist.isNotEmpty()) {&#10;        Text(&#10;            text = &quot;${currentTrackIndex + 1}/${currentPlaylist.size}&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 10.sp,&#10;                color = MaterialTheme.colorScheme.secondary&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Sección de barra de progreso o indicador de carga.&#10; */&#10;@Composable&#10;private fun ProgressSection(&#10;    isLoading: Boolean,&#10;    audioUrl: String?,&#10;    progress: Float,&#10;    duration: Long,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    var isDragging by remember { mutableStateOf(false) }&#10;    var dragProgress by remember { mutableFloatStateOf(0f) }&#10;    var lastDragProgress by remember { mutableFloatStateOf(0f) }&#10;    val displayProgress = if (isDragging) dragProgress else progress&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(8.dp)&#10;    ) {&#10;        if (isLoading) {&#10;            LoadingProgressBar()&#10;        } else {&#10;            // Slider interactivo estilo Spotify/YouTube&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(4.dp)&#10;                    .clip(RoundedCornerShape(2.dp))&#10;                    .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))&#10;                    .pointerInput(Unit) {&#10;                        detectDragGestures(&#10;                            onDragStart = { offset -&gt;&#10;                                if (audioUrl != null &amp;&amp; duration &gt; 0) {&#10;                                    isDragging = true&#10;                                    dragProgress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                                    lastDragProgress = dragProgress&#10;                                }&#10;                            },&#10;                            onDrag = { change, dragAmount -&gt;&#10;                                if (audioUrl != null &amp;&amp; duration &gt; 0) {&#10;                                    val newProgress = ((change.position.x) / size.width).coerceIn(0f, 1f)&#10;                                    dragProgress = newProgress&#10;                                    lastDragProgress = newProgress&#10;                                }&#10;                            },&#10;                            onDragEnd = {&#10;                                if (isDragging &amp;&amp; duration &gt; 0) {&#10;                                    val newPosition = (duration * lastDragProgress).toLong()&#10;                                    playerViewModel.seekTo(newPosition)&#10;                                    isDragging = false&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;            ) {&#10;                // Barra de progreso visual&#10;                if (audioUrl != null) {&#10;                    ProgressBar(displayProgress)&#10;                    ProgressIndicator(displayProgress, isDragging)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Barra de progreso para estado de carga.&#10; */&#10;@Composable&#10;private fun LoadingProgressBar() {&#10;    LinearProgressIndicator(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(4.dp)&#10;            .clip(RoundedCornerShape(2.dp)),&#10;        color = Color(0xFFFFD93D),&#10;        trackColor = Color(0xFF2C2C2C).copy(alpha = 0.3f),&#10;    )&#10;}&#10;&#10;/**&#10; * Barra de progreso interactiva para reproducción.&#10; */&#10;@Composable&#10;private fun InteractiveProgressBar(&#10;    audioUrl: String?,&#10;    displayProgress: Float,&#10;    duration: Long,&#10;    isDragging: Boolean,&#10;    onDragStart: (Float) -&gt; Unit,&#10;    onDragEnd: () -&gt; Unit,&#10;    onTap: (Float) -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(4.dp)&#10;            .clip(RoundedCornerShape(2.dp))&#10;            .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))&#10;            .pointerInput(Unit) {&#10;                detectDragGestures(&#10;                    onDragStart = { offset -&gt;&#10;                        val progress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                        onDragStart(progress)&#10;                    },&#10;                    onDrag = { _, _ -&gt; /* Handled in start/end */ },&#10;                    onDragEnd = { onDragEnd() }&#10;                )&#10;            }&#10;            .pointerInput(Unit) {&#10;                detectTapGestures { offset -&gt;&#10;                    val progress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                    onTap(progress)&#10;                }&#10;            }&#10;    ) {&#10;        // Barra de progreso visual&#10;        if (audioUrl != null) {&#10;            ProgressBar(displayProgress)&#10;            ProgressIndicator(displayProgress, isDragging)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Barra visual de progreso.&#10; */&#10;@Composable&#10;private fun ProgressBar(progress: Float) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxHeight()&#10;            .fillMaxWidth(progress)&#10;            .background(&#10;                MaterialTheme.colorScheme.primary,&#10;                RoundedCornerShape(2.dp)&#10;            )&#10;    )&#10;}&#10;&#10;/**&#10; * Indicador circular de posición.&#10; */&#10;@Composable&#10;private fun ProgressIndicator(progress: Float, isDragging: Boolean) {&#10;    val density = LocalDensity.current&#10;    &#10;    Box(&#10;        modifier = Modifier&#10;            .size(if (isDragging) 16.dp else 12.dp) // Más grande al arrastrar&#10;            .background(&#10;                MaterialTheme.colorScheme.primary,&#10;                androidx.compose.foundation.shape.CircleShape&#10;            )&#10;            .border(&#10;                1.dp,&#10;                MaterialTheme.colorScheme.surface,&#10;                androidx.compose.foundation.shape.CircleShape&#10;            )&#10;            .offset(x = (progress * density.run { &#10;                (300.dp - 12.dp).toPx() &#10;            } / density.density).dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Fila de controles de reproducción (anterior, play/pause, siguiente, repetición).&#10; */&#10;@Composable&#10;private fun PlaybackControlsRow(&#10;    audioUrl: String?,&#10;    isLoading: Boolean,&#10;    isPlaying: Boolean,&#10;    hasPrevious: Boolean,&#10;    hasNext: Boolean,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;&#10;    // Estado del modo de repetición&#10;    var currentRepeatMode by remember { mutableStateOf(Config.getRepeatMode(context)) }&#10;&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 6.dp),&#10;        horizontalArrangement = Arrangement.SpaceEvenly,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Botón anterior&#10;        PlaybackButton(&#10;            text = &quot;&lt;&lt;&quot;,&#10;            fontSize = 16.sp,&#10;            isEnabled = audioUrl != null &amp;&amp; !isLoading &amp;&amp; hasPrevious,&#10;            onClick = {&#10;                coroutineScope.launch {&#10;                    playerViewModel.navigateToPrevious()&#10;                }&#10;            }&#10;        )&#10;&#10;        // Botón play/pause principal&#10;        PlaybackButton(&#10;            text = if (isPlaying) &quot;//&quot; else &quot;&gt;&quot;,&#10;            fontSize = 24.sp,&#10;            isEnabled = audioUrl != null &amp;&amp; !isLoading,&#10;            onClick = {&#10;                if (isPlaying) {&#10;                    playerViewModel.pausePlayer()&#10;                } else {&#10;                    playerViewModel.playPlayer()&#10;                }&#10;            }&#10;        )&#10;&#10;        // Botón siguiente&#10;        PlaybackButton(&#10;            text = &quot;&gt;&gt;&quot;,&#10;            fontSize = 16.sp,&#10;            isEnabled = audioUrl != null &amp;&amp; !isLoading &amp;&amp; hasNext,&#10;            onClick = {&#10;                coroutineScope.launch {&#10;                    playerViewModel.navigateToNext()&#10;                }&#10;            }&#10;        )&#10;&#10;        // Botón de repetición&#10;        RepeatButton(&#10;            currentMode = currentRepeatMode,&#10;            isEnabled = audioUrl != null &amp;&amp; !isLoading,&#10;            onClick = {&#10;                val nextMode = Config.getNextRepeatMode(currentRepeatMode)&#10;                currentRepeatMode = nextMode&#10;                Config.setRepeatMode(context, nextMode)&#10;                // TODO: Aplicar la lógica de repetición al PlayerViewModel&#10;            }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Botón de control de reproducción reutilizable.&#10; */&#10;@Composable&#10;private fun PlaybackButton(&#10;    text: String,&#10;    fontSize: androidx.compose.ui.unit.TextUnit,&#10;    isEnabled: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = fontSize&#10;        ),&#10;        color = if (isEnabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,&#10;        modifier = Modifier&#10;            .clickable(enabled = isEnabled) { onClick() }&#10;            .padding(6.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Botón de repetición con estilo terminal que cicla entre modos.&#10; */&#10;@Composable&#10;private fun RepeatButton(&#10;    currentMode: String,&#10;    isEnabled: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    val symbol = Config.REPEAT_MODE_SYMBOLS[currentMode] ?: &quot;0&quot;&#10;    val color = when (currentMode) {&#10;        Config.REPEAT_MODE_OFF -&gt; MaterialTheme.colorScheme.outline&#10;        Config.REPEAT_MODE_ONE -&gt; Color(0xFFFFD93D)&#10;        Config.REPEAT_MODE_ALL -&gt; Color(0xFF4ECDC4)&#10;        else -&gt; MaterialTheme.colorScheme.outline&#10;    }&#10;&#10;    Text(&#10;        text = symbol,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 16.sp&#10;        ),&#10;        color = if (isEnabled) color else MaterialTheme.colorScheme.outline.copy(alpha = 0.5f),&#10;        modifier = Modifier&#10;            .clickable(enabled = isEnabled) { onClick() }&#10;            .padding(6.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Mensaje de error compacto.&#10; */&#10;@Composable&#10;private fun ErrorMessage(error: String) {&#10;    Text(&#10;        text = &quot;ERR: ${error.take(40)}${if (error.length &gt; 40) &quot;...&quot; else &quot;&quot;}&quot;,&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 10.sp,&#10;            color = MaterialTheme.colorScheme.error&#10;        ),&#10;        maxLines = 1,&#10;        overflow = TextOverflow.Ellipsis,&#10;        modifier = Modifier.padding(top = 4.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Indicador de cola que muestra cuántos tracks están pendientes.&#10; */&#10;@Composable&#10;private fun QueueIndicator(queueSize: Int) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        horizontalArrangement = Arrangement.Center,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Text(&#10;            text = &quot;● QUEUE: $queueSize pending&quot;,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 12.sp,&#10;                color = Color(0xFFFF6B6B)&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// === PREVIEWS ===&#10;&#10;/**&#10; * Preview de los controles flotantes de música.&#10; * Muestra una simulación del componente con datos mock.&#10; */&#10;@Preview(showBackground = true, widthDp = 320, heightDp = 200)&#10;@Composable&#10;fun FloatingMusicControlsPreview() {&#10;    TerminalTheme {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Simulación de controles flotantes con datos mock&#10;            MockFloatingControls(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Componente mock para el preview.&#10; */&#10;@Composable&#10;private fun MockFloatingControls(modifier: Modifier = Modifier) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            // Estado y título mock&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;$ Now Playing: Sample Song Title&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                Text(&#10;                    text = &quot;01:23/04:56&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    )&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            &#10;            // Barra de progreso mock&#10;            LinearProgressIndicator(&#10;                progress = 0.3f,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(4.dp)&#10;                    .clip(RoundedCornerShape(2.dp)),&#10;                color = MaterialTheme.colorScheme.primary,&#10;                trackColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(6.dp))&#10;&#10;            // Controles mock&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                MockPlaybackButton(&quot;&lt;&lt;&quot;, 16.sp)&#10;                MockPlaybackButton(&quot;||&quot;, 24.sp) // Pause state&#10;                MockPlaybackButton(&quot;&gt;&gt;&quot;, 16.sp)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Botón mock para el preview.&#10; */&#10;@Composable&#10;private fun MockPlaybackButton(text: String, fontSize: androidx.compose.ui.unit.TextUnit) {&#10;    Text(&#10;        text = text,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = fontSize&#10;        ),&#10;        color = MaterialTheme.colorScheme.primary,&#10;        modifier = Modifier.padding(6.dp)&#10;    )&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.gestures.detectTapGestures&#10;import androidx.compose.foundation.gestures.detectDragGestures&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.livedata.observeAsState&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.tooling.preview.Preview&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.draw.clipToBounds&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.foundation.border&#10;import androidx.compose.animation.core.*&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.runtime.rememberCoroutineScope&#10;import android.util.Log&#10;import androidx.compose.ui.platform.LocalConfiguration&#10;import androidx.compose.ui.unit.IntOffset&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.utils.formatTime&#10;import com.plyr.utils.Config&#10;import com.plyr.ui.theme.TerminalTheme&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.delay&#10;import androidx.compose.foundation.background&#10;&#10;/**&#10; * FloatingMusicControls - Controles flotantes de música que aparecen en la parte inferior&#10; * &#10; * Este composable proporciona:&#10; * - Controles de reproducción (play/pause, seek)&#10; * - Información de la canción actual con texto en marquesina&#10; * - Barra de progreso interactiva&#10; * - Indicadores de carga y error&#10; * - Diseño terminal-style consistente con el tema de la app&#10; * &#10; * Se posiciona como overlay flotante que no interfiere con el contenido principal.&#10; */&#10;&#10;/**&#10; * Componente de texto con efecto marquesina para textos largos.&#10; * &#10; * @param text Texto a mostrar&#10; * @param modifier Modificadores de Compose&#10; * @param style Estilo del texto&#10; * @param color Color del texto&#10; * @param maxLines Número máximo de líneas&#10; */&#10;@Composable&#10;fun MarqueeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: androidx.compose.ui.text.TextStyle = MaterialTheme.typography.bodyMedium,&#10;    color: Color = MaterialTheme.colorScheme.onSurface,&#10;    maxLines: Int = 1&#10;) {&#10;    val density = LocalDensity.current&#10;    var textWidth by remember { mutableStateOf(0) }&#10;    var containerWidth by remember { mutableStateOf(0) }&#10;    val shouldAnimate = textWidth &gt; containerWidth &amp;&amp; containerWidth &gt; 0&#10;    &#10;    val infiniteTransition = rememberInfiniteTransition(label = &quot;marquee&quot;)&#10;    &#10;    val animatedOffset by infiniteTransition.animateFloat(&#10;        initialValue = 0f,&#10;        targetValue = if (shouldAnimate) -(textWidth - containerWidth).toFloat() else 0f,&#10;        animationSpec = infiniteRepeatable(&#10;            animation = tween(&#10;                durationMillis = if (shouldAnimate) maxOf(text.length * 100, 3000) else 0,&#10;                easing = LinearEasing,&#10;                delayMillis = 1500 // Pausa al inicio&#10;            ),&#10;            repeatMode = RepeatMode.Restart&#10;        ),&#10;        label = &quot;marquee_animation&quot;&#10;    )&#10;    &#10;    Box(&#10;        modifier = modifier&#10;            .clipToBounds()&#10;            .onSizeChanged { size -&gt;&#10;                containerWidth = size.width&#10;            }&#10;    ) {&#10;        Text(&#10;            text = text,&#10;            style = style,&#10;            color = color,&#10;            maxLines = maxLines,&#10;            overflow = TextOverflow.Visible,&#10;            softWrap = false,&#10;            modifier = Modifier&#10;                .onSizeChanged { size -&gt;&#10;                    textWidth = size.width&#10;                }&#10;                .offset(x = with(density) { animatedOffset.toDp() })&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Controles flotantes principales de música.&#10; * &#10; * @param playerViewModel ViewModel que maneja la lógica de reproducción&#10; * @param modifier Modificadores de Compose para personalización&#10; */&#10;@Composable&#10;fun FloatingMusicControls(&#10;    playerViewModel: PlayerViewModel,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    // Observar estados del PlayerViewModel&#10;    val audioUrl by playerViewModel.audioUrl.observeAsState()&#10;    val currentTitle by playerViewModel.currentTitle.observeAsState()&#10;    val isLoading by playerViewModel.isLoading.observeAsState(false)&#10;    val error by playerViewModel.error.observeAsState()&#10;    &#10;    // Observar estados de navegación de playlist&#10;    val hasPrevious by playerViewModel.hasPrevious.observeAsState(false)&#10;    val hasNext by playerViewModel.hasNext.observeAsState(false)&#10;    val observedCurrentTrack by playerViewModel.currentTrack.observeAsState()&#10;    val observedCurrentPlaylist by playerViewModel.currentPlaylist.observeAsState()&#10;    val observedCurrentTrackIndex by playerViewModel.currentTrackIndex.observeAsState()&#10;    &#10;    // Observar estados de cola&#10;    val isQueueMode by playerViewModel.isQueueMode.observeAsState(false)&#10;    val playbackQueue by playerViewModel.playbackQueue.observeAsState(mutableListOf())&#10;    &#10;    // Debug: Log de estados de navegación&#10;    LaunchedEffect(hasPrevious, hasNext, observedCurrentPlaylist?.size, observedCurrentTrackIndex, isQueueMode, playbackQueue.size) {&#10;        Log.d(&quot;FloatingControls&quot;, &quot;Navigation states: hasPrevious=$hasPrevious, hasNext=$hasNext, playlistSize=${observedCurrentPlaylist?.size}, currentIndex=$observedCurrentTrackIndex, isQueue=$isQueueMode, queueSize=${playbackQueue.size}&quot;)&#10;    }&#10;    &#10;    // Estados locales del reproductor&#10;    var isPlaying by remember { mutableStateOf(false) }&#10;    var duration by remember { mutableLongStateOf(0L) }&#10;    var position by remember { mutableLongStateOf(0L) }&#10;    var progress by remember { mutableFloatStateOf(0f) }&#10;&#10;    &#10;    // === EFECTOS Y ACTUALIZACIONES DE ESTADO ===&#10;    &#10;    /**&#10;     * Actualiza el estado del reproductor de forma periódica.&#10;     * Obtiene información de posición, duración y estado de reproducción.&#10;     */&#10;    LaunchedEffect(playerViewModel.exoPlayer) {&#10;        while (true) {&#10;            updatePlayerState(playerViewModel) { newIsPlaying, newDuration, newPosition, newProgress -&gt;&#10;                isPlaying = newIsPlaying&#10;                duration = newDuration&#10;                position = newPosition&#10;                progress = newProgress&#10;            }&#10;            delay(500) // Actualizar cada 500ms&#10;        }&#10;    }&#10;&#10;    // Mostrar controles solo si hay contenido o estado relevante&#10;    if (shouldShowControls(audioUrl, isLoading, error)) {&#10;        FloatingControlsCard(&#10;            modifier = modifier,&#10;            isLoading = isLoading,&#10;            error = error,&#10;            audioUrl = audioUrl,&#10;            currentTitle = currentTitle,&#10;            currentTrack = observedCurrentTrack,&#10;            currentPlaylist = observedCurrentPlaylist,&#10;            currentTrackIndex = observedCurrentTrackIndex,&#10;            position = position,&#10;            duration = duration,&#10;            progress = progress,&#10;            isPlaying = isPlaying,&#10;            hasPrevious = hasPrevious,&#10;            hasNext = hasNext,&#10;            isQueueMode = isQueueMode,&#10;            queueSize = playbackQueue.size,&#10;            playerViewModel = playerViewModel&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Actualiza los estados del reproductor desde ExoPlayer.&#10; */&#10;private suspend fun updatePlayerState(&#10;    playerViewModel: PlayerViewModel,&#10;    onUpdate: (Boolean, Long, Long, Float) -&gt; Unit&#10;) {&#10;    playerViewModel.exoPlayer?.let { player -&gt;&#10;        val currentIsPlaying = player.isPlaying&#10;        val currentDuration = if (player.duration &gt; 0) player.duration else 1L&#10;        val currentPosition = player.currentPosition&#10;        val currentProgress = if (currentDuration &gt; 0) currentPosition.toFloat() / currentDuration.toFloat() else 0f&#10;        &#10;        onUpdate(currentIsPlaying, currentDuration, currentPosition, currentProgress)&#10;    }&#10;}&#10;&#10;/**&#10; * Determina si los controles deben mostrarse.&#10; */&#10;private fun shouldShowControls(audioUrl: String?, isLoading: Boolean, error: String?): Boolean {&#10;    return audioUrl != null || isLoading || error != null&#10;}&#10;&#10;/**&#10; * Card principal que contiene todos los controles flotantes.&#10; */&#10;@Composable&#10;private fun FloatingControlsCard(&#10;    modifier: Modifier,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    audioUrl: String?,&#10;    currentTitle: String?,&#10;    currentTrack: TrackEntity?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?,&#10;    position: Long,&#10;    duration: Long,&#10;    progress: Float,&#10;    isPlaying: Boolean,&#10;    hasPrevious: Boolean,&#10;    hasNext: Boolean,&#10;    isQueueMode: Boolean,&#10;    queueSize: Int,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    Card(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .padding(horizontal = 16.dp, vertical = 4.dp),&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp),&#10;        shape = RoundedCornerShape(12.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(horizontal = 16.dp, vertical = 6.dp)&#10;        ) {&#10;            // Línea de estado y título&#10;            StatusAndTitleRow(&#10;                isLoading = isLoading,&#10;                error = error,&#10;                audioUrl = audioUrl,&#10;                currentTitle = currentTitle,&#10;                currentTrack = currentTrack,&#10;                currentPlaylist = currentPlaylist,&#10;                currentTrackIndex = currentTrackIndex,&#10;                position = position,&#10;                duration = duration&#10;            )&#10;            &#10;            // Barra de progreso/loading&#10;            ProgressSection(&#10;                isLoading = isLoading,&#10;                audioUrl = audioUrl,&#10;                progress = progress,&#10;                duration = duration,&#10;                playerViewModel = playerViewModel&#10;            )&#10;            &#10;            // Controles de reproducción&#10;            PlaybackControlsRow(&#10;                audioUrl = audioUrl,&#10;                isLoading = isLoading,&#10;                isPlaying = isPlaying,&#10;                hasPrevious = hasPrevious,&#10;                hasNext = hasNext,&#10;                playerViewModel = playerViewModel&#10;            )&#10;            &#10;            // Indicador de cola si está activa&#10;            if (isQueueMode &amp;&amp; queueSize &gt; 0) {&#10;                QueueIndicator(queueSize = queueSize)&#10;            }&#10;            &#10;            // Mensaje de error si existe&#10;            error?.let {&#10;                ErrorMessage(it)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Fila que muestra el estado y título de la canción.&#10; */&#10;@Composable&#10;private fun StatusAndTitleRow(&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    audioUrl: String?,&#10;    currentTitle: String?,&#10;    currentTrack: TrackEntity?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?,&#10;    position: Long,&#10;    duration: Long&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(bottom = 4.dp),&#10;        horizontalArrangement = Arrangement.SpaceBetween,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Estado y título&#10;        Row(&#10;            modifier = Modifier.weight(1f),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            StatusIndicator(isLoading, error, audioUrl, currentPlaylist, currentTrackIndex)&#10;            &#10;            if (audioUrl != null &amp;&amp; !isLoading) {&#10;                TitleWithMarquee(currentTitle, currentTrack)&#10;            }&#10;        }&#10;        &#10;        // Información de tiempo y playlist&#10;        Column(&#10;            horizontalAlignment = Alignment.End&#10;        ) {&#10;            if (audioUrl != null &amp;&amp; !isLoading) {&#10;                TimeDisplay(position, duration)&#10;                &#10;                // Mostrar información de playlist si está disponible&#10;                PlaylistInfoDisplay(currentPlaylist, currentTrackIndex)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Indicador de estado del reproductor.&#10; */&#10;@Composable&#10;private fun StatusIndicator(&#10;    isLoading: Boolean, &#10;    error: String?, &#10;    audioUrl: String?,&#10;    currentPlaylist: List&lt;TrackEntity&gt;?,&#10;    currentTrackIndex: Int?&#10;) {&#10;    val hasPlaylist = currentPlaylist != null &amp;&amp; currentPlaylist.isNotEmpty()&#10;    &#10;    Text(&#10;        text = when {&#10;            isLoading -&gt; &quot;$ loading&quot;&#10;            error != null -&gt; &quot;$ error&quot;&#10;            audioUrl != null &amp;&amp; hasPlaylist -&gt; &quot;$ &quot;&#10;            audioUrl != null -&gt; &quot;$ &quot;&#10;            else -&gt; &quot;$ ready&quot;&#10;        },&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp,&#10;            color = when {&#10;                error != null -&gt; MaterialTheme.colorScheme.error&#10;                isLoading -&gt; Color(0xFFFFD93D)&#10;                audioUrl != null -&gt; MaterialTheme.colorScheme.primary&#10;                else -&gt; MaterialTheme.colorScheme.secondary&#10;            }&#10;        )&#10;    )&#10;}&#10;&#10;/**&#10; * Título con efecto marquesina.&#10; */&#10;@Composable&#10;private fun RowScope.TitleWithMarquee(currentTitle: String?, currentTrack: TrackEntity?) {&#10;    val displayTitle = when {&#10;        currentTrack != null -&gt; &quot;${currentTrack.name} - ${currentTrack.artists}&quot;&#10;        currentTitle != null -&gt; currentTitle&#10;        else -&gt; &quot;Playing audio...&quot;&#10;    }&#10;    &#10;    MarqueeText(&#10;        text = displayTitle,&#10;        modifier = Modifier.weight(1f),&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp&#10;        ),&#10;        color = MaterialTheme.colorScheme.primary&#10;    )&#10;}&#10;&#10;/**&#10; * Display de tiempo actual y duración.&#10; */&#10;@Composable&#10;private fun TimeDisplay(position: Long, duration: Long) {&#10;    Text(&#10;        text = &quot;${formatTime(position)}/${formatTime(duration)}&quot;,&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp,&#10;            color = MaterialTheme.colorScheme.secondary&#10;        )&#10;    )&#10;}&#10;&#10;/**&#10; * Display de información de playlist.&#10; */&#10;@Composable&#10;private fun PlaylistInfoDisplay(currentPlaylist: List&lt;TrackEntity&gt;?, currentTrackIndex: Int?) {&#10;    if (currentPlaylist != null &amp;&amp; currentTrackIndex != null &amp;&amp; currentPlaylist.isNotEmpty()) {&#10;        Text(&#10;            text = &quot;${currentTrackIndex + 1}/${currentPlaylist.size}&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 10.sp,&#10;                color = MaterialTheme.colorScheme.secondary&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Sección de barra de progreso o indicador de carga.&#10; */&#10;@Composable&#10;private fun ProgressSection(&#10;    isLoading: Boolean,&#10;    audioUrl: String?,&#10;    progress: Float,&#10;    duration: Long,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    var isDragging by remember { mutableStateOf(false) }&#10;    var dragProgress by remember { mutableFloatStateOf(0f) }&#10;    var lastDragProgress by remember { mutableFloatStateOf(0f) }&#10;    val displayProgress = if (isDragging) dragProgress else progress&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(8.dp)&#10;    ) {&#10;        if (isLoading) {&#10;            LoadingProgressBar()&#10;        } else {&#10;            // Slider interactivo estilo Spotify/YouTube&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(4.dp)&#10;                    .clip(RoundedCornerShape(2.dp))&#10;                    .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))&#10;                    .pointerInput(Unit) {&#10;                        detectDragGestures(&#10;                            onDragStart = { offset -&gt;&#10;                                if (audioUrl != null &amp;&amp; duration &gt; 0) {&#10;                                    isDragging = true&#10;                                    dragProgress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                                    lastDragProgress = dragProgress&#10;                                }&#10;                            },&#10;                            onDrag = { change, dragAmount -&gt;&#10;                                if (audioUrl != null &amp;&amp; duration &gt; 0) {&#10;                                    val newProgress = ((change.position.x) / size.width).coerceIn(0f, 1f)&#10;                                    dragProgress = newProgress&#10;                                    lastDragProgress = newProgress&#10;                                }&#10;                            },&#10;                            onDragEnd = {&#10;                                if (isDragging &amp;&amp; duration &gt; 0) {&#10;                                    val newPosition = (duration * lastDragProgress).toLong()&#10;                                    playerViewModel.seekTo(newPosition)&#10;                                    isDragging = false&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;            ) {&#10;                // Barra de progreso visual&#10;                if (audioUrl != null) {&#10;                    ProgressBar(displayProgress)&#10;                    ProgressIndicator(displayProgress, isDragging)&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Barra de progreso para estado de carga.&#10; */&#10;@Composable&#10;private fun LoadingProgressBar() {&#10;    LinearProgressIndicator(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(4.dp)&#10;            .clip(RoundedCornerShape(2.dp)),&#10;        color = Color(0xFFFFD93D),&#10;        trackColor = Color(0xFF2C2C2C).copy(alpha = 0.3f),&#10;    )&#10;}&#10;&#10;/**&#10; * Barra de progreso interactiva para reproducción.&#10; */&#10;@Composable&#10;private fun InteractiveProgressBar(&#10;    audioUrl: String?,&#10;    displayProgress: Float,&#10;    duration: Long,&#10;    isDragging: Boolean,&#10;    onDragStart: (Float) -&gt; Unit,&#10;    onDragEnd: () -&gt; Unit,&#10;    onTap: (Float) -&gt; Unit&#10;) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .height(4.dp)&#10;            .clip(RoundedCornerShape(2.dp))&#10;            .background(MaterialTheme.colorScheme.surfaceVariant.copy(alpha = 0.5f))&#10;            .pointerInput(Unit) {&#10;                detectDragGestures(&#10;                    onDragStart = { offset -&gt;&#10;                        val progress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                        onDragStart(progress)&#10;                    },&#10;                    onDrag = { _, _ -&gt; /* Handled in start/end */ },&#10;                    onDragEnd = { onDragEnd() }&#10;                )&#10;            }&#10;            .pointerInput(Unit) {&#10;                detectTapGestures { offset -&gt;&#10;                    val progress = (offset.x / size.width).coerceIn(0f, 1f)&#10;                    onTap(progress)&#10;                }&#10;            }&#10;    ) {&#10;        // Barra de progreso visual&#10;        if (audioUrl != null) {&#10;            ProgressBar(displayProgress)&#10;            ProgressIndicator(displayProgress, isDragging)&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Barra visual de progreso.&#10; */&#10;@Composable&#10;private fun ProgressBar(progress: Float) {&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxHeight()&#10;            .fillMaxWidth(progress)&#10;            .background(&#10;                MaterialTheme.colorScheme.primary,&#10;                RoundedCornerShape(2.dp)&#10;            )&#10;    )&#10;}&#10;&#10;/**&#10; * Indicador circular de posición.&#10; */&#10;@Composable&#10;private fun ProgressIndicator(progress: Float, isDragging: Boolean) {&#10;    val density = LocalDensity.current&#10;    &#10;    Box(&#10;        modifier = Modifier&#10;            .size(if (isDragging) 16.dp else 12.dp) // Más grande al arrastrar&#10;            .background(&#10;                MaterialTheme.colorScheme.primary,&#10;                androidx.compose.foundation.shape.CircleShape&#10;            )&#10;            .border(&#10;                1.dp,&#10;                MaterialTheme.colorScheme.surface,&#10;                androidx.compose.foundation.shape.CircleShape&#10;            )&#10;            .offset(x = (progress * density.run { &#10;                (300.dp - 12.dp).toPx() &#10;            } / density.density).dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Fila de controles de reproducción (anterior, play/pause, siguiente, repetición).&#10; */&#10;@Composable&#10;private fun PlaybackControlsRow(&#10;    audioUrl: String?,&#10;    isLoading: Boolean,&#10;    isPlaying: Boolean,&#10;    hasPrevious: Boolean,&#10;    hasNext: Boolean,&#10;    playerViewModel: PlayerViewModel&#10;) {&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val context = androidx.compose.ui.platform.LocalContext.current&#10;&#10;    // Estado del modo de repetición&#10;    var currentRepeatMode by remember { mutableStateOf(Config.getRepeatMode(context)) }&#10;&#10;    Box(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(top = 6.dp)&#10;    ) {&#10;        // Botones principales centrados&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .align(Alignment.Center),&#10;            horizontalArrangement = Arrangement.Center,&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Botón anterior&#10;            PlaybackButton(&#10;                text = &quot;&lt;&lt;&quot;,&#10;                fontSize = 16.sp,&#10;                isEnabled = audioUrl != null &amp;&amp; !isLoading &amp;&amp; hasPrevious,&#10;                onClick = {&#10;                    coroutineScope.launch {&#10;                        playerViewModel.navigateToPrevious()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(24.dp))&#10;&#10;            // Botón play/pause principal&#10;            PlaybackButton(&#10;                text = if (isPlaying) &quot;//&quot; else &quot;&gt;&quot;,&#10;                fontSize = 24.sp,&#10;                isEnabled = audioUrl != null &amp;&amp; !isLoading,&#10;                onClick = {&#10;                    if (isPlaying) {&#10;                        playerViewModel.pausePlayer()&#10;                    } else {&#10;                        playerViewModel.playPlayer()&#10;                    }&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.width(24.dp))&#10;&#10;            // Botón siguiente&#10;            PlaybackButton(&#10;                text = &quot;&gt;&gt;&quot;,&#10;                fontSize = 16.sp,&#10;                isEnabled = audioUrl != null &amp;&amp; !isLoading &amp;&amp; hasNext,&#10;                onClick = {&#10;                    coroutineScope.launch {&#10;                        playerViewModel.navigateToNext()&#10;                    }&#10;                }&#10;            )&#10;        }&#10;&#10;        // Botón de repetición en la esquina inferior derecha&#10;        RepeatButton(&#10;            currentMode = currentRepeatMode,&#10;            isEnabled = audioUrl != null &amp;&amp; !isLoading,&#10;            onClick = {&#10;                val nextMode = Config.getNextRepeatMode(currentRepeatMode)&#10;                currentRepeatMode = nextMode&#10;                Config.setRepeatMode(context, nextMode)&#10;                // TODO: Aplicar la lógica de repetición al PlayerViewModel&#10;            },&#10;            modifier = Modifier.align(Alignment.BottomEnd)&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Botón de control de reproducción reutilizable.&#10; */&#10;@Composable&#10;private fun PlaybackButton(&#10;    text: String,&#10;    fontSize: androidx.compose.ui.unit.TextUnit,&#10;    isEnabled: Boolean,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = fontSize&#10;        ),&#10;        color = if (isEnabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.outline,&#10;        modifier = Modifier&#10;            .clickable(enabled = isEnabled) { onClick() }&#10;            .padding(6.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Botón de repetición con estilo terminal que cicla entre modos.&#10; */&#10;@Composable&#10;private fun RepeatButton(&#10;    currentMode: String,&#10;    isEnabled: Boolean,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    val symbol = when (currentMode) {&#10;        Config.REPEAT_MODE_OFF -&gt; &quot;o&quot;   // Sin repetición&#10;        Config.REPEAT_MODE_ONE -&gt; &quot;1&quot;   // Repetir una vez&#10;        Config.REPEAT_MODE_ALL -&gt; &quot;*&quot;   // Repetir indefinidamente&#10;        else -&gt; &quot;o&quot;&#10;    }&#10;    val color = when (currentMode) {&#10;        Config.REPEAT_MODE_OFF -&gt; MaterialTheme.colorScheme.outline&#10;        Config.REPEAT_MODE_ONE -&gt; Color(0xFFFFD93D)&#10;        Config.REPEAT_MODE_ALL -&gt; Color(0xFF4ECDC4)&#10;        else -&gt; MaterialTheme.colorScheme.outline&#10;    }&#10;&#10;    Text(&#10;        text = symbol,&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 12.sp&#10;        ),&#10;        color = if (isEnabled) color else MaterialTheme.colorScheme.outline.copy(alpha = 0.5f),&#10;        modifier = modifier&#10;            .clickable(enabled = isEnabled) { onClick() }&#10;            .padding(4.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Mensaje de error compacto.&#10; */&#10;@Composable&#10;private fun ErrorMessage(error: String) {&#10;    Text(&#10;        text = &quot;ERR: ${error.take(40)}${if (error.length &gt; 40) &quot;...&quot; else &quot;&quot;}&quot;,&#10;        style = MaterialTheme.typography.bodyMedium.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = 10.sp,&#10;            color = MaterialTheme.colorScheme.error&#10;        ),&#10;        maxLines = 1,&#10;        overflow = TextOverflow.Ellipsis,&#10;        modifier = Modifier.padding(top = 4.dp)&#10;    )&#10;}&#10;&#10;/**&#10; * Indicador de cola que muestra cuántos tracks están pendientes.&#10; */&#10;@Composable&#10;private fun QueueIndicator(queueSize: Int) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .padding(vertical = 4.dp),&#10;        horizontalArrangement = Arrangement.Center,&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Text(&#10;            text = &quot;● QUEUE: $queueSize pending&quot;,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 12.sp,&#10;                color = Color(0xFFFF6B6B)&#10;            )&#10;        )&#10;    }&#10;}&#10;&#10;// === PREVIEWS ===&#10;&#10;/**&#10; * Preview de los controles flotantes de música.&#10; * Muestra una simulación del componente con datos mock.&#10; */&#10;@Preview(showBackground = true, widthDp = 320, heightDp = 200)&#10;@Composable&#10;fun FloatingMusicControlsPreview() {&#10;    TerminalTheme {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .background(MaterialTheme.colorScheme.background)&#10;        ) {&#10;            // Simulación de controles flotantes con datos mock&#10;            MockFloatingControls(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .align(Alignment.BottomCenter)&#10;                    .padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Componente mock para el preview.&#10; */&#10;@Composable&#10;private fun MockFloatingControls(modifier: Modifier = Modifier) {&#10;    Card(&#10;        modifier = modifier,&#10;        colors = CardDefaults.cardColors(&#10;            containerColor = MaterialTheme.colorScheme.surface.copy(alpha = 0.95f)&#10;        ),&#10;        elevation = CardDefaults.cardElevation(defaultElevation = 8.dp)&#10;    ) {&#10;        Column(&#10;            modifier = Modifier.padding(12.dp)&#10;        ) {&#10;            // Estado y título mock&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceBetween&#10;            ) {&#10;                Text(&#10;                    text = &quot;$ Now Playing: Sample Song Title&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    ),&#10;                    modifier = Modifier.weight(1f)&#10;                )&#10;                Text(&#10;                    text = &quot;01:23/04:56&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp&#10;                    )&#10;                )&#10;            }&#10;            &#10;            Spacer(modifier = Modifier.height(4.dp))&#10;            &#10;            // Barra de progreso mock&#10;            LinearProgressIndicator(&#10;                progress = 0.3f,&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .height(4.dp)&#10;                    .clip(RoundedCornerShape(2.dp)),&#10;                color = MaterialTheme.colorScheme.primary,&#10;                trackColor = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.3f)&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(6.dp))&#10;&#10;            // Controles mock&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.SpaceEvenly,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                MockPlaybackButton(&quot;&lt;&lt;&quot;, 16.sp)&#10;                MockPlaybackButton(&quot;||&quot;, 24.sp) // Pause state&#10;                MockPlaybackButton(&quot;&gt;&gt;&quot;, 16.sp)&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * Botón mock para el preview.&#10; */&#10;@Composable&#10;private fun MockPlaybackButton(text: String, fontSize: androidx.compose.ui.unit.TextUnit) {&#10;    Text(&#10;        text = text,&#10;        style = MaterialTheme.typography.bodyLarge.copy(&#10;            fontFamily = FontFamily.Monospace,&#10;            fontSize = fontSize&#10;        ),&#10;        color = MaterialTheme.colorScheme.primary,&#10;        modifier = Modifier.padding(6.dp)&#10;    )&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.OutlinedTextFieldDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para paginación&#10;    var currentOffset by remember { mutableStateOf(0) }&#10;    var isLoadingMore by remember { mutableStateOf(false) }&#10;    var hasMoreResults by remember { mutableStateOf(true) }&#10;    val itemsPerPage = 10&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) } // Nuevo estado para artista&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) } // Nuevo estado para álbumes del artista&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) } // Nuevo estado de carga para álbumes&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoadingMore = true&#10;            } else {&#10;                isLoading = true&#10;                currentOffset = 0&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                hasMoreResults = true&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        isLoadingMore = false&#10;                        error = &quot;Query vacía después de procesar prefijo&quot;&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Search YouTube with detailed information&#10;                            val youtubeResults = youtubeSearchManager.searchYouTubeVideosDetailed(finalQuery)&#10;                            // Convert YouTube video info to AudioItem objects&#10;                            val newResults = youtubeResults.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            if (isLoadMore) {&#10;                                results = results + newResults&#10;                            } else {&#10;                                results = newResults&#10;                            }&#10;&#10;                            hasMoreResults = newResults.size &gt;= itemsPerPage&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    Log.d(&quot;SearchScreen&quot;, &quot; Iniciando búsqueda en Spotify: '$finalQuery'&quot;)&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                error = &quot;Error searching Spotify: $searchError&quot;&#10;                                                Log.e(&quot;SearchScreen&quot;, &quot;Error searching Spotify: $searchError&quot;)&#10;                                            } else if (searchResults != null) {&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Resultados actualizados: ${searchResults.tracks.items.size} tracks, ${searchResults.albums.items.size} albums, ${searchResults.artists.items.size} artists, ${searchResults.playlists.items.size} playlists&quot;)&#10;&#10;                                                if (isLoadMore &amp;&amp; spotifyResults != null) {&#10;                                                    // Combinar resultados existentes con nuevos&#10;                                                    val combinedResults = SpotifySearchAllResponse(&#10;                                                        tracks = SpotifyTracksSearchResult(&#10;                                                            items = spotifyResults!!.tracks.items + searchResults.tracks.items,&#10;                                                            total = searchResults.tracks.total,&#10;                                                            limit = searchResults.tracks.limit,&#10;                                                            offset = searchResults.tracks.offset,&#10;                                                            next = searchResults.tracks.next&#10;                                                        ),&#10;                                                        albums = SpotifyAlbumsSearchResult(&#10;                                                            items = spotifyResults!!.albums.items + searchResults.albums.items,&#10;                                                            total = searchResults.albums.total,&#10;                                                            limit = searchResults.albums.limit,&#10;                                                            offset = searchResults.albums.offset,&#10;                                                            next = searchResults.albums.next&#10;                                                        ),&#10;                                                        artists = SpotifyArtistsSearchResult(&#10;                                                            items = spotifyResults!!.artists.items + searchResults.artists.items,&#10;                                                            total = searchResults.artists.total,&#10;                                                            limit = searchResults.artists.limit,&#10;                                                            offset = searchResults.artists.offset,&#10;                                                            next = searchResults.artists.next&#10;                                                        ),&#10;                                                        playlists = SpotifyPlaylistsSearchResult(&#10;                                                            items = spotifyResults!!.playlists.items + searchResults.playlists.items,&#10;                                                            total = searchResults.playlists.total,&#10;                                                            limit = searchResults.playlists.limit,&#10;                                                            offset = searchResults.playlists.offset,&#10;                                                            next = searchResults.playlists.next&#10;                                                        )&#10;                                                    )&#10;                                                    spotifyResults = combinedResults&#10;                                                } else {&#10;                                                    spotifyResults = searchResults&#10;                                                }&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                hasMoreResults = false&#10;&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                showSpotifyResults = true&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot; Estado actualizado - showSpotifyResults=$showSpotifyResults&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    isLoadingMore = false&#10;                                    error = &quot;Token de Spotify no disponible&quot;&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                isLoadingMore = false&#10;                                error = &quot;Spotify no está conectado&quot;&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                            error = &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;&#10;                            Log.w(&quot;SearchScreen&quot;, &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;)&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    isLoadingMore = false&#10;                    error = &quot;Error en búsqueda: ${e.message}&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;Error en búsqueda&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Guardando playlist en biblioteca de Spotify: ${playlist.name}&quot;)&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Playlist seguida exitosamente: ${playlist.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error siguiendo playlist: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Guardando álbum en biblioteca de Spotify: ${album.name}&quot;)&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Álbum guardado exitosamente: ${album.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error guardando álbum: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error guardando en biblioteca de Spotify&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando tracks de la playlist: ${playlist.name}&quot;)&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks cargados para la playlist: ${playlist.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando tracks de la playlist: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks de playlist: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando playlist tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando tracks del álbum: ${album.name}&quot;)&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks cargados para el álbum: ${album.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks de álbum: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando album tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Nueva función para cargar álbumes de un artista&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando álbumes del artista: ${artist.name}&quot;)&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${albums.size} álbumes cargados para el artista: ${artist.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando álbumes de artista: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando artist albums&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyPlaylist = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción de la playlist: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir playlist&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria de la playlist: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir playlist aleatoria&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                SpotifyAlbumDetailView(&#10;                    album = selectedSpotifyAlbum!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyAlbum = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        // Reproducir álbum desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción del álbum: ${selectedSpotifyAlbum!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir álbum en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria del álbum: ${selectedSpotifyAlbum!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum aleatorio&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyArtist = null&#10;                        selectedArtistAlbums = emptyList()&#10;                    },&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    },&#10;                    onShuffleAll = {&#10;                        // Reproducir todos los álbumes del artista en orden aleatorio&#10;                        if (selectedArtistAlbums.isNotEmpty()) {&#10;                            val firstAlbum = selectedArtistAlbums.first()&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria del primer álbum del artista: ${firstAlbum.name}&quot;)&#10;&#10;                            // Cargar los tracks del primer álbum&#10;                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                            if (accessToken != null) {&#10;                                SpotifyRepository.getAlbumTracks(accessToken, firstAlbum.id) { tracks, errorMsg -&gt;&#10;                                    if (tracks != null) {&#10;                                        // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                                        val shuffledTracks = tracks.shuffled()&#10;                                        val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                            TrackEntity(&#10;                                                id = &quot;spotify_${firstAlbum.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                                playlistId = firstAlbum.id,&#10;                                                spotifyTrackId = spotifyTrack.id,&#10;                                                name = spotifyTrack.name,&#10;                                                artists = spotifyTrack.getArtistNames(),&#10;                                                youtubeVideoId = null, // Se buscará dinámicamente&#10;                                                audioUrl = null,&#10;                                                position = index,&#10;                                                lastSyncTime = System.currentTimeMillis()&#10;                                            )&#10;                                        }&#10;&#10;                                        // Establecer playlist mezclada y comenzar reproducción&#10;                                        playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                                        // Buscar y reproducir el primer track de la lista mezclada&#10;                                        trackEntities.firstOrNull()?.let { track -&gt;&#10;                                            coroutineScope.launch {&#10;                                                try {&#10;                                                    playerViewModel?.loadAudioFromTrack(track)&#10;                                                } catch (e: Exception) {&#10;                                                    Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum del artista aleatorio&quot;, e)&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    } else {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks para shuffle: $errorMsg&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums, // Agregar callback para artistas&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Nuevo callback para artistas&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    &quot;&gt; search_audio&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                if (searchQuery.isNotEmpty()) {&#10;                    IconButton(onClick = {&#10;                        onSearchQueryChange(&quot;&quot;)&#10;                    }) {&#10;                        Text(&#10;                            text = &quot;x&quot;,&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 18.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        android.util.Log.d(&#10;            &quot;SearchMainView&quot;,&#10;            &quot;Renderizando vista principal - showSpotifyResults=$showSpotifyResults, spotifyResults!=null=${spotifyResults != null}&quot;&#10;        )&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                    // Convertir tracks de Spotify a TrackEntity y crear playlist temporal&#10;                    val trackEntities = allTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                        TrackEntity(&#10;                            id = &quot;spotify_search_${spotifyTrack.id}_$index&quot;,&#10;                            playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                            spotifyTrackId = spotifyTrack.id,&#10;                            name = spotifyTrack.name,&#10;                            artists = spotifyTrack.getArtistNames(),&#10;                            youtubeVideoId = null, // Se buscará dinámicamente&#10;                            audioUrl = null,&#10;                            position = index,&#10;                            lastSyncTime = System.currentTimeMillis()&#10;                        )&#10;                    }&#10;&#10;                    // Establecer playlist en el PlayerViewModel&#10;                    playerViewModel?.setCurrentPlaylist(trackEntities, selectedIndex)&#10;&#10;                    // Cargar el track seleccionado&#10;                    val selectedTrackEntity = trackEntities[selectedIndex]&#10;                    coroutineScope.launch {&#10;                        try {&#10;                            playerViewModel?.loadAudioFromTrack(selectedTrackEntity)&#10;                            Log.d(&#10;                                &quot;SpotifySearch&quot;,&#10;                                &quot; Track Spotify como playlist: ${track.name} (${selectedIndex + 1}/${allTracks.size})&quot;&#10;                            )&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;SpotifySearch&quot;, &quot;Error al reproducir track de Spotify&quot;, e)&#10;                        }&#10;                    }&#10;                },&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE ===&#10;        if (results.isNotEmpty()) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                results = results,&#10;                onVideoSelected = onVideoSelected,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onTrackSelectedFromSearch: (SpotifyTrack, List&lt;SpotifyTrack&gt;, Int) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(true) }&#10;    var albumsExpanded by remember { mutableStateOf(true) }&#10;    var playlistsExpanded by remember { mutableStateOf(true) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ tracks [${results.tracks.items.size}] ${if (tracksExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(bottom = 8.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    onTrackSelectedFromSearch(track, results.tracks.items, index)&#10;                                }&#10;                                .padding(vertical = 4.dp, horizontal = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;&#10;                            Column(modifier = Modifier.weight(1f)) {&#10;                                Text(&#10;                                    text = track.name ?: &quot;Unknown Track&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFFE0E0E0)&#10;                                    ),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;                                Text(&#10;                                    text = track.getArtistNames(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;                            }&#10;&#10;                            Text(&#10;                                text = track.getDurationText(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ albums [${results.albums.items.size}] ${if (albumsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = &quot;Album cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ playlists [${results.playlists.items.size}] ${if (playlistsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.playlists.items.size) { index -&gt;&#10;                        val playlist = results.playlists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = &quot;Playlist cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = &quot;${playlist.getTrackCount()} tracks&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ artists [${results.artists.items.size}] ${if (artistsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) }, // Conectar con el callback&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = &quot;Artist image&quot;,&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    results: List&lt;AudioItem&gt;,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var expanded by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = &quot;$ youtube_results [${results.size}] ${if (expanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { expanded = !expanded }&#10;                .padding(bottom = 8.dp, top = 16.dp)&#10;        )&#10;&#10;        if (expanded) {&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                results.take(5).forEachIndexed { index, item -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable {&#10;                                onVideoSelectedFromSearch(item.videoId, item.title, results, index)&#10;                            }&#10;                            .padding(8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;${index + 1}. &quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            modifier = Modifier.width(32.dp)&#10;                        )&#10;&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = item.title,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween&#10;                            ) {&#10;                                Text(&#10;                                    text = item.channel ?: &quot;Unknown Channel&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.weight(1f),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;&#10;                                item.duration?.let { duration -&gt;&#10;                                    Text(&#10;                                        text = duration,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.OutlinedTextField&#10;import androidx.compose.material3.OutlinedTextFieldDefaults&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para paginación&#10;    var currentOffset by remember { mutableStateOf(0) }&#10;    var isLoadingMore by remember { mutableStateOf(false) }&#10;    var hasMoreResults by remember { mutableStateOf(true) }&#10;    val itemsPerPage = 10&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) } // Nuevo estado para artista&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) } // Nuevo estado para álbumes del artista&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) } // Nuevo estado de carga para álbumes&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoadingMore = true&#10;            } else {&#10;                isLoading = true&#10;                currentOffset = 0&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                hasMoreResults = true&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        isLoadingMore = false&#10;                        error = &quot;Query vacía después de procesar prefijo&quot;&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Search YouTube with detailed information&#10;                            val youtubeResults = youtubeSearchManager.searchYouTubeVideosDetailed(finalQuery)&#10;                            // Convert YouTube video info to AudioItem objects&#10;                            val newResults = youtubeResults.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            if (isLoadMore) {&#10;                                results = results + newResults&#10;                            } else {&#10;                                results = newResults&#10;                            }&#10;&#10;                            hasMoreResults = newResults.size &gt;= itemsPerPage&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    Log.d(&quot;SearchScreen&quot;, &quot; Iniciando búsqueda en Spotify: '$finalQuery'&quot;)&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                error = &quot;Error searching Spotify: $searchError&quot;&#10;                                                Log.e(&quot;SearchScreen&quot;, &quot;Error searching Spotify: $searchError&quot;)&#10;                                            } else if (searchResults != null) {&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Resultados actualizados: ${searchResults.tracks.items.size} tracks, ${searchResults.albums.items.size} albums, ${searchResults.artists.items.size} artists, ${searchResults.playlists.items.size} playlists&quot;)&#10;&#10;                                                if (isLoadMore &amp;&amp; spotifyResults != null) {&#10;                                                    // Combinar resultados existentes con nuevos&#10;                                                    val combinedResults = SpotifySearchAllResponse(&#10;                                                        tracks = SpotifyTracksSearchResult(&#10;                                                            items = spotifyResults!!.tracks.items + searchResults.tracks.items,&#10;                                                            total = searchResults.tracks.total,&#10;                                                            limit = searchResults.tracks.limit,&#10;                                                            offset = searchResults.tracks.offset,&#10;                                                            next = searchResults.tracks.next&#10;                                                        ),&#10;                                                        albums = SpotifyAlbumsSearchResult(&#10;                                                            items = spotifyResults!!.albums.items + searchResults.albums.items,&#10;                                                            total = searchResults.albums.total,&#10;                                                            limit = searchResults.albums.limit,&#10;                                                            offset = searchResults.albums.offset,&#10;                                                            next = searchResults.albums.next&#10;                                                        ),&#10;                                                        artists = SpotifyArtistsSearchResult(&#10;                                                            items = spotifyResults!!.artists.items + searchResults.artists.items,&#10;                                                            total = searchResults.artists.total,&#10;                                                            limit = searchResults.artists.limit,&#10;                                                            offset = searchResults.artists.offset,&#10;                                                            next = searchResults.artists.next&#10;                                                        ),&#10;                                                        playlists = SpotifyPlaylistsSearchResult(&#10;                                                            items = spotifyResults!!.playlists.items + searchResults.playlists.items,&#10;                                                            total = searchResults.playlists.total,&#10;                                                            limit = searchResults.playlists.limit,&#10;                                                            offset = searchResults.playlists.offset,&#10;                                                            next = searchResults.playlists.next&#10;                                                        )&#10;                                                    )&#10;                                                    spotifyResults = combinedResults&#10;                                                } else {&#10;                                                    spotifyResults = searchResults&#10;                                                }&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                hasMoreResults = false&#10;&#10;                                                isLoading = false&#10;                                                isLoadingMore = false&#10;                                                showSpotifyResults = true&#10;                                                Log.d(&quot;SearchScreen&quot;, &quot; Estado actualizado - showSpotifyResults=$showSpotifyResults&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    isLoadingMore = false&#10;                                    error = &quot;Token de Spotify no disponible&quot;&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                isLoadingMore = false&#10;                                error = &quot;Spotify no está conectado&quot;&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            isLoadingMore = false&#10;                            error = &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;&#10;                            Log.w(&quot;SearchScreen&quot;, &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;)&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    isLoadingMore = false&#10;                    error = &quot;Error en búsqueda: ${e.message}&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;Error en búsqueda&quot;, e)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Guardando playlist en biblioteca de Spotify: ${playlist.name}&quot;)&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Playlist seguida exitosamente: ${playlist.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error siguiendo playlist: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        Log.d(&quot;SearchScreen&quot;, &quot; Guardando álbum en biblioteca de Spotify: ${album.name}&quot;)&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                            if (success) {&#10;                                Log.d(&quot;SearchScreen&quot;, &quot;✅ Álbum guardado exitosamente: ${album.name}&quot;)&#10;                            } else {&#10;                                Log.e(&quot;SearchScreen&quot;, &quot;❌ Error guardando álbum: $errorMsg&quot;)&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error guardando en biblioteca de Spotify&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando tracks de la playlist: ${playlist.name}&quot;)&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks cargados para la playlist: ${playlist.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando tracks de la playlist: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks de playlist: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando playlist tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando tracks del álbum: ${album.name}&quot;)&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${tracks.size} tracks cargados para el álbum: ${album.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks de álbum: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando album tracks&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Nueva función para cargar álbumes de un artista&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    Log.d(&quot;SearchScreen&quot;, &quot; Cargando álbumes del artista: ${artist.name}&quot;)&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                            Log.d(&quot;SearchScreen&quot;, &quot;✅ ${albums.size} álbumes cargados para el artista: ${artist.name}&quot;)&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                            Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando álbumes de artista: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                    Log.e(&quot;SearchScreen&quot;, &quot;❌ Token de Spotify no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;                Log.e(&quot;SearchScreen&quot;, &quot;Error cargando artist albums&quot;, e)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyPlaylist = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción de la playlist: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir playlist&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria de la playlist: ${selectedSpotifyPlaylist!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir playlist aleatoria&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                SpotifyAlbumDetailView(&#10;                    album = selectedSpotifyAlbum!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyAlbum = null&#10;                        selectedItemTracks = emptyList()&#10;                    },&#10;                    onStart = {&#10;                        // Reproducir álbum desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción del álbum: ${selectedSpotifyAlbum!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir álbum en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria del álbum: ${selectedSpotifyAlbum!!.name}&quot;)&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyAlbum!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyAlbum!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum aleatorio&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onBack = {&#10;                        selectedSpotifyArtist = null&#10;                        selectedArtistAlbums = emptyList()&#10;                    },&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    },&#10;                    onShuffleAll = {&#10;                        // Reproducir todos los álbumes del artista en orden aleatorio&#10;                        if (selectedArtistAlbums.isNotEmpty()) {&#10;                            val firstAlbum = selectedArtistAlbums.first()&#10;                            Log.d(&quot;SearchScreen&quot;, &quot; Iniciando reproducción aleatoria del primer álbum del artista: ${firstAlbum.name}&quot;)&#10;&#10;                            // Cargar los tracks del primer álbum&#10;                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                            if (accessToken != null) {&#10;                                SpotifyRepository.getAlbumTracks(accessToken, firstAlbum.id) { tracks, errorMsg -&gt;&#10;                                    if (tracks != null) {&#10;                                        // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                                        val shuffledTracks = tracks.shuffled()&#10;                                        val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                            TrackEntity(&#10;                                                id = &quot;spotify_${firstAlbum.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                                playlistId = firstAlbum.id,&#10;                                                spotifyTrackId = spotifyTrack.id,&#10;                                                name = spotifyTrack.name,&#10;                                                artists = spotifyTrack.getArtistNames(),&#10;                                                youtubeVideoId = null, // Se buscará dinámicamente&#10;                                                audioUrl = null,&#10;                                                position = index,&#10;                                                lastSyncTime = System.currentTimeMillis()&#10;                                            )&#10;                                        }&#10;&#10;                                        // Establecer playlist mezclada y comenzar reproducción&#10;                                        playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                                        // Buscar y reproducir el primer track de la lista mezclada&#10;                                        trackEntities.firstOrNull()?.let { track -&gt;&#10;                                            coroutineScope.launch {&#10;                                                try {&#10;                                                    playerViewModel?.loadAudioFromTrack(track)&#10;                                                } catch (e: Exception) {&#10;                                                    Log.e(&quot;SearchScreen&quot;, &quot;Error al reproducir álbum del artista aleatorio&quot;, e)&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    } else {&#10;                                        Log.e(&quot;SearchScreen&quot;, &quot;❌ Error cargando tracks para shuffle: $errorMsg&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums, // Agregar callback para artistas&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Nuevo callback para artistas&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    &quot;&gt; search_audio&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                if (searchQuery.isNotEmpty()) {&#10;                    IconButton(onClick = {&#10;                        onSearchQueryChange(&quot;&quot;)&#10;                    }) {&#10;                        Text(&#10;                            text = &quot;x&quot;,&#10;                            style = MaterialTheme.typography.titleLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 18.sp,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.bodyLarge.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        android.util.Log.d(&#10;            &quot;SearchMainView&quot;,&#10;            &quot;Renderizando vista principal - showSpotifyResults=$showSpotifyResults, spotifyResults!=null=${spotifyResults != null}&quot;&#10;        )&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                onArtistSelected = onArtistSelected, // Pasar el callback de artista&#10;                onTrackSelectedFromSearch = { track, allTracks, selectedIndex -&gt;&#10;                    // Convertir tracks de Spotify a TrackEntity y crear playlist temporal&#10;                    val trackEntities = allTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                        TrackEntity(&#10;                            id = &quot;spotify_search_${spotifyTrack.id}_$index&quot;,&#10;                            playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                            spotifyTrackId = spotifyTrack.id,&#10;                            name = spotifyTrack.name,&#10;                            artists = spotifyTrack.getArtistNames(),&#10;                            youtubeVideoId = null, // Se buscará dinámicamente&#10;                            audioUrl = null,&#10;                            position = index,&#10;                            lastSyncTime = System.currentTimeMillis()&#10;                        )&#10;                    }&#10;&#10;                    // Establecer playlist en el PlayerViewModel&#10;                    playerViewModel?.setCurrentPlaylist(trackEntities, selectedIndex)&#10;&#10;                    // Cargar el track seleccionado&#10;                    val selectedTrackEntity = trackEntities[selectedIndex]&#10;                    coroutineScope.launch {&#10;                        try {&#10;                            playerViewModel?.loadAudioFromTrack(selectedTrackEntity)&#10;                            Log.d(&#10;                                &quot;SpotifySearch&quot;,&#10;                                &quot; Track Spotify como playlist: ${track.name} (${selectedIndex + 1}/${allTracks.size})&quot;&#10;                            )&#10;                        } catch (e: Exception) {&#10;                            Log.e(&quot;SpotifySearch&quot;, &quot;Error al reproducir track de Spotify&quot;, e)&#10;                        }&#10;                    }&#10;                },&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE ===&#10;        if (results.isNotEmpty()) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                results = results,&#10;                onVideoSelected = onVideoSelected,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Agregar parámetro faltante&#10;    onTrackSelectedFromSearch: (SpotifyTrack, List&lt;SpotifyTrack&gt;, Int) -&gt; Unit,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(true) }&#10;    var albumsExpanded by remember { mutableStateOf(true) }&#10;    var playlistsExpanded by remember { mutableStateOf(true) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ tracks [${results.tracks.items.size}] ${if (tracksExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(bottom = 8.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    onTrackSelectedFromSearch(track, results.tracks.items, index)&#10;                                }&#10;                                .padding(vertical = 4.dp, horizontal = 8.dp),&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;&#10;                            Column(modifier = Modifier.weight(1f)) {&#10;                                Text(&#10;                                    text = track.name ?: &quot;Unknown Track&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFFE0E0E0)&#10;                                    ),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;                                Text(&#10;                                    text = track.getArtistNames(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;                            }&#10;&#10;                            Text(&#10;                                text = track.getDurationText(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ albums [${results.albums.items.size}] ${if (albumsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = &quot;Album cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ playlists [${results.playlists.items.size}] ${if (playlistsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.playlists.items.size) { index -&gt;&#10;                        val playlist = results.playlists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = &quot;Playlist cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = &quot;${playlist.getTrackCount()} tracks&quot;,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = &quot;$ artists [${results.artists.items.size}] ${if (artistsExpanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(bottom = 8.dp, top = 16.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) }, // Conectar con el callback&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = &quot;Artist image&quot;,&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    results: List&lt;AudioItem&gt;,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var expanded by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth()&#10;    ) {&#10;        Text(&#10;            text = &quot;$ youtube_results [${results.size}] ${if (expanded) &quot;[-]&quot; else &quot;[+]&quot;}&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { expanded = !expanded }&#10;                .padding(bottom = 8.dp, top = 16.dp)&#10;        )&#10;&#10;        if (expanded) {&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;            ) {&#10;                results.take(5).forEachIndexed { index, item -&gt;&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .clickable {&#10;                                onVideoSelectedFromSearch(item.videoId, item.title, results, index)&#10;                            }&#10;                            .padding(8.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;${index + 1}. &quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            ),&#10;                            modifier = Modifier.width(32.dp)&#10;                        )&#10;&#10;                        Column(modifier = Modifier.weight(1f)) {&#10;                            Text(&#10;                                text = item.title,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis&#10;                            )&#10;&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.SpaceBetween&#10;                            ) {&#10;                                Text(&#10;                                    text = item.channel ?: &quot;Unknown Channel&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.weight(1f),&#10;                                    maxLines = 1,&#10;                                    overflow = TextOverflow.Ellipsis&#10;                                )&#10;&#10;                                item.duration?.let { duration -&gt;&#10;                                    Text(&#10;                                        text = duration,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/MarqueeText.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/MarqueeText.kt" />
              <option name="updatedContent" value="package com.plyr.ui.components&#10;&#10;import androidx.compose.animation.core.*&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.BasicText&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clipToBounds&#10;import androidx.compose.ui.layout.onSizeChanged&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.IntOffset&#10;import kotlinx.coroutines.delay&#10;&#10;@Composable&#10;fun MarqueeText(&#10;    text: String,&#10;    modifier: Modifier = Modifier,&#10;    style: TextStyle = TextStyle(),&#10;    delayMillis: Int = 1000,&#10;    velocity: Float = 30f&#10;) {&#10;    val density = LocalDensity.current&#10;    var textWidth by remember { mutableStateOf(0) }&#10;    var containerWidth by remember { mutableStateOf(0) }&#10;    &#10;    val shouldMarquee = textWidth &gt; containerWidth &amp;&amp; containerWidth &gt; 0&#10;    &#10;    val animationSpec = infiniteRepeatable&lt;Float&gt;(&#10;        animation = tween(&#10;            durationMillis = if (shouldMarquee) ((textWidth - containerWidth) / velocity * 1000).toInt() else 0,&#10;            easing = LinearEasing&#10;        ),&#10;        repeatMode = RepeatMode.Restart&#10;    )&#10;    &#10;    val animatedOffset by animateFloatAsState(&#10;        targetValue = if (shouldMarquee) -(textWidth - containerWidth).toFloat() else 0f,&#10;        animationSpec = animationSpec,&#10;        label = &quot;marquee&quot;&#10;    )&#10;    &#10;    var startAnimation by remember { mutableStateOf(false) }&#10;    &#10;    LaunchedEffect(shouldMarquee) {&#10;        if (shouldMarquee) {&#10;            delay(delayMillis.toLong())&#10;            startAnimation = true&#10;        } else {&#10;            startAnimation = false&#10;        }&#10;    }&#10;    &#10;    Box(&#10;        modifier = modifier&#10;            .clipToBounds()&#10;            .onSizeChanged { size -&gt;&#10;                containerWidth = size.width&#10;            }&#10;    ) {&#10;        BasicText(&#10;            text = text,&#10;            style = style,&#10;            maxLines = 1,&#10;            overflow = TextOverflow.Visible,&#10;            modifier = Modifier&#10;                .onSizeChanged { size -&gt;&#10;                    textWidth = size.width&#10;                }&#10;                .offset {&#10;                    IntOffset(&#10;                        x = if (startAnimation) animatedOffset.toInt() else 0,&#10;                        y = 0&#10;                    )&#10;                }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SearchMainView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SearchMainView.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifySearchAllResponse&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;&#10;@Composable&#10;fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        // Search header&#10;        Text(&#10;            text = &quot;$ search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search input&#10;        TextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            placeholder = {&#10;                Text(&#10;                    &quot;Search (prefix: yt: youtube, sp: spotify)&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    onSearchTriggered(searchQuery, false)&#10;                }&#10;            ),&#10;            singleLine = true,&#10;            textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color.White&#10;            ),&#10;            colors = TextFieldDefaults.colors(&#10;                focusedContainerColor = Color.Transparent,&#10;                unfocusedContainerColor = Color.Transparent,&#10;                focusedIndicatorColor = Color.Transparent,&#10;                unfocusedIndicatorColor = Color.Transparent,&#10;                cursorColor = Color(0xFF4ECDC4)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Loading indicator&#10;        if (isLoading) {&#10;            Text(&#10;                text = &quot;&gt; searching...&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFFFD93D)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Error message&#10;        error?.let { errorMessage -&gt;&#10;            Text(&#10;                text = &quot;&gt; error: $errorMessage&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(vertical = 8.dp)&#10;            )&#10;        }&#10;&#10;        // Search results&#10;        when {&#10;            showSpotifyResults &amp;&amp; spotifyResults != null -&gt; {&#10;                SpotifySearchResults(&#10;                    searchResults = spotifyResults,&#10;                    onAlbumSelected = onAlbumSelected,&#10;                    onPlaylistSelected = onPlaylistSelected,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            results.isNotEmpty() -&gt; {&#10;                YouTubeSearchResults(&#10;                    results = results,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch&#10;                )&#10;            }&#10;            !isLoading &amp;&amp; searchQuery.isNotBlank() -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no results found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyArtistFull&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifySearchAllResponse&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;&#10;@Composable&#10;fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelected: (String, String) -&gt; Unit,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Agregar parámetro faltante&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        // Search header&#10;        Text(&#10;            text = &quot;$ search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search input&#10;        TextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            placeholder = {&#10;                Text(&#10;                    &quot;Search (prefix: yt: youtube, sp: spotify)&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    onSearchTriggered(searchQuery, false)&#10;                }&#10;            ),&#10;            singleLine = true,&#10;            textStyle = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color.White&#10;            ),&#10;            colors = TextFieldDefaults.colors(&#10;                focusedContainerColor = Color.Transparent,&#10;                unfocusedContainerColor = Color.Transparent,&#10;                focusedIndicatorColor = Color.Transparent,&#10;                unfocusedIndicatorColor = Color.Transparent,&#10;                cursorColor = Color(0xFF4ECDC4)&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        // Loading indicator&#10;        if (isLoading) {&#10;            Text(&#10;                text = &quot;&gt; searching...&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFFFD93D)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Error message&#10;        error?.let { errorMessage -&gt;&#10;            Text(&#10;                text = &quot;&gt; error: $errorMessage&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(vertical = 8.dp)&#10;            )&#10;        }&#10;&#10;        // Search results&#10;        when {&#10;            showSpotifyResults &amp;&amp; spotifyResults != null -&gt; {&#10;                SpotifySearchResults(&#10;                    searchResults = spotifyResults,&#10;                    onAlbumSelected = onAlbumSelected,&#10;                    onPlaylistSelected = onPlaylistSelected,&#10;                    onArtistSelected = onArtistSelected, // Pasar el parámetro&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            results.isNotEmpty() -&gt; {&#10;                YouTubeSearchResults(&#10;                    results = results,&#10;                    onVideoSelected = onVideoSelected,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch&#10;                )&#10;            }&#10;            !isLoading &amp;&amp; searchQuery.isNotBlank() -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no results found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyPlaylistDetailView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyPlaylistDetailView.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with playlist info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Playlist image&#10;            playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ playlist_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = playlist.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from playlist&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${playlist.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = playlist.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                // Track image (if available from album)&#10;                                track.album?.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                                    AsyncImage(&#10;                                        model = imageUrl,&#10;                                        contentDescription = null,&#10;                                        modifier = Modifier&#10;                                            .size(40.dp)&#10;                                            .clip(RoundedCornerShape(4.dp))&#10;                                    )&#10;                                    Spacer(modifier = Modifier.width(12.dp))&#10;                                }&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = track.getDurationText(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onBack: () -&gt; Unit,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header with playlist info&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Playlist image&#10;            playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = null,&#10;                    modifier = Modifier&#10;                        .size(80.dp)&#10;                        .clip(RoundedCornerShape(8.dp))&#10;                )&#10;                Spacer(modifier = Modifier.width(16.dp))&#10;            }&#10;&#10;            Column(modifier = Modifier.weight(1f)) {&#10;                Text(&#10;                    text = &quot;$ playlist_detail&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 18.sp,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;&#10;                Text(&#10;                    text = playlist.name,&#10;                    style = MaterialTheme.typography.titleLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                Text(&#10;                    text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 12.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Action buttons&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(8.dp)&#10;        ) {&#10;            TextButton(onClick = onBack) {&#10;                Text(&#10;                    &quot;&lt; back&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onStart) {&#10;                Text(&#10;                    &quot;play&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF4ECDC4)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onRandom) {&#10;                Text(&#10;                    &quot;shuffle&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;&#10;            TextButton(onClick = onSave) {&#10;                Text(&#10;                    &quot;save&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        // Content&#10;        when {&#10;            isLoading -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            error != null -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; error: $error&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFE74C3C)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;&#10;            tracks.isNotEmpty() -&gt; {&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(tracks.size) { index -&gt;&#10;                        val track = tracks[index]&#10;&#10;                        Card(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 2.dp)&#10;                                .clickable {&#10;                                    // Play individual track from playlist&#10;                                    playerViewModel?.let { vm -&gt;&#10;                                        coroutineScope.launch {&#10;                                            val trackEntities = tracks.mapIndexed { idx, spotifyTrack -&gt;&#10;                                                TrackEntity(&#10;                                                    id = &quot;spotify_${playlist.id}_${spotifyTrack.id}&quot;,&#10;                                                    playlistId = playlist.id,&#10;                                                    spotifyTrackId = spotifyTrack.id,&#10;                                                    name = spotifyTrack.name,&#10;                                                    artists = spotifyTrack.getArtistNames(),&#10;                                                    youtubeVideoId = null,&#10;                                                    audioUrl = null,&#10;                                                    position = idx,&#10;                                                    lastSyncTime = System.currentTimeMillis()&#10;                                                )&#10;                                            }&#10;                                            vm.setCurrentPlaylist(trackEntities, index)&#10;                                            vm.loadAudioFromTrack(trackEntities[index])&#10;                                        }&#10;                                    }&#10;                                },&#10;                            colors = CardDefaults.cardColors(&#10;                                containerColor = Color(0xFF1DB954).copy(alpha = 0.2f)&#10;                            )&#10;                        ) {&#10;                            Row(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(12.dp),&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                // Track number&#10;                                Text(&#10;                                    text = &quot;${index + 1}.&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    ),&#10;                                    modifier = Modifier.width(32.dp)&#10;                                )&#10;&#10;                                Column(modifier = Modifier.weight(1f)) {&#10;                                    MarqueeText(&#10;                                        text = track.name,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 14.sp,&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;&#10;                                    Text(&#10;                                        text = track.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 12.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;&#10;                                Text(&#10;                                    text = track.getDurationText(),&#10;                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 12.sp,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                Text(&#10;                    text = &quot;&gt; no tracks found&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(16.dp)&#10;                )&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifySearchResults.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items.map { artistFull -&gt;&#10;                        SpotifyArtist(name = artistFull.name)&#10;                    }&#10;                )&#10;            }&#10;        }&#10;}&#10;&#10;                    artists = searchResults.artists.items.map { artistFull -&gt;&#10;                        SpotifyArtist(name = artistFull.name)&#10;                    }&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 4.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Track icon&#10;                Text(&#10;                    text = &quot;♫&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        color = Color(0xFF1DB954),&#10;                        fontSize = 16.sp&#10;                    ),&#10;                    modifier = Modifier.padding(end = 12.dp)&#10;                )&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = track.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = track.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = album.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = album.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = playlist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtist&gt;&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;    artists: List&lt;SpotifyArtist&gt;&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(120.dp)&#10;                        .padding(8.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // SpotifyArtist doesn't have images, so we'll show a placeholder&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 24.sp&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    Text(&#10;                    // SpotifyArtist doesn't have images, so we'll show a placeholder&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineMedium.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 24.sp&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.network.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.shape.CircleShape&#10;&#10;@Composable&#10;fun SpotifySearchResults(&#10;    searchResults: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit, // Nuevo callback para artistas&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    LazyColumn(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        contentPadding = PaddingValues(bottom = 16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(16.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (searchResults.tracks.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyTracksSection(&#10;                    tracks = searchResults.tracks.items,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (searchResults.albums.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyAlbumsSection(&#10;                    albums = searchResults.albums.items,&#10;                    onAlbumSelected = onAlbumSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (searchResults.playlists.items.isNotEmpty()) {&#10;            item {&#10;                SpotifyPlaylistsSection(&#10;                    playlists = searchResults.playlists.items,&#10;                    onPlaylistSelected = onPlaylistSelected&#10;                )&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (searchResults.artists.items.isNotEmpty()) {&#10;            item {&#10;                Spacer(modifier = Modifier.height(16.dp))&#10;                SpotifyArtistsSection(&#10;                    artists = searchResults.artists.items, // Ahora son SpotifyArtistFull&#10;                    onArtistSelected = onArtistSelected&#10;                )&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyTracksSection(&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify tracks [${tracks.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        tracks.take(5).forEach { track -&gt;&#10;            Row(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(vertical = 4.dp)&#10;                    .clickable {&#10;                        // Play individual track&#10;                        playerViewModel?.let { vm -&gt;&#10;                            coroutineScope.launch {&#10;                                val trackEntity = TrackEntity(&#10;                                    id = &quot;spotify_single_${track.id}&quot;,&#10;                                    playlistId = &quot;single_track&quot;,&#10;                                    spotifyTrackId = track.id,&#10;                                    name = track.name,&#10;                                    artists = track.getArtistNames(),&#10;                                    youtubeVideoId = null,&#10;                                    audioUrl = null,&#10;                                    position = 0,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                                vm.setCurrentPlaylist(listOf(trackEntity), 0)&#10;                                vm.loadAudioFromTrack(trackEntity)&#10;                            }&#10;                        }&#10;                    },&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Track icon&#10;                Text(&#10;                    text = &quot;♫&quot;,&#10;                    style = MaterialTheme.typography.headlineMedium.copy(&#10;                        color = Color(0xFF1DB954),&#10;                        fontSize = 16.sp&#10;                    ),&#10;                    modifier = Modifier.padding(end = 12.dp)&#10;                )&#10;&#10;                Column(modifier = Modifier.weight(1f)) {&#10;                    Text(&#10;                        text = track.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = track.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        if (tracks.size &gt; 5) {&#10;            Text(&#10;                text = &quot;... and ${tracks.size - 5} more tracks&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = Color(0xFF95A5A6)&#10;                ),&#10;                modifier = Modifier.padding(8.dp)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyAlbumsSection(&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify albums [${albums.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(albums.size) { index -&gt;&#10;                val album = albums[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onAlbumSelected(album) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = album.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = album.getArtistNames(),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyPlaylistsSection(&#10;    playlists: List&lt;SpotifyPlaylist&gt;,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify playlists [${playlists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(playlists.size) { index -&gt;&#10;                val playlist = playlists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(160.dp)&#10;                        .clickable { onPlaylistSelected(playlist) }&#10;                        .padding(8.dp)&#10;                ) {&#10;                    playlist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = null,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .aspectRatio(1f)&#10;                                .clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = playlist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = Color.White&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis&#10;                    )&#10;&#10;                    Text(&#10;                        text = &quot;${playlist.tracks?.total ?: 0} tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;private fun SpotifyArtistsSection(&#10;    artists: List&lt;SpotifyArtistFull&gt;, // Cambiar de SpotifyArtist a SpotifyArtistFull&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit&#10;) {&#10;    Column {&#10;        Text(&#10;            text = &quot;&gt; spotify artists [${artists.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 16.sp,&#10;                color = Color(0xFFFFD93D)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 8.dp)&#10;        )&#10;&#10;        LazyRow(&#10;            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;            contentPadding = PaddingValues(horizontal = 4.dp)&#10;        ) {&#10;            items(artists.size) { index -&gt;&#10;                val artist = artists[index]&#10;                Column(&#10;                    modifier = Modifier&#10;                        .width(120.dp)&#10;                        .clickable { onArtistSelected(artist) } // Hacer clickeable&#10;                        .padding(8.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Usar imagen del artista si está disponible&#10;                    artist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                        AsyncImage(&#10;                            model = imageUrl,&#10;                            contentDescription = &quot;Imagen de ${artist.name}&quot;,&#10;                            modifier = Modifier&#10;                                .size(80.dp)&#10;                                .clip(CircleShape)&#10;                        )&#10;                    } ?: run {&#10;                        // Placeholder si no hay imagen&#10;                        Box(&#10;                            modifier = Modifier&#10;                                .size(80.dp)&#10;                                .clip(CircleShape)&#10;                                .background(Color(0xFF1DB954).copy(alpha = 0.2f)),&#10;                            contentAlignment = Alignment.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;♫&quot;,&#10;                                style = MaterialTheme.typography.headlineMedium.copy(&#10;                                    color = Color(0xFF1DB954),&#10;                                    fontSize = 24.sp&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = artist.name,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 12.sp,&#10;                            color = MaterialTheme.colorScheme.onSurface&#10;                        ),&#10;                        maxLines = 2,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        textAlign = TextAlign.Center&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/SpotifyTokenManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/SpotifyTokenManager.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.plyr.network.SpotifyRepository&#10;import kotlinx.coroutines.*&#10;import java.util.concurrent.atomic.AtomicBoolean&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * SpotifyTokenManager - Gestor centralizado de tokens de Spotify&#10; * &#10; * Este manager se encarga de:&#10; * - Verificar automáticamente si los tokens han expirado&#10; * - Renovar tokens automáticamente cuando sea necesario&#10; * - Proporcionar tokens válidos para todas las llamadas a la API&#10; * - Manejar la renovación de forma thread-safe&#10; * - Evitar múltiples renovaciones simultáneas&#10; */&#10;object SpotifyTokenManager {&#10;    &#10;    private const val TAG = &quot;SpotifyTokenManager&quot;&#10;    &#10;    // Margen de seguridad: renovar 5 minutos antes de que expire&#10;    private const val EXPIRATION_BUFFER_MS = 5 * 60 * 1000L // 5 minutos&#10;    &#10;    // Control de renovación en progreso&#10;    private val isRefreshing = AtomicBoolean(false)&#10;    private var refreshDeferred: Deferred&lt;String?&gt;? = null&#10;    &#10;    /**&#10;     * Obtiene un token de acceso válido, renovándolo automáticamente si es necesario.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    suspend fun getValidAccessToken(context: Context): String? = withContext(Dispatchers.IO) {&#10;        try {&#10;            // 1. Verificar si tenemos un token actual válido&#10;            val currentToken = Config.getSpotifyAccessToken(context)&#10;            if (currentToken != null &amp;&amp; !isTokenExpired(context)) {&#10;                Log.d(TAG, &quot;Token actual es válido&quot;)&#10;                return@withContext currentToken&#10;            }&#10;            &#10;            // 2. El token ha expirado o no existe, necesitamos renovarlo&#10;            Log.d(TAG, &quot;Token expirado o inexistente, iniciando renovación&quot;)&#10;            return@withContext refreshTokenSafely(context)&#10;            &#10;        } catch (e: Exception) {&#10;            Log.e(TAG, &quot;Error obteniendo token válido&quot;, e)&#10;            return@withContext null&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el token actual ha expirado o está cerca de expirar.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si el token ha expirado o está cerca de expirar&#10;     */&#10;    private fun isTokenExpired(context: Context): Boolean {&#10;        val tokenTimestamp = Config.getSpotifyTokenTimestamp(context)&#10;        val expiresIn = Config.getSpotifyTokenExpiresIn(context)&#10;        &#10;        if (tokenTimestamp == 0L || expiresIn == 0) {&#10;            Log.d(TAG, &quot;No hay información de expiración del token&quot;)&#10;            return true&#10;        }&#10;        &#10;        val expirationTime = tokenTimestamp + (expiresIn * 1000L)&#10;        val currentTime = System.currentTimeMillis()&#10;        val timeToExpiry = expirationTime - currentTime&#10;        &#10;        val isExpired = timeToExpiry &lt;= EXPIRATION_BUFFER_MS&#10;        &#10;        Log.d(TAG, &quot;Verificación de expiración: tiempo restante = ${timeToExpiry / 1000}s, expirado = $isExpired&quot;)&#10;        &#10;        return isExpired&#10;    }&#10;    &#10;    /**&#10;     * Renueva el token de forma thread-safe, evitando múltiples renovaciones simultáneas.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token renovado o null si falló&#10;     */&#10;    private suspend fun refreshTokenSafely(context: Context): String? = withContext(Dispatchers.IO) {&#10;        // Si ya hay una renovación en progreso, esperar a que termine&#10;        if (isRefreshing.get()) {&#10;            Log.d(TAG, &quot;Renovación ya en progreso, esperando...&quot;)&#10;            return@withContext refreshDeferred?.await()&#10;        }&#10;        &#10;        // Iniciar nueva renovación&#10;        if (isRefreshing.compareAndSet(false, true)) {&#10;            Log.d(TAG, &quot;Iniciando nueva renovación de token&quot;)&#10;            &#10;            refreshDeferred = async {&#10;                try {&#10;                    refreshTokenInternal(context)&#10;                } finally {&#10;                    isRefreshing.set(false)&#10;                    refreshDeferred = null&#10;                }&#10;            }&#10;            &#10;            return@withContext refreshDeferred!!.await()&#10;        } else {&#10;            // Otra corrutina ganó la carrera, esperar su resultado&#10;            return@withContext refreshDeferred?.await()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Realiza la renovación real del token.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Token renovado o null si falló&#10;     */&#10;    private suspend fun refreshTokenInternal(context: Context): String? = suspendCoroutine { continuation -&gt;&#10;        val refreshToken = Config.getSpotifyRefreshToken(context)&#10;        &#10;        if (refreshToken == null) {&#10;            Log.e(TAG, &quot;No hay refresh token disponible&quot;)&#10;            continuation.resume(null)&#10;            return@suspendCoroutine&#10;        }&#10;        &#10;        Log.d(TAG, &quot;Enviando solicitud de renovación a Spotify...&quot;)&#10;        &#10;        SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;            if (error != null) {&#10;                Log.e(TAG, &quot;Error renovando token: $error&quot;)&#10;                continuation.resume(null)&#10;            } else if (newAccessToken != null) {&#10;                // Guardar el nuevo token con timestamp actual&#10;                val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                Config.setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                &#10;                Log.d(TAG, &quot;Token renovado exitosamente&quot;)&#10;                continuation.resume(newAccessToken)&#10;            } else {&#10;                Log.e(TAG, &quot;Respuesta inesperada al renovar token&quot;)&#10;                continuation.resume(null)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Invalida el token actual, forzando una renovación en la próxima solicitud.&#10;     * Útil cuando sabemos que el token ha sido revocado o es inválido.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun invalidateCurrentToken(context: Context) {&#10;        Log.d(TAG, &quot;Invalidando token actual&quot;)&#10;        Config.clearSpotifyAccessToken(context)&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay credenciales de Spotify configuradas.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay refresh token disponible&#10;     */&#10;    fun hasValidCredentials(context: Context): Boolean {&#10;        return Config.getSpotifyRefreshToken(context) != null&#10;    }&#10;    &#10;    /**&#10;     * Ejecuta una operación con un token válido, manejando automáticamente la renovación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param operation Operación a ejecutar con el token&#10;     * @return Resultado de la operación o null si no se pudo obtener token válido&#10;     */&#10;    suspend fun &lt;T&gt; withValidToken(&#10;        context: Context, &#10;        operation: suspend (token: String) -&gt; T?&#10;    ): T? {&#10;        val token = getValidAccessToken(context)&#10;        return if (token != null) {&#10;            try {&#10;                operation(token)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error ejecutando operación con token&quot;, e)&#10;                null&#10;            }&#10;        } else {&#10;            Log.e(TAG, &quot;No se pudo obtener token válido para la operación&quot;)&#10;            null&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/YouTubeAudioExtractor.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/YouTubeAudioExtractor.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;&#10;/**&#10; * YouTubeAudioExtractor - Utilidad para extraer audio de YouTube con calidad configurable&#10; * &#10; * Esta clase maneja:&#10; * - Extracción de URLs de audio de YouTube basada en la configuración de calidad&#10; * - Mapeo de calidades de audio a formatos específicos&#10; * - Optimización de streaming según las preferencias del usuario&#10; * &#10; * Las calidades se mapean de la siguiente manera:&#10; * - worst: Prioriza menor uso de datos (formatos de menor bitrate)&#10; * - medium: Equilibrio entre calidad y datos (formatos estándar)&#10; * - best: Máxima calidad disponible (formatos de mayor bitrate)&#10; */&#10;object YouTubeAudioExtractor {&#10;    &#10;    private const val TAG = &quot;YouTubeAudioExtractor&quot;&#10;    &#10;    /**&#10;     * Parámetros de calidad para yt-dlp/youtube-dl según configuración del usuario&#10;     */&#10;    private val qualityFormats = mapOf(&#10;        Config.AUDIO_QUALITY_WORST to listOf(&#10;            &quot;worstaudio[ext=m4a]&quot;,&#10;            &quot;worstaudio[ext=webm]&quot;, &#10;            &quot;worstaudio&quot;,&#10;            &quot;worst[height&lt;=360]&quot;&#10;        ),&#10;        Config.AUDIO_QUALITY_MEDIUM to listOf(&#10;            &quot;bestaudio[ext=m4a][abr&lt;=128]&quot;,&#10;            &quot;bestaudio[ext=webm][abr&lt;=128]&quot;,&#10;            &quot;bestaudio[abr&lt;=128]&quot;,&#10;            &quot;best[height&lt;=720]&quot;&#10;        ),&#10;        Config.AUDIO_QUALITY_BEST to listOf(&#10;            &quot;bestaudio[ext=m4a]&quot;,&#10;            &quot;bestaudio[ext=webm]&quot;,&#10;            &quot;bestaudio&quot;,&#10;            &quot;best&quot;&#10;        )&#10;    )&#10;    &#10;    /**&#10;     * Obtiene el formato de audio recomendado basado en la configuración actual.&#10;     * &#10;     * @param context Contexto de la aplicación para acceder a configuración&#10;     * @return String con el formato de audio para yt-dlp/youtube-dl&#10;     */&#10;    fun getAudioFormat(context: Context): String {&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        val formats = qualityFormats[currentQuality] ?: qualityFormats[Config.AUDIO_QUALITY_MEDIUM]!!&#10;        &#10;        Log.d(TAG, &quot;Calidad de audio configurada: $currentQuality&quot;)&#10;        Log.d(TAG, &quot;Formatos de audio seleccionados: $formats&quot;)&#10;        &#10;        // Unir formatos con '/' para que yt-dlp pruebe en orden de preferencia&#10;        return formats.joinToString(&quot;/&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene los parámetros adicionales para la extracción según calidad configurada.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Map con parámetros adicionales para el extractor&#10;     */&#10;    fun getExtractionParams(context: Context): Map&lt;String, Any&gt; {&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        &#10;        return when (currentQuality) {&#10;            Config.AUDIO_QUALITY_WORST -&gt; mapOf(&#10;                &quot;prefer_ffmpeg&quot; to true,&#10;                &quot;postprocessors&quot; to listOf(&#10;                    mapOf(&#10;                        &quot;key&quot; to &quot;FFmpegAudioConvertor&quot;,&#10;                        &quot;preferredcodec&quot; to &quot;m4a&quot;,&#10;                        &quot;preferredquality&quot; to &quot;64&quot;&#10;                    )&#10;                )&#10;            )&#10;            Config.AUDIO_QUALITY_MEDIUM -&gt; mapOf(&#10;                &quot;prefer_ffmpeg&quot; to true,&#10;                &quot;postprocessors&quot; to listOf(&#10;                    mapOf(&#10;                        &quot;key&quot; to &quot;FFmpegAudioConvertor&quot;,&#10;                        &quot;preferredcodec&quot; to &quot;m4a&quot;,&#10;                        &quot;preferredquality&quot; to &quot;128&quot;&#10;                    )&#10;                )&#10;            )&#10;            Config.AUDIO_QUALITY_BEST -&gt; mapOf(&#10;                &quot;prefer_ffmpeg&quot; to true,&#10;                &quot;postprocessors&quot; to listOf(&#10;                    mapOf(&#10;                        &quot;key&quot; to &quot;FFmpegAudioConvertor&quot;,&#10;                        &quot;preferredcodec&quot; to &quot;m4a&quot;,&#10;                        &quot;preferredquality&quot; to &quot;192&quot;&#10;                    )&#10;                )&#10;            )&#10;            else -&gt; mapOf()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene una descripción amigable de la calidad actual y su impacto.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return String descriptivo de la calidad actual&#10;     */&#10;    fun getQualityDescription(context: Context): String {&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        val baseDescription = Config.AUDIO_QUALITY_DESCRIPTIONS[currentQuality] &#10;            ?: Config.AUDIO_QUALITY_DESCRIPTIONS[Config.AUDIO_QUALITY_MEDIUM]!!&#10;        &#10;        val additionalInfo = when (currentQuality) {&#10;            Config.AUDIO_QUALITY_WORST -&gt; &quot; • Bitrate: ~64 kbps • Uso de datos mínimo&quot;&#10;            Config.AUDIO_QUALITY_MEDIUM -&gt; &quot; • Bitrate: ~128 kbps • Buena calidad y uso moderado de datos&quot;&#10;            Config.AUDIO_QUALITY_BEST -&gt; &quot; • Bitrate: ~192+ kbps • Máxima calidad disponible&quot;&#10;            else -&gt; &quot;&quot;&#10;        }&#10;        &#10;        return &quot;$baseDescription$additionalInfo&quot;&#10;    }&#10;    &#10;    /**&#10;     * Estima el uso de datos por minuto de audio según la calidad configurada.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return Uso estimado de datos en MB por minuto&#10;     */&#10;    fun getEstimatedDataUsagePerMinute(context: Context): Double {&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        &#10;        return when (currentQuality) {&#10;            Config.AUDIO_QUALITY_WORST -&gt; 0.48   // ~64 kbps = 0.48 MB/min&#10;            Config.AUDIO_QUALITY_MEDIUM -&gt; 0.96  // ~128 kbps = 0.96 MB/min&#10;            Config.AUDIO_QUALITY_BEST -&gt; 1.44    // ~192 kbps = 1.44 MB/min&#10;            else -&gt; 0.96&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Genera el comando completo para yt-dlp basado en la configuración actual.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param videoUrl URL del video de YouTube&#10;     * @return Lista de argumentos para yt-dlp&#10;     */&#10;    fun generateYtDlpCommand(context: Context, videoUrl: String): List&lt;String&gt; {&#10;        val audioFormat = getAudioFormat(context)&#10;        val currentQuality = Config.getAudioQuality(context)&#10;        &#10;        val baseCommand = mutableListOf(&#10;            &quot;yt-dlp&quot;,&#10;            &quot;--extract-flat&quot;, &quot;false&quot;,&#10;            &quot;--format&quot;, audioFormat,&#10;            &quot;--no-playlist&quot;,&#10;            &quot;--get-url&quot;&#10;        )&#10;        &#10;        // Añadir parámetros específicos según calidad&#10;        when (currentQuality) {&#10;            Config.AUDIO_QUALITY_WORST -&gt; {&#10;                baseCommand.addAll(listOf(&#10;                    &quot;--audio-quality&quot;, &quot;3&quot;,  // Calidad baja&#10;                    &quot;--prefer-ffmpeg&quot;&#10;                ))&#10;            }&#10;            Config.AUDIO_QUALITY_MEDIUM -&gt; {&#10;                baseCommand.addAll(listOf(&#10;                    &quot;--audio-quality&quot;, &quot;5&quot;,  // Calidad media&#10;                    &quot;--prefer-ffmpeg&quot;&#10;                ))&#10;            }&#10;            Config.AUDIO_QUALITY_BEST -&gt; {&#10;                baseCommand.addAll(listOf(&#10;                    &quot;--audio-quality&quot;, &quot;0&quot;,  // Mejor calidad&#10;                    &quot;--prefer-ffmpeg&quot;&#10;                ))&#10;            }&#10;        }&#10;        &#10;        baseCommand.add(videoUrl)&#10;        &#10;        Log.d(TAG, &quot;Comando yt-dlp generado: ${baseCommand.joinToString(&quot; &quot;)}&quot;)&#10;        return baseCommand&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt" />
              <option name="originalContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeAudioExtractor&#10;import com.plyr.utils.isValidAudioUrl&#10;import com.plyr.utils.Config&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.database.TrackEntity&#10;import android.os.Handler&#10;import android.os.Looper&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import android.util.Log&#10;import android.content.Intent&#10;import com.plyr.service.MusicService&#10;&#10;/**&#10; * PlayerViewModel - Maneja la reproducción de audio usando ExoPlayer y NewPipe&#10; * &#10; * FUNCIONALIDADES PRINCIPALES:&#10; * - Gestionar el ciclo de vida del ExoPlayer&#10; * - Extraer URLs de audio de YouTube usando NewPipe Extractor&#10; * - Proporcionar una interfaz para reproducir audio desde videos o tracks de Spotify&#10; * - Manejar estados de reproducción (loading, error, etc.)&#10; * - Proporcionar funcionalidades como play, pause, seek y control de tiempo&#10; * &#10; * NAVEGACIÓN DE PLAYLIST:&#10; * - Mantener el estado de la playlist actual y el índice del track&#10; * - Navegación manual hacia adelante/atrás con botones fwd/bwd&#10; * - Auto-navegación automática al final de cada canción (configurable)&#10; * - Información de posición en playlist (ej: &quot;3 de 10&quot;)&#10; * - Estados de disponibilidad de navegación (hasPrevious/hasNext)&#10; * &#10; * USO:&#10; * 1. Llamar setCurrentPlaylist() para establecer la lista de tracks&#10; * 2. Los botones fwd/bwd en FloatingMusicControls permiten navegación manual&#10; * 3. La auto-navegación se puede habilitar/deshabilitar con setAutoNavigationEnabled()&#10; * 4. Los estados de navegación se observan automáticamente en la UI&#10; * &#10; * @param application Contexto de la aplicación para acceder a recursos del sistema&#10; */&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    &#10;    // === CONSTANTES ===&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;PlayerViewModel&quot;&#10;    }&#10;    &#10;    // === PROPIEDADES PRIVADAS ===&#10;    &#10;    /** Instancia del ExoPlayer para reproducción de audio */&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    &#10;    /** ExoPlayer secundario para preloading de la siguiente canción */&#10;    private var _preloadPlayer: ExoPlayer? = null&#10;    &#10;    /** Track que está siendo preloaded */&#10;    private var _preloadedTrack: TrackEntity? = null&#10;    &#10;    /** Estado de preloading activo */&#10;    private var _isPreloading = false&#10;    &#10;    /** Listener actual del ExoPlayer principal para poder removerlo durante intercambios */&#10;    private var _currentPlayerListener: Player.Listener? = null&#10;    &#10;    /** LiveData privado para la URL de audio actual */&#10;    private val _audioUrl = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** LiveData privado para el título de la canción actual */&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** LiveData privado para el estado de carga */&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    &#10;    /** LiveData privado para mensajes de error */&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** Handler para ejecutar código en el hilo principal */&#10;    private val mainHandler = Handler(Looper.getMainLooper())&#10;    &#10;    /** Manejador de búsquedas de YouTube usando NewPipe */&#10;    private val youtubeSearchManager = YouTubeSearchManager(application)&#10;    &#10;    /** Callback para notificar cuando una canción termina de reproducirse */&#10;    private var playbackEndedCallback: CompletableDeferred&lt;Boolean&gt;? = null&#10;    &#10;    // === PROPIEDADES DE PLAYLIST ===&#10;    &#10;    /** Lista actual de tracks de la playlist */&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    &#10;    /** Índice del track actual en la playlist */&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    &#10;    /** Track actual que se está reproduciendo */&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    &#10;    /** Estado de si hay track anterior disponible */&#10;    private val _hasPrevious = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    /** Estado de si hay track siguiente disponible */&#10;    private val _hasNext = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    /** Estado de auto-navegación habilitada */&#10;    private val _autoNavigationEnabled = MutableLiveData&lt;Boolean&gt;(true)&#10;    &#10;    // === PROPIEDADES DE COLA (QUEUE) ===&#10;    &#10;    /** Cola de reproducción - lista de tracks pendientes */&#10;    private val _playbackQueue = MutableLiveData&lt;MutableList&lt;TrackEntity&gt;&gt;(mutableListOf())&#10;    &#10;    /** Indica si está en modo cola (queue) */&#10;    private val _isQueueMode = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    // === PROPIEDADES DE COLA (STATEFLOW) ===&#10;    &#10;    /** Estado de la cola como StateFlow para Compose */&#10;    private val _queueState = MutableStateFlow(QueueState())&#10;    val queueState: StateFlow&lt;QueueState&gt; = _queueState.asStateFlow()&#10;&#10;    // === PROPIEDADES PÚBLICAS (READONLY) ===&#10;    &#10;    /** Acceso público de solo lectura al ExoPlayer */&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;    &#10;    /** LiveData observable para la URL de audio actual */&#10;    val audioUrl: LiveData&lt;String?&gt; = _audioUrl&#10;    &#10;    /** LiveData observable para el título de la canción actual */&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;    &#10;    /** LiveData observable para el estado de carga */&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;    &#10;    /** LiveData observable para mensajes de error */&#10;    val error: LiveData&lt;String?&gt; = _error&#10;    &#10;    /** LiveData observable para la playlist actual */&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;    &#10;    /** LiveData observable para el índice del track actual */&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;    &#10;    /** LiveData observable para el track actual */&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;    &#10;    /** LiveData observable para disponibilidad de track anterior */&#10;    val hasPrevious: LiveData&lt;Boolean&gt; = _hasPrevious&#10;    &#10;    /** LiveData observable para disponibilidad de track siguiente */&#10;    val hasNext: LiveData&lt;Boolean&gt; = _hasNext&#10;    &#10;    /** LiveData observable para el estado de auto-navegación */&#10;    val autoNavigationEnabled: LiveData&lt;Boolean&gt; = _autoNavigationEnabled&#10;    &#10;    /** LiveData observable para la cola de reproducción */&#10;    val playbackQueue: LiveData&lt;MutableList&lt;TrackEntity&gt;&gt; = _playbackQueue&#10;    &#10;    /** LiveData observable para el estado de modo cola */&#10;    val isQueueMode: LiveData&lt;Boolean&gt; = _isQueueMode&#10;&#10;    // === INICIALIZACIÓN ===&#10;    &#10;    init {&#10;        // Inicializar el estado de la cola&#10;        updateQueueState()&#10;        // Observadores para actualizar el estado de navegación automáticamente&#10;        _playbackQueue.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        _currentPlaylist.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        _currentTrackIndex.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        Log.d(TAG, &quot;PlayerViewModel inicializado&quot;)&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS ===&#10;    &#10;    /**&#10;     * Inicializa el ExoPlayer si no ha sido creado aún.&#10;     * Configura los listeners necesarios para el manejo de estados de reproducción.&#10;     * También inicializa el ExoPlayer de preloading para transiciones sin delay.&#10;     */&#10;    fun initializePlayer() {&#10;        // Asegurar que la inicialización ocurra en el hilo principal&#10;        mainHandler.post {&#10;            if (_exoPlayer == null) {&#10;                _currentPlayerListener = createPlayerListener()&#10;                _exoPlayer = ExoPlayer.Builder(getApplication())&#10;                    .setSeekBackIncrementMs(10000)&#10;                    .setSeekForwardIncrementMs(10000)&#10;                    .build().apply {&#10;                        // Configurar listener para eventos de reproducción&#10;                        addListener(_currentPlayerListener!!)&#10;                        // Configurar para liberar recursos inmediatamente cuando se detiene&#10;                        setHandleAudioBecomingNoisy(true)&#10;                        &#10;                        // Aplicar optimizaciones de buffer&#10;                        optimizeBufferSettings(this)&#10;                    }&#10;                Log.d(TAG, &quot;✅ ExoPlayer principal inicializado&quot;)&#10;            }&#10;            &#10;            // Inicializar el ExoPlayer de preloading si no existe&#10;            if (_preloadPlayer == null) {&#10;                _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                    .setSeekBackIncrementMs(10000)&#10;                    .setSeekForwardIncrementMs(10000)&#10;                    .build().apply {&#10;                        // Configurar para NO reproducir automáticamente&#10;                        playWhenReady = false&#10;                        setHandleAudioBecomingNoisy(false) // Solo el player principal maneja esto&#10;                        &#10;                        // Aplicar optimizaciones de buffer&#10;                        optimizeBufferSettings(this)&#10;                        &#10;                        // Agregar listener para monitorear el estado del preloading&#10;                        addListener(object : Player.Listener {&#10;                            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                when (playbackState) {&#10;                                    Player.STATE_READY -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer LISTO - Track: ${_preloadedTrack?.name}&quot;)&#10;                                    }&#10;                                    Player.STATE_BUFFERING -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer bufferizando...&quot;)&#10;                                    }&#10;                                    Player.STATE_IDLE -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer en IDLE&quot;)&#10;                                    }&#10;                                    Player.STATE_ENDED -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer terminado&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        })&#10;                    }&#10;                Log.d(TAG, &quot;✅ ExoPlayer preload inicializado&quot;)&#10;            }&#10;            &#10;            // Monitorear uso de memoria después de inicialización&#10;            monitorMemoryUsage()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Crea el listener para el ExoPlayer que maneja cambios de estado.&#10;     * @return Player.Listener configurado con los callbacks necesarios&#10;     */&#10;    private fun createPlayerListener(): Player.Listener {&#10;        return object : Player.Listener {&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                when (playbackState) {&#10;                    Player.STATE_ENDED -&gt; {&#10;                        Log.d(TAG, &quot; Canción terminada - Player.STATE_ENDED&quot;)&#10;                        playbackEndedCallback?.complete(true)&#10;                        playbackEndedCallback = null&#10;                        &#10;                        // Intentar reproducción sin delay usando preloaded track&#10;                        handleSeamlessTransition()&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer en estado IDLE&quot;)&#10;                    }&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer bufferizando...&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer listo para reproducir&quot;)&#10;                        &#10;                        // Limpiar estado de carga cuando el player esté listo&#10;                        _isLoading.postValue(false)&#10;                        &#10;                        // Cuando el player actual esté listo, iniciar preloading de la siguiente canción&#10;                        // Pero solo si no hay preloading activo ya&#10;                        if (!_isPreloading) {&#10;                            startPreloadingNextTrack()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(TAG, &quot;Estado de reproducción cambió: $isPlaying&quot;)&#10;            }&#10;            &#10;            override fun onPlayerError(error: PlaybackException) {&#10;                Log.e(TAG, &quot;❌ Error de ExoPlayer: ${error.message}&quot;, error)&#10;                // Limpiar recursos y reintentar si es posible&#10;                handlePlayerError(error)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores del ExoPlayer y intenta recuperarse.&#10;     * @param error El error que ocurrió&#10;     */&#10;    private fun handlePlayerError(error: PlaybackException) {&#10;        Log.e(TAG, &quot; Manejando error de ExoPlayer: ${error.errorCode}&quot;)&#10;        &#10;        // Cancelar preloading activo que podría estar causando problemas&#10;        cancelPreloading()&#10;        &#10;        // Liberar y reinicializar ExoPlayers para limpiar estado corrupto&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                releasePlayersForRecovery()&#10;                kotlinx.coroutines.delay(1000) // Esperar un momento&#10;                initializePlayer()&#10;                &#10;                // Intentar recargar el track actual si existe&#10;                _currentTrack.value?.let { track -&gt;&#10;                    Log.d(TAG, &quot; Reintentando cargar track actual después de error: ${track.name}&quot;)&#10;                    loadAudioFromTrack(track)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error durante recuperación&quot;, e)&#10;                updateLoadingState(false, &quot;Error de reproducción. Reinicia la app si persiste.&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Libera ExoPlayers para recuperación de errores.&#10;     */&#10;    private fun releasePlayersForRecovery() {&#10;        Log.d(TAG, &quot; Liberando ExoPlayers para recuperación&quot;)&#10;        &#10;        _currentPlayerListener?.let { listener -&gt;&#10;            _exoPlayer?.removeListener(listener)&#10;        }&#10;        &#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;        &#10;        _preloadPlayer?.release()&#10;        _preloadPlayer = null&#10;        &#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;    }&#10;    &#10;    /**&#10;     * Carga y reproduce audio desde un video ID de YouTube.&#10;     * &#10;     * @param videoId ID del video de YouTube (ej: &quot;dQw4w9WgXcQ&quot;)&#10;     * @param title Título opcional para mostrar en la UI&#10;     */&#10;    fun loadAudio(videoId: String, title: String? = null) {&#10;        println(&quot;PlayerViewModel: Cargando audio para video ID: $videoId con título: $title&quot;)&#10;        updateLoadingState(true, null, title)&#10;        &#10;        // Usar NewPipe Extractor para obtener la URL de audio&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                val audioUrl = extractAudioUrl(videoId)&#10;                &#10;                if (audioUrl != null &amp;&amp; isValidAudioUrl(audioUrl)) {&#10;                    println(&quot;PlayerViewModel: ✅ URL obtenida con NewPipe: $audioUrl&quot;)&#10;                    playAudioFromUrl(audioUrl)&#10;                } else {&#10;                    handleAudioExtractionError(videoId, audioUrl)&#10;                }&#10;            } catch (e: Exception) {&#10;                handleException(&quot;Error al extraer audio&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube usando NewPipe.&#10;     * @param videoId ID del video de YouTube&#10;     * @return URL de audio o null si falla&#10;     */&#10;    private suspend fun extractAudioUrl(videoId: String): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            YouTubeAudioExtractor.getAudioUrl(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Delegar la reproducción al MusicService desde el PlayerViewModel.&#10;     */&#10;    private fun playAudioInService(audioUrl: String) {&#10;        val serviceIntent = Intent(getApplication&lt;Application&gt;(), MusicService::class.java).apply {&#10;            putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;        }&#10;        getApplication&lt;Application&gt;().startService(serviceIntent)&#10;    }&#10;&#10;    // Reproduce audio directamente usando ExoPlayer en lugar de delegar al servicio&#10;    private fun playAudioFromUrl(audioUrl: String) {&#10;        _audioUrl.postValue(audioUrl)&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Asegurar que el ExoPlayer esté inicializado&#10;                if (_exoPlayer == null) {&#10;                    Log.d(TAG, &quot; Inicializando ExoPlayer para reproducción directa...&quot;)&#10;                    initializePlayer()&#10;                    &#10;                    // Esperar a que la inicialización se complete&#10;                    var attempts = 0&#10;                    while (_exoPlayer == null &amp;&amp; attempts &lt; 50) {&#10;                        delay(50)&#10;                        attempts++&#10;                    }&#10;                    &#10;                    if (_exoPlayer == null) {&#10;                        Log.e(TAG, &quot;❌ Error: ExoPlayer no se inicializó correctamente&quot;)&#10;                        updateLoadingState(false, &quot;Error: No se pudo inicializar el reproductor&quot;)&#10;                        return@launch&#10;                    }&#10;                }&#10;                &#10;                _exoPlayer?.let { player -&gt;&#10;                    Log.d(TAG, &quot; Configurando ExoPlayer para URL: $audioUrl&quot;)&#10;                    player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                    player.prepare()&#10;                    player.play()&#10;                    Log.d(TAG, &quot;✅ Reproducción iniciada para URL&quot;)&#10;                    updateLoadingState(false) // Limpiar estado de carga&#10;                } ?: run {&#10;                    Log.e(TAG, &quot;❌ ExoPlayer es null después de inicialización&quot;)&#10;                    updateLoadingState(false, &quot;Error: Reproductor no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error configurando ExoPlayer para URL&quot;, e)&#10;                handleException(&quot;Error configurando ExoPlayer&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la extracción de audio.&#10;     */&#10;    private fun handleAudioExtractionError(videoId: String, audioUrl: String?) {&#10;        if (audioUrl == null) {&#10;            println(&quot;PlayerViewModel: ❌ No se pudo obtener URL de audio&quot;)&#10;            updateLoadingState(false, &quot;No se pudo extraer la URL de audio para el video ID: $videoId&quot;)&#10;        } else {&#10;            println(&quot;PlayerViewModel: URL no válida según isValidAudioUrl&quot;)&#10;            updateLoadingState(false, &quot;La URL obtenida no es válida para reproducción de audio&quot;)&#10;        }&#10;    }&#10;    &#10;    &#10;    /**&#10;     * Carga y reproduce audio desde un TrackEntity de forma transparente.&#10;     * Obtiene el YouTube ID automáticamente si no existe.&#10;     * &#10;     * @param track Entidad del track con información de Spotify&#10;     * @return true si la carga fue exitosa, false si falló&#10;     */&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            println(&quot;PlayerViewModel: Cargando audio para track: ${track.name} - ${track.artists}&quot;)&#10;            updateLoadingState(true, null, &quot;${track.name} - ${track.artists}&quot;)&#10;            &#10;            // Obtener YouTube ID de forma transparente&#10;            val youtubeId = obtainYouTubeId(track)&#10;            &#10;            if (youtubeId != null) {&#10;                println(&quot;PlayerViewModel: ✅ YouTube ID obtenido: $youtubeId&quot;)&#10;                return@withContext playTrackAudio(youtubeId, track)&#10;            } else {&#10;                println(&quot;PlayerViewModel: ❌ No se encontró YouTube ID para: ${track.name}&quot;)&#10;                updateLoadingState(false, &quot;No se encontró el video para: ${track.name}&quot;)&#10;                return@withContext false&#10;            }&#10;        } catch (e: Exception) {&#10;            handleException(&quot;Error al cargar audio desde track&quot;, e)&#10;            return@withContext false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el YouTube ID para un track.&#10;     * @param track Track del cual obtener el ID&#10;     * @return YouTube ID o null si no se encuentra&#10;     */&#10;    private suspend fun obtainYouTubeId(track: TrackEntity): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            youtubeSearchManager.getYouTubeIdTransparently(track)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reproduce audio de un track usando su YouTube ID.&#10;     * @param youtubeId ID de YouTube del track&#10;     * @param track Información del track para logs&#10;     * @return true si la reproducción fue exitosa&#10;     */&#10;    private suspend fun playTrackAudio(youtubeId: String, track: TrackEntity): Boolean {&#10;        // Obtener URL de audio con el ID&#10;        val audioUrl = withContext(Dispatchers.IO) {&#10;            YouTubeAudioExtractor.getAudioUrl(youtubeId)&#10;        }&#10;        &#10;        if (audioUrl != null &amp;&amp; isValidAudioUrl(audioUrl)) {&#10;            println(&quot;PlayerViewModel: ✅ URL de audio obtenida: $audioUrl&quot;)&#10;            return configureAndPlayAudio(audioUrl, track)&#10;        } else {&#10;            println(&quot;PlayerViewModel: ❌ No se pudo obtener URL de audio válida&quot;)&#10;            updateLoadingState(false, &quot;No se pudo obtener el audio para: ${track.name}&quot;)&#10;            return false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura ExoPlayer y inicia la reproducción.&#10;     * @param audioUrl URL del audio a reproducir&#10;     * @param track Información del track para logs&#10;     * @return true si la configuración fue exitosa&#10;     */&#10;    private suspend fun configureAndPlayAudio(audioUrl: String, track: TrackEntity): Boolean {&#10;        _audioUrl.postValue(audioUrl)&#10;        &#10;        return withContext(Dispatchers.Main) {&#10;            // Asegurar que ambos ExoPlayers estén inicializados&#10;            if (_exoPlayer == null || _preloadPlayer == null) {&#10;                Log.d(TAG, &quot; Inicializando ExoPlayers...&quot;)&#10;                initializePlayer()&#10;                &#10;                // Esperar a que la inicialización se complete&#10;                var attempts = 0&#10;                while ((_exoPlayer == null || _preloadPlayer == null) &amp;&amp; attempts &lt; 50) {&#10;                    kotlinx.coroutines.delay(50)&#10;                    attempts++&#10;                }&#10;                &#10;                if (_exoPlayer == null || _preloadPlayer == null) {&#10;                    Log.e(TAG, &quot;❌ Error: ExoPlayers no se inicializaron correctamente&quot;)&#10;                    _isLoading.postValue(false)&#10;                    _error.postValue(&quot;Error: No se pudo inicializar el reproductor&quot;)&#10;                    return@withContext false&#10;                }&#10;            }&#10;            &#10;            _exoPlayer?.let { player -&gt;&#10;                try {&#10;                    Log.d(TAG, &quot; Configurando ExoPlayer para: ${track.name}&quot;)&#10;                    player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                    player.prepare()&#10;                    player.play()&#10;                    Log.d(TAG, &quot;✅ Reproducción iniciada para: ${track.name}&quot;)&#10;                    _isLoading.postValue(false)&#10;                    return@withContext true&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error configurando ExoPlayer para ${track.name}&quot;, e)&#10;                    handleException(&quot;Error configurando ExoPlayer&quot;, e)&#10;                    return@withContext false&#10;                }&#10;            } ?: run {&#10;                Log.e(TAG, &quot;❌ ExoPlayer es null después de inicialización&quot;)&#10;                diagnoseExoPlayerState()&#10;                _isLoading.postValue(false)&#10;                _error.postValue(&quot;Error: Reproductor no disponible&quot;)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS DE CONTROL DE REPRODUCCIÓN ===&#10;    &#10;    /**&#10;     * Pausa la reproducción actual.&#10;     */&#10;    fun pausePlayer() {&#10;        mainHandler.post {&#10;            _exoPlayer?.pause()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reanuda la reproducción.&#10;     */&#10;    fun playPlayer() {&#10;        mainHandler.post {&#10;            _exoPlayer?.play()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reanuda la reproducción si está pausada.&#10;     */&#10;    fun resumeIfPaused() {&#10;        _exoPlayer?.let { player -&gt;&#10;            if (!player.isPlaying) {&#10;                player.play()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Busca a una posición específica en la canción.&#10;     * @param positionMs Posición en milisegundos&#10;     */&#10;    fun seekTo(positionMs: Long) {&#10;        mainHandler.post {&#10;            _exoPlayer?.seekTo(positionMs)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la posición actual de reproducción.&#10;     * @return Posición actual en milisegundos&#10;     */&#10;    fun getCurrentPosition(): Long {&#10;        return try {&#10;            _exoPlayer?.currentPosition ?: 0L&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error obteniendo posición: ${e.message}&quot;)&#10;            0L&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la duración total de la canción actual.&#10;     * @return Duración en milisegundos&#10;     */&#10;    fun getDuration(): Long {&#10;        return try {&#10;            _exoPlayer?.duration?.takeIf { it &gt; 0 } ?: 0L&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error obteniendo duración: ${e.message}&quot;)&#10;            0L&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el reproductor está reproduciendo actualmente.&#10;     * @return true si está reproduciendo, false en caso contrario&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return try {&#10;            _exoPlayer?.isPlaying ?: false&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error verificando estado de reproducción: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;    &#10;    &#10;    /**&#10;     * Habilita o deshabilita la navegación automática al final de cada canción.&#10;     * @param enabled true para habilitar, false para deshabilitar&#10;     */&#10;    fun setAutoNavigationEnabled(enabled: Boolean) {&#10;        _autoNavigationEnabled.postValue(enabled)&#10;        println(&quot;PlayerViewModel: Auto-navegación ${if (enabled) &quot;habilitada&quot; else &quot;deshabilitada&quot;}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el estado actual de la auto-navegación.&#10;     * @return true si está habilitada, false en caso contrario&#10;     */&#10;    fun isAutoNavigationEnabled(): Boolean {&#10;        return _autoNavigationEnabled.value ?: true&#10;    }&#10;&#10;    // === MÉTODOS DE NAVEGACIÓN DE PLAYLIST ===&#10;    &#10;    /**&#10;     * Establece la playlist actual y el índice del track.&#10;     * @param playlist Lista de tracks de la playlist&#10;     * @param startIndex Índice del track inicial (por defecto 0)&#10;     */&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        Log.d(TAG, &quot;Estableciendo playlist: ${playlist.size} tracks, startIndex=$startIndex&quot;)&#10;        _currentPlaylist.postValue(playlist)&#10;        _currentTrackIndex.postValue(startIndex.coerceIn(0, playlist.size - 1))&#10;        &#10;        if (playlist.isNotEmpty() &amp;&amp; startIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[startIndex])&#10;            Log.d(TAG, &quot;Track actual establecido: ${playlist[startIndex].name}&quot;)&#10;        }&#10;        &#10;        updateNavigationState()&#10;    }&#10;    &#10;    /**&#10;     * Navega al track siguiente en la playlist o cola.&#10;     * @return true si pudo navegar, false si no hay siguiente track&#10;     */&#10;    suspend fun navigateToNext(): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        // Si está en modo cola, reproducir siguiente de la cola&#10;        if (_isQueueMode.value == true) {&#10;            return playNextFromQueue()&#10;        }&#10;        &#10;        // Modo playlist normal&#10;        val playlist = _currentPlaylist.value ?: return false&#10;        val currentIndex = _currentTrackIndex.value ?: return false&#10;        &#10;        if (currentIndex &lt; playlist.size - 1) {&#10;            val nextIndex = currentIndex + 1&#10;            val nextTrack = playlist[nextIndex]&#10;            &#10;            _currentTrackIndex.postValue(nextIndex)&#10;            _currentTrack.postValue(nextTrack)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el siguiente track&#10;            val success = loadAudioFromTrack(nextTrack)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al siguiente track: ${nextTrack.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al siguiente track: ${nextTrack.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Navega al track anterior en la playlist.&#10;     * @return true si pudo navegar, false si no hay track anterior&#10;     */&#10;    suspend fun navigateToPrevious(): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        val playlist = _currentPlaylist.value ?: return false&#10;        val currentIndex = _currentTrackIndex.value ?: return false&#10;        &#10;        if (currentIndex &gt; 0) {&#10;            val previousIndex = currentIndex - 1&#10;            val previousTrack = playlist[previousIndex]&#10;            &#10;            _currentTrackIndex.postValue(previousIndex)&#10;            _currentTrack.postValue(previousTrack)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el track anterior&#10;            val success = loadAudioFromTrack(previousTrack)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al track anterior: ${previousTrack.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al track anterior: ${previousTrack.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Navega a un track específico en la playlist por índice.&#10;     * @param index Índice del track al que navegar&#10;     * @return true si pudo navegar, false si el índice es inválido&#10;     */&#10;    suspend fun navigateToTrack(index: Int): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        val playlist = _currentPlaylist.value ?: return false&#10;        &#10;        if (index in playlist.indices) {&#10;            val track = playlist[index]&#10;            &#10;            _currentTrackIndex.postValue(index)&#10;            _currentTrack.postValue(track)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el track seleccionado&#10;            val success = loadAudioFromTrack(track)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al track ${index + 1}: ${track.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al track ${index + 1}: ${track.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Actualiza el estado de navegación (hasPrevious, hasNext).&#10;     */&#10;    private fun updateNavigationState() {&#10;        val isQueue = _isQueueMode.value == true&#10;        val queue = _playbackQueue.value&#10;        val queueSize = queue?.size ?: 0&#10;        val playlist = _currentPlaylist.value&#10;        val currentIndex = _currentTrackIndex.value&#10;&#10;        Log.d(TAG, &quot;Actualizando estado de navegación: isQueue=$isQueue, queueSize=$queueSize, playlist=${playlist?.size}, index=$currentIndex&quot;)&#10;&#10;        if (isQueue) {&#10;            // En modo cola: no hay &quot;previous&quot;, y &quot;next&quot; solo si hay tracks en cola&#10;            _hasPrevious.postValue(false)&#10;            _hasNext.postValue(queueSize &gt; 0)&#10;            Log.d(TAG, &quot;Modo cola: hasPrevious=false, hasNext=${queueSize &gt; 0}&quot;)&#10;        } else if (playlist != null &amp;&amp; currentIndex != null) {&#10;            val hasPrev = currentIndex &gt; 0&#10;            val hasNext = currentIndex &lt; playlist.size - 1&#10;            Log.d(TAG, &quot;Modo playlist: hasPrevious=$hasPrev, hasNext=$hasNext&quot;)&#10;            _hasPrevious.postValue(hasPrev)&#10;            _hasNext.postValue(hasNext)&#10;        } else {&#10;            Log.d(TAG, &quot;Deshabilitando navegación (sin contexto)&quot;)&#10;            _hasPrevious.postValue(false)&#10;            _hasNext.postValue(false)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene información del track actual de la playlist.&#10;     * @return Información del track actual o null si no hay playlist activa&#10;     */&#10;    fun getCurrentTrackInfo(): TrackEntity? {&#10;        return _currentTrack.value&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el número total de tracks en la playlist actual.&#10;     * @return Número de tracks o 0 si no hay playlist&#10;     */&#10;    fun getPlaylistSize(): Int {&#10;        return _currentPlaylist.value?.size ?: 0&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la posición actual en la playlist (1-indexed para mostrar al usuario).&#10;     * @return Posición actual (ej: &quot;3 de 10&quot;) o null si no hay playlist&#10;     */&#10;    fun getCurrentPlaylistPosition(): String? {&#10;        val playlist = _currentPlaylist.value&#10;        val currentIndex = _currentTrackIndex.value&#10;        &#10;        return if (playlist != null &amp;&amp; currentIndex != null) {&#10;            &quot;${currentIndex + 1} de ${playlist.size}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    // === MÉTODOS DE GESTIÓN DE COLA (QUEUE) ===&#10;    &#10;    /**&#10;     * Agrega un track a la cola de reproducción.&#10;     * @param track Track a agregar a la cola&#10;     */&#10;    fun addToQueue(track: TrackEntity) {&#10;        val currentQueue = _playbackQueue.value ?: mutableListOf()&#10;        currentQueue.add(track)&#10;        // Crear una nueva lista para asegurar que la UI se actualice&#10;        val newQueue = currentQueue.toMutableList()&#10;        _playbackQueue.postValue(newQueue)&#10;        updateNavigationState()&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Track agregado a la cola: ${track.name} (${newQueue.size} en cola)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Elimina un track de la cola por índice.&#10;     * @param index Índice del track a eliminar&#10;     */&#10;    fun removeFromQueue(index: Int) {&#10;        val currentQueue = _playbackQueue.value ?: return&#10;        if (index in currentQueue.indices) {&#10;            val removedTrack = currentQueue.removeAt(index)&#10;            // Crear una nueva lista para asegurar que la UI se actualice&#10;            val newQueue = currentQueue.toMutableList()&#10;            _playbackQueue.postValue(newQueue)&#10;            updateQueueState()&#10;            Log.d(TAG, &quot;Track eliminado de la cola: ${removedTrack.name} (${newQueue.size} restantes)&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpia toda la cola de reproducción.&#10;     */&#10;    fun clearQueue() {&#10;        _playbackQueue.postValue(mutableListOf())&#10;        _isQueueMode.postValue(false)&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Cola de reproducción limpiada&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción en modo cola.&#10;     * Reproduce el primer track de la cola y establece el modo cola.&#10;     */&#10;    suspend fun startQueueMode(): Boolean {&#10;        val queue = _playbackQueue.value&#10;        if (queue.isNullOrEmpty()) {&#10;            Log.d(TAG, &quot;No hay tracks en la cola para iniciar&quot;)&#10;            return false&#10;        }&#10;        &#10;        _isQueueMode.postValue(true)&#10;        Log.d(TAG, &quot;Iniciando modo cola con ${queue.size} tracks&quot;)&#10;        &#10;        // Reproducir el primer track de la cola&#10;        return playNextFromQueue()&#10;    }&#10;    &#10;    /**&#10;     * Reproduce el siguiente track de la cola.&#10;     * @return true si pudo reproducir, false si no hay más tracks en cola&#10;     */&#10;    suspend fun playNextFromQueue(): Boolean {&#10;        val queue = _playbackQueue.value&#10;        if (queue.isNullOrEmpty()) {&#10;            Log.d(TAG, &quot;Cola vacía, desactivando modo cola&quot;)&#10;            _isQueueMode.postValue(false)&#10;            updateNavigationState()&#10;            return false&#10;        }&#10;        &#10;        // Tomar el primer track de la cola&#10;        val nextTrack = queue.removeAt(0)&#10;        _playbackQueue.postValue(queue)&#10;        updateNavigationState()&#10;        &#10;        Log.d(TAG, &quot; Reproduciendo desde cola: ${nextTrack.name} (${queue.size} tracks restantes en cola)&quot;)&#10;        &#10;        // Cargar y reproducir el track&#10;        val success = loadAudioFromTrack(nextTrack)&#10;        if (success) {&#10;            // Actualizar el track actual&#10;            _currentTrack.postValue(nextTrack)&#10;            Log.d(TAG, &quot;✅ Track de cola cargado exitosamente: ${nextTrack.name}&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Error cargando track de cola: ${nextTrack.name}&quot;)&#10;            diagnoseExoPlayerState()&#10;        }&#10;        &#10;        return success&#10;    }&#10;    &#10;    /**&#10;     * Reproduce un track específico de la cola por índice.&#10;     * @param index Índice del track en la cola a reproducir&#10;     */&#10;    suspend fun playFromQueue(index: Int) {&#10;        val queue = _playbackQueue.value ?: return&#10;        if (index !in queue.indices) {&#10;            Log.e(TAG, &quot;Índice de cola fuera de rango: $index&quot;)&#10;            return&#10;        }&#10;        &#10;        val track = queue[index]&#10;        Log.d(TAG, &quot;Reproduciendo track de cola en índice $index: ${track.name}&quot;)&#10;        &#10;        // Actualizar el estado de la cola&#10;        updateQueueState()&#10;        &#10;        // Cargar y reproducir el track&#10;        val success = loadAudioFromTrack(track)&#10;        if (success) {&#10;            _currentTrack.postValue(track)&#10;            _isQueueMode.postValue(true)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de la cola desde el primer track.&#10;     */&#10;    fun startQueue() {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            val success = startQueueMode()&#10;            if (success) {&#10;                Log.d(TAG, &quot;Cola iniciada correctamente&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;No se pudo iniciar la cola&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Mezcla aleatoriamente los tracks en la cola.&#10;     */&#10;    fun shuffleQueue() {&#10;        val currentQueue = _playbackQueue.value ?: return&#10;        if (currentQueue.size &lt;= 1) return&#10;        &#10;        currentQueue.shuffle()&#10;        // Crear una nueva lista para asegurar que la UI se actualice&#10;        val newQueue = currentQueue.toMutableList()&#10;        _playbackQueue.postValue(newQueue)&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Cola mezclada - ${newQueue.size} tracks&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Reproduce la cola desde un índice específico y activa el modo cola.&#10;     * Esto reorganiza la cola para que comience desde el índice seleccionado&#10;     * y continúe con el resto de tracks en orden.&#10;     * &#10;     * @param startIndex Índice desde donde comenzar la reproducción&#10;     */&#10;    suspend fun playQueueFromIndex(startIndex: Int) {&#10;        val queue = _playbackQueue.value ?: return&#10;        if (startIndex !in queue.indices) {&#10;            Log.e(TAG, &quot;Índice de cola fuera de rango: $startIndex&quot;)&#10;            return&#10;        }&#10;        &#10;        Log.d(TAG, &quot; Iniciando cola desde índice $startIndex de ${queue.size} tracks&quot;)&#10;        &#10;        // Asegurar que ExoPlayer esté inicializado&#10;        if (_exoPlayer == null) {&#10;            Log.d(TAG, &quot; Inicializando ExoPlayer para cola...&quot;)&#10;            initializePlayer()&#10;        }&#10;        &#10;        // Reorganizar la cola: tracks desde startIndex hasta el final&#10;        val reorderedQueue = queue.drop(startIndex).toMutableList()&#10;        &#10;        // Actualizar la cola con la nueva secuencia&#10;        _playbackQueue.postValue(reorderedQueue)&#10;        &#10;        // Activar modo cola&#10;        _isQueueMode.postValue(true)&#10;        updateQueueState()&#10;        &#10;        // Reproducir el primer track de la nueva secuencia&#10;        val success = playNextFromQueue()&#10;        if (success) {&#10;            Log.d(TAG, &quot;✅ Cola iniciada correctamente desde índice $startIndex&quot;)&#10;        } else {&#10;            Log.w(TAG, &quot;❌ No se pudo iniciar la cola desde índice $startIndex&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza el estado de la cola (StateFlow).&#10;     */&#10;    private fun updateQueueState() {&#10;        val queue = _playbackQueue.value ?: emptyList()&#10;        val isActive = _isQueueMode.value ?: false&#10;        &#10;        _queueState.value = QueueState(&#10;            queue = queue.toList(), // Crear copia inmutable&#10;            currentIndex = -1, // Por ahora no trackear índice específico&#10;            isActive = isActive&#10;        )&#10;    }&#10;&#10;    // === MÉTODOS DE ESPERA Y SINCRONIZACIÓN ===&#10;    &#10;    /**&#10;     * Espera a que termine la canción actual usando el listener de ExoPlayer.&#10;     * Útil para reproducción secuencial de playlists.&#10;     * &#10;     * @return true si terminó naturalmente, false si se canceló o falló&#10;     */&#10;    suspend fun waitForCurrentSongToFinish(): Boolean {&#10;        return try {&#10;            Log.d(TAG, &quot;⏳ Esperando a que termine la canción actual...&quot;)&#10;            &#10;            // Verificar que hay una canción reproduciéndose&#10;            val hasPlayback = checkCurrentPlayback()&#10;            if (!hasPlayback) {&#10;                Log.w(TAG, &quot;⚠️ No hay canción reproduciéndose&quot;)&#10;                return false&#10;            }&#10;            &#10;            // Configurar callback para esperar el final&#10;            playbackEndedCallback = CompletableDeferred()&#10;            &#10;            // Esperar el resultado con timeout&#10;            waitForPlaybackCompletion()&#10;            &#10;        } catch (e: Exception) {&#10;            handleWaitException(e)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay una canción reproduciéndose actualmente.&#10;     * @return true si hay reproducción activa&#10;     */&#10;    private suspend fun checkCurrentPlayback(): Boolean {&#10;        return withContext(Dispatchers.Main) {&#10;            _exoPlayer != null &amp;&amp; isPlaying()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Espera a que la reproducción termine con un timeout de seguridad.&#10;     * @return true si terminó correctamente&#10;     */&#10;    private suspend fun waitForPlaybackCompletion(): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            // Timeout de 8 minutos (480 segundos) por seguridad&#10;            val timeout = 480000L&#10;            val startTime = System.currentTimeMillis()&#10;            &#10;            // Esperar hasta que termine o se agote el tiempo&#10;            while (playbackEndedCallback != null &amp;&amp; !playbackEndedCallback!!.isCompleted) {&#10;                if (System.currentTimeMillis() - startTime &gt; timeout) {&#10;                    Log.w(TAG, &quot;⚠️ Timeout esperando fin de canción&quot;)&#10;                    playbackEndedCallback?.complete(false)&#10;                    break&#10;                }&#10;                kotlinx.coroutines.delay(1000)&#10;            }&#10;            &#10;            val result = playbackEndedCallback?.await() ?: false&#10;            playbackEndedCallback = null&#10;            &#10;            Log.d(TAG, &quot;${if (result) &quot;✅&quot; else &quot;⚠️&quot;} Canción ${if (result) &quot;terminada&quot; else &quot;cancelada&quot;}&quot;)&#10;            result&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja excepciones durante la espera de finalización.&#10;     * @param e Excepción ocurrida&#10;     * @return false indicando fallo&#10;     */&#10;    private fun handleWaitException(e: Exception): Boolean {&#10;        Log.e(TAG, &quot;❌ Error esperando fin de canción: ${e.message}&quot;, e)&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Cancela la espera del final de la canción.&#10;     * Útil cuando se quiere detener la reproducción secuencial.&#10;     */&#10;    fun cancelWaitForSong() {&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;    }&#10;    &#10;    /**&#10;     * Maneja la navegación automática al final de una canción.&#10;     * Si hay una playlist activa y hay más canciones, navega automáticamente.&#10;     */&#10;    private fun handleAutoNavigation() {&#10;        // Verificar si la auto-navegación está habilitada&#10;        if (!isAutoNavigationEnabled()) {&#10;            Log.d(TAG, &quot; Auto-navegación deshabilitada&quot;)&#10;            return&#10;        }&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Priorizar cola de reproducción si está activa&#10;            val isQueueActive = _isQueueMode.value ?: false&#10;            val queue = _playbackQueue.value&#10;            &#10;            if (isQueueActive &amp;&amp; !queue.isNullOrEmpty()) {&#10;                Log.d(TAG, &quot; Auto-navegando en modo cola...&quot;)&#10;                &#10;                // Pequeña pausa antes de la siguiente canción&#10;                kotlinx.coroutines.delay(1000)&#10;                &#10;                // Reproducir siguiente canción de la cola&#10;                val success = playNextFromQueue()&#10;                if (!success) {&#10;                    Log.d(TAG, &quot; Cola terminada, saliendo de modo cola&quot;)&#10;                    _isQueueMode.postValue(false)&#10;                    updateQueueState()&#10;                }&#10;                return@launch&#10;            }&#10;            &#10;            // Si no hay cola activa, usar navegación de playlist&#10;            val playlist = _currentPlaylist.value&#10;            val currentIndex = _currentTrackIndex.value&#10;            &#10;            // Verificar si hay playlist activa y siguiente canción disponible&#10;            if (playlist != null &amp;&amp; currentIndex != null &amp;&amp; &#10;                currentIndex &lt; playlist.size - 1) {&#10;                &#10;                Log.d(TAG, &quot; Auto-navegando a la siguiente canción de playlist...&quot;)&#10;                &#10;                // Pequeña pausa antes de la siguiente canción&#10;                kotlinx.coroutines.delay(1000)&#10;                &#10;                // Navegar automáticamente al siguiente track&#10;                try {&#10;                    navigateToNext()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error durante auto-navegación&quot;, e)&#10;                    updateLoadingState(false, &quot;Error navegando al siguiente track&quot;)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot; Fin de playlist o no hay playlist activa&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS UTILITARIOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Actualiza el estado de carga y error de forma consistente.&#10;     * @param loading Estado de carga&#10;     * @param errorMessage Mensaje de error (null si no hay error)&#10;     * @param title Título a mostrar (opcional)&#10;     */&#10;    private fun updateLoadingState(loading: Boolean, errorMessage: String? = null, title: String? = null) {&#10;        _isLoading.postValue(loading)&#10;        _error.postValue(errorMessage)&#10;        title?.let { _currentTitle.postValue(it) }&#10;    }&#10;    &#10;    /**&#10;     * Maneja excepciones de forma consistente.&#10;     * @param message Mensaje descriptivo del error&#10;     * @param exception Excepción ocurrida&#10;     */&#10;    private fun handleException(message: String, exception: Exception) {&#10;        Log.e(TAG, &quot;❌ $message: ${exception.message}&quot;, exception)&#10;        updateLoadingState(false, &quot;$message: ${exception.message}&quot;)&#10;    }&#10;    &#10;    // === LIMPIEZA DE RECURSOS ===&#10;    &#10;    /**&#10;     * Limpia los recursos cuando el ViewModel es destruido.&#10;     * Cancela callbacks pendientes y libera el ExoPlayer.&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        &#10;        Log.d(TAG, &quot; Limpiando recursos del PlayerViewModel&quot;)&#10;        &#10;        // Cancelar cualquier callback pendiente&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;        &#10;        // Cancelar preloading activo&#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;        &#10;        // Liberar ExoPlayer en el hilo principal&#10;        mainHandler.post {&#10;            try {&#10;                // Remover listeners antes de liberar&#10;                _currentPlayerListener?.let { listener -&gt;&#10;                    _exoPlayer?.removeListener(listener)&#10;                }&#10;                &#10;                // Detener y liberar ambos players completamente&#10;                _exoPlayer?.let { player -&gt;&#10;                    player.stop()&#10;                    player.clearMediaItems()&#10;                    player.release()&#10;                }&#10;                _exoPlayer = null&#10;                &#10;                _preloadPlayer?.let { player -&gt;&#10;                    player.stop()&#10;                    player.clearMediaItems()&#10;                    player.release()&#10;                }&#10;                _preloadPlayer = null&#10;                &#10;                // Limpiar referencia del listener&#10;                _currentPlayerListener = null&#10;                &#10;                Log.d(TAG, &quot;✅ Recursos liberados correctamente&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error liberando recursos&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS DE PRELOADING PARA TRANSICIONES SIN DELAY ===&#10;    &#10;    /**&#10;     * Maneja la transición sin delay entre canciones usando el track preloaded.&#10;     * Si hay un track preloaded listo, intercambia los ExoPlayers instantáneamente.&#10;     */&#10;    private fun handleSeamlessTransition() {&#10;        if (!isAutoNavigationEnabled()) {&#10;            Log.d(TAG, &quot; Auto-navegación deshabilitada&quot;)&#10;            return&#10;        }&#10;        &#10;        val nextTrack = getNextTrackToPlay()&#10;        if (nextTrack == null) {&#10;            Log.d(TAG, &quot; No hay siguiente track, finalizando reproducción&quot;)&#10;            return&#10;        }&#10;        &#10;        // Si tenemos el track preloaded y es el correcto, hacer intercambio instantáneo&#10;        Log.d(TAG, &quot; Verificando preloading:&quot;)&#10;        Log.d(TAG, &quot;  - Track esperado: ${nextTrack.name}&quot;)&#10;        Log.d(TAG, &quot;  - Track preloaded: ${_preloadedTrack?.name}&quot;)&#10;        Log.d(TAG, &quot;  - PreloadPlayer existe: ${_preloadPlayer != null}&quot;)&#10;        Log.d(TAG, &quot;  - PreloadPlayer estado: ${_preloadPlayer?.playbackState}&quot;)&#10;        Log.d(TAG, &quot;  - Estado esperado (READY): ${Player.STATE_READY}&quot;)&#10;        &#10;        // Intentar swap instantáneo hasta 500ms si el preloading está casi listo&#10;        if (_preloadedTrack == nextTrack &amp;&amp; _preloadPlayer != null) {&#10;            val maxAttempts = 5&#10;            var attempt = 0&#10;            while (_preloadPlayer?.playbackState != Player.STATE_READY &amp;&amp; attempt &lt; maxAttempts) {&#10;                Log.d(TAG, &quot;⌛ Esperando a que PreloadPlayer esté listo (intento ${attempt + 1}/$maxAttempts)...&quot;)&#10;                Thread.sleep(100)&#10;                attempt++&#10;            }&#10;            if (_preloadPlayer?.playbackState == Player.STATE_READY) {&#10;                Log.d(TAG, &quot; ✅ Todas las condiciones cumplidas - Track preloaded detectado: ${nextTrack.name}, iniciando intercambio&quot;)&#10;                performSeamlessSwap(nextTrack)&#10;                return&#10;            }&#10;        }&#10;        // Fallback a navegación normal con delay&#10;        val reason = when {&#10;            _preloadedTrack != nextTrack -&gt; &quot;Track preloaded incorrecto (esperado: ${nextTrack.name}, actual: ${_preloadedTrack?.name})&quot;&#10;            _preloadPlayer == null -&gt; &quot;PreloadPlayer es null&quot;&#10;            _preloadPlayer?.playbackState != Player.STATE_READY -&gt; &quot;PreloadPlayer no está listo (estado: ${_preloadPlayer?.playbackState})&quot;&#10;            else -&gt; &quot;Razón desconocida&quot;&#10;        }&#10;        Log.w(TAG, &quot;⚠️ ❌ No hay preloading válido: $reason. Usando navegación normal&quot;)&#10;        handleAutoNavigation()&#10;    }&#10;    &#10;    /**&#10;     * Realiza el intercambio instantáneo de ExoPlayers para transición sin delay.&#10;     * @param nextTrack El track que debe reproducirse next&#10;     */&#10;    private fun performSeamlessSwap(nextTrack: TrackEntity) {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                Log.d(TAG, &quot; Iniciando intercambio sin delay para: ${nextTrack.name}&quot;)&#10;                &#10;                // Verificar que el preload player esté listo&#10;                if (_preloadPlayer?.playbackState != Player.STATE_READY) {&#10;                    Log.w(TAG, &quot;⚠️ PreloadPlayer no está listo, usando navegación normal&quot;)&#10;                    handleAutoNavigation()&#10;                    return@launch&#10;                }&#10;                &#10;                // Detener y limpiar el player actual ANTES del intercambio&#10;                _exoPlayer?.let { currentPlayer -&gt;&#10;                    currentPlayer.pause()&#10;                    currentPlayer.stop()&#10;                    // Remover listener del player actual&#10;                    _currentPlayerListener?.let { listener -&gt;&#10;                        currentPlayer.removeListener(listener)&#10;                    }&#10;                }&#10;                &#10;                // Guardar referencia al player anterior para limpieza&#10;                val oldPlayer = _exoPlayer&#10;                &#10;                // Intercambiar los ExoPlayers (el preload ya está preparado y listo)&#10;                _exoPlayer = _preloadPlayer&#10;                _preloadPlayer = oldPlayer&#10;                &#10;                // Configurar el nuevo player principal para reproducción INMEDIATA&#10;                _exoPlayer?.let { newMainPlayer -&gt;&#10;                    // Agregar listener al nuevo player principal&#10;                    _currentPlayerListener?.let { listener -&gt;&#10;                        newMainPlayer.addListener(listener)&#10;                    }&#10;                    &#10;                    // EL PLAYER YA ESTÁ PREPARADO - solo activar reproducción&#10;                    newMainPlayer.playWhenReady = true&#10;                    newMainPlayer.play()&#10;                    &#10;                    Log.d(TAG, &quot;⚡ Reproducción instantánea iniciada para: ${nextTrack.name}&quot;)&#10;                }&#10;                &#10;                // Limpiar completamente el player anterior para liberar recursos&#10;                _preloadPlayer?.let { oldPreloadPlayer -&gt;&#10;                    oldPreloadPlayer.stop()&#10;                    oldPreloadPlayer.clearMediaItems()&#10;                    oldPreloadPlayer.playWhenReady = false&#10;                    // Forzar liberación de buffers&#10;                    oldPreloadPlayer.release()&#10;                    &#10;                    // Recrear el preload player inmediatamente con recursos limpios&#10;                    _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                        .setSeekBackIncrementMs(10000)&#10;                        .setSeekForwardIncrementMs(10000)&#10;                        .build().apply {&#10;                            playWhenReady = false&#10;                            setHandleAudioBecomingNoisy(false)&#10;                            &#10;                            // Aplicar optimizaciones de buffer&#10;                            optimizeBufferSettings(this)&#10;                            &#10;                            addListener(object : Player.Listener {&#10;                                override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                    when (playbackState) {&#10;                                        Player.STATE_READY -&gt; {&#10;                                            Log.d(TAG, &quot; Nuevo PreloadPlayer LISTO&quot;)&#10;                                        }&#10;                                        Player.STATE_BUFFERING -&gt; {&#10;                                            Log.d(TAG, &quot; Nuevo PreloadPlayer bufferizando...&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            })&#10;                        }&#10;                    Log.d(TAG, &quot;♻️ PreloadPlayer recreado después de intercambio&quot;)&#10;                }&#10;                &#10;                // Actualizar estados de la UI&#10;                updateTrackStates(nextTrack)&#10;                &#10;                // Resetear estado de preloading&#10;                _preloadedTrack = null&#10;                _isPreloading = false&#10;                &#10;                Log.d(TAG, &quot;✅ Intercambio sin delay completado para: ${nextTrack.name}&quot;)&#10;                &#10;                // Monitorear memoria después del intercambio&#10;                monitorMemoryUsage()&#10;                &#10;                // Esperar un momento antes de iniciar nuevo preloading para evitar sobrecarga&#10;                kotlinx.coroutines.delay(2000)&#10;                &#10;                // Comenzar a preloading el siguiente track&#10;                if (!_isPreloading) {&#10;                    startPreloadingNextTrack()&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en intercambio sin delay&quot;, e)&#10;                // Limpiar estado y usar navegación normal como fallback&#10;                _isPreloading = false&#10;                _preloadedTrack = null&#10;                handleAutoNavigation()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza los estados del track actual después de un intercambio.&#10;     * @param track El nuevo track actual&#10;     */&#10;    private fun updateTrackStates(track: TrackEntity) {&#10;        // Actualizar estados según el modo de reproducción&#10;        if (_isQueueMode.value == true) {&#10;            // Remover el track de la cola ya que se está reproduciendo&#10;            val queue = _playbackQueue.value?.toMutableList() ?: mutableListOf()&#10;            if (queue.isNotEmpty()) {&#10;                queue.removeAt(0)&#10;                _playbackQueue.postValue(queue)&#10;                updateQueueState()&#10;            }&#10;        } else {&#10;            // Modo playlist - actualizar índice&#10;            val playlist = _currentPlaylist.value&#10;            if (playlist != null) {&#10;                val index = playlist.indexOf(track)&#10;                if (index != -1) {&#10;                    _currentTrackIndex.postValue(index)&#10;                    updateNavigationState()&#10;                }&#10;            }&#10;        }&#10;        &#10;        _currentTrack.postValue(track)&#10;        _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el siguiente track que debería reproducirse.&#10;     * @return El siguiente TrackEntity o null si no hay siguiente&#10;     */&#10;    private fun getNextTrackToPlay(): TrackEntity? {&#10;        // Priorizar cola de reproducción&#10;        if (_isQueueMode.value == true) {&#10;            val queue = _playbackQueue.value&#10;            return if (!queue.isNullOrEmpty()) queue[0] else null&#10;        }&#10;        &#10;        // Modo playlist&#10;        val playlist = _currentPlaylist.value ?: return null&#10;        val currentIndex = _currentTrackIndex.value ?: return null&#10;        &#10;        return if (currentIndex &lt; playlist.size - 1) {&#10;            playlist[currentIndex + 1]&#10;        } else null&#10;    }&#10;    &#10;    /**&#10;     * Inicia el preloading de la siguiente canción en background.&#10;     * Se llama automáticamente cuando el track actual está listo.&#10;     */&#10;    private fun startPreloadingNextTrack() {&#10;        if (_isPreloading) {&#10;            Log.d(TAG, &quot; Ya hay preloading en progreso&quot;)&#10;            return&#10;        }&#10;        &#10;        val nextTrack = getNextTrackToPlay()&#10;        if (nextTrack == null) {&#10;            Log.d(TAG, &quot; No hay siguiente track para preload&quot;)&#10;            return&#10;        }&#10;        &#10;        if (_preloadPlayer == null) {&#10;            Log.e(TAG, &quot;❌ PreloadPlayer no inicializado&quot;)&#10;            return&#10;        }&#10;        &#10;        _isPreloading = true&#10;        _preloadedTrack = nextTrack&#10;        &#10;        Log.d(TAG, &quot; Iniciando preloading de: ${nextTrack.name}&quot;)&#10;        &#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                // Obtener YouTube ID y URL de audio&#10;                val youtubeId = youtubeSearchManager.getYouTubeIdTransparently(nextTrack)&#10;                if (youtubeId == null) {&#10;                    Log.e(TAG, &quot;❌ No se encontró YouTube ID para preload: ${nextTrack.name}&quot;)&#10;                    resetPreloadingState()&#10;                    return@launch&#10;                }&#10;                &#10;                val audioUrl = YouTubeAudioExtractor.getAudioUrl(youtubeId)&#10;                if (audioUrl == null || !isValidAudioUrl(audioUrl)) {&#10;                    Log.e(TAG, &quot;❌ No se obtuvo URL válida para preload: ${nextTrack.name}&quot;)&#10;                    resetPreloadingState()&#10;                    return@launch&#10;                }&#10;                &#10;                // Preparar el track en el preload player&#10;                withContext(Dispatchers.Main) {&#10;                    _preloadPlayer?.let { player -&gt;&#10;                        try {&#10;                            // Limpiar estado anterior completamente&#10;                            player.stop()&#10;                            player.clearMediaItems()&#10;                            &#10;                            // Asegurar que NO se reproduzca automáticamente&#10;                            player.playWhenReady = false&#10;                            player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                            player.prepare()&#10;                            &#10;                            // Verificar que efectivamente no esté reproduciéndose&#10;                            if (player.isPlaying) {&#10;                                player.pause()&#10;                            }&#10;                            &#10;                            Log.d(TAG, &quot; Preparando preload para: ${nextTrack.name}&quot;)&#10;                            &#10;                            // Esperar a que el player esté realmente listo con timeout más corto&#10;                            var attempts = 0&#10;                            while (player.playbackState != Player.STATE_READY &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                                kotlinx.coroutines.delay(100)&#10;                                attempts++&#10;                                &#10;                                // Verificar si el preloading fue cancelado&#10;                                if (!_isPreloading) {&#10;                                    Log.d(TAG, &quot; Preloading cancelado durante espera&quot;)&#10;                                    return@withContext&#10;                                }&#10;                            }&#10;                            &#10;                            if (player.playbackState == Player.STATE_READY &amp;&amp; _isPreloading) {&#10;                                Log.d(TAG, &quot;✅ Preloading completado para: ${nextTrack.name}&quot;)&#10;                            } else {&#10;                                Log.w(TAG, &quot;⚠️ Preloading timeout o cancelado para: ${nextTrack.name}&quot;)&#10;                                resetPreloadingState()&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;❌ Error en preparación de preload para ${nextTrack.name}&quot;, e)&#10;                            resetPreloadingState()&#10;                        }&#10;                    }&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en preloading para ${nextTrack.name}&quot;, e)&#10;                resetPreloadingState()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Resetea el estado de preloading de forma segura.&#10;     */&#10;    private fun resetPreloadingState() {&#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;    }&#10;    &#10;    /**&#10;     * Cancela el preloading activo si existe.&#10;     * Útil cuando se cambia manualmente de canción o se reinicia el player.&#10;     */&#10;    private fun cancelPreloading() {&#10;        if (_isPreloading) {&#10;            Log.d(TAG, &quot; Cancelando preloading activo&quot;)&#10;            resetPreloadingState()&#10;            &#10;            // Limpiar el preload player en el hilo principal de forma más agresiva&#10;            mainHandler.post {&#10;                _preloadPlayer?.let { player -&gt;&#10;                    try {&#10;                        player.stop()&#10;                        player.clearMediaItems()&#10;                        player.playWhenReady = false&#10;                        &#10;                        // Liberar completamente el preload player para evitar leaks&#10;                        player.release()&#10;                        &#10;                        // Recrear inmediatamente&#10;                        _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                            .setSeekBackIncrementMs(10000)&#10;                            .setSeekForwardIncrementMs(10000)&#10;                            .build().apply {&#10;                                playWhenReady = false&#10;                                setHandleAudioBecomingNoisy(false)&#10;                                &#10;                                // Aplicar optimizaciones de buffer&#10;                                optimizeBufferSettings(this)&#10;                                &#10;                                addListener(object : Player.Listener {&#10;                                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                        when (playbackState) {&#10;                                            Player.STATE_READY -&gt; {&#10;                                                Log.d(TAG, &quot; PreloadPlayer recreado y listo&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                })&#10;                            }&#10;                        Log.d(TAG, &quot;♻️ PreloadPlayer recreado después de cancelación&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;❌ Error cancelando preloading&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Estado de la cola de reproducción.&#10;     * @param queue Lista de tracks en la cola&#10;     * @param currentIndex Índice del track actual en la cola (-1 si no hay track actual)&#10;     * @param isActive Si la cola está activa&#10;     */&#10;    data class QueueState(&#10;        val queue: List&lt;TrackEntity&gt; = emptyList(),&#10;        val currentIndex: Int = -1,&#10;        val isActive: Boolean = false&#10;    )&#10;&#10;    /**&#10;     * Diagnostica el estado de ambos ExoPlayers para debugging.&#10;     */&#10;    private fun diagnoseExoPlayerState() {&#10;        Log.d(TAG, &quot; Diagnóstico ExoPlayer:&quot;)&#10;        Log.d(TAG, &quot;   - ExoPlayer principal: ${if (_exoPlayer != null) &quot;✅ Existe&quot; else &quot;❌ Es null&quot;}&quot;)&#10;        _exoPlayer?.let { player -&gt;&#10;            Log.d(TAG, &quot;     - Estado actual: ${player.playbackState}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está reproduciéndose?: ${player.isPlaying}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está preparado?: ${player.playbackState == Player.STATE_READY}&quot;)&#10;            Log.d(TAG, &quot;     - Duración: ${player.duration}&quot;)&#10;            Log.d(TAG, &quot;     - Posición actual: ${player.currentPosition}&quot;)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;   - ExoPlayer preload: ${if (_preloadPlayer != null) &quot;✅ Existe&quot; else &quot;❌ Es null&quot;}&quot;)&#10;        _preloadPlayer?.let { preloadPlayer -&gt;&#10;            Log.d(TAG, &quot;     - Estado preload: ${preloadPlayer.playbackState}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está preparado?: ${preloadPlayer.playbackState == Player.STATE_READY}&quot;)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;   - Track preloaded: ${_preloadedTrack?.name ?: &quot;Ninguno&quot;}&quot;)&#10;        Log.d(TAG, &quot;   - Preloading activo: $_isPreloading&quot;)&#10;    }&#10;    &#10;    // === CONFIGURACIÓN DE BUFFER Y OPTIMIZACIÓN ===&#10;    &#10;    /**&#10;     * Optimiza la configuración de buffer para reducir uso de memoria.&#10;     */&#10;    private fun optimizeBufferSettings(player: ExoPlayer) {&#10;        try {&#10;            // Configurar parámetros de buffer más conservadores para evitar exhaustión&#10;            // Estos valores reducen el uso de memoria pero mantienen buena reproducción&#10;            player.setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true // Handle audio becoming noisy&#10;            )&#10;            &#10;            Log.d(TAG, &quot; Configuración de buffer optimizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ No se pudo optimizar configuración de buffer&quot;, e)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Fuerza la liberación de recursos de memoria de ExoPlayer.&#10;     */&#10;    private fun forceMemoryCleanup(player: ExoPlayer?) {&#10;        player?.let {&#10;            try {&#10;                // Detener reproducción y limpiar media items&#10;                it.stop()&#10;                it.clearMediaItems()&#10;                &#10;                // Forzar garbage collection (solo en casos críticos)&#10;                System.gc()&#10;                &#10;                Log.d(TAG, &quot;♻️ Limpieza forzada de memoria completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;⚠️ Error durante limpieza forzada&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Monitorea el uso de memoria y toma acciones si es necesario.&#10;     */&#10;    private fun monitorMemoryUsage() {&#10;        try {&#10;            val runtime = Runtime.getRuntime()&#10;            val usedMemory = runtime.totalMemory() - runtime.freeMemory()&#10;            val maxMemory = runtime.maxMemory()&#10;            val memoryPercentage = (usedMemory * 100) / maxMemory&#10;            &#10;            Log.d(TAG, &quot; Uso de memoria: ${memoryPercentage}% (${usedMemory / 1024 / 1024}MB / ${maxMemory / 1024 / 1024}MB)&quot;)&#10;            &#10;            // Si el uso de memoria es alto (&gt;80%), realizar limpieza&#10;            if (memoryPercentage &gt; 80) {&#10;                Log.w(TAG, &quot;⚠️ Uso de memoria alto, realizando limpieza preventiva&quot;)&#10;                &#10;                // Cancelar preloading para liberar memoria&#10;                if (_isPreloading) {&#10;                    cancelPreloading()&#10;                }&#10;                &#10;                // Forzar garbage collection&#10;                System.gc()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ Error monitoreando memoria&quot;, e)&#10;        }&#10;    }&#10;    /**&#10;     * Obtiene la instancia del ExoPlayer para uso externo.&#10;     * @return ExoPlayer actual o null si no está inicializado&#10;     */&#10;    fun getPlayer(): ExoPlayer? {&#10;        return _exoPlayer&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeAudioExtractor&#10;import com.plyr.utils.isValidAudioUrl&#10;import com.plyr.utils.Config&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.database.TrackEntity&#10;import android.os.Handler&#10;import android.os.Looper&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.CompletableDeferred&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.flow.MutableStateFlow&#10;import kotlinx.coroutines.flow.StateFlow&#10;import kotlinx.coroutines.flow.asStateFlow&#10;import android.util.Log&#10;import android.content.Intent&#10;import com.plyr.service.MusicService&#10;&#10;/**&#10; * PlayerViewModel - Maneja la reproducción de audio usando ExoPlayer y NewPipe&#10; * &#10; * FUNCIONALIDADES PRINCIPALES:&#10; * - Gestionar el ciclo de vida del ExoPlayer&#10; * - Extraer URLs de audio de YouTube usando NewPipe Extractor&#10; * - Proporcionar una interfaz para reproducir audio desde videos o tracks de Spotify&#10; * - Manejar estados de reproducción (loading, error, etc.)&#10; * - Proporcionar funcionalidades como play, pause, seek y control de tiempo&#10; * &#10; * NAVEGACIÓN DE PLAYLIST:&#10; * - Mantener el estado de la playlist actual y el índice del track&#10; * - Navegación manual hacia adelante/atrás con botones fwd/bwd&#10; * - Auto-navegación automática al final de cada canción (configurable)&#10; * - Información de posición en playlist (ej: &quot;3 de 10&quot;)&#10; * - Estados de disponibilidad de navegación (hasPrevious/hasNext)&#10; * &#10; * USO:&#10; * 1. Llamar setCurrentPlaylist() para establecer la lista de tracks&#10; * 2. Los botones fwd/bwd en FloatingMusicControls permiten navegación manual&#10; * 3. La auto-navegación se puede habilitar/deshabilitar con setAutoNavigationEnabled()&#10; * 4. Los estados de navegación se observan automáticamente en la UI&#10; * &#10; * @param application Contexto de la aplicación para acceder a recursos del sistema&#10; */&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    &#10;    // === CONSTANTES ===&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;PlayerViewModel&quot;&#10;    }&#10;    &#10;    // === PROPIEDADES PRIVADAS ===&#10;    &#10;    /** Instancia del ExoPlayer para reproducción de audio */&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    &#10;    /** ExoPlayer secundario para preloading de la siguiente canción */&#10;    private var _preloadPlayer: ExoPlayer? = null&#10;    &#10;    /** Track que está siendo preloaded */&#10;    private var _preloadedTrack: TrackEntity? = null&#10;    &#10;    /** Estado de preloading activo */&#10;    private var _isPreloading = false&#10;    &#10;    /** Listener actual del ExoPlayer principal para poder removerlo durante intercambios */&#10;    private var _currentPlayerListener: Player.Listener? = null&#10;    &#10;    /** LiveData privado para la URL de audio actual */&#10;    private val _audioUrl = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** LiveData privado para el título de la canción actual */&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** LiveData privado para el estado de carga */&#10;    private val _isLoading = MutableLiveData&lt;Boolean&gt;()&#10;    &#10;    /** LiveData privado para mensajes de error */&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    &#10;    /** Handler para ejecutar código en el hilo principal */&#10;    private val mainHandler = Handler(Looper.getMainLooper())&#10;    &#10;    /** Manejador de búsquedas de YouTube usando NewPipe */&#10;    private val youtubeSearchManager = YouTubeSearchManager(application)&#10;    &#10;    /** Callback para notificar cuando una canción termina de reproducirse */&#10;    private var playbackEndedCallback: CompletableDeferred&lt;Boolean&gt;? = null&#10;    &#10;    // === PROPIEDADES DE PLAYLIST ===&#10;    &#10;    /** Lista actual de tracks de la playlist */&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    &#10;    /** Índice del track actual en la playlist */&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    &#10;    /** Track actual que se está reproduciendo */&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    &#10;    /** Estado de si hay track anterior disponible */&#10;    private val _hasPrevious = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    /** Estado de si hay track siguiente disponible */&#10;    private val _hasNext = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    /** Estado de auto-navegación habilitada */&#10;    private val _autoNavigationEnabled = MutableLiveData&lt;Boolean&gt;(true)&#10;    &#10;    // === PROPIEDADES DE COLA (QUEUE) ===&#10;    &#10;    /** Cola de reproducción - lista de tracks pendientes */&#10;    private val _playbackQueue = MutableLiveData&lt;MutableList&lt;TrackEntity&gt;&gt;(mutableListOf())&#10;    &#10;    /** Indica si está en modo cola (queue) */&#10;    private val _isQueueMode = MutableLiveData&lt;Boolean&gt;(false)&#10;    &#10;    // === PROPIEDADES DE COLA (STATEFLOW) ===&#10;    &#10;    /** Estado de la cola como StateFlow para Compose */&#10;    private val _queueState = MutableStateFlow(QueueState())&#10;    val queueState: StateFlow&lt;QueueState&gt; = _queueState.asStateFlow()&#10;&#10;    // === PROPIEDADES PÚBLICAS (READONLY) ===&#10;    &#10;    /** Acceso público de solo lectura al ExoPlayer */&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;    &#10;    /** LiveData observable para la URL de audio actual */&#10;    val audioUrl: LiveData&lt;String?&gt; = _audioUrl&#10;    &#10;    /** LiveData observable para el título de la canción actual */&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;    &#10;    /** LiveData observable para el estado de carga */&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;    &#10;    /** LiveData observable para mensajes de error */&#10;    val error: LiveData&lt;String?&gt; = _error&#10;    &#10;    /** LiveData observable para la playlist actual */&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;    &#10;    /** LiveData observable para el índice del track actual */&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;    &#10;    /** LiveData observable para el track actual */&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;    &#10;    /** LiveData observable para disponibilidad de track anterior */&#10;    val hasPrevious: LiveData&lt;Boolean&gt; = _hasPrevious&#10;    &#10;    /** LiveData observable para disponibilidad de track siguiente */&#10;    val hasNext: LiveData&lt;Boolean&gt; = _hasNext&#10;    &#10;    /** LiveData observable para el estado de auto-navegación */&#10;    val autoNavigationEnabled: LiveData&lt;Boolean&gt; = _autoNavigationEnabled&#10;    &#10;    /** LiveData observable para la cola de reproducción */&#10;    val playbackQueue: LiveData&lt;MutableList&lt;TrackEntity&gt;&gt; = _playbackQueue&#10;    &#10;    /** LiveData observable para el estado de modo cola */&#10;    val isQueueMode: LiveData&lt;Boolean&gt; = _isQueueMode&#10;&#10;    // === INICIALIZACIÓN ===&#10;    &#10;    init {&#10;        // Inicializar el estado de la cola&#10;        updateQueueState()&#10;        // Observadores para actualizar el estado de navegación automáticamente&#10;        _playbackQueue.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        _currentPlaylist.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        _currentTrackIndex.observeForever {&#10;            updateNavigationState()&#10;        }&#10;        Log.d(TAG, &quot;PlayerViewModel inicializado&quot;)&#10;    }&#10;&#10;    // === MÉTODOS PÚBLICOS ===&#10;    &#10;    /**&#10;     * Inicializa el ExoPlayer si no ha sido creado aún.&#10;     * Configura los listeners necesarios para el manejo de estados de reproducción.&#10;     * También inicializa el ExoPlayer de preloading para transiciones sin delay.&#10;     */&#10;    fun initializePlayer() {&#10;        // Asegurar que la inicialización ocurra en el hilo principal&#10;        mainHandler.post {&#10;            if (_exoPlayer == null) {&#10;                _currentPlayerListener = createPlayerListener()&#10;                _exoPlayer = ExoPlayer.Builder(getApplication())&#10;                    .setSeekBackIncrementMs(10000)&#10;                    .setSeekForwardIncrementMs(10000)&#10;                    .build().apply {&#10;                        // Configurar listener para eventos de reproducción&#10;                        addListener(_currentPlayerListener!!)&#10;                        // Configurar para liberar recursos inmediatamente cuando se detiene&#10;                        setHandleAudioBecomingNoisy(true)&#10;                        &#10;                        // Aplicar optimizaciones de buffer&#10;                        optimizeBufferSettings(this)&#10;                    }&#10;                Log.d(TAG, &quot;✅ ExoPlayer principal inicializado&quot;)&#10;            }&#10;            &#10;            // Inicializar el ExoPlayer de preloading si no existe&#10;            if (_preloadPlayer == null) {&#10;                _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                    .setSeekBackIncrementMs(10000)&#10;                    .setSeekForwardIncrementMs(10000)&#10;                    .build().apply {&#10;                        // Configurar para NO reproducir automáticamente&#10;                        playWhenReady = false&#10;                        setHandleAudioBecomingNoisy(false) // Solo el player principal maneja esto&#10;                        &#10;                        // Aplicar optimizaciones de buffer&#10;                        optimizeBufferSettings(this)&#10;                        &#10;                        // Agregar listener para monitorear el estado del preloading&#10;                        addListener(object : Player.Listener {&#10;                            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                when (playbackState) {&#10;                                    Player.STATE_READY -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer LISTO - Track: ${_preloadedTrack?.name}&quot;)&#10;                                    }&#10;                                    Player.STATE_BUFFERING -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer bufferizando...&quot;)&#10;                                    }&#10;                                    Player.STATE_IDLE -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer en IDLE&quot;)&#10;                                    }&#10;                                    Player.STATE_ENDED -&gt; {&#10;                                        Log.d(TAG, &quot; PreloadPlayer terminado&quot;)&#10;                                    }&#10;                                }&#10;                            }&#10;                        })&#10;                    }&#10;                Log.d(TAG, &quot;✅ ExoPlayer preload inicializado&quot;)&#10;            }&#10;            &#10;            // Monitorear uso de memoria después de inicialización&#10;            monitorMemoryUsage()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Crea el listener para el ExoPlayer que maneja cambios de estado.&#10;     * @return Player.Listener configurado con los callbacks necesarios&#10;     */&#10;    private fun createPlayerListener(): Player.Listener {&#10;        return object : Player.Listener {&#10;            override fun onPlaybackStateChanged(playbackState: Int) {&#10;                when (playbackState) {&#10;                    Player.STATE_ENDED -&gt; {&#10;                        Log.d(TAG, &quot; Canción terminada - Player.STATE_ENDED&quot;)&#10;                        playbackEndedCallback?.complete(true)&#10;                        playbackEndedCallback = null&#10;                        &#10;                        // Verificar modo de repetición antes de manejar la transición&#10;                        handleRepeatModeTransition()&#10;                    }&#10;                    Player.STATE_IDLE -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer en estado IDLE&quot;)&#10;                    }&#10;                    Player.STATE_BUFFERING -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer bufferizando...&quot;)&#10;                    }&#10;                    Player.STATE_READY -&gt; {&#10;                        Log.d(TAG, &quot;ExoPlayer listo para reproducir&quot;)&#10;                        &#10;                        // Limpiar estado de carga cuando el player esté listo&#10;                        _isLoading.postValue(false)&#10;                        &#10;                        // Cuando el player actual esté listo, iniciar preloading de la siguiente canción&#10;                        // Pero solo si no hay preloading activo ya&#10;                        if (!_isPreloading) {&#10;                            startPreloadingNextTrack()&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            &#10;            override fun onIsPlayingChanged(isPlaying: Boolean) {&#10;                Log.d(TAG, &quot;Estado de reproducción cambió: $isPlaying&quot;)&#10;            }&#10;            &#10;            override fun onPlayerError(error: PlaybackException) {&#10;                Log.e(TAG, &quot;❌ Error de ExoPlayer: ${error.message}&quot;, error)&#10;                // Limpiar recursos y reintentar si es posible&#10;                handlePlayerError(error)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores del ExoPlayer y intenta recuperarse.&#10;     * @param error El error que ocurrió&#10;     */&#10;    private fun handlePlayerError(error: PlaybackException) {&#10;        Log.e(TAG, &quot; Manejando error de ExoPlayer: ${error.errorCode}&quot;)&#10;        &#10;        // Cancelar preloading activo que podría estar causando problemas&#10;        cancelPreloading()&#10;        &#10;        // Liberar y reinicializar ExoPlayers para limpiar estado corrupto&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                releasePlayersForRecovery()&#10;                kotlinx.coroutines.delay(1000) // Esperar un momento&#10;                initializePlayer()&#10;                &#10;                // Intentar recargar el track actual si existe&#10;                _currentTrack.value?.let { track -&gt;&#10;                    Log.d(TAG, &quot; Reintentando cargar track actual después de error: ${track.name}&quot;)&#10;                    loadAudioFromTrack(track)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error durante recuperación&quot;, e)&#10;                updateLoadingState(false, &quot;Error de reproducción. Reinicia la app si persiste.&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Libera ExoPlayers para recuperación de errores.&#10;     */&#10;    private fun releasePlayersForRecovery() {&#10;        Log.d(TAG, &quot; Liberando ExoPlayers para recuperación&quot;)&#10;        &#10;        _currentPlayerListener?.let { listener -&gt;&#10;            _exoPlayer?.removeListener(listener)&#10;        }&#10;        &#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;        &#10;        _preloadPlayer?.release()&#10;        _preloadPlayer = null&#10;        &#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;    }&#10;    &#10;    /**&#10;     * Carga y reproduce audio desde un video ID de YouTube.&#10;     * &#10;     * @param videoId ID del video de YouTube (ej: &quot;dQw4w9WgXcQ&quot;)&#10;     * @param title Título opcional para mostrar en la UI&#10;     */&#10;    fun loadAudio(videoId: String, title: String? = null) {&#10;        println(&quot;PlayerViewModel: Cargando audio para video ID: $videoId con título: $title&quot;)&#10;        updateLoadingState(true, null, title)&#10;        &#10;        // Usar NewPipe Extractor para obtener la URL de audio&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                val audioUrl = extractAudioUrl(videoId)&#10;                &#10;                if (audioUrl != null &amp;&amp; isValidAudioUrl(audioUrl)) {&#10;                    println(&quot;PlayerViewModel: ✅ URL obtenida con NewPipe: $audioUrl&quot;)&#10;                    playAudioFromUrl(audioUrl)&#10;                } else {&#10;                    handleAudioExtractionError(videoId, audioUrl)&#10;                }&#10;            } catch (e: Exception) {&#10;                handleException(&quot;Error al extraer audio&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Extrae la URL de audio de un video de YouTube usando NewPipe.&#10;     * @param videoId ID del video de YouTube&#10;     * @return URL de audio o null si falla&#10;     */&#10;    private suspend fun extractAudioUrl(videoId: String): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            YouTubeAudioExtractor.getAudioUrl(videoId)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Delegar la reproducción al MusicService desde el PlayerViewModel.&#10;     */&#10;    private fun playAudioInService(audioUrl: String) {&#10;        val serviceIntent = Intent(getApplication&lt;Application&gt;(), MusicService::class.java).apply {&#10;            putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;        }&#10;        getApplication&lt;Application&gt;().startService(serviceIntent)&#10;    }&#10;&#10;    // Reproduce audio directamente usando ExoPlayer en lugar de delegar al servicio&#10;    private fun playAudioFromUrl(audioUrl: String) {&#10;        _audioUrl.postValue(audioUrl)&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Asegurar que el ExoPlayer esté inicializado&#10;                if (_exoPlayer == null) {&#10;                    Log.d(TAG, &quot; Inicializando ExoPlayer para reproducción directa...&quot;)&#10;                    initializePlayer()&#10;                    &#10;                    // Esperar a que la inicialización se complete&#10;                    var attempts = 0&#10;                    while (_exoPlayer == null &amp;&amp; attempts &lt; 50) {&#10;                        delay(50)&#10;                        attempts++&#10;                    }&#10;                    &#10;                    if (_exoPlayer == null) {&#10;                        Log.e(TAG, &quot;❌ Error: ExoPlayer no se inicializó correctamente&quot;)&#10;                        updateLoadingState(false, &quot;Error: No se pudo inicializar el reproductor&quot;)&#10;                        return@launch&#10;                    }&#10;                }&#10;                &#10;                _exoPlayer?.let { player -&gt;&#10;                    Log.d(TAG, &quot; Configurando ExoPlayer para URL: $audioUrl&quot;)&#10;                    player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                    player.prepare()&#10;                    player.play()&#10;                    Log.d(TAG, &quot;✅ Reproducción iniciada para URL&quot;)&#10;                    updateLoadingState(false) // Limpiar estado de carga&#10;                } ?: run {&#10;                    Log.e(TAG, &quot;❌ ExoPlayer es null después de inicialización&quot;)&#10;                    updateLoadingState(false, &quot;Error: Reproductor no disponible&quot;)&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error configurando ExoPlayer para URL&quot;, e)&#10;                handleException(&quot;Error configurando ExoPlayer&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja errores en la extracción de audio.&#10;     */&#10;    private fun handleAudioExtractionError(videoId: String, audioUrl: String?) {&#10;        if (audioUrl == null) {&#10;            println(&quot;PlayerViewModel: ❌ No se pudo obtener URL de audio&quot;)&#10;            updateLoadingState(false, &quot;No se pudo extraer la URL de audio para el video ID: $videoId&quot;)&#10;        } else {&#10;            println(&quot;PlayerViewModel: URL no válida según isValidAudioUrl&quot;)&#10;            updateLoadingState(false, &quot;La URL obtenida no es válida para reproducción de audio&quot;)&#10;        }&#10;    }&#10;    &#10;    &#10;    /**&#10;     * Carga y reproduce audio desde un TrackEntity de forma transparente.&#10;     * Obtiene el YouTube ID automáticamente si no existe.&#10;     * &#10;     * @param track Entidad del track con información de Spotify&#10;     * @return true si la carga fue exitosa, false si falló&#10;     */&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            println(&quot;PlayerViewModel: Cargando audio para track: ${track.name} - ${track.artists}&quot;)&#10;            updateLoadingState(true, null, &quot;${track.name} - ${track.artists}&quot;)&#10;            &#10;            // Obtener YouTube ID de forma transparente&#10;            val youtubeId = obtainYouTubeId(track)&#10;            &#10;            if (youtubeId != null) {&#10;                println(&quot;PlayerViewModel: ✅ YouTube ID obtenido: $youtubeId&quot;)&#10;                return@withContext playTrackAudio(youtubeId, track)&#10;            } else {&#10;                println(&quot;PlayerViewModel: ❌ No se encontró YouTube ID para: ${track.name}&quot;)&#10;                updateLoadingState(false, &quot;No se encontró el video para: ${track.name}&quot;)&#10;                return@withContext false&#10;            }&#10;        } catch (e: Exception) {&#10;            handleException(&quot;Error al cargar audio desde track&quot;, e)&#10;            return@withContext false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el YouTube ID para un track.&#10;     * @param track Track del cual obtener el ID&#10;     * @return YouTube ID o null si no se encuentra&#10;     */&#10;    private suspend fun obtainYouTubeId(track: TrackEntity): String? {&#10;        return withContext(Dispatchers.IO) {&#10;            youtubeSearchManager.getYouTubeIdTransparently(track)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reproduce audio de un track usando su YouTube ID.&#10;     * @param youtubeId ID de YouTube del track&#10;     * @param track Información del track para logs&#10;     * @return true si la reproducción fue exitosa&#10;     */&#10;    private suspend fun playTrackAudio(youtubeId: String, track: TrackEntity): Boolean {&#10;        // Obtener URL de audio con el ID&#10;        val audioUrl = withContext(Dispatchers.IO) {&#10;            YouTubeAudioExtractor.getAudioUrl(youtubeId)&#10;        }&#10;        &#10;        if (audioUrl != null &amp;&amp; isValidAudioUrl(audioUrl)) {&#10;            println(&quot;PlayerViewModel: ✅ URL de audio obtenida: $audioUrl&quot;)&#10;            return configureAndPlayAudio(audioUrl, track)&#10;        } else {&#10;            println(&quot;PlayerViewModel: ❌ No se pudo obtener URL de audio válida&quot;)&#10;            updateLoadingState(false, &quot;No se pudo obtener el audio para: ${track.name}&quot;)&#10;            return false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Configura ExoPlayer y inicia la reproducción.&#10;     * @param audioUrl URL del audio a reproducir&#10;     * @param track Información del track para logs&#10;     * @return true si la configuración fue exitosa&#10;     */&#10;    private suspend fun configureAndPlayAudio(audioUrl: String, track: TrackEntity): Boolean {&#10;        _audioUrl.postValue(audioUrl)&#10;        &#10;        return withContext(Dispatchers.Main) {&#10;            // Asegurar que ambos ExoPlayers estén inicializados&#10;            if (_exoPlayer == null || _preloadPlayer == null) {&#10;                Log.d(TAG, &quot; Inicializando ExoPlayers...&quot;)&#10;                initializePlayer()&#10;                &#10;                // Esperar a que la inicialización se complete&#10;                var attempts = 0&#10;                while ((_exoPlayer == null || _preloadPlayer == null) &amp;&amp; attempts &lt; 50) {&#10;                    kotlinx.coroutines.delay(50)&#10;                    attempts++&#10;                }&#10;                &#10;                if (_exoPlayer == null || _preloadPlayer == null) {&#10;                    Log.e(TAG, &quot;❌ Error: ExoPlayers no se inicializaron correctamente&quot;)&#10;                    _isLoading.postValue(false)&#10;                    _error.postValue(&quot;Error: No se pudo inicializar el reproductor&quot;)&#10;                    return@withContext false&#10;                }&#10;            }&#10;            &#10;            _exoPlayer?.let { player -&gt;&#10;                try {&#10;                    Log.d(TAG, &quot; Configurando ExoPlayer para: ${track.name}&quot;)&#10;                    player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                    player.prepare()&#10;                    player.play()&#10;                    Log.d(TAG, &quot;✅ Reproducción iniciada para: ${track.name}&quot;)&#10;                    _isLoading.postValue(false)&#10;                    return@withContext true&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error configurando ExoPlayer para ${track.name}&quot;, e)&#10;                    handleException(&quot;Error configurando ExoPlayer&quot;, e)&#10;                    return@withContext false&#10;                }&#10;            } ?: run {&#10;                Log.e(TAG, &quot;❌ ExoPlayer es null después de inicialización&quot;)&#10;                diagnoseExoPlayerState()&#10;                _isLoading.postValue(false)&#10;                _error.postValue(&quot;Error: Reproductor no disponible&quot;)&#10;                return@withContext false&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS DE CONTROL DE REPRODUCCIÓN ===&#10;    &#10;    /**&#10;     * Pausa la reproducción actual.&#10;     */&#10;    fun pausePlayer() {&#10;        mainHandler.post {&#10;            _exoPlayer?.pause()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reanuda la reproducción.&#10;     */&#10;    fun playPlayer() {&#10;        mainHandler.post {&#10;            _exoPlayer?.play()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reanuda la reproducción si está pausada.&#10;     */&#10;    fun resumeIfPaused() {&#10;        _exoPlayer?.let { player -&gt;&#10;            if (!player.isPlaying) {&#10;                player.play()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Busca a una posición específica en la canción.&#10;     * @param positionMs Posición en milisegundos&#10;     */&#10;    fun seekTo(positionMs: Long) {&#10;        mainHandler.post {&#10;            _exoPlayer?.seekTo(positionMs)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la posición actual de reproducción.&#10;     * @return Posición actual en milisegundos&#10;     */&#10;    fun getCurrentPosition(): Long {&#10;        return try {&#10;            _exoPlayer?.currentPosition ?: 0L&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error obteniendo posición: ${e.message}&quot;)&#10;            0L&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la duración total de la canción actual.&#10;     * @return Duración en milisegundos&#10;     */&#10;    fun getDuration(): Long {&#10;        return try {&#10;            _exoPlayer?.duration?.takeIf { it &gt; 0 } ?: 0L&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error obteniendo duración: ${e.message}&quot;)&#10;            0L&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el reproductor está reproduciendo actualmente.&#10;     * @return true si está reproduciendo, false en caso contrario&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return try {&#10;            _exoPlayer?.isPlaying ?: false&#10;        } catch (e: Exception) {&#10;            println(&quot;PlayerViewModel: Error verificando estado de reproducción: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;    &#10;    &#10;    /**&#10;     * Habilita o deshabilita la navegación automática al final de cada canción.&#10;     * @param enabled true para habilitar, false para deshabilitar&#10;     */&#10;    fun setAutoNavigationEnabled(enabled: Boolean) {&#10;        _autoNavigationEnabled.postValue(enabled)&#10;        println(&quot;PlayerViewModel: Auto-navegación ${if (enabled) &quot;habilitada&quot; else &quot;deshabilitada&quot;}&quot;)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el estado actual de la auto-navegación.&#10;     * @return true si está habilitada, false en caso contrario&#10;     */&#10;    fun isAutoNavigationEnabled(): Boolean {&#10;        return _autoNavigationEnabled.value ?: true&#10;    }&#10;&#10;    // === MÉTODOS DE NAVEGACIÓN DE PLAYLIST ===&#10;    &#10;    /**&#10;     * Establece la playlist actual y el índice del track.&#10;     * @param playlist Lista de tracks de la playlist&#10;     * @param startIndex Índice del track inicial (por defecto 0)&#10;     */&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        Log.d(TAG, &quot;Estableciendo playlist: ${playlist.size} tracks, startIndex=$startIndex&quot;)&#10;        _currentPlaylist.postValue(playlist)&#10;        _currentTrackIndex.postValue(startIndex.coerceIn(0, playlist.size - 1))&#10;        &#10;        if (playlist.isNotEmpty() &amp;&amp; startIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[startIndex])&#10;            Log.d(TAG, &quot;Track actual establecido: ${playlist[startIndex].name}&quot;)&#10;        }&#10;        &#10;        updateNavigationState()&#10;    }&#10;    &#10;    /**&#10;     * Navega al track siguiente en la playlist o cola.&#10;     * @return true si pudo navegar, false si no hay siguiente track&#10;     */&#10;    suspend fun navigateToNext(): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        // Si está en modo cola, reproducir siguiente de la cola&#10;        if (_isQueueMode.value == true) {&#10;            return playNextFromQueue()&#10;        }&#10;        &#10;        // Modo playlist normal&#10;        val playlist = _currentPlaylist.value ?: return false&#10;        val currentIndex = _currentTrackIndex.value ?: return false&#10;        &#10;        if (currentIndex &lt; playlist.size - 1) {&#10;            val nextIndex = currentIndex + 1&#10;            val nextTrack = playlist[nextIndex]&#10;            &#10;            _currentTrackIndex.postValue(nextIndex)&#10;            _currentTrack.postValue(nextTrack)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el siguiente track&#10;            val success = loadAudioFromTrack(nextTrack)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al siguiente track: ${nextTrack.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al siguiente track: ${nextTrack.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Navega al track anterior en la playlist.&#10;     * @return true si pudo navegar, false si no hay track anterior&#10;     */&#10;    suspend fun navigateToPrevious(): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        val playlist = _currentPlaylist.value ?: return false&#10;        val currentIndex = _currentTrackIndex.value ?: return false&#10;        &#10;        if (currentIndex &gt; 0) {&#10;            val previousIndex = currentIndex - 1&#10;            val previousTrack = playlist[previousIndex]&#10;            &#10;            _currentTrackIndex.postValue(previousIndex)&#10;            _currentTrack.postValue(previousTrack)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el track anterior&#10;            val success = loadAudioFromTrack(previousTrack)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al track anterior: ${previousTrack.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al track anterior: ${previousTrack.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Navega a un track específico en la playlist por índice.&#10;     * @param index Índice del track al que navegar&#10;     * @return true si pudo navegar, false si el índice es inválido&#10;     */&#10;    suspend fun navigateToTrack(index: Int): Boolean {&#10;        // Cancelar cualquier preloading activo ya que es navegación manual&#10;        cancelPreloading()&#10;        &#10;        val playlist = _currentPlaylist.value ?: return false&#10;        &#10;        if (index in playlist.indices) {&#10;            val track = playlist[index]&#10;            &#10;            _currentTrackIndex.postValue(index)&#10;            _currentTrack.postValue(track)&#10;            updateNavigationState()&#10;            &#10;            // Cargar y reproducir el track seleccionado&#10;            val success = loadAudioFromTrack(track)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Navegación exitosa al track ${index + 1}: ${track.name}&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;❌ Falló navegación al track ${index + 1}: ${track.name}&quot;)&#10;            }&#10;            return success&#10;        }&#10;        &#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Actualiza el estado de navegación (hasPrevious, hasNext).&#10;     */&#10;    private fun updateNavigationState() {&#10;        val isQueue = _isQueueMode.value == true&#10;        val queue = _playbackQueue.value&#10;        val queueSize = queue?.size ?: 0&#10;        val playlist = _currentPlaylist.value&#10;        val currentIndex = _currentTrackIndex.value&#10;&#10;        Log.d(TAG, &quot;Actualizando estado de navegación: isQueue=$isQueue, queueSize=$queueSize, playlist=${playlist?.size}, index=$currentIndex&quot;)&#10;&#10;        if (isQueue) {&#10;            // En modo cola: no hay &quot;previous&quot;, y &quot;next&quot; solo si hay tracks en cola&#10;            _hasPrevious.postValue(false)&#10;            _hasNext.postValue(queueSize &gt; 0)&#10;            Log.d(TAG, &quot;Modo cola: hasPrevious=false, hasNext=${queueSize &gt; 0}&quot;)&#10;        } else if (playlist != null &amp;&amp; currentIndex != null) {&#10;            val hasPrev = currentIndex &gt; 0&#10;            val hasNext = currentIndex &lt; playlist.size - 1&#10;            Log.d(TAG, &quot;Modo playlist: hasPrevious=$hasPrev, hasNext=$hasNext&quot;)&#10;            _hasPrevious.postValue(hasPrev)&#10;            _hasNext.postValue(hasNext)&#10;        } else {&#10;            Log.d(TAG, &quot;Deshabilitando navegación (sin contexto)&quot;)&#10;            _hasPrevious.postValue(false)&#10;            _hasNext.postValue(false)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene información del track actual de la playlist.&#10;     * @return Información del track actual o null si no hay playlist activa&#10;     */&#10;    fun getCurrentTrackInfo(): TrackEntity? {&#10;        return _currentTrack.value&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el número total de tracks en la playlist actual.&#10;     * @return Número de tracks o 0 si no hay playlist&#10;     */&#10;    fun getPlaylistSize(): Int {&#10;        return _currentPlaylist.value?.size ?: 0&#10;    }&#10;    &#10;    /**&#10;     * Obtiene la posición actual en la playlist (1-indexed para mostrar al usuario).&#10;     * @return Posición actual (ej: &quot;3 de 10&quot;) o null si no hay playlist&#10;     */&#10;    fun getCurrentPlaylistPosition(): String? {&#10;        val playlist = _currentPlaylist.value&#10;        val currentIndex = _currentTrackIndex.value&#10;        &#10;        return if (playlist != null &amp;&amp; currentIndex != null) {&#10;            &quot;${currentIndex + 1} de ${playlist.size}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;&#10;    // === MÉTODOS DE GESTIÓN DE COLA (QUEUE) ===&#10;    &#10;    /**&#10;     * Agrega un track a la cola de reproducción.&#10;     * @param track Track a agregar a la cola&#10;     */&#10;    fun addToQueue(track: TrackEntity) {&#10;        val currentQueue = _playbackQueue.value ?: mutableListOf()&#10;        currentQueue.add(track)&#10;        // Crear una nueva lista para asegurar que la UI se actualice&#10;        val newQueue = currentQueue.toMutableList()&#10;        _playbackQueue.postValue(newQueue)&#10;        updateNavigationState()&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Track agregado a la cola: ${track.name} (${newQueue.size} en cola)&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Elimina un track de la cola por índice.&#10;     * @param index Índice del track a eliminar&#10;     */&#10;    fun removeFromQueue(index: Int) {&#10;        val currentQueue = _playbackQueue.value ?: return&#10;        if (index in currentQueue.indices) {&#10;            val removedTrack = currentQueue.removeAt(index)&#10;            // Crear una nueva lista para asegurar que la UI se actualice&#10;            val newQueue = currentQueue.toMutableList()&#10;            _playbackQueue.postValue(newQueue)&#10;            updateQueueState()&#10;            Log.d(TAG, &quot;Track eliminado de la cola: ${removedTrack.name} (${newQueue.size} restantes)&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpia toda la cola de reproducción.&#10;     */&#10;    fun clearQueue() {&#10;        _playbackQueue.postValue(mutableListOf())&#10;        _isQueueMode.postValue(false)&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Cola de reproducción limpiada&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción en modo cola.&#10;     * Reproduce el primer track de la cola y establece el modo cola.&#10;     */&#10;    suspend fun startQueueMode(): Boolean {&#10;        val queue = _playbackQueue.value&#10;        if (queue.isNullOrEmpty()) {&#10;            Log.d(TAG, &quot;No hay tracks en la cola para iniciar&quot;)&#10;            return false&#10;        }&#10;        &#10;        _isQueueMode.postValue(true)&#10;        Log.d(TAG, &quot;Iniciando modo cola con ${queue.size} tracks&quot;)&#10;        &#10;        // Reproducir el primer track de la cola&#10;        return playNextFromQueue()&#10;    }&#10;    &#10;    /**&#10;     * Reproduce el siguiente track de la cola.&#10;     * @return true si pudo reproducir, false si no hay más tracks en cola&#10;     */&#10;    suspend fun playNextFromQueue(): Boolean {&#10;        val queue = _playbackQueue.value&#10;        if (queue.isNullOrEmpty()) {&#10;            Log.d(TAG, &quot;Cola vacía, desactivando modo cola&quot;)&#10;            _isQueueMode.postValue(false)&#10;            updateNavigationState()&#10;            return false&#10;        }&#10;        &#10;        // Tomar el primer track de la cola&#10;        val nextTrack = queue.removeAt(0)&#10;        _playbackQueue.postValue(queue)&#10;        updateNavigationState()&#10;        &#10;        Log.d(TAG, &quot; Reproduciendo desde cola: ${nextTrack.name} (${queue.size} tracks restantes en cola)&quot;)&#10;        &#10;        // Cargar y reproducir el track&#10;        val success = loadAudioFromTrack(nextTrack)&#10;        if (success) {&#10;            // Actualizar el track actual&#10;            _currentTrack.postValue(nextTrack)&#10;            Log.d(TAG, &quot;✅ Track de cola cargado exitosamente: ${nextTrack.name}&quot;)&#10;        } else {&#10;            Log.e(TAG, &quot;❌ Error cargando track de cola: ${nextTrack.name}&quot;)&#10;            diagnoseExoPlayerState()&#10;        }&#10;        &#10;        return success&#10;    }&#10;    &#10;    /**&#10;     * Reproduce un track específico de la cola por índice.&#10;     * @param index Índice del track en la cola a reproducir&#10;     */&#10;    suspend fun playFromQueue(index: Int) {&#10;        val queue = _playbackQueue.value ?: return&#10;        if (index !in queue.indices) {&#10;            Log.e(TAG, &quot;Índice de cola fuera de rango: $index&quot;)&#10;            return&#10;        }&#10;        &#10;        val track = queue[index]&#10;        Log.d(TAG, &quot;Reproduciendo track de cola en índice $index: ${track.name}&quot;)&#10;        &#10;        // Actualizar el estado de la cola&#10;        updateQueueState()&#10;        &#10;        // Cargar y reproducir el track&#10;        val success = loadAudioFromTrack(track)&#10;        if (success) {&#10;            _currentTrack.postValue(track)&#10;            _isQueueMode.postValue(true)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de la cola desde el primer track.&#10;     */&#10;    fun startQueue() {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            val success = startQueueMode()&#10;            if (success) {&#10;                Log.d(TAG, &quot;Cola iniciada correctamente&quot;)&#10;            } else {&#10;                Log.w(TAG, &quot;No se pudo iniciar la cola&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Mezcla aleatoriamente los tracks en la cola.&#10;     */&#10;    fun shuffleQueue() {&#10;        val currentQueue = _playbackQueue.value ?: return&#10;        if (currentQueue.size &lt;= 1) return&#10;        &#10;        currentQueue.shuffle()&#10;        // Crear una nueva lista para asegurar que la UI se actualice&#10;        val newQueue = currentQueue.toMutableList()&#10;        _playbackQueue.postValue(newQueue)&#10;        updateQueueState()&#10;        Log.d(TAG, &quot;Cola mezclada - ${newQueue.size} tracks&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Reproduce la cola desde un índice específico y activa el modo cola.&#10;     * Esto reorganiza la cola para que comience desde el índice seleccionado&#10;     * y continúe con el resto de tracks en orden.&#10;     * &#10;     * @param startIndex Índice desde donde comenzar la reproducción&#10;     */&#10;    suspend fun playQueueFromIndex(startIndex: Int) {&#10;        val queue = _playbackQueue.value ?: return&#10;        if (startIndex !in queue.indices) {&#10;            Log.e(TAG, &quot;Índice de cola fuera de rango: $startIndex&quot;)&#10;            return&#10;        }&#10;        &#10;        Log.d(TAG, &quot; Iniciando cola desde índice $startIndex de ${queue.size} tracks&quot;)&#10;        &#10;        // Asegurar que ExoPlayer esté inicializado&#10;        if (_exoPlayer == null) {&#10;            Log.d(TAG, &quot; Inicializando ExoPlayer para cola...&quot;)&#10;            initializePlayer()&#10;        }&#10;        &#10;        // Reorganizar la cola: tracks desde startIndex hasta el final&#10;        val reorderedQueue = queue.drop(startIndex).toMutableList()&#10;        &#10;        // Actualizar la cola con la nueva secuencia&#10;        _playbackQueue.postValue(reorderedQueue)&#10;        &#10;        // Activar modo cola&#10;        _isQueueMode.postValue(true)&#10;        updateQueueState()&#10;        &#10;        // Reproducir el primer track de la nueva secuencia&#10;        val success = playNextFromQueue()&#10;        if (success) {&#10;            Log.d(TAG, &quot;✅ Cola iniciada correctamente desde índice $startIndex&quot;)&#10;        } else {&#10;            Log.w(TAG, &quot;❌ No se pudo iniciar la cola desde índice $startIndex&quot;)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza el estado de la cola (StateFlow).&#10;     */&#10;    private fun updateQueueState() {&#10;        val queue = _playbackQueue.value ?: emptyList()&#10;        val isActive = _isQueueMode.value ?: false&#10;        &#10;        _queueState.value = QueueState(&#10;            queue = queue.toList(), // Crear copia inmutable&#10;            currentIndex = -1, // Por ahora no trackear índice específico&#10;            isActive = isActive&#10;        )&#10;    }&#10;&#10;    // === MÉTODOS DE ESPERA Y SINCRONIZACIÓN ===&#10;    &#10;    /**&#10;     * Espera a que termine la canción actual usando el listener de ExoPlayer.&#10;     * Útil para reproducción secuencial de playlists.&#10;     * &#10;     * @return true si terminó naturalmente, false si se canceló o falló&#10;     */&#10;    suspend fun waitForCurrentSongToFinish(): Boolean {&#10;        return try {&#10;            Log.d(TAG, &quot;⏳ Esperando a que termine la canción actual...&quot;)&#10;            &#10;            // Verificar que hay una canción reproduciéndose&#10;            val hasPlayback = checkCurrentPlayback()&#10;            if (!hasPlayback) {&#10;                Log.w(TAG, &quot;⚠️ No hay canción reproduciéndose&quot;)&#10;                return false&#10;            }&#10;            &#10;            // Configurar callback para esperar el final&#10;            playbackEndedCallback = CompletableDeferred()&#10;            &#10;            // Esperar el resultado con timeout&#10;            waitForPlaybackCompletion()&#10;            &#10;        } catch (e: Exception) {&#10;            handleWaitException(e)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay una canción reproduciéndose actualmente.&#10;     * @return true si hay reproducción activa&#10;     */&#10;    private suspend fun checkCurrentPlayback(): Boolean {&#10;        return withContext(Dispatchers.Main) {&#10;            _exoPlayer != null &amp;&amp; isPlaying()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Espera a que la reproducción termine con un timeout de seguridad.&#10;     * @return true si terminó correctamente&#10;     */&#10;    private suspend fun waitForPlaybackCompletion(): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            // Timeout de 8 minutos (480 segundos) por seguridad&#10;            val timeout = 480000L&#10;            val startTime = System.currentTimeMillis()&#10;            &#10;            // Esperar hasta que termine o se agote el tiempo&#10;            while (playbackEndedCallback != null &amp;&amp; !playbackEndedCallback!!.isCompleted) {&#10;                if (System.currentTimeMillis() - startTime &gt; timeout) {&#10;                    Log.w(TAG, &quot;⚠️ Timeout esperando fin de canción&quot;)&#10;                    playbackEndedCallback?.complete(false)&#10;                    break&#10;                }&#10;                kotlinx.coroutines.delay(1000)&#10;            }&#10;            &#10;            val result = playbackEndedCallback?.await() ?: false&#10;            playbackEndedCallback = null&#10;            &#10;            Log.d(TAG, &quot;${if (result) &quot;✅&quot; else &quot;⚠️&quot;} Canción ${if (result) &quot;terminada&quot; else &quot;cancelada&quot;}&quot;)&#10;            result&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja excepciones durante la espera de finalización.&#10;     * @param e Excepción ocurrida&#10;     * @return false indicando fallo&#10;     */&#10;    private fun handleWaitException(e: Exception): Boolean {&#10;        Log.e(TAG, &quot;❌ Error esperando fin de canción: ${e.message}&quot;, e)&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;        return false&#10;    }&#10;    &#10;    /**&#10;     * Cancela la espera del final de la canción.&#10;     * Útil cuando se quiere detener la reproducción secuencial.&#10;     */&#10;    fun cancelWaitForSong() {&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;    }&#10;    &#10;    /**&#10;     * Maneja la navegación automática al final de una canción.&#10;     * Si hay una playlist activa y hay más canciones, navega automáticamente.&#10;     */&#10;    private fun handleAutoNavigation() {&#10;        // Verificar si la auto-navegación está habilitada&#10;        if (!isAutoNavigationEnabled()) {&#10;            Log.d(TAG, &quot; Auto-navegación deshabilitada&quot;)&#10;            return&#10;        }&#10;        &#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            // Priorizar cola de reproducción si está activa&#10;            val isQueueActive = _isQueueMode.value ?: false&#10;            val queue = _playbackQueue.value&#10;            &#10;            if (isQueueActive &amp;&amp; !queue.isNullOrEmpty()) {&#10;                Log.d(TAG, &quot; Auto-navegando en modo cola...&quot;)&#10;                &#10;                // Pequeña pausa antes de la siguiente canción&#10;                kotlinx.coroutines.delay(1000)&#10;                &#10;                // Reproducir siguiente canción de la cola&#10;                val success = playNextFromQueue()&#10;                if (!success) {&#10;                    Log.d(TAG, &quot; Cola terminada, saliendo de modo cola&quot;)&#10;                    _isQueueMode.postValue(false)&#10;                    updateQueueState()&#10;                }&#10;                return@launch&#10;            }&#10;            &#10;            // Si no hay cola activa, usar navegación de playlist&#10;            val playlist = _currentPlaylist.value&#10;            val currentIndex = _currentTrackIndex.value&#10;            &#10;            // Verificar si hay playlist activa y siguiente canción disponible&#10;            if (playlist != null &amp;&amp; currentIndex != null &amp;&amp; &#10;                currentIndex &lt; playlist.size - 1) {&#10;                &#10;                Log.d(TAG, &quot; Auto-navegando a la siguiente canción de playlist...&quot;)&#10;                &#10;                // Pequeña pausa antes de la siguiente canción&#10;                kotlinx.coroutines.delay(1000)&#10;                &#10;                // Navegar automáticamente al siguiente track&#10;                try {&#10;                    navigateToNext()&#10;                } catch (e: Exception) {&#10;                    Log.e(TAG, &quot;❌ Error durante auto-navegación&quot;, e)&#10;                    updateLoadingState(false, &quot;Error navegando al siguiente track&quot;)&#10;                }&#10;            } else {&#10;                Log.d(TAG, &quot; Fin de playlist o no hay playlist activa&quot;)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS UTILITARIOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Actualiza el estado de carga y error de forma consistente.&#10;     * @param loading Estado de carga&#10;     * @param errorMessage Mensaje de error (null si no hay error)&#10;     * @param title Título a mostrar (opcional)&#10;     */&#10;    private fun updateLoadingState(loading: Boolean, errorMessage: String? = null, title: String? = null) {&#10;        _isLoading.postValue(loading)&#10;        _error.postValue(errorMessage)&#10;        title?.let { _currentTitle.postValue(it) }&#10;    }&#10;    &#10;    /**&#10;     * Maneja excepciones de forma consistente.&#10;     * @param message Mensaje descriptivo del error&#10;     * @param exception Excepción ocurrida&#10;     */&#10;    private fun handleException(message: String, exception: Exception) {&#10;        Log.e(TAG, &quot;❌ $message: ${exception.message}&quot;, exception)&#10;        updateLoadingState(false, &quot;$message: ${exception.message}&quot;)&#10;    }&#10;    &#10;    // === LIMPIEZA DE RECURSOS ===&#10;    &#10;    /**&#10;     * Limpia los recursos cuando el ViewModel es destruido.&#10;     * Cancela callbacks pendientes y libera el ExoPlayer.&#10;     */&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        &#10;        Log.d(TAG, &quot; Limpiando recursos del PlayerViewModel&quot;)&#10;        &#10;        // Cancelar cualquier callback pendiente&#10;        playbackEndedCallback?.complete(false)&#10;        playbackEndedCallback = null&#10;        &#10;        // Cancelar preloading activo&#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;        &#10;        // Liberar ExoPlayer en el hilo principal&#10;        mainHandler.post {&#10;            try {&#10;                // Remover listeners antes de liberar&#10;                _currentPlayerListener?.let { listener -&gt;&#10;                    _exoPlayer?.removeListener(listener)&#10;                }&#10;                &#10;                // Detener y liberar ambos players completamente&#10;                _exoPlayer?.let { player -&gt;&#10;                    player.stop()&#10;                    player.clearMediaItems()&#10;                    player.release()&#10;                }&#10;                _exoPlayer = null&#10;                &#10;                _preloadPlayer?.let { player -&gt;&#10;                    player.stop()&#10;                    player.clearMediaItems()&#10;                    player.release()&#10;                }&#10;                _preloadPlayer = null&#10;                &#10;                // Limpiar referencia del listener&#10;                _currentPlayerListener = null&#10;                &#10;                Log.d(TAG, &quot;✅ Recursos liberados correctamente&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error liberando recursos&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    // === MÉTODOS DE PRELOADING PARA TRANSICIONES SIN DELAY ===&#10;    &#10;    /**&#10;     * Maneja la transición sin delay entre canciones usando el track preloaded.&#10;     * Si hay un track preloaded listo, intercambia los ExoPlayers instantáneamente.&#10;     */&#10;    private fun handleSeamlessTransition() {&#10;        if (!isAutoNavigationEnabled()) {&#10;            Log.d(TAG, &quot; Auto-navegación deshabilitada&quot;)&#10;            return&#10;        }&#10;        &#10;        val nextTrack = getNextTrackToPlay()&#10;        if (nextTrack == null) {&#10;            Log.d(TAG, &quot; No hay siguiente track, finalizando reproducción&quot;)&#10;            return&#10;        }&#10;        &#10;        // Si tenemos el track preloaded y es el correcto, hacer intercambio instantáneo&#10;        Log.d(TAG, &quot; Verificando preloading:&quot;)&#10;        Log.d(TAG, &quot;  - Track esperado: ${nextTrack.name}&quot;)&#10;        Log.d(TAG, &quot;  - Track preloaded: ${_preloadedTrack?.name}&quot;)&#10;        Log.d(TAG, &quot;  - PreloadPlayer existe: ${_preloadPlayer != null}&quot;)&#10;        Log.d(TAG, &quot;  - PreloadPlayer estado: ${_preloadPlayer?.playbackState}&quot;)&#10;        Log.d(TAG, &quot;  - Estado esperado (READY): ${Player.STATE_READY}&quot;)&#10;        &#10;        // Intentar swap instantáneo hasta 500ms si el preloading está casi listo&#10;        if (_preloadedTrack == nextTrack &amp;&amp; _preloadPlayer != null) {&#10;            val maxAttempts = 5&#10;            var attempt = 0&#10;            while (_preloadPlayer?.playbackState != Player.STATE_READY &amp;&amp; attempt &lt; maxAttempts) {&#10;                Log.d(TAG, &quot;⌛ Esperando a que PreloadPlayer esté listo (intento ${attempt + 1}/$maxAttempts)...&quot;)&#10;                Thread.sleep(100)&#10;                attempt++&#10;            }&#10;            if (_preloadPlayer?.playbackState == Player.STATE_READY) {&#10;                Log.d(TAG, &quot; ✅ Todas las condiciones cumplidas - Track preloaded detectado: ${nextTrack.name}, iniciando intercambio&quot;)&#10;                performSeamlessSwap(nextTrack)&#10;                return&#10;            }&#10;        }&#10;        // Fallback a navegación normal con delay&#10;        val reason = when {&#10;            _preloadedTrack != nextTrack -&gt; &quot;Track preloaded incorrecto (esperado: ${nextTrack.name}, actual: ${_preloadedTrack?.name})&quot;&#10;            _preloadPlayer == null -&gt; &quot;PreloadPlayer es null&quot;&#10;            _preloadPlayer?.playbackState != Player.STATE_READY -&gt; &quot;PreloadPlayer no está listo (estado: ${_preloadPlayer?.playbackState})&quot;&#10;            else -&gt; &quot;Razón desconocida&quot;&#10;        }&#10;        Log.w(TAG, &quot;⚠️ ❌ No hay preloading válido: $reason. Usando navegación normal&quot;)&#10;        handleAutoNavigation()&#10;    }&#10;    &#10;    /**&#10;     * Realiza el intercambio instantáneo de ExoPlayers para transición sin delay.&#10;     * @param nextTrack El track que debe reproducirse next&#10;     */&#10;    private fun performSeamlessSwap(nextTrack: TrackEntity) {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                Log.d(TAG, &quot; Iniciando intercambio sin delay para: ${nextTrack.name}&quot;)&#10;                &#10;                // Verificar que el preload player esté listo&#10;                if (_preloadPlayer?.playbackState != Player.STATE_READY) {&#10;                    Log.w(TAG, &quot;⚠️ PreloadPlayer no está listo, usando navegación normal&quot;)&#10;                    handleAutoNavigation()&#10;                    return@launch&#10;                }&#10;                &#10;                // Detener y limpiar el player actual ANTES del intercambio&#10;                _exoPlayer?.let { currentPlayer -&gt;&#10;                    currentPlayer.pause()&#10;                    currentPlayer.stop()&#10;                    // Remover listener del player actual&#10;                    _currentPlayerListener?.let { listener -&gt;&#10;                        currentPlayer.removeListener(listener)&#10;                    }&#10;                }&#10;                &#10;                // Guardar referencia al player anterior para limpieza&#10;                val oldPlayer = _exoPlayer&#10;                &#10;                // Intercambiar los ExoPlayers (el preload ya está preparado y listo)&#10;                _exoPlayer = _preloadPlayer&#10;                _preloadPlayer = oldPlayer&#10;                &#10;                // Configurar el nuevo player principal para reproducción INMEDIATA&#10;                _exoPlayer?.let { newMainPlayer -&gt;&#10;                    // Agregar listener al nuevo player principal&#10;                    _currentPlayerListener?.let { listener -&gt;&#10;                        newMainPlayer.addListener(listener)&#10;                    }&#10;                    &#10;                    // EL PLAYER YA ESTÁ PREPARADO - solo activar reproducción&#10;                    newMainPlayer.playWhenReady = true&#10;                    newMainPlayer.play()&#10;                    &#10;                    Log.d(TAG, &quot;⚡ Reproducción instantánea iniciada para: ${nextTrack.name}&quot;)&#10;                }&#10;                &#10;                // Limpiar completamente el player anterior para liberar recursos&#10;                _preloadPlayer?.let { oldPreloadPlayer -&gt;&#10;                    oldPreloadPlayer.stop()&#10;                    oldPreloadPlayer.clearMediaItems()&#10;                    oldPreloadPlayer.playWhenReady = false&#10;                    // Forzar liberación de buffers&#10;                    oldPreloadPlayer.release()&#10;                    &#10;                    // Recrear el preload player inmediatamente con recursos limpios&#10;                    _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                        .setSeekBackIncrementMs(10000)&#10;                        .setSeekForwardIncrementMs(10000)&#10;                        .build().apply {&#10;                            playWhenReady = false&#10;                            setHandleAudioBecomingNoisy(false)&#10;                            &#10;                            // Aplicar optimizaciones de buffer&#10;                            optimizeBufferSettings(this)&#10;                            &#10;                            addListener(object : Player.Listener {&#10;                                override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                    when (playbackState) {&#10;                                        Player.STATE_READY -&gt; {&#10;                                            Log.d(TAG, &quot; Nuevo PreloadPlayer LISTO&quot;)&#10;                                        }&#10;                                        Player.STATE_BUFFERING -&gt; {&#10;                                            Log.d(TAG, &quot; Nuevo PreloadPlayer bufferizando...&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            })&#10;                        }&#10;                    Log.d(TAG, &quot;♻️ PreloadPlayer recreado después de intercambio&quot;)&#10;                }&#10;                &#10;                // Actualizar estados de la UI&#10;                updateTrackStates(nextTrack)&#10;                &#10;                // Resetear estado de preloading&#10;                _preloadedTrack = null&#10;                _isPreloading = false&#10;                &#10;                Log.d(TAG, &quot;✅ Intercambio sin delay completado para: ${nextTrack.name}&quot;)&#10;                &#10;                // Monitorear memoria después del intercambio&#10;                monitorMemoryUsage()&#10;                &#10;                // Esperar un momento antes de iniciar nuevo preloading para evitar sobrecarga&#10;                kotlinx.coroutines.delay(2000)&#10;                &#10;                // Comenzar a preloading el siguiente track&#10;                if (!_isPreloading) {&#10;                    startPreloadingNextTrack()&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en intercambio sin delay&quot;, e)&#10;                // Limpiar estado y usar navegación normal como fallback&#10;                _isPreloading = false&#10;                _preloadedTrack = null&#10;                handleAutoNavigation()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza los estados del track actual después de un intercambio.&#10;     * @param track El nuevo track actual&#10;     */&#10;    private fun updateTrackStates(track: TrackEntity) {&#10;        // Actualizar estados según el modo de reproducción&#10;        if (_isQueueMode.value == true) {&#10;            // Remover el track de la cola ya que se está reproduciendo&#10;            val queue = _playbackQueue.value?.toMutableList() ?: mutableListOf()&#10;            if (queue.isNotEmpty()) {&#10;                queue.removeAt(0)&#10;                _playbackQueue.postValue(queue)&#10;                updateQueueState()&#10;            }&#10;        } else {&#10;            // Modo playlist - actualizar índice&#10;            val playlist = _currentPlaylist.value&#10;            if (playlist != null) {&#10;                val index = playlist.indexOf(track)&#10;                if (index != -1) {&#10;                    _currentTrackIndex.postValue(index)&#10;                    updateNavigationState()&#10;                }&#10;            }&#10;        }&#10;        &#10;        _currentTrack.postValue(track)&#10;        _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el siguiente track que debería reproducirse.&#10;     * @return El siguiente TrackEntity o null si no hay siguiente&#10;     */&#10;    private fun getNextTrackToPlay(): TrackEntity? {&#10;        // Priorizar cola de reproducción&#10;        if (_isQueueMode.value == true) {&#10;            val queue = _playbackQueue.value&#10;            return if (!queue.isNullOrEmpty()) queue[0] else null&#10;        }&#10;        &#10;        // Modo playlist&#10;        val playlist = _currentPlaylist.value ?: return null&#10;        val currentIndex = _currentTrackIndex.value ?: return null&#10;        &#10;        return if (currentIndex &lt; playlist.size - 1) {&#10;            playlist[currentIndex + 1]&#10;        } else null&#10;    }&#10;    &#10;    /**&#10;     * Inicia el preloading de la siguiente canción en background.&#10;     * Se llama automáticamente cuando el track actual está listo.&#10;     */&#10;    private fun startPreloadingNextTrack() {&#10;        if (_isPreloading) {&#10;            Log.d(TAG, &quot; Ya hay preloading en progreso&quot;)&#10;            return&#10;        }&#10;        &#10;        val nextTrack = getNextTrackToPlay()&#10;        if (nextTrack == null) {&#10;            Log.d(TAG, &quot; No hay siguiente track para preload&quot;)&#10;            return&#10;        }&#10;        &#10;        if (_preloadPlayer == null) {&#10;            Log.e(TAG, &quot;❌ PreloadPlayer no inicializado&quot;)&#10;            return&#10;        }&#10;        &#10;        _isPreloading = true&#10;        _preloadedTrack = nextTrack&#10;        &#10;        Log.d(TAG, &quot; Iniciando preloading de: ${nextTrack.name}&quot;)&#10;        &#10;        CoroutineScope(Dispatchers.IO).launch {&#10;            try {&#10;                // Obtener YouTube ID y URL de audio&#10;                val youtubeId = youtubeSearchManager.getYouTubeIdTransparently(nextTrack)&#10;                if (youtubeId == null) {&#10;                    Log.e(TAG, &quot;❌ No se encontró YouTube ID para preload: ${nextTrack.name}&quot;)&#10;                    resetPreloadingState()&#10;                    return@launch&#10;                }&#10;                &#10;                val audioUrl = YouTubeAudioExtractor.getAudioUrl(youtubeId)&#10;                if (audioUrl == null || !isValidAudioUrl(audioUrl)) {&#10;                    Log.e(TAG, &quot;❌ No se obtuvo URL válida para preload: ${nextTrack.name}&quot;)&#10;                    resetPreloadingState()&#10;                    return@launch&#10;                }&#10;                &#10;                // Preparar el track en el preload player&#10;                withContext(Dispatchers.Main) {&#10;                    _preloadPlayer?.let { player -&gt;&#10;                        try {&#10;                            // Limpiar estado anterior completamente&#10;                            player.stop()&#10;                            player.clearMediaItems()&#10;                            &#10;                            // Asegurar que NO se reproduzca automáticamente&#10;                            player.playWhenReady = false&#10;                            player.setMediaItem(MediaItem.fromUri(audioUrl))&#10;                            player.prepare()&#10;                            &#10;                            // Verificar que efectivamente no esté reproduciéndose&#10;                            if (player.isPlaying) {&#10;                                player.pause()&#10;                            }&#10;                            &#10;                            Log.d(TAG, &quot; Preparando preload para: ${nextTrack.name}&quot;)&#10;                            &#10;                            // Esperar a que el player esté realmente listo con timeout más corto&#10;                            var attempts = 0&#10;                            while (player.playbackState != Player.STATE_READY &amp;&amp; attempts &lt; 50) { // 5 segundos máximo&#10;                                kotlinx.coroutines.delay(100)&#10;                                attempts++&#10;                                &#10;                                // Verificar si el preloading fue cancelado&#10;                                if (!_isPreloading) {&#10;                                    Log.d(TAG, &quot; Preloading cancelado durante espera&quot;)&#10;                                    return@withContext&#10;                                }&#10;                            }&#10;                            &#10;                            if (player.playbackState == Player.STATE_READY &amp;&amp; _isPreloading) {&#10;                                Log.d(TAG, &quot;✅ Preloading completado para: ${nextTrack.name}&quot;)&#10;                            } else {&#10;                                Log.w(TAG, &quot;⚠️ Preloading timeout o cancelado para: ${nextTrack.name}&quot;)&#10;                                resetPreloadingState()&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            Log.e(TAG, &quot;❌ Error en preparación de preload para ${nextTrack.name}&quot;, e)&#10;                            resetPreloadingState()&#10;                        }&#10;                    }&#10;                }&#10;                &#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en preloading para ${nextTrack.name}&quot;, e)&#10;                resetPreloadingState()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Resetea el estado de preloading de forma segura.&#10;     */&#10;    private fun resetPreloadingState() {&#10;        _isPreloading = false&#10;        _preloadedTrack = null&#10;    }&#10;    &#10;    /**&#10;     * Cancela el preloading activo si existe.&#10;     * Útil cuando se cambia manualmente de canción o se reinicia el player.&#10;     */&#10;    private fun cancelPreloading() {&#10;        if (_isPreloading) {&#10;            Log.d(TAG, &quot; Cancelando preloading activo&quot;)&#10;            resetPreloadingState()&#10;            &#10;            // Limpiar el preload player en el hilo principal de forma más agresiva&#10;            mainHandler.post {&#10;                _preloadPlayer?.let { player -&gt;&#10;                    try {&#10;                        player.stop()&#10;                        player.clearMediaItems()&#10;                        player.playWhenReady = false&#10;                        &#10;                        // Liberar completamente el preload player para evitar leaks&#10;                        player.release()&#10;                        &#10;                        // Recrear inmediatamente&#10;                        _preloadPlayer = ExoPlayer.Builder(getApplication())&#10;                            .setSeekBackIncrementMs(10000)&#10;                            .setSeekForwardIncrementMs(10000)&#10;                            .build().apply {&#10;                                playWhenReady = false&#10;                                setHandleAudioBecomingNoisy(false)&#10;                                &#10;                                // Aplicar optimizaciones de buffer&#10;                                optimizeBufferSettings(this)&#10;                                &#10;                                addListener(object : Player.Listener {&#10;                                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                                        when (playbackState) {&#10;                                            Player.STATE_READY -&gt; {&#10;                                                Log.d(TAG, &quot; PreloadPlayer recreado y listo&quot;)&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                })&#10;                            }&#10;                        Log.d(TAG, &quot;♻️ PreloadPlayer recreado después de cancelación&quot;)&#10;                    } catch (e: Exception) {&#10;                        Log.e(TAG, &quot;❌ Error cancelando preloading&quot;, e)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Estado de la cola de reproducción.&#10;     * @param queue Lista de tracks en la cola&#10;     * @param currentIndex Índice del track actual en la cola (-1 si no hay track actual)&#10;     * @param isActive Si la cola está activa&#10;     */&#10;    data class QueueState(&#10;        val queue: List&lt;TrackEntity&gt; = emptyList(),&#10;        val currentIndex: Int = -1,&#10;        val isActive: Boolean = false&#10;    )&#10;&#10;    /**&#10;     * Diagnostica el estado de ambos ExoPlayers para debugging.&#10;     */&#10;    private fun diagnoseExoPlayerState() {&#10;        Log.d(TAG, &quot; Diagnóstico ExoPlayer:&quot;)&#10;        Log.d(TAG, &quot;   - ExoPlayer principal: ${if (_exoPlayer != null) &quot;✅ Existe&quot; else &quot;❌ Es null&quot;}&quot;)&#10;        _exoPlayer?.let { player -&gt;&#10;            Log.d(TAG, &quot;     - Estado actual: ${player.playbackState}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está reproduciéndose?: ${player.isPlaying}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está preparado?: ${player.playbackState == Player.STATE_READY}&quot;)&#10;            Log.d(TAG, &quot;     - Duración: ${player.duration}&quot;)&#10;            Log.d(TAG, &quot;     - Posición actual: ${player.currentPosition}&quot;)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;   - ExoPlayer preload: ${if (_preloadPlayer != null) &quot;✅ Existe&quot; else &quot;❌ Es null&quot;}&quot;)&#10;        _preloadPlayer?.let { preloadPlayer -&gt;&#10;            Log.d(TAG, &quot;     - Estado preload: ${preloadPlayer.playbackState}&quot;)&#10;            Log.d(TAG, &quot;     - ¿Está preparado?: ${preloadPlayer.playbackState == Player.STATE_READY}&quot;)&#10;        }&#10;        &#10;        Log.d(TAG, &quot;   - Track preloaded: ${_preloadedTrack?.name ?: &quot;Ninguno&quot;}&quot;)&#10;        Log.d(TAG, &quot;   - Preloading activo: $_isPreloading&quot;)&#10;    }&#10;    &#10;    // === CONFIGURACIÓN DE BUFFER Y OPTIMIZACIÓN ===&#10;    &#10;    /**&#10;     * Optimiza la configuración de buffer para reducir uso de memoria.&#10;     */&#10;    private fun optimizeBufferSettings(player: ExoPlayer) {&#10;        try {&#10;            // Configurar parámetros de buffer más conservadores para evitar exhaustión&#10;            // Estos valores reducen el uso de memoria pero mantienen buena reproducción&#10;            player.setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true // Handle audio becoming noisy&#10;            )&#10;            &#10;            Log.d(TAG, &quot; Configuración de buffer optimizada&quot;)&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ No se pudo optimizar configuración de buffer&quot;, e)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Fuerza la liberación de recursos de memoria de ExoPlayer.&#10;     */&#10;    private fun forceMemoryCleanup(player: ExoPlayer?) {&#10;        player?.let {&#10;            try {&#10;                // Detener reproducción y limpiar media items&#10;                it.stop()&#10;                it.clearMediaItems()&#10;                &#10;                // Forzar garbage collection (solo en casos críticos)&#10;                System.gc()&#10;                &#10;                Log.d(TAG, &quot;♻️ Limpieza forzada de memoria completada&quot;)&#10;            } catch (e: Exception) {&#10;                Log.w(TAG, &quot;⚠️ Error durante limpieza forzada&quot;, e)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Monitorea el uso de memoria y toma acciones si es necesario.&#10;     */&#10;    private fun monitorMemoryUsage() {&#10;        try {&#10;            val runtime = Runtime.getRuntime()&#10;            val usedMemory = runtime.totalMemory() - runtime.freeMemory()&#10;            val maxMemory = runtime.maxMemory()&#10;            val memoryPercentage = (usedMemory * 100) / maxMemory&#10;            &#10;            Log.d(TAG, &quot; Uso de memoria: ${memoryPercentage}% (${usedMemory / 1024 / 1024}MB / ${maxMemory / 1024 / 1024}MB)&quot;)&#10;            &#10;            // Si el uso de memoria es alto (&gt;80%), realizar limpieza&#10;            if (memoryPercentage &gt; 80) {&#10;                Log.w(TAG, &quot;⚠️ Uso de memoria alto, realizando limpieza preventiva&quot;)&#10;                &#10;                // Cancelar preloading para liberar memoria&#10;                if (_isPreloading) {&#10;                    cancelPreloading()&#10;                }&#10;                &#10;                // Forzar garbage collection&#10;                System.gc()&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.w(TAG, &quot;⚠️ Error monitoreando memoria&quot;, e)&#10;        }&#10;    }&#10;    /**&#10;     * Obtiene la instancia del ExoPlayer para uso externo.&#10;     * @return ExoPlayer actual o null si no está inicializado&#10;     */&#10;    fun getPlayer(): ExoPlayer? {&#10;        return _exoPlayer&#10;    }&#10;    &#10;    // === MÉTODOS DE MODO DE REPETICIÓN ===&#10;    &#10;    /**&#10;     * Maneja la transición basada en el modo de repetición configurado.&#10;     * Se llama cuando una canción termina para determinar qué hacer siguiente.&#10;     */&#10;    private fun handleRepeatModeTransition() {&#10;        val context = getApplication&lt;Application&gt;()&#10;        val repeatMode = Config.getRepeatMode(context)&#10;        &#10;        Log.d(TAG, &quot; Manejando transición con modo de repetición: $repeatMode&quot;)&#10;        &#10;        when (repeatMode) {&#10;            Config.REPEAT_MODE_OFF -&gt; {&#10;                // Sin repetición - comportamiento normal (navegar a siguiente)&#10;                Log.d(TAG, &quot;○ Modo OFF - Navegando a siguiente canción&quot;)&#10;                handleSeamlessTransition()&#10;            }&#10;            &#10;            Config.REPEAT_MODE_ONE -&gt; {&#10;                // Repetir una vez - reproducir la misma canción nuevamente&#10;                Log.d(TAG, &quot;① Modo ONE - Repitiendo canción actual&quot;)&#10;                repeatCurrentTrack()&#10;            }&#10;            &#10;            Config.REPEAT_MODE_ALL -&gt; {&#10;                // Repetir indefinidamente - al final de playlist, volver al inicio&#10;                Log.d(TAG, &quot;∞ Modo ALL - Repetición continua&quot;)&#10;                handleInfiniteRepeat()&#10;            }&#10;            &#10;            else -&gt; {&#10;                // Modo desconocido - usar comportamiento por defecto&#10;                Log.w(TAG, &quot;⚠️ Modo de repetición desconocido: $repeatMode - usando comportamiento normal&quot;)&#10;                handleSeamlessTransition()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Repite la canción actual (modo &quot;repeat one&quot;).&#10;     */&#10;    private fun repeatCurrentTrack() {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                val currentTrack = _currentTrack.value&#10;                &#10;                if (currentTrack != null) {&#10;                    Log.d(TAG, &quot; Repitiendo: ${currentTrack.name}&quot;)&#10;                    &#10;                    // Pequeña pausa antes de reiniciar&#10;                    kotlinx.coroutines.delay(500)&#10;                    &#10;                    // Recargar y reproducir la misma canción&#10;                    val success = loadAudioFromTrack(currentTrack)&#10;                    if (success) {&#10;                        Log.d(TAG, &quot;✅ Repetición exitosa de: ${currentTrack.name}&quot;)&#10;                    } else {&#10;                        Log.e(TAG, &quot;❌ Error repitiendo: ${currentTrack.name}&quot;)&#10;                        // Si falla la repetición, usar navegación normal como fallback&#10;                        handleSeamlessTransition()&#10;                    }&#10;                } else {&#10;                    Log.w(TAG, &quot;⚠️ No hay track actual para repetir&quot;)&#10;                    handleSeamlessTransition()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en repetición de track actual&quot;, e)&#10;                handleSeamlessTransition()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Maneja la repetición infinita de playlist (modo &quot;repeat all&quot;).&#10;     * Al final de la playlist, vuelve al inicio automáticamente.&#10;     */&#10;    private fun handleInfiniteRepeat() {&#10;        CoroutineScope(Dispatchers.Main).launch {&#10;            try {&#10;                // Verificar si hay siguiente canción en la playlist/cola&#10;                val nextTrack = getNextTrackToPlay()&#10;                &#10;                if (nextTrack != null) {&#10;                    // Hay siguiente canción - navegación normal&#10;                    Log.d(TAG, &quot; Hay siguiente canción, navegando normalmente&quot;)&#10;                    handleSeamlessTransition()&#10;                } else {&#10;                    // Final de playlist - volver al inicio&#10;                    Log.d(TAG, &quot; Final de playlist, volviendo al inicio&quot;)&#10;                    restartPlaylistFromBeginning()&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;❌ Error en repetición infinita&quot;, e)&#10;                handleSeamlessTransition()&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Reinicia la playlist desde el primer track (para repetición infinita).&#10;     */&#10;    private suspend fun restartPlaylistFromBeginning() {&#10;        // Priorizar cola si está activa&#10;        if (_isQueueMode.value == true) {&#10;            Log.d(TAG, &quot; Modo cola activo - fin de cola&quot;)&#10;            _isQueueMode.postValue(false)&#10;            updateQueueState()&#10;            return&#10;        }&#10;        &#10;        // Reiniciar playlist desde el primer track&#10;        val playlist = _currentPlaylist.value&#10;        if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;            Log.d(TAG, &quot; Reiniciando playlist desde el inicio&quot;)&#10;            &#10;            val firstTrack = playlist[0]&#10;            _currentTrackIndex.postValue(0)&#10;            _currentTrack.postValue(firstTrack)&#10;            updateNavigationState()&#10;            &#10;            // Pequeña pausa antes de reiniciar&#10;            kotlinx.coroutines.delay(1000)&#10;            &#10;            // Cargar y reproducir el primer track&#10;            val success = loadAudioFromTrack(firstTrack)&#10;            if (success) {&#10;                Log.d(TAG, &quot;✅ Playlist reiniciada desde: ${firstTrack.name}&quot;)&#10;            } else {&#10;                Log.e(TAG, &quot;❌ Error reiniciando playlist&quot;)&#10;            }&#10;        } else {&#10;            Log.w(TAG, &quot;⚠️ No hay playlist para reiniciar&quot;)&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>