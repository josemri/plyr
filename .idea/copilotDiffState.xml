<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/database/DownloadedTrackDao.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/database/DownloadedTrackDao.kt" />
              <option name="updatedContent" value="package com.plyr.database&#10;&#10;import androidx.room.*&#10;import kotlinx.coroutines.flow.Flow&#10;&#10;/**&#10; * DownloadedTrackDao - Data Access Object para operaciones sobre tracks descargados&#10; */&#10;@Dao&#10;interface DownloadedTrackDao {&#10;    &#10;    /**&#10;     * Obtiene todos los tracks descargados como Flow observable.&#10;     */&#10;    @Query(&quot;SELECT * FROM downloaded_tracks ORDER BY downloadTime DESC&quot;)&#10;    fun getAllDownloadedTracks(): Flow&lt;List&lt;DownloadedTrackEntity&gt;&gt;&#10;    &#10;    /**&#10;     * Obtiene todos los tracks descargados de forma síncrona.&#10;     */&#10;    @Query(&quot;SELECT * FROM downloaded_tracks ORDER BY downloadTime DESC&quot;)&#10;    suspend fun getAllDownloadedTracksSync(): List&lt;DownloadedTrackEntity&gt;&#10;    &#10;    /**&#10;     * Busca un track descargado por su ID de Spotify.&#10;     */&#10;    @Query(&quot;SELECT * FROM downloaded_tracks WHERE spotifyTrackId = :spotifyTrackId&quot;)&#10;    suspend fun getDownloadedTrackBySpotifyId(spotifyTrackId: String): DownloadedTrackEntity?&#10;    &#10;    /**&#10;     * Verifica si un track ya está descargado.&#10;     */&#10;    @Query(&quot;SELECT COUNT(*) FROM downloaded_tracks WHERE spotifyTrackId = :spotifyTrackId&quot;)&#10;    suspend fun isTrackDownloaded(spotifyTrackId: String): Int&#10;    &#10;    /**&#10;     * Inserta o actualiza un track descargado.&#10;     */&#10;    @Insert(onConflict = OnConflictStrategy.REPLACE)&#10;    suspend fun insertDownloadedTrack(track: DownloadedTrackEntity)&#10;    &#10;    /**&#10;     * Elimina un track descargado.&#10;     */&#10;    @Delete&#10;    suspend fun deleteDownloadedTrack(track: DownloadedTrackEntity)&#10;    &#10;    /**&#10;     * Elimina un track descargado por su ID.&#10;     */&#10;    @Query(&quot;DELETE FROM downloaded_tracks WHERE id = :trackId&quot;)&#10;    suspend fun deleteDownloadedTrackById(trackId: String)&#10;    &#10;    /**&#10;     * Elimina todos los tracks descargados.&#10;     */&#10;    @Query(&quot;DELETE FROM downloaded_tracks&quot;)&#10;    suspend fun deleteAllDownloadedTracks()&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/database/DownloadedTrackEntity.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/database/DownloadedTrackEntity.kt" />
              <option name="updatedContent" value="package com.plyr.database&#10;&#10;import androidx.room.Entity&#10;import androidx.room.PrimaryKey&#10;&#10;/**&#10; * DownloadedTrackEntity - Entidad para representar canciones descargadas localmente&#10; * &#10; * Almacena información de tracks descargados con su ruta de archivo local.&#10; */&#10;@Entity(tableName = &quot;downloaded_tracks&quot;)&#10;data class DownloadedTrackEntity(&#10;    /** ID único del track */&#10;    @PrimaryKey&#10;    val id: String,&#10;&#10;    /** ID único del track en Spotify */&#10;    val spotifyTrackId: String,&#10;&#10;    /** Nombre/título del track */&#10;    val name: String,&#10;&#10;    /** Lista de artistas separados por coma */&#10;    val artists: String,&#10;&#10;    /** ID del video de YouTube correspondiente */&#10;    val youtubeVideoId: String,&#10;&#10;    /** Ruta del archivo de audio descargado */&#10;    val localFilePath: String,&#10;&#10;    /** Duración del track en milisegundos */&#10;    val durationMs: Long? = null,&#10;&#10;    /** Timestamp de la descarga */&#10;    val downloadTime: Long = System.currentTimeMillis()&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/database/PlaylistDatabase.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/database/PlaylistDatabase.kt" />
              <option name="originalContent" value="package com.plyr.database&#10;&#10;import androidx.room.Database&#10;import androidx.room.Room&#10;import androidx.room.RoomDatabase&#10;import android.content.Context&#10;&#10;/**&#10; * PlaylistDatabase - Configuración principal de Room Database&#10; * &#10; * Define la base de datos para playlists y tracks con:&#10; * - Entidades: PlaylistEntity y TrackEntity&#10; * - Versión: 1 (primera versión)&#10; * - DAOs: PlaylistDao y TrackDao&#10; * &#10; * Implementa patrón Singleton thread-safe para garantizar una sola instancia.&#10; */&#10;@Database(&#10;    entities = [PlaylistEntity::class, TrackEntity::class],&#10;    version = 2,&#10;    exportSchema = false&#10;)&#10;abstract class PlaylistDatabase : RoomDatabase() {&#10;    &#10;    /**&#10;     * Acceso al DAO de playlists.&#10;     */&#10;    abstract fun playlistDao(): PlaylistDao&#10;    &#10;    /**&#10;     * Acceso al DAO de tracks.&#10;     */&#10;    abstract fun trackDao(): TrackDao&#10;    &#10;    companion object {&#10;        /** Instancia volátil para thread-safety */&#10;        @Volatile&#10;        private var INSTANCE: PlaylistDatabase? = null&#10;        &#10;        /**&#10;         * Obtiene la instancia única de la base de datos.&#10;         * Implementa patrón Singleton con double-checked locking.&#10;         * &#10;         * @param context Contexto de aplicación&#10;         * @return Instancia única de PlaylistDatabase&#10;         */&#10;        fun getDatabase(context: Context): PlaylistDatabase {&#10;            return INSTANCE ?: synchronized(this) {&#10;                val instance = Room.databaseBuilder(&#10;                    context.applicationContext,&#10;                    PlaylistDatabase::class.java,&#10;                    &quot;playlist_database&quot;&#10;                )&#10;                    .fallbackToDestructiveMigration(false)&#10;                .build()&#10;                INSTANCE = instance&#10;                instance&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.database&#13;&#10;&#13;&#10;import androidx.room.Database&#13;&#10;import androidx.room.Room&#13;&#10;import androidx.room.RoomDatabase&#13;&#10;import android.content.Context&#13;&#10;&#13;&#10;/**&#13;&#10; * PlaylistDatabase - Configuración principal de Room Database&#13;&#10; * &#13;&#10; * Define la base de datos para playlists y tracks con:&#13;&#10; * - Entidades: PlaylistEntity y TrackEntity&#13;&#10; * - Versión: 1 (primera versión)&#13;&#10; * - DAOs: PlaylistDao y TrackDao&#13;&#10; * &#13;&#10; * Implementa patrón Singleton thread-safe para garantizar una sola instancia.&#13;&#10; */&#13;&#10;@Database(&#13;&#10;    entities = [PlaylistEntity::class, TrackEntity::class, DownloadedTrackEntity::class],&#13;&#10;    version = 3,&#13;&#10;    exportSchema = false&#13;&#10;)&#13;&#10;abstract class PlaylistDatabase : RoomDatabase() {&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Acceso al DAO de playlists.&#13;&#10;     */&#13;&#10;    abstract fun playlistDao(): PlaylistDao&#13;&#10;    &#13;&#10;    /**&#13;&#10;     * Acceso al DAO de tracks.&#13;&#10;     */&#13;&#10;    abstract fun trackDao(): TrackDao&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Acceso al DAO de tracks descargados.&#13;&#10;     */&#13;&#10;    abstract fun downloadedTrackDao(): DownloadedTrackDao&#13;&#10;    &#13;&#10;    companion object {&#13;&#10;        /** Instancia volátil para thread-safety */&#13;&#10;        @Volatile&#13;&#10;        private var INSTANCE: PlaylistDatabase? = null&#13;&#10;        &#13;&#10;        /**&#13;&#10;         * Obtiene la instancia única de la base de datos.&#13;&#10;         * Implementa patrón Singleton con double-checked locking.&#13;&#10;         * &#13;&#10;         * @param context Contexto de aplicación&#13;&#10;         * @return Instancia única de PlaylistDatabase&#13;&#10;         */&#13;&#10;        fun getDatabase(context: Context): PlaylistDatabase {&#13;&#10;            return INSTANCE ?: synchronized(this) {&#13;&#10;                val instance = Room.databaseBuilder(&#13;&#10;                    context.applicationContext,&#13;&#10;                    PlaylistDatabase::class.java,&#13;&#10;                    &quot;playlist_database&quot;&#13;&#10;                )&#13;&#10;                    .fallbackToDestructiveMigration(false)&#13;&#10;                .build()&#13;&#10;                INSTANCE = instance&#13;&#10;                instance&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/AudioListScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/AudioListScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.runtime.*&#10;import com.plyr.model.AudioItem&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)&#10;&#10;@Composable&#10;fun AudioListScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onThemeChanged: (String) -&gt; Unit = {},&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var currentScreen by remember { mutableStateOf(Screen.HOME) }&#10;&#10;    BackHandler(enabled = currentScreen != Screen.HOME) {&#10;        currentScreen = Screen.HOME&#10;    }&#10;&#10;    when (currentScreen) {&#10;        Screen.HOME -&gt; HomeScreen(context) { screen -&gt; currentScreen = screen }&#10;        Screen.SEARCH -&gt; SearchScreen(&#10;            context = context,&#10;            onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.QUEUE -&gt; QueueScreen(&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.CONFIG -&gt; ConfigScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            onThemeChanged = onThemeChanged&#10;        )&#10;        Screen.PLAYLISTS -&gt; PlaylistsScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.runtime.*&#10;import com.plyr.model.AudioItem&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS,&#10;    LOCAL&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)&#10;&#10;@Composable&#10;fun AudioListScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onThemeChanged: (String) -&gt; Unit = {},&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var currentScreen by remember { mutableStateOf(Screen.HOME) }&#10;&#10;    BackHandler(enabled = currentScreen != Screen.HOME) {&#10;        currentScreen = Screen.HOME&#10;    }&#10;&#10;    when (currentScreen) {&#10;        Screen.HOME -&gt; HomeScreen(context) { screen -&gt; currentScreen = screen }&#10;        Screen.SEARCH -&gt; SearchScreen(&#10;            context = context,&#10;            onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.QUEUE -&gt; QueueScreen(&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.CONFIG -&gt; ConfigScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            onThemeChanged = onThemeChanged&#10;        )&#10;        Screen.PLAYLISTS -&gt; PlaylistsScreen(&#10;            context = context,&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;        Screen.LOCAL -&gt; LocalScreen(&#10;            onBack = { currentScreen = Screen.HOME },&#10;            playerViewModel = playerViewModel&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.ui.theme.*&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var backPressedTime by remember { mutableLongStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;&#10;    // List of ASCII arts (add your own manually)&#10;    val asciiArts = listOf(&#10;        &quot;&quot;&quot;&#10;                 __          &#10;          ____  / /_  _______&#10;         / __ \/ / / / / ___/&#10;        / /_/ / / /_/ / /    &#10; ______/ .___/_/\__, /_/     &#10;/_____/_/      /____/        &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;             _            &#10;       _ __ | |_   _ _ __ &#10;      | '_ \| | | | | '__|&#10;      | |_) | | |_| | |   &#10; _____| .__/|_|\__, |_|   &#10;|_____|_|      |___/      &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;    ___       ___       ___       ___   &#10;   /\  \     /\__\     /\__\     /\  \  &#10;  /::\  \   /:/  /    |::L__L   /::\  \ &#10; /::\:\__\ /:/__/     |:::\__\ /::\:\__\&#10; \/\::/  / \:\  \     /:;;/__/ \;:::/  /&#10;    \/__/   \:\__\    \/__/     |:\/__/ &#10;             \/__/               \|__|  &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10; ______   __         __  __     ______    &#10;/\  == \ /\ \       /\ \_\ \   /\  == \   &#10;\ \  _-/ \ \ \____  \ \____ \  \ \  __&lt;   &#10; \ \_\    \ \_____\  \/\_____\  \ \_\ \_\ &#10;  \/_/     \/_____/   \/_____/   \/_/ /_/ &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10; ▄▄▄·▄▄▌   ▄· ▄▌▄▄▄  &#10;▐█ ▄███•  ▐█▪██▌▀▄ █·&#10; ██▀·██▪  ▐█▌▐█▪▐▀▀▄ &#10;▐█▪·•▐█▌▐▌ ▐█▀·.▐█•█▌&#10;.▀   .▀▀▀   ▀ • .▀  ▀&#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;&#10;█ ▄▄  █    ▀▄    ▄ █▄▄▄▄ &#10;█   █ █      █  █  █  ▄▀ &#10;█▀▀▀  █       ▀█   █▀▀▌  &#10;█     ███▄    █    █  █  &#10; █        ▀ ▄▀       █   &#10;  ▀                 ▀    &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;      ____  __   _  _  ____ &#10;     (  _ \(  ) ( \/ )(  _ \&#10; ___  )___/ )(__ \  /  )   /&#10;(___)(__)  (____)(__) (_)\_)&#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;▄▄▄▄  █ ▄   ▄  ▄▄▄ &#10;█   █ █ █   █ █    &#10;█▄▄▄▀ █  ▀▀▀█ █    &#10;█     █ ▄   █      &#10;▀        ▀▀▀       &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;               (             &#10;               )\ (     (    &#10;        `  )  ((_))\ )  )(   &#10;        /(/(   _ (()/( (()\  &#10;       ((_)_\ | | )(_)) ((_) &#10;       | '_ \)| || || || '_| &#10; _____ | .__/ |_| \_, ||_|   &#10;|_____||_|        |__/       &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;             .__                 &#10;      ______ |  | ___.__._______ &#10;      \____ \|  |&lt;   |  |\_  __ \&#10;      |  |_&gt; &gt;  |_\___  | |  | \/&#10; _____|   __/|____/ ____| |__|   &#10;/_____/__|        \/             &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;   _______   ___       ___  ___  _______   &#10;  |   __ &quot;\ |&quot;  |     |&quot;  \/&quot;  |/&quot;      \  &#10;  (. |__) :)||  |      \   \  /|:        | &#10;  |:  ____/ |:  |       \\  \/ |_____/   ) &#10;  (|  /      \  |___    /   /   //      /  &#10; /|__/ \    ( \_|:  \  /   /   |:  __   \  &#10;(_______)    \_______)|___/    |__|  \___) &#10;        &quot;&quot;&quot;,&#10;    )&#10;    // Select a random ASCII art on each composition&#10;    val selectedAscii = remember { asciiArts.random() }&#10;&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        val verticalScrollState = rememberScrollState()&#10;        Box(modifier = Modifier.verticalScroll(verticalScrollState)) {&#10;            // Center all content (ASCII art, title, buttons) vertically and horizontally&#10;            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .fillMaxHeight(),&#10;                    verticalArrangement = Arrangement.Center,&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // ASCII art and title&#10;                    val horizontalScrollState = rememberScrollState()&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(horizontalScrollState),&#10;                        horizontalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Text(&#10;                            text = selectedAscii,&#10;                            fontFamily = FontFamily.Monospace,&#10;                            style = PlyrTextStyles.commandTitle().copy(&#10;                                fontSize = 12.sp,&#10;                                lineHeight = 13.sp&#10;                            ),&#10;                            modifier = Modifier&#10;                                .align(Alignment.CenterVertically)&#10;                                .padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                    // Centered menu options&#10;                    val options = listOf(&#10;                        MenuOption(Screen.SEARCH, &quot;search&quot;),&#10;                        MenuOption(Screen.PLAYLISTS, &quot;playlists&quot;),&#10;                        MenuOption(Screen.QUEUE, &quot;queue&quot;),&#10;                        MenuOption(Screen.CONFIG, &quot;settings&quot;)&#10;                    )&#10;                    // Restore previous layout: buttons below ASCII, left-aligned but centered vertically&#10;                    Spacer(modifier = Modifier.height(50.dp))&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f), // keep buttons visually centered horizontally&#10;                        verticalArrangement = Arrangement.Center,&#10;                        horizontalAlignment = Alignment.Start // left-align buttons&#10;                    ) {&#10;                        options.forEach { option -&gt;&#10;                            PlyrMenuOption(&#10;                                text = option.title,&#10;                                onClick = { onNavigateToScreen(option.screen) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(vertical = 16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                        }&#10;                    }&#10;                    if (showExitMessage) {&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;                        PlyrErrorText(&#10;                            text = &quot;Press back again to exit&quot;,&#10;                            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.horizontalScroll&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.Text&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.ui.theme.*&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var backPressedTime by remember { mutableLongStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;&#10;    // List of ASCII arts (add your own manually)&#10;    val asciiArts = listOf(&#10;        &quot;&quot;&quot;&#10;                 __          &#10;          ____  / /_  _______&#10;         / __ \/ / / / / ___/&#10;        / /_/ / / /_/ / /    &#10; ______/ .___/_/\__, /_/     &#10;/_____/_/      /____/        &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;             _            &#10;       _ __ | |_   _ _ __ &#10;      | '_ \| | | | | '__|&#10;      | |_) | | |_| | |   &#10; _____| .__/|_|\__, |_|   &#10;|_____|_|      |___/      &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;    ___       ___       ___       ___   &#10;   /\  \     /\__\     /\__\     /\  \  &#10;  /::\  \   /:/  /    |::L__L   /::\  \ &#10; /::\:\__\ /:/__/     |:::\__\ /::\:\__\&#10; \/\::/  / \:\  \     /:;;/__/ \;:::/  /&#10;    \/__/   \:\__\    \/__/     |:\/__/ &#10;             \/__/               \|__|  &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10; ______   __         __  __     ______    &#10;/\  == \ /\ \       /\ \_\ \   /\  == \   &#10;\ \  _-/ \ \ \____  \ \____ \  \ \  __&lt;   &#10; \ \_\    \ \_____\  \/\_____\  \ \_\ \_\ &#10;  \/_/     \/_____/   \/_____/   \/_/ /_/ &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10; ▄▄▄·▄▄▌   ▄· ▄▌▄▄▄  &#10;▐█ ▄███•  ▐█▪██▌▀▄ █·&#10; ██▀·██▪  ▐█▌▐█▪▐▀▀▄ &#10;▐█▪·•▐█▌▐▌ ▐█▀·.▐█•█▌&#10;.▀   .▀▀▀   ▀ • .▀  ▀&#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;&#10;█ ▄▄  █    ▀▄    ▄ █▄▄▄▄ &#10;█   █ █      █  █  █  ▄▀ &#10;█▀▀▀  █       ▀█   █▀▀▌  &#10;█     ███▄    █    █  █  &#10; █        ▀ ▄▀       █   &#10;  ▀                 ▀    &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;      ____  __   _  _  ____ &#10;     (  _ \(  ) ( \/ )(  _ \&#10; ___  )___/ )(__ \  /  )   /&#10;(___)(__)  (____)(__) (_)\_)&#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;▄▄▄▄  █ ▄   ▄  ▄▄▄ &#10;█   █ █ █   █ █    &#10;█▄▄▄▀ █  ▀▀▀█ █    &#10;█     █ ▄   █      &#10;▀        ▀▀▀       &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;               (             &#10;               )\ (     (    &#10;        `  )  ((_))\ )  )(   &#10;        /(/(   _ (()/( (()\  &#10;       ((_)_\ | | )(_)) ((_) &#10;       | '_ \)| || || || '_| &#10; _____ | .__/ |_| \_, ||_|   &#10;|_____||_|        |__/       &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;             .__                 &#10;      ______ |  | ___.__._______ &#10;      \____ \|  |&lt;   |  |\_  __ \&#10;      |  |_&gt; &gt;  |_\___  | |  | \/&#10; _____|   __/|____/ ____| |__|   &#10;/_____/__|        \/             &#10;        &quot;&quot;&quot;,&#10;        &quot;&quot;&quot;&#10;   _______   ___       ___  ___  _______   &#10;  |   __ &quot;\ |&quot;  |     |&quot;  \/&quot;  |/&quot;      \  &#10;  (. |__) :)||  |      \   \  /|:        | &#10;  |:  ____/ |:  |       \\  \/ |_____/   ) &#10;  (|  /      \  |___    /   /   //      /  &#10; /|__/ \    ( \_|:  \  /   /   |:  __   \  &#10;(_______)    \_______)|___/    |__|  \___) &#10;        &quot;&quot;&quot;,&#10;    )&#10;    // Select a random ASCII art on each composition&#10;    val selectedAscii = remember { asciiArts.random() }&#10;&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        val verticalScrollState = rememberScrollState()&#10;        Box(modifier = Modifier.verticalScroll(verticalScrollState)) {&#10;            // Center all content (ASCII art, title, buttons) vertically and horizontally&#10;            Box(modifier = Modifier.fillMaxSize(), contentAlignment = Alignment.Center) {&#10;                Column(&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .fillMaxHeight(),&#10;                    verticalArrangement = Arrangement.Center,&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // ASCII art and title&#10;                    val horizontalScrollState = rememberScrollState()&#10;                    Row(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .horizontalScroll(horizontalScrollState),&#10;                        horizontalArrangement = Arrangement.Center&#10;                    ) {&#10;                        Text(&#10;                            text = selectedAscii,&#10;                            fontFamily = FontFamily.Monospace,&#10;                            style = PlyrTextStyles.commandTitle().copy(&#10;                                fontSize = 12.sp,&#10;                                lineHeight = 13.sp&#10;                            ),&#10;                            modifier = Modifier&#10;                                .align(Alignment.CenterVertically)&#10;                                .padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                    // Centered menu options&#10;                    val options = listOf(&#10;                        MenuOption(Screen.SEARCH, &quot;search&quot;),&#10;                        MenuOption(Screen.PLAYLISTS, &quot;playlists&quot;),&#10;                        MenuOption(Screen.QUEUE, &quot;queue&quot;),&#10;                        MenuOption(Screen.LOCAL, &quot;local&quot;),&#10;                        MenuOption(Screen.CONFIG, &quot;settings&quot;)&#10;                    )&#10;                    // Restore previous layout: buttons below ASCII, left-aligned but centered vertically&#10;                    Spacer(modifier = Modifier.height(50.dp))&#10;                    Column(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth(0.8f), // keep buttons visually centered horizontally&#10;                        verticalArrangement = Arrangement.Center,&#10;                        horizontalAlignment = Alignment.Start // left-align buttons&#10;                    ) {&#10;                        options.forEach { option -&gt;&#10;                            PlyrMenuOption(&#10;                                text = option.title,&#10;                                onClick = { onNavigateToScreen(option.screen) },&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .padding(vertical = 16.dp)&#10;                            )&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;                        }&#10;                    }&#10;                    if (showExitMessage) {&#10;                        Spacer(modifier = Modifier.height(24.dp))&#10;                        PlyrErrorText(&#10;                            text = &quot;Press back again to exit&quot;,&#10;                            modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/LocalScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/LocalScreen.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.itemsIndexed&#10;import androidx.compose.foundation.lazy.rememberLazyListState&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.database.DownloadedTrackEntity&#10;import com.plyr.database.PlaylistDatabase&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.ui.components.*&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.utils.DownloadManager&#10;import kotlinx.coroutines.launch&#10;import android.util.Log&#10;&#10;@Composable&#10;fun LocalScreen(&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?&#10;) {&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val listState = rememberLazyListState()&#10;&#10;    var downloadedTracks by remember { mutableStateOf&lt;List&lt;DownloadedTrackEntity&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(true) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var showDeleteDialog by remember { mutableStateOf(false) }&#10;    var trackToDelete by remember { mutableStateOf&lt;DownloadedTrackEntity?&gt;(null) }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Cargar tracks descargados&#10;    LaunchedEffect(Unit) {&#10;        try {&#10;            val database = PlaylistDatabase.getDatabase(context)&#10;            database.downloadedTrackDao().getAllDownloadedTracks().collect { tracks -&gt;&#10;                downloadedTracks = tracks&#10;                isLoading = false&#10;                Log.d(&quot;LocalScreen&quot;, &quot;Loaded ${tracks.size} downloaded tracks&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            error = &quot;Error loading downloaded tracks: ${e.message}&quot;&#10;            isLoading = false&#10;            Log.e(&quot;LocalScreen&quot;, &quot;Error loading tracks&quot;, e)&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ local&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        when {&#10;            isLoading -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                }&#10;            }&#10;            error != null -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = error ?: &quot;Unknown error&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            color = Color(0xFFFF6B6B)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            downloadedTracks.isEmpty() -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;no downloaded tracks yet&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            color = Color(0xFF888888)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                // Info de cantidad&#10;                Text(&#10;                    text = &quot;${downloadedTracks.size} track${if (downloadedTracks.size != 1) &quot;s&quot; else &quot;&quot;}&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                // Lista de tracks&#10;                LazyColumn(&#10;                    state = listState,&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    verticalArrangement = Arrangement.spacedBy(4.dp)&#10;                ) {&#10;                    itemsIndexed(downloadedTracks) { index, track -&gt;&#10;                        // Convertir DownloadedTrackEntity a TrackEntity para SongListItem&#10;                        val song = Song(&#10;                            number = index + 1,&#10;                            title = track.name,&#10;                            artist = track.artists,&#10;                            spotifyId = track.spotifyTrackId,&#10;                            youtubeId = track.youtubeVideoId&#10;                        )&#10;&#10;                        SongListItem(&#10;                            song = song,&#10;                            trackEntities = downloadedTracks.map { dt -&gt;&#10;                                val trackEntity = TrackEntity(&#10;                                    id = dt.id,&#10;                                    playlistId = &quot;local&quot;,&#10;                                    spotifyTrackId = dt.spotifyTrackId,&#10;                                    name = dt.name,&#10;                                    artists = dt.artists,&#10;                                    youtubeVideoId = dt.youtubeVideoId,&#10;                                    audioUrl = dt.localFilePath, // Esta ruta debe usarse para reproducción local&#10;                                    position = downloadedTracks.indexOf(dt)&#10;                                )&#10;                                Log.d(&quot;LocalScreen&quot;, &quot;TrackEntity creado - audioUrl: ${trackEntity.audioUrl}&quot;)&#10;                                trackEntity&#10;                            },&#10;                            index = index,&#10;                            playerViewModel = playerViewModel,&#10;                            coroutineScope = coroutineScope,&#10;                            customButtonIcon = &quot;✗&quot;,&#10;                            customButtonAction = {&#10;                                trackToDelete = track&#10;                                showDeleteDialog = true&#10;                            }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de confirmación de eliminación&#10;    if (showDeleteDialog &amp;&amp; trackToDelete != null) {&#10;        PlyrConfirmDialog(&#10;            title = &quot;delete track?&quot;,&#10;            message = &quot;this will permanently delete '${trackToDelete?.name}' from your device&quot;,&#10;            confirmText = &quot;delete&quot;,&#10;            cancelText = &quot;cancel&quot;,&#10;            onConfirm = {&#10;                coroutineScope.launch {&#10;                    trackToDelete?.let { track -&gt;&#10;                        val success = DownloadManager.deleteDownloadedTrack(context, track)&#10;                        if (success) {&#10;                            Log.d(&quot;LocalScreen&quot;, &quot;Track deleted successfully&quot;)&#10;                        } else {&#10;                            error = &quot;Failed to delete track&quot;&#10;                        }&#10;                    }&#10;                    showDeleteDialog = false&#10;                    trackToDelete = null&#10;                }&#10;            },&#10;            onDismiss = {&#10;                showDeleteDialog = false&#10;                trackToDelete = null&#10;            }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/PlyrComponents.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/PlyrComponents.kt" />
              <option name="originalContent" value="package com.plyr.ui.components&#10;&#10;import android.annotation.SuppressLint&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.plyr.ui.theme.*&#10;&#10;@Composable&#10;fun PlyrMenuOption(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Text(&#10;        text = &quot;${PlyrSymbols.PROMPT}$text&quot;,&#10;        style = PlyrTextStyles.menuOption().copy(textAlign = TextAlign.Center),&#10;        modifier = modifier&#10;            .clickable(enabled = enabled) {&#10;                if (enabled) {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onClick()&#10;                }&#10;            }&#10;            .padding(PlyrSpacing.xs)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun PlyrErrorText(&#10;    text: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = PlyrTextStyles.errorText(),&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;fun PlyrInfoText(&#10;    text: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = PlyrTextStyles.infoText(),&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;// === COMPONENTES DE SELECCIÓN ===&#10;&#10;// === COMPONENTES DE LAYOUT ===&#10;&#10;@Composable&#10;fun PlyrScreenContainer(&#10;    modifier: Modifier = Modifier,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(PlyrSpacing.large),&#10;        verticalArrangement = Arrangement.spacedBy(PlyrSpacing.medium),&#10;        content = content&#10;    )&#10;}&#10;&#10;// === COMPONENTES DE BOTONES ===&#10;&#10;&#10;// === COMPONENTES DE ESTADO ===&#10;&#10;@Composable&#10;fun PlyrLoadingIndicator(&#10;    text: String = &quot;loading&quot;,&#10;    @SuppressLint(&quot;ModifierParameter&quot;) modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;$text${PlyrSymbols.LOADING}&quot;,&#10;            style = PlyrTextStyles.trackArtist()&#10;        )&#10;    }&#10;}&#10;&#10;// === COMPONENTES DE LISTA ===&#10;&#10;// === ESPACIADORES PREDEFINIDOS ===&#10;&#10;@Composable&#10;fun PlyrSmallSpacer() = Spacer(modifier = Modifier.height(PlyrSpacing.small))&#10;&#10;@Composable&#10;fun PlyrMediumSpacer() = Spacer(modifier = Modifier.height(PlyrSpacing.medium))&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components&#10;&#10;import android.annotation.SuppressLint&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.Composable&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.window.Dialog&#10;import com.plyr.ui.theme.*&#10;&#10;@Composable&#10;fun PlyrMenuOption(&#10;    text: String,&#10;    onClick: () -&gt; Unit,&#10;    modifier: Modifier = Modifier,&#10;    enabled: Boolean = true&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Text(&#10;        text = &quot;${PlyrSymbols.PROMPT}$text&quot;,&#10;        style = PlyrTextStyles.menuOption().copy(textAlign = TextAlign.Center),&#10;        modifier = modifier&#10;            .clickable(enabled = enabled) {&#10;                if (enabled) {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onClick()&#10;                }&#10;            }&#10;            .padding(PlyrSpacing.xs)&#10;    )&#10;}&#10;&#10;@Composable&#10;fun PlyrErrorText(&#10;    text: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = PlyrTextStyles.errorText(),&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;@Composable&#10;fun PlyrInfoText(&#10;    text: String,&#10;    modifier: Modifier = Modifier&#10;) {&#10;    Text(&#10;        text = text,&#10;        style = PlyrTextStyles.infoText(),&#10;        modifier = modifier&#10;    )&#10;}&#10;&#10;// === COMPONENTES DE SELECCIÓN ===&#10;&#10;// === COMPONENTES DE LAYOUT ===&#10;&#10;@Composable&#10;fun PlyrScreenContainer(&#10;    modifier: Modifier = Modifier,&#10;    content: @Composable ColumnScope.() -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = modifier&#10;            .fillMaxSize()&#10;            .padding(PlyrSpacing.large),&#10;        verticalArrangement = Arrangement.spacedBy(PlyrSpacing.medium),&#10;        content = content&#10;    )&#10;}&#10;&#10;// === COMPONENTES DE BOTONES ===&#10;&#10;&#10;// === COMPONENTES DE ESTADO ===&#10;&#10;@Composable&#10;fun PlyrLoadingIndicator(&#10;    text: String = &quot;loading&quot;,&#10;    @SuppressLint(&quot;ModifierParameter&quot;) modifier: Modifier = Modifier&#10;) {&#10;    Row(&#10;        modifier = modifier,&#10;        verticalAlignment = Alignment.CenterVertically,&#10;        horizontalArrangement = Arrangement.Center&#10;    ) {&#10;        Text(&#10;            text = &quot;$text${PlyrSymbols.LOADING}&quot;,&#10;            style = PlyrTextStyles.trackArtist()&#10;        )&#10;    }&#10;}&#10;&#10;// === COMPONENTES DE LISTA ===&#10;&#10;// === DIÁLOGOS ===&#10;&#10;@Composable&#10;fun PlyrConfirmDialog(&#10;    title: String,&#10;    message: String,&#10;    confirmText: String = &quot;confirm&quot;,&#10;    cancelText: String = &quot;cancel&quot;,&#10;    onConfirm: () -&gt; Unit,&#10;    onDismiss: () -&gt; Unit&#10;) {&#10;    Dialog(onDismissRequest = onDismiss) {&#10;        Box(&#10;            modifier = Modifier&#10;                .clip(RoundedCornerShape(24.dp))&#10;                .background(Color(0xFF181818))&#10;                .padding(24.dp)&#10;                .fillMaxWidth(0.9f)&#10;        ) {&#10;            Column(&#10;                verticalArrangement = Arrangement.spacedBy(PlyrSpacing.medium),&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                Text(&#10;                    text = title,&#10;                    style = PlyrTextStyles.commandTitle(),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                Text(&#10;                    text = message,&#10;                    style = PlyrTextStyles.infoText(),&#10;                    textAlign = TextAlign.Center&#10;                )&#10;                Spacer(modifier = Modifier.height(PlyrSpacing.small))&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceEvenly&#10;                ) {&#10;                    Text(&#10;                        text = cancelText,&#10;                        style = PlyrTextStyles.menuOption(),&#10;                        modifier = Modifier&#10;                            .clickable { onDismiss() }&#10;                            .padding(PlyrSpacing.small)&#10;                    )&#10;                    Text(&#10;                        text = confirmText,&#10;                        style = PlyrTextStyles.menuOption(),&#10;                        color = Color(0xFFFF6B6B),&#10;                        modifier = Modifier&#10;                            .clickable { onConfirm() }&#10;                            .padding(PlyrSpacing.small)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;// === ESPACIADORES PREDEFINIDOS ===&#10;&#10;@Composable&#10;fun PlyrSmallSpacer() = Spacer(modifier = Modifier.height(PlyrSpacing.small))&#10;&#10;@Composable&#10;fun PlyrMediumSpacer() = Spacer(modifier = Modifier.height(PlyrSpacing.medium))" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/SongListItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/SongListItem.kt" />
              <option name="originalContent" value="package com.plyr.ui.components&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.PlaylistsScreen&#10;import com.plyr.utils.Config&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.theme.PlyrSpacing&#10;import com.plyr.ui.theme.PlyrTextStyles&#10;&#10;// Data class para unificar los datos de la canción&#10;data class Song(&#10;    val number: Int,&#10;    val title: String,&#10;    val artist: String,&#10;    val spotifyId: String? = null,&#10;    val youtubeId: String? = null,&#10;    val spotifyUrl: String? = null&#10;)&#10;&#10;@Composable&#10;fun SongListItem(&#10;    song: Song,&#10;    trackEntities: List&lt;TrackEntity&gt;,&#10;    index: Int,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    modifier: Modifier = Modifier,&#10;    isSelected: Boolean = false,&#10;    onLikedStatusChanged: (() -&gt; Unit)? = null,&#10;    customButtonIcon: String? = null, // Nueva: Icono personalizado para el botón (ej: &quot;+&quot;)&#10;    customButtonAction: (() -&gt; Unit)? = null // Nueva: Acción personalizada para el botón&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val context = LocalContext.current&#10;    var showPopup by remember { mutableStateOf(false) }&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;    var showPlaylistDialog by remember { mutableStateOf(false) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;com.plyr.network.SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;    var addToPlaylistError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var addToPlaylistSuccess by remember { mutableStateOf(false) }&#10;    var isLoadingTrackInfo by remember { mutableStateOf(false) }&#10;    var fetchedTrackInfo by remember { mutableStateOf&lt;com.plyr.network.SpotifyTrack?&gt;(null) }&#10;    var fetchInfoError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLiked by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;    var isCheckingLiked by remember { mutableStateOf(false) }&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .clickable {&#10;                haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                playerViewModel?.let { viewModel -&gt;&#10;                    if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                        viewModel.setCurrentPlaylist(trackEntities, index)&#10;                        val selectedTrackEntity = trackEntities[index]&#10;                        coroutineScope.launch {&#10;                            try {&#10;                                viewModel.loadAudioFromTrack(selectedTrackEntity)&#10;                                Log.d(&quot;SongListItem&quot;, &quot; Reproduciendo track ${index + 1}/${trackEntities.size}: ${selectedTrackEntity.name}&quot;)&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;SongListItem&quot;, &quot;Error al reproducir track&quot;, e)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            .fillMaxWidth()&#10;            .height(32.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Track number&#10;        Text(&#10;            text = song.number.toString(),&#10;            style = PlyrTextStyles.trackArtist(),&#10;            modifier = Modifier.padding(end = PlyrSpacing.small)&#10;        )&#10;        // Song title and artist&#10;        Column(&#10;            modifier = Modifier.weight(1f),&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = song.title,&#10;                style = if (isSelected)&#10;                    PlyrTextStyles.selectableOption(true)&#10;                else&#10;                    PlyrTextStyles.trackTitle(),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            Text(&#10;                text = song.artist,&#10;                style = PlyrTextStyles.trackArtist(),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis,&#10;                modifier = Modifier.padding(top = 0.dp)&#10;            )&#10;        }&#10;        // Botón personalizable&#10;        IconButton(onClick = {&#10;            if (customButtonAction != null) {&#10;                customButtonAction()&#10;            } else {&#10;                showPopup = true&#10;            }&#10;        }, modifier = Modifier.size(32.dp)) {&#10;            Text(&#10;                text = customButtonIcon ?: &quot;*&quot;,&#10;                style = PlyrTextStyles.menuOption(),&#10;                color = Color(0xFF3FFFEF)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Solo mostrar popup si no hay acción personalizada&#10;    if (showPopup &amp;&amp; customButtonAction == null) {&#10;        // Cargar información de la canción cuando se abre el popup&#10;        LaunchedEffect(true) {&#10;            if (showPopup &amp;&amp; song.spotifyId != null) {&#10;                isLoadingTrackInfo = true&#10;                isCheckingLiked = true&#10;                fetchInfoError = null&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener info del track&#10;                    SpotifyRepository.getTrackInfo(accessToken, song.spotifyId) { trackInfo, error -&gt;&#10;                        isLoadingTrackInfo = false&#10;                        if (trackInfo != null) {&#10;                            fetchedTrackInfo = trackInfo&#10;                        } else {&#10;                            fetchInfoError = error ?: &quot;Error fetching track info&quot;&#10;                        }&#10;                    }&#10;&#10;                    // Verificar si está en Liked Songs&#10;                    SpotifyRepository.checkSavedTrack(accessToken, song.spotifyId) { liked, error -&gt;&#10;                        isCheckingLiked = false&#10;                        if (error == null) {&#10;                            isLiked = liked&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTrackInfo = false&#10;                    isCheckingLiked = false&#10;                    fetchInfoError = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            }&#10;        }&#10;&#10;        Dialog(onDismissRequest = {&#10;            showPopup = false&#10;            fetchedTrackInfo = null&#10;            fetchInfoError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Sección de información del track&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(150.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingTrackInfo -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;loading...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchInfoError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayMedium.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = fetchInfoError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchedTrackInfo != null -&gt; {&#10;                                // Mostrar información de la canción&#10;                                val trackInfo = fetchedTrackInfo&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.name ?: song.title,&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                                color = Color.White,&#10;                                                fontWeight = FontWeight.Bold&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.artists?.joinToString(&quot;, &quot;) { it.name } ?: song.artist,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                color = Color(0xFFAAAAAA)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    trackInfo?.album?.let { album -&gt;&#10;                                        item {&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = &quot;Album: ${album.name}&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = Color(0xFF888888)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                        album.releaseDate?.let { date -&gt;&#10;                                            item {&#10;                                                Text(&#10;                                                    text = &quot;Release: $date&quot;,&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                                        color = Color(0xFF888888)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = &quot;Duration: ${trackInfo?.durationMs?.let { ms -&gt; &#10;                                                val minutes = ms / 60000&#10;                                                val seconds = &quot;%02d&quot;.format((ms % 60000) / 1000)&#10;                                                &quot;$minutes:$seconds&quot;&#10;                                            } ?: &quot;N/A&quot;}&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                color = Color(0xFF888888)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Mostrar info básica mientras carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.Start,&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    Text(&#10;                                        text = song.title,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            color = Color.White,&#10;                                            fontWeight = FontWeight.Bold&#10;                                        )&#10;                                    )&#10;                                    Text(&#10;                                        text = song.artist,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFFAAAAAA)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Botones de acción&#10;                    Column(&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        // Add to Playlist&#10;                        Text(&#10;                            text = &quot;add to playlist&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#10;                                        showPopup = false&#10;                                        showPlaylistDialog = true&#10;                                        isLoadingPlaylists = true&#10;                                        addToPlaylistError = null&#10;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null) {&#10;                                            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#10;                                                isLoadingPlaylists = false&#10;                                                if (playlists != null) {&#10;                                                    userPlaylists = playlists&#10;                                                } else {&#10;                                                    addToPlaylistError = error ?: &quot;Error cargando playlists&quot;&#10;                                                }&#10;                                            }&#10;                                        } else {&#10;                                            isLoadingPlaylists = false&#10;                                            addToPlaylistError = &quot;Token de Spotify no disponible&quot;&#10;                                        }&#10;                                    } else {&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#10;                                        showPopup = false&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Add to Queue&#10;                        Text(&#10;                            text = &quot;add to queue&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showPopup = false&#10;                                    playerViewModel?.let { viewModel -&gt;&#10;                                        if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                            val trackToAdd = trackEntities[index]&#10;                                            viewModel.addToQueue(trackToAdd)&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Share&#10;                        Text(&#10;                            text = &quot;share&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showShareDialog = true&#10;                                    showPopup = false&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Like / Unlike&#10;                        Text(&#10;                            text = if (isLiked == true) &quot;remove from liked songs&quot; else &quot;add to liked songs&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    // Acción de agregar/quitar de Liked Songs&#10;                                    showPopup = false&#10;                                    isLiked?.let { currentlyLiked -&gt;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                            isLoadingTrackInfo = true&#10;                                            if (currentlyLiked) {&#10;                                                // Quitar de Liked Songs&#10;                                                SpotifyRepository.removeTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = false&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción quitada de Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error quitando canción de Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                // Añadir a Liked Songs&#10;                                                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = true&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción a Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de selección de playlist&#10;    if (showPlaylistDialog) {&#10;        Dialog(onDismissRequest = {&#10;            showPlaylistDialog = false&#10;            addToPlaylistSuccess = false&#10;            addToPlaylistError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Contenido del diálogo&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(300.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingPlaylists -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;loading playlists...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistSuccess -&gt; {&#10;                                // Éxito&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✓&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;Track added successfully!&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = addToPlaylistError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            userPlaylists.isEmpty() -&gt; {&#10;                                // Sin playlists&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;No playlists found&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Lista de playlists&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    items(userPlaylists) { playlist -&gt;&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .clip(RoundedCornerShape(8.dp))&#10;                                                .clickable {&#10;                                                    // Añadir la canción a la playlist&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                                        isLoadingPlaylists = true&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#10;                                                            accessToken,&#10;                                                            playlist.id,&#10;                                                            song.spotifyId&#10;                                                        ) { success, error -&gt;&#10;                                                            isLoadingPlaylists = false&#10;                                                            if (success) {&#10;                                                                addToPlaylistSuccess = true&#10;                                                                Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a '${playlist.name}'&quot;)&#10;                                                                // Cerrar el diálogo después de 1.5 segundos&#10;                                                                coroutineScope.launch {&#10;                                                                    kotlinx.coroutines.delay(1500)&#10;                                                                    showPlaylistDialog = false&#10;                                                                    addToPlaylistSuccess = false&#10;                                                                }&#10;                                                            } else {&#10;                                                                addToPlaylistError = error&#10;                                                                Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción: $error&quot;)&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                                .background(Color(0xFF252525))&#10;                                                .padding(12.dp),&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Column(&#10;                                                modifier = Modifier.weight(1f)&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = playlist.name,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        color = Color.White&#10;                                                    ),&#10;                                                    maxLines = 1,&#10;                                                    overflow = TextOverflow.Ellipsis&#10;                                                )&#10;                                                playlist.description?.let { desc -&gt;&#10;                                                    if (desc.isNotBlank()) {&#10;                                                        Text(&#10;                                                            text = desc,&#10;                                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                                color = Color(0xFF888888)&#10;                                                            ),&#10;                                                            maxLines = 1,&#10;                                                            overflow = TextOverflow.Ellipsis&#10;                                                        )&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            Text(&#10;                                                text = &quot;&gt;&quot;,&#10;                                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                                    color = Color(0xFF4ECDC4)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = song.spotifyId,&#10;                spotifyUrl = song.spotifyUrl,&#10;                youtubeId = song.youtubeId,&#10;                title = song.title,&#10;                artist = song.artist,&#10;                type = ShareType.TRACK&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.ui.PlaylistsScreen&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.DownloadManager&#10;import com.plyr.database.PlaylistDatabase&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.Dispatchers&#10;import com.plyr.ui.theme.PlyrSpacing&#10;import com.plyr.ui.theme.PlyrTextStyles&#10;&#10;// Data class para unificar los datos de la canción&#10;data class Song(&#10;    val number: Int,&#10;    val title: String,&#10;    val artist: String,&#10;    val spotifyId: String? = null,&#10;    val youtubeId: String? = null,&#10;    val spotifyUrl: String? = null&#10;)&#10;&#10;@Composable&#10;fun SongListItem(&#10;    song: Song,&#10;    trackEntities: List&lt;TrackEntity&gt;,&#10;    index: Int,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    modifier: Modifier = Modifier,&#10;    isSelected: Boolean = false,&#10;    onLikedStatusChanged: (() -&gt; Unit)? = null,&#10;    customButtonIcon: String? = null, // Nueva: Icono personalizado para el botón (ej: &quot;+&quot;)&#10;    customButtonAction: (() -&gt; Unit)? = null // Nueva: Acción personalizada para el botón&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val context = LocalContext.current&#10;    var showPopup by remember { mutableStateOf(false) }&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;    var showPlaylistDialog by remember { mutableStateOf(false) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;com.plyr.network.SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;    var addToPlaylistError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var addToPlaylistSuccess by remember { mutableStateOf(false) }&#10;    var isLoadingTrackInfo by remember { mutableStateOf(false) }&#10;    var fetchedTrackInfo by remember { mutableStateOf&lt;com.plyr.network.SpotifyTrack?&gt;(null) }&#10;    var fetchInfoError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLiked by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;    var isCheckingLiked by remember { mutableStateOf(false) }&#10;&#10;    Row(&#10;        modifier = modifier&#10;            .clickable {&#10;                haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                playerViewModel?.let { viewModel -&gt;&#10;                    if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                        viewModel.setCurrentPlaylist(trackEntities, index)&#10;                        val selectedTrackEntity = trackEntities[index]&#10;                        &#10;                        Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#10;                        Log.d(&quot;SongListItem&quot;, &quot; REPRODUCIR TRACK&quot;)&#10;                        Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Track: ${selectedTrackEntity.name}&quot;)&#10;                        Log.d(&quot;SongListItem&quot;, &quot;AudioUrl: ${selectedTrackEntity.audioUrl}&quot;)&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Es archivo local: ${selectedTrackEntity.audioUrl?.startsWith(&quot;/&quot;) == true}&quot;)&#10;                        &#10;                        coroutineScope.launch {&#10;                            try {&#10;                                viewModel.loadAudioFromTrack(selectedTrackEntity)&#10;                                Log.d(&quot;SongListItem&quot;, &quot;✓ loadAudioFromTrack llamado exitosamente&quot;)&#10;                            } catch (e: Exception) {&#10;                                Log.e(&quot;SongListItem&quot;, &quot;✗ Error al reproducir track&quot;, e)&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;            .fillMaxWidth()&#10;            .height(32.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Track number&#10;        Text(&#10;            text = song.number.toString(),&#10;            style = PlyrTextStyles.trackArtist(),&#10;            modifier = Modifier.padding(end = PlyrSpacing.small)&#10;        )&#10;        // Song title and artist&#10;        Column(&#10;            modifier = Modifier.weight(1f),&#10;            verticalArrangement = Arrangement.Center&#10;        ) {&#10;            Text(&#10;                text = song.title,&#10;                style = if (isSelected)&#10;                    PlyrTextStyles.selectableOption(true)&#10;                else&#10;                    PlyrTextStyles.trackTitle(),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;            Text(&#10;                text = song.artist,&#10;                style = PlyrTextStyles.trackArtist(),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis,&#10;                modifier = Modifier.padding(top = 0.dp)&#10;            )&#10;        }&#10;        // Botón personalizable&#10;        IconButton(onClick = {&#10;            if (customButtonAction != null) {&#10;                customButtonAction()&#10;            } else {&#10;                showPopup = true&#10;            }&#10;        }, modifier = Modifier.size(32.dp)) {&#10;            Text(&#10;                text = customButtonIcon ?: &quot;*&quot;,&#10;                style = PlyrTextStyles.menuOption(),&#10;                color = Color(0xFF3FFFEF)&#10;            )&#10;        }&#10;    }&#10;&#10;    // Solo mostrar popup si no hay acción personalizada&#10;    if (showPopup &amp;&amp; customButtonAction == null) {&#10;        // Cargar información de la canción cuando se abre el popup&#10;        LaunchedEffect(true) {&#10;            if (showPopup &amp;&amp; song.spotifyId != null) {&#10;                isLoadingTrackInfo = true&#10;                isCheckingLiked = true&#10;                fetchInfoError = null&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener info del track&#10;                    SpotifyRepository.getTrackInfo(accessToken, song.spotifyId) { trackInfo, error -&gt;&#10;                        isLoadingTrackInfo = false&#10;                        if (trackInfo != null) {&#10;                            fetchedTrackInfo = trackInfo&#10;                        } else {&#10;                            fetchInfoError = error ?: &quot;Error fetching track info&quot;&#10;                        }&#10;                    }&#10;&#10;                    // Verificar si está en Liked Songs&#10;                    SpotifyRepository.checkSavedTrack(accessToken, song.spotifyId) { liked, error -&gt;&#10;                        isCheckingLiked = false&#10;                        if (error == null) {&#10;                            isLiked = liked&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTrackInfo = false&#10;                    isCheckingLiked = false&#10;                    fetchInfoError = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            }&#10;        }&#10;&#10;        Dialog(onDismissRequest = {&#10;            showPopup = false&#10;            fetchedTrackInfo = null&#10;            fetchInfoError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Sección de información del track&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(150.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingTrackInfo -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;loading...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchInfoError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayMedium.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = fetchInfoError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchedTrackInfo != null -&gt; {&#10;                                // Mostrar información de la canción&#10;                                val trackInfo = fetchedTrackInfo&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.name ?: song.title,&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                                color = Color.White,&#10;                                                fontWeight = FontWeight.Bold&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.artists?.joinToString(&quot;, &quot;) { it.name } ?: song.artist,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                color = Color(0xFFAAAAAA)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    trackInfo?.album?.let { album -&gt;&#10;                                        item {&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = &quot;Album: ${album.name}&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = Color(0xFF888888)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                        album.releaseDate?.let { date -&gt;&#10;                                            item {&#10;                                                Text(&#10;                                                    text = &quot;Release: $date&quot;,&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                                        color = Color(0xFF888888)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = &quot;Duration: ${trackInfo?.durationMs?.let { ms -&gt; &#10;                                                val minutes = ms / 60000&#10;                                                val seconds = &quot;%02d&quot;.format((ms % 60000) / 1000)&#10;                                                &quot;$minutes:$seconds&quot;&#10;                                            } ?: &quot;N/A&quot;}&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                color = Color(0xFF888888)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Mostrar info básica mientras carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.Start,&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    Text(&#10;                                        text = song.title,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            color = Color.White,&#10;                                            fontWeight = FontWeight.Bold&#10;                                        )&#10;                                    )&#10;                                    Text(&#10;                                        text = song.artist,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFFAAAAAA)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Botones de acción&#10;                    Column(&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        // Add to Playlist&#10;                        Text(&#10;                            text = &quot;add to playlist&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#10;                                        showPopup = false&#10;                                        showPlaylistDialog = true&#10;                                        isLoadingPlaylists = true&#10;                                        addToPlaylistError = null&#10;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null) {&#10;                                            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#10;                                                isLoadingPlaylists = false&#10;                                                if (playlists != null) {&#10;                                                    userPlaylists = playlists&#10;                                                } else {&#10;                                                    addToPlaylistError = error ?: &quot;Error cargando playlists&quot;&#10;                                                }&#10;                                            }&#10;                                        } else {&#10;                                            isLoadingPlaylists = false&#10;                                            addToPlaylistError = &quot;Token de Spotify no disponible&quot;&#10;                                        }&#10;                                    } else {&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#10;                                        showPopup = false&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Add to Queue&#10;                        Text(&#10;                            text = &quot;add to queue&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showPopup = false&#10;                                    playerViewModel?.let { viewModel -&gt;&#10;                                        if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                            val trackToAdd = trackEntities[index]&#10;                                            viewModel.addToQueue(trackToAdd)&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Share&#10;                        Text(&#10;                            text = &quot;share&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showShareDialog = true&#10;                                    showPopup = false&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Like / Unlike&#10;                        Text(&#10;                            text = if (isLiked == true) &quot;remove from liked songs&quot; else &quot;add to liked songs&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    // Acción de agregar/quitar de Liked Songs&#10;                                    showPopup = false&#10;                                    isLiked?.let { currentlyLiked -&gt;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                            isLoadingTrackInfo = true&#10;                                            if (currentlyLiked) {&#10;                                                // Quitar de Liked Songs&#10;                                                SpotifyRepository.removeTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = false&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción quitada de Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error quitando canción de Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                // Añadir a Liked Songs&#10;                                                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = true&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción a Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Download&#10;                        Text(&#10;                            text = &quot;download&quot;,&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showPopup = false&#10;                                    if (song.spotifyId != null) {&#10;                                        coroutineScope.launch {&#10;                                            // Verificar si ya está descargada&#10;                                            val database = PlaylistDatabase.getDatabase(context)&#10;                                            val alreadyDownloaded = database.downloadedTrackDao()&#10;                                                .isTrackDownloaded(song.spotifyId) &gt; 0&#10;&#10;                                            if (alreadyDownloaded) {&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Track already downloaded&quot;)&#10;                                            } else {&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Starting download: ${song.title}&quot;)&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Song data - Title: '${song.title}', Artist: '${song.artist}', SpotifyId: '${song.spotifyId}', YoutubeId: '${song.youtubeId}'&quot;)&#10;&#10;                                                // Primero intentar obtener el youtubeId del TrackEntity actual&#10;                                                val trackEntity = if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                                    trackEntities[index]&#10;                                                } else null&#10;&#10;                                                val initialYoutubeId = trackEntity?.youtubeVideoId ?: song.youtubeId&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;TrackEntity youtubeVideoId: ${trackEntity?.youtubeVideoId}&quot;)&#10;&#10;                                                // Si aún no tenemos youtubeId, buscarlo en YouTube&#10;                                                val finalYoutubeId = if (initialYoutubeId == null) {&#10;                                                    withContext(Dispatchers.IO) {&#10;                                                        val searchQuery = &quot;${song.title} ${song.artist}&quot;&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;YouTube ID not available, searching with query: '$searchQuery'&quot;)&#10;                                                        val foundId = com.plyr.network.YouTubeManager.searchVideoId(searchQuery)&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;YouTube search result: ${if (foundId != null) &quot;Found ID: $foundId&quot; else &quot;NOT FOUND&quot;}&quot;)&#10;                                                        foundId&#10;                                                    }&#10;                                                } else {&#10;                                                    Log.d(&quot;SongListItem&quot;, &quot;Using existing YouTube ID: $initialYoutubeId&quot;)&#10;                                                    initialYoutubeId&#10;                                                }&#10;&#10;                                                if (finalYoutubeId != null) {&#10;                                                    Log.d(&quot;SongListItem&quot;, &quot;YouTube ID confirmed: $finalYoutubeId&quot;)&#10;                                                    Log.d(&quot;SongListItem&quot;, &quot;Attempting to get audio URL for video: $finalYoutubeId&quot;)&#10;                                                    DownloadManager.downloadTrack(&#10;                                                        context = context,&#10;                                                        spotifyTrackId = song.spotifyId,&#10;                                                        youtubeVideoId = finalYoutubeId,&#10;                                                        trackName = song.title,&#10;                                                        artists = song.artist,&#10;                                                        onProgress = { progress -&gt;&#10;                                                            Log.d(&quot;SongListItem&quot;, &quot;Download progress: $progress%&quot;)&#10;                                                        },&#10;                                                        onComplete = { success, error -&gt;&#10;                                                            if (success) {&#10;                                                                Log.d(&quot;SongListItem&quot;, &quot;✓ Download completed: ${song.title}&quot;)&#10;                                                            } else {&#10;                                                                Log.e(&quot;SongListItem&quot;, &quot;✗ Download failed: $error&quot;)&#10;                                                            }&#10;                                                        }&#10;                                                    )&#10;                                                } else {&#10;                                                    Log.e(&quot;SongListItem&quot;, &quot;Cannot download: YouTube video not found for query: '${song.title} ${song.artist}'&quot;)&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    } else {&#10;                                        Log.e(&quot;SongListItem&quot;, &quot;Cannot download: missing Spotify ID&quot;)&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de selección de playlist&#10;    if (showPlaylistDialog) {&#10;        Dialog(onDismissRequest = {&#10;            showPlaylistDialog = false&#10;            addToPlaylistSuccess = false&#10;            addToPlaylistError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Contenido del diálogo&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(300.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingPlaylists -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;loading playlists...&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistSuccess -&gt; {&#10;                                // Éxito&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✓&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = &quot;Track added successfully!&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = addToPlaylistError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            userPlaylists.isEmpty() -&gt; {&#10;                                // Sin playlists&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;No playlists found&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Lista de playlists&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    items(userPlaylists) { playlist -&gt;&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .clip(RoundedCornerShape(8.dp))&#10;                                                .clickable {&#10;                                                    // Añadir la canción a la playlist&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                                        isLoadingPlaylists = true&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#10;                                                            accessToken,&#10;                                                            playlist.id,&#10;                                                            song.spotifyId&#10;                                                        ) { success, error -&gt;&#10;                                                            isLoadingPlaylists = false&#10;                                                            if (success) {&#10;                                                                addToPlaylistSuccess = true&#10;                                                                Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a '${playlist.name}'&quot;)&#10;                                                                // Cerrar el diálogo después de 1.5 segundos&#10;                                                                coroutineScope.launch {&#10;                                                                    kotlinx.coroutines.delay(1500)&#10;                                                                    showPlaylistDialog = false&#10;                                                                    addToPlaylistSuccess = false&#10;                                                                }&#10;                                                            } else {&#10;                                                                addToPlaylistError = error&#10;                                                                Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción: $error&quot;)&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                                .background(Color(0xFF252525))&#10;                                                .padding(12.dp),&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Column(&#10;                                                modifier = Modifier.weight(1f)&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = playlist.name,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        color = Color.White&#10;                                                    ),&#10;                                                    maxLines = 1,&#10;                                                    overflow = TextOverflow.Ellipsis&#10;                                                )&#10;                                                playlist.description?.let { desc -&gt;&#10;                                                    if (desc.isNotBlank()) {&#10;                                                        Text(&#10;                                                            text = desc,&#10;                                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                                color = Color(0xFF888888)&#10;                                                            ),&#10;                                                            maxLines = 1,&#10;                                                            overflow = TextOverflow.Ellipsis&#10;                                                        )&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            Text(&#10;                                                text = &quot;&gt;&quot;,&#10;                                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                                    color = Color(0xFF4ECDC4)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = song.spotifyId,&#10;                spotifyUrl = song.spotifyUrl,&#10;                youtubeId = song.youtubeId,&#10;                title = song.title,&#10;                artist = song.artist,&#10;                type = ShareType.TRACK&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/DownloadManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/DownloadManager.kt" />
              <option name="originalContent" value="&#10;&#10;&#10;&#10;&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import com.plyr.database.DownloadedTrackEntity&#10;import com.plyr.database.PlaylistDatabase&#10;import com.plyr.network.YouTubeManager&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.delay&#10;import java.io.File&#10;import java.io.FileOutputStream&#10;import java.net.HttpURLConnection&#10;import java.net.URL&#10;&#10;/**&#10; * DownloadManager - Gestor de descargas de audio&#10; *&#10; * Descarga manual con headers correctos para evitar bloqueos de YouTube.&#10; */&#10;object DownloadManager {&#10;&#10;    private const val TAG = &quot;DownloadManager&quot;&#10;    private const val DOWNLOADS_FOLDER = &quot;plyr_downloads&quot;&#10;    private const val MAX_RETRIES = 3&#10;    private const val RETRY_DELAY_MS = 2000L&#10;    private const val TIMEOUT_MS = 30000&#10;    private const val BUFFER_SIZE = 8192&#10;&#10;    /**&#10;     * Descarga una canción desde YouTube y la guarda localmente.&#10;     */&#10;    suspend fun downloadTrack(&#10;        context: Context,&#10;        spotifyTrackId: String,&#10;        youtubeVideoId: String,&#10;        trackName: String,&#10;        artists: String,&#10;        onProgress: (Int) -&gt; Unit = {},&#10;        onComplete: (Boolean, String?) -&gt; Unit&#10;    ) {&#10;        withContext(Dispatchers.IO) {&#10;            try {&#10;                Log.d(TAG, &quot;Iniciando descarga: $trackName - $artists&quot;)&#10;&#10;                // Verificar si ya está descargada&#10;                val database = PlaylistDatabase.getDatabase(context)&#10;                val existingTrack = database.downloadedTrackDao().getDownloadedTrackBySpotifyId(spotifyTrackId)&#10;                if (existingTrack != null) {&#10;                    Log.d(TAG, &quot;Track ya descargado previamente&quot;)&#10;                    withContext(Dispatchers.Main) {&#10;                        onComplete(false, &quot;Track already downloaded&quot;)&#10;                    }&#10;                    return@withContext&#10;                }&#10;&#10;                onProgress(10)&#10;&#10;                // Crear directorio de descargas&#10;                val downloadsDir = File(context.getExternalFilesDir(null), DOWNLOADS_FOLDER)&#10;                if (!downloadsDir.exists()) {&#10;                    downloadsDir.mkdirs()&#10;                }&#10;&#10;                val safeFileName = &quot;${trackName.replace(&quot;[^a-zA-Z0-9.-]&quot;.toRegex(), &quot;_&quot;)}_${System.currentTimeMillis()}.m4a&quot;&#10;                val outputFile = File(downloadsDir, safeFileName)&#10;&#10;                // Intentar descargar con reintentos&#10;                var lastError: String? = null&#10;                for (attempt in 1..MAX_RETRIES) {&#10;                    try {&#10;                        Log.d(TAG, &quot;Intento $attempt/$MAX_RETRIES&quot;)&#10;&#10;                        // Obtener URL fresca de YouTube&#10;                        val audioUrl = YouTubeManager.getAudioUrl(youtubeVideoId)&#10;                        if (audioUrl == null) {&#10;                            lastError = &quot;Failed to get audio URL&quot;&#10;                            Log.e(TAG, &quot;No se pudo obtener URL&quot;)&#10;                            if (attempt &lt; MAX_RETRIES) {&#10;                                delay(RETRY_DELAY_MS)&#10;                                continue&#10;                            }&#10;                            break&#10;                        }&#10;&#10;                        onProgress(30)&#10;                        Log.d(TAG, &quot;Descargando desde URL (longitud: ${audioUrl.length})&quot;)&#10;&#10;                        // Configurar conexión con headers que imitan curl/navegador&#10;                        val url = URL(audioUrl)&#10;                        val connection = (url.openConnection() as HttpURLConnection).apply {&#10;                            requestMethod = &quot;GET&quot;&#10;                            connectTimeout = TIMEOUT_MS&#10;                            readTimeout = TIMEOUT_MS&#10;&#10;                            // Headers críticos para que YouTube acepte la descarga&#10;                            setRequestProperty(&quot;User-Agent&quot;, &quot;Mozilla/5.0 (Windows NT 10.0; Win64; x64) AppleWebKit/537.36 (KHTML, like Gecko) Chrome/120.0.0.0 Safari/537.36&quot;)&#10;                            setRequestProperty(&quot;Accept&quot;, &quot;*/*&quot;)&#10;                            setRequestProperty(&quot;Accept-Language&quot;, &quot;en-US,en;q=0.9&quot;)&#10;                            setRequestProperty(&quot;Accept-Encoding&quot;, &quot;identity&quot;)&#10;                            setRequestProperty(&quot;Range&quot;, &quot;bytes=0-&quot;)&#10;&#10;                            doInput = true&#10;                            instanceFollowRedirects = true&#10;                        }&#10;&#10;                        connection.connect()&#10;&#10;                        val responseCode = connection.responseCode&#10;                        if (responseCode != HttpURLConnection.HTTP_OK &amp;&amp; responseCode != HttpURLConnection.HTTP_PARTIAL) {&#10;                            lastError = &quot;HTTP error: $responseCode&quot;&#10;                            Log.e(TAG, &quot;Error HTTP: $responseCode&quot;)&#10;                            connection.disconnect()&#10;                            if (attempt &lt; MAX_RETRIES) {&#10;                                delay(RETRY_DELAY_MS)&#10;                                continue&#10;                            }&#10;                            break&#10;                        }&#10;&#10;                        val fileLength = connection.contentLengthLong&#10;                        Log.d(TAG, &quot;Tamaño del archivo: $fileLength bytes&quot;)&#10;&#10;                        // Descargar archivo&#10;                        var downloadSuccess = false&#10;                        connection.inputStream.use { input -&gt;&#10;                            FileOutputStream(outputFile).use { output -&gt;&#10;                                val buffer = ByteArray(BUFFER_SIZE)&#10;                                var bytesRead: Int&#10;                                var totalBytesRead = 0L&#10;                                var lastProgress = 30&#10;&#10;                                while (input.read(buffer).also { bytesRead = it } != -1) {&#10;                                    output.write(buffer, 0, bytesRead)&#10;                                    totalBytesRead += bytesRead&#10;&#10;                                    if (fileLength &gt; 0) {&#10;                                        val progress = 30 + ((totalBytesRead * 65) / fileLength).toInt()&#10;                                        if (progress != lastProgress) {&#10;                                            withContext(Dispatchers.Main) {&#10;                                                onProgress(progress)&#10;                                            }&#10;                                            lastProgress = progress&#10;                                        }&#10;                                    }&#10;                                }&#10;                                downloadSuccess = true&#10;                            }&#10;                        }&#10;&#10;                        connection.disconnect()&#10;&#10;                        if (!downloadSuccess || !outputFile.exists() || outputFile.length() == 0L) {&#10;                            lastError = &quot;Download incomplete&quot;&#10;                            Log.e(TAG, &quot;Descarga incompleta&quot;)&#10;                            outputFile.delete()&#10;                            if (attempt &lt; MAX_RETRIES) {&#10;                                delay(RETRY_DELAY_MS)&#10;                                continue&#10;                            }&#10;                            break&#10;                        }&#10;&#10;                        onProgress(95)&#10;&#10;                        // Guardar en base de datos&#10;                        val downloadedTrack = DownloadedTrackEntity(&#10;                            id = &quot;${spotifyTrackId}_${System.currentTimeMillis()}&quot;,&#10;                            spotifyTrackId = spotifyTrackId,&#10;                            name = trackName,&#10;                            artists = artists,&#10;                            youtubeVideoId = youtubeVideoId,&#10;                            localFilePath = outputFile.absolutePath&#10;                        )&#10;&#10;                        database.downloadedTrackDao().insertDownloadedTrack(downloadedTrack)&#10;&#10;                        onProgress(100)&#10;&#10;                        Log.d(TAG, &quot;✓ Descarga completada: ${outputFile.length()} bytes&quot;)&#10;                        Log.d(TAG, &quot;✓ Archivo guardado en: ${outputFile.absolutePath}&quot;)&#10;                        Log.d(TAG, &quot;✓ Archivo existe: ${outputFile.exists()}&quot;)&#10;                        Log.d(TAG, &quot;✓ Archivo legible: ${outputFile.canRead()}&quot;)&#10;                        Log.d(TAG, &quot;✓ Guardado en BD con ID: ${downloadedTrack.id}&quot;)&#10;                        &#10;                        withContext(Dispatchers.Main) {&#10;                            onComplete(true, null)&#10;                        }&#10;                        return@withContext&#10;&#10;                    } catch (e: Exception) {&#10;                        lastError = e.message ?: &quot;Unknown error&quot;&#10;                        Log.e(TAG, &quot;Error en intento $attempt: ${e.message}&quot;, e)&#10;                        if (outputFile.exists()) {&#10;                            outputFile.delete()&#10;                        }&#10;                        if (attempt &lt; MAX_RETRIES) {&#10;                            delay(RETRY_DELAY_MS)&#10;                        }&#10;                    }&#10;                }&#10;&#10;                // Todos los intentos fallaron&#10;                Log.e(TAG, &quot;✗ Descarga falló después de $MAX_RETRIES intentos&quot;)&#10;                withContext(Dispatchers.Main) {&#10;                    onComplete(false, lastError ?: &quot;Download failed&quot;)&#10;                }&#10;&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error crítico&quot;, e)&#10;                withContext(Dispatchers.Main) {&#10;                    onComplete(false, e.message ?: &quot;Unknown error&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Elimina una canción descargada.&#10;     */&#10;    suspend fun deleteDownloadedTrack(&#10;        context: Context,&#10;        track: DownloadedTrackEntity&#10;    ): Boolean {&#10;        return withContext(Dispatchers.IO) {&#10;            try {&#10;                val file = File(track.localFilePath)&#10;                if (file.exists()) {&#10;                    file.delete()&#10;                }&#10;&#10;                val database = PlaylistDatabase.getDatabase(context)&#10;                database.downloadedTrackDao().deleteDownloadedTrack(track)&#10;&#10;                Log.d(TAG, &quot;Track eliminado: ${track.name}&quot;)&#10;                true&#10;            } catch (e: Exception) {&#10;                Log.e(TAG, &quot;Error eliminando track&quot;, e)&#10;                false&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el directorio de descargas.&#10;     */&#10;    fun getDownloadsDirectory(context: Context): File {&#10;        val dir = File(context.getExternalFilesDir(null), DOWNLOADS_FOLDER)&#10;        if (!dir.exists()) {&#10;            dir.mkdirs()&#10;        }&#10;        return dir&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt" />
              <option name="originalContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import androidx.annotation.OptIn&#10;import androidx.media3.common.util.UnstableApi&#10;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;&#10;    // Queue management&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#10;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#10;&#10;    private var loadingJobsActive = false&#10;&#10;    fun initializePlayer() {&#10;        if (_exoPlayer == null) {&#10;            _exoPlayer = buildPlayer()&#10;        }&#10;    }&#10;&#10;    @OptIn(UnstableApi::class)&#10;    private fun buildPlayer(): ExoPlayer =&#10;        ExoPlayer.Builder(getApplication())&#10;            .setSeekBackIncrementMs(10_000)&#10;            .setSeekForwardIncrementMs(10_000)&#10;            .setHandleAudioBecomingNoisy(true)&#10;            .setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true&#10;            )&#10;            .build().apply {&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#10;                }&#10;&#10;                addListener(object : Player.Listener {&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#10;                    }&#10;&#10;                    override fun onPlayerError(error: PlaybackException) {&#10;                        _isLoading.postValue(false)&#10;                        _error.postValue(&quot;Error: ${error.message}&quot;)&#10;                    }&#10;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#10;                        updateCurrentTrackFromPlayer()&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#10;                    }&#10;                })&#10;            }&#10;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            _isLoading.postValue(true)&#10;            _error.postValue(null)&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;            }&#10;&#10;            if (audioUrl == null) {&#10;                _isLoading.postValue(false)&#10;                _error.postValue(&quot;No se pudo obtener audio&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            initializePlayer()&#10;            _exoPlayer?.let { player -&gt;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#10;                player.prepare()&#10;                player.play()&#10;                _isLoading.postValue(false)&#10;                onMediaSessionUpdate?.invoke(player)&#10;&#10;                // Iniciar carga concurrente de las siguientes canciones&#10;                startLoadingRemainingTracks()&#10;                true&#10;            } ?: false&#10;        } catch (e: Exception) {&#10;            _isLoading.postValue(false)&#10;            _error.postValue(&quot;Error: ${e.message}&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#10;        MediaItem.Builder()&#10;            .setUri(audioUrl)&#10;            .setMediaId(track.id)&#10;            .setMediaMetadata(&#10;                androidx.media3.common.MediaMetadata.Builder()&#10;                    .setTitle(track.name)&#10;                    .setArtist(track.artists)&#10;                    .build()&#10;            )&#10;            .build()&#10;&#10;    private fun startLoadingRemainingTracks() {&#10;        if (loadingJobsActive) return&#10;        loadingJobsActive = true&#10;&#10;        val playlist = _currentPlaylist.value ?: return&#10;        val currentIndex = _currentTrackIndex.value ?: return&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            for (i in currentIndex + 1 until playlist.size) {&#10;                val track = playlist[i]&#10;                try {&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                } catch (_: Exception) {&#10;                    // Continuar con la siguiente canción si hay error&#10;                }&#10;            }&#10;            loadingJobsActive = false&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentTrackFromPlayer() {&#10;        val player = _exoPlayer ?: return&#10;        val playlist = _currentPlaylist.value ?: return&#10;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#10;&#10;        if (newIndex &gt;= 0) {&#10;            _currentTrackIndex.postValue(newIndex)&#10;            _currentTrack.postValue(playlist[newIndex])&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#10;        }&#10;    }&#10;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#10;&#10;    fun playPlayer() = _exoPlayer?.play()&#10;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        _currentPlaylist.postValue(playlist)&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#10;        _currentTrackIndex.postValue(validIndex)&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[validIndex])&#10;        }&#10;    }&#10;&#10;    fun navigateToNext() {&#10;        _exoPlayer?.seekToNextMediaItem()&#10;    }&#10;&#10;    fun navigateToPrevious() {&#10;        _exoPlayer?.seekToPreviousMediaItem()&#10;    }&#10;&#10;    fun updateRepeatMode() {&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;            else -&gt; Player.REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // Queue functionality&#10;    fun addToQueue(track: TrackEntity) {&#10;        // Añadir a la lista interna de queue&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#10;        updatedQueue.add(track)&#10;        _queueTracks.postValue(updatedQueue)&#10;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#10;        currentPlaylist.add(track)&#10;        _currentPlaylist.postValue(currentPlaylist)&#10;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;&#10;                if (audioUrl != null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;Error loading track to queue: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import androidx.annotation.OptIn&#10;import androidx.media3.common.util.UnstableApi&#10;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;&#10;    // Queue management&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#10;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#10;&#10;    private var loadingJobsActive = false&#10;&#10;    fun initializePlayer() {&#10;        if (_exoPlayer == null) {&#10;            _exoPlayer = buildPlayer()&#10;        }&#10;    }&#10;&#10;    @OptIn(UnstableApi::class)&#10;    private fun buildPlayer(): ExoPlayer =&#10;        ExoPlayer.Builder(getApplication())&#10;            .setSeekBackIncrementMs(10_000)&#10;            .setSeekForwardIncrementMs(10_000)&#10;            .setHandleAudioBecomingNoisy(true)&#10;            .setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true&#10;            )&#10;            .build().apply {&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#10;                }&#10;&#10;                addListener(object : Player.Listener {&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#10;                    }&#10;&#10;                    override fun onPlayerError(error: PlaybackException) {&#10;                        _isLoading.postValue(false)&#10;                        _error.postValue(&quot;Error: ${error.message}&quot;)&#10;                    }&#10;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#10;                        updateCurrentTrackFromPlayer()&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#10;                    }&#10;                })&#10;            }&#10;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; LOAD AUDIO FROM TRACK&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track name: ${track.name}&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track audioUrl: ${track.audioUrl}&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;Track youtubeVideoId: ${track.youtubeVideoId}&quot;)&#10;            &#10;            _isLoading.postValue(true)&#10;            _error.postValue(null)&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#10;                // Verificar si audioUrl es una ruta de archivo local&#10;                if (track.audioUrl != null &amp;&amp; (track.audioUrl.startsWith(&quot;/&quot;) || track.audioUrl.startsWith(&quot;file://&quot;))) {&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Detectado archivo local&quot;)&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Ruta: ${track.audioUrl}&quot;)&#10;                    &#10;                    val localFile = java.io.File(track.audioUrl.removePrefix(&quot;file://&quot;))&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Archivo: ${localFile.absolutePath}&quot;)&#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Existe: ${localFile.exists()}&quot;)&#10;                    &#10;                    if (localFile.exists()) {&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Tamaño: ${localFile.length()} bytes&quot;)&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   Legible: ${localFile.canRead()}&quot;)&#10;                        android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Archivo local válido - usando para reproducción&quot;)&#10;                        return@withContext track.audioUrl&#10;                    } else {&#10;                        android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Archivo local NO existe: ${localFile.absolutePath}&quot;)&#10;                    }&#10;                }&#10;                &#10;                // Si no es archivo local, obtener de YouTube&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Obteniendo audio de YouTube...&quot;)&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                videoId?.let { &#10;                    android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;   YouTube ID: $it&quot;)&#10;                    YouTubeManager.getAudioUrl(it) &#10;                }&#10;            }&#10;&#10;            if (audioUrl == null) {&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ No se pudo obtener audioUrl&quot;)&#10;                _isLoading.postValue(false)&#10;                _error.postValue(&quot;No se pudo obtener audio&quot;)&#10;                return@withContext false&#10;            }&#10;&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ AudioUrl obtenida: $audioUrl&quot;)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot; Inicializando reproductor...&quot;)&#10;&#10;            initializePlayer()&#10;            _exoPlayer?.let { player -&gt;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#10;                player.prepare()&#10;                player.play()&#10;                _isLoading.postValue(false)&#10;                onMediaSessionUpdate?.invoke(player)&#10;&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;✓ Reproducción iniciada&quot;)&#10;                android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;&#10;                // Iniciar carga concurrente de las siguientes canciones&#10;                startLoadingRemainingTracks()&#10;                true&#10;            } ?: false&#10;        } catch (e: Exception) {&#10;            _isLoading.postValue(false)&#10;            _error.postValue(&quot;Error: ${e.message}&quot;)&#10;            android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;✗ Error reproduciendo track&quot;, e)&#10;            android.util.Log.d(&quot;PlayerViewModel&quot;, &quot;═══════════════════════════════════&quot;)&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#10;        MediaItem.Builder()&#10;            .setUri(audioUrl)&#10;            .setMediaId(track.id)&#10;            .setMediaMetadata(&#10;                androidx.media3.common.MediaMetadata.Builder()&#10;                    .setTitle(track.name)&#10;                    .setArtist(track.artists)&#10;                    .build()&#10;            )&#10;            .build()&#10;&#10;    private fun startLoadingRemainingTracks() {&#10;        if (loadingJobsActive) return&#10;        loadingJobsActive = true&#10;&#10;        val playlist = _currentPlaylist.value ?: return&#10;        val currentIndex = _currentTrackIndex.value ?: return&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            for (i in currentIndex + 1 until playlist.size) {&#10;                val track = playlist[i]&#10;                try {&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                } catch (_: Exception) {&#10;                    // Continuar con la siguiente canción si hay error&#10;                }&#10;            }&#10;            loadingJobsActive = false&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentTrackFromPlayer() {&#10;        val player = _exoPlayer ?: return&#10;        val playlist = _currentPlaylist.value ?: return&#10;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#10;&#10;        if (newIndex &gt;= 0) {&#10;            _currentTrackIndex.postValue(newIndex)&#10;            _currentTrack.postValue(playlist[newIndex])&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#10;        }&#10;    }&#10;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#10;&#10;    fun playPlayer() = _exoPlayer?.play()&#10;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        _currentPlaylist.postValue(playlist)&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#10;        _currentTrackIndex.postValue(validIndex)&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[validIndex])&#10;        }&#10;    }&#10;&#10;    fun navigateToNext() {&#10;        _exoPlayer?.seekToNextMediaItem()&#10;    }&#10;&#10;    fun navigateToPrevious() {&#10;        _exoPlayer?.seekToPreviousMediaItem()&#10;    }&#10;&#10;    fun updateRepeatMode() {&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;            else -&gt; Player.REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // Queue functionality&#10;    fun addToQueue(track: TrackEntity) {&#10;        // Añadir a la lista interna de queue&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#10;        updatedQueue.add(track)&#10;        _queueTracks.postValue(updatedQueue)&#10;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#10;        currentPlaylist.add(track)&#10;        _currentPlaylist.postValue(currentPlaylist)&#10;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;&#10;                if (audioUrl != null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                }&#10;            } catch (e: Exception) {&#10;                android.util.Log.e(&quot;PlayerViewModel&quot;, &quot;Error loading track to queue: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>