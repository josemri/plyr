<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantManager.kt" />
              <option name="originalContent" value="package com.plyr.assistant&#10;&#10;import android.content.Context&#10;import android.media.AudioManager&#10;import android.util.Log&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.utils.SpotifyTokenManager&#10;import com.plyr.utils.Translations&#10;&#10;import java.util.Collections&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.Calendar&#10;&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;import ai.onnxruntime.OnnxTensor&#10;import ai.onnxruntime.OrtEnvironment&#10;import ai.onnxruntime.OrtSession&#10;&#10;/**&#10; * Lightweight on-device assistant manager.&#10; */&#10;class AssistantManager(private val context: Context) {&#10;&#10;    data class IntentResult(&#10;        val intent: String,&#10;        val score: Float = 1.0f,&#10;        val entities: Map&lt;String, String&gt; = emptyMap()&#10;    )&#10;&#10;    // Estado del asistente&#10;    enum class AssistantState {&#10;        IDLE, LISTENING, PROCESSING, SPEAKING&#10;    }&#10;&#10;    private var onnxAvailable = false&#10;    private var ortEnv: OrtEnvironment? = null&#10;    private var sessionIntent: OrtSession? = null&#10;    private var sessionNer: OrtSession? = null&#10;&#10;    // Sleep timer&#10;    private var sleepTimer: Timer? = null&#10;    private var sleepTimerEndTime: Long = 0&#10;&#10;    // Estado actual&#10;    var currentState: AssistantState = AssistantState.IDLE&#10;        private set&#10;&#10;    // Callback para cambios de estado&#10;    var onStateChange: ((AssistantState) -&gt; Unit)? = null&#10;&#10;    // Último comando entendido (para feedback visual)&#10;    var lastRecognizedCommand: String = &quot;&quot;&#10;        private set&#10;&#10;    private fun t(key: String) = Translations.get(context, key)&#10;&#10;    private fun getTriggers(key: String): List&lt;String&gt; {&#10;        return t(key).split(&quot;|&quot;).map { it.trim().lowercase() }&#10;    }&#10;&#10;    fun setState(state: AssistantState) {&#10;        currentState = state&#10;        onStateChange?.invoke(state)&#10;    }&#10;&#10;    init {&#10;        try {&#10;            Class.forName(&quot;ai.onnxruntime.OnnxTensor&quot;)&#10;            onnxAvailable = true&#10;        } catch (_: Exception) {&#10;            onnxAvailable = false&#10;        }&#10;&#10;        if (onnxAvailable) {&#10;            try {&#10;                ortEnv = OrtEnvironment.getEnvironment()&#10;                val am = context.assets&#10;                fun loadSession(assetName: String): OrtSession? {&#10;                    return try {&#10;                        val bytes = am.open(assetName).use { it.readBytes() }&#10;                        ortEnv?.createSession(bytes)&#10;                    } catch (ex: Exception) {&#10;                        Log.i(&quot;AssistantManager&quot;, &quot;Model $assetName not found: ${ex.message}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;                sessionIntent = loadSession(&quot;assistant_intent.onnx&quot;)&#10;                sessionNer = loadSession(&quot;assistant_ner.onnx&quot;)&#10;                if (sessionIntent == null &amp;&amp; sessionNer == null) {&#10;                    onnxAvailable = false&#10;                }&#10;            } catch (ex: Throwable) {&#10;                Log.i(&quot;AssistantManager&quot;, &quot;ONNX init failed: ${ex.message}&quot;)&#10;                onnxAvailable = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun analyze(text: String): IntentResult {&#10;        val trimmed = text.trim()&#10;        if (trimmed.isEmpty()) return IntentResult(&quot;none&quot;, 1f)&#10;&#10;        if (onnxAvailable &amp;&amp; sessionIntent != null &amp;&amp; ortEnv != null) {&#10;            try {&#10;                val inputName = sessionIntent!!.inputNames.iterator().next()&#10;                val tensor = OnnxTensor.createTensor(ortEnv!!, arrayOf(trimmed))&#10;                val res = sessionIntent!!.run(Collections.singletonMap(inputName, tensor))&#10;                try {&#10;                    if (res.size() &gt; 0) {&#10;                        val first = res.get(0)&#10;                        val value = first.value&#10;                        if (value is Array&lt;*&gt;) {&#10;                            val maybe = value.firstOrNull() as? String&#10;                            if (!maybe.isNullOrBlank()) return IntentResult(maybe, 0.95f)&#10;                        } else if (value is String) {&#10;                            if (value.isNotBlank()) return IntentResult(value, 0.95f)&#10;                        }&#10;                    }&#10;                } finally {&#10;                    try { res.close() } catch (_: Exception) {}&#10;                    try { tensor.close() } catch (_: Exception) {}&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.i(&quot;AssistantManager&quot;, &quot;ONNX intent inference failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;        return ruleBasedAnalysis(trimmed)&#10;    }&#10;&#10;    private fun ruleBasedAnalysis(text: String): IntentResult {&#10;        val lower = text.lowercase()&#10;&#10;        val quoteRegex = &quot;\&quot;(.*?)\&quot;&quot;.toRegex()&#10;        val quoted = quoteRegex.find(text)?.groups?.get(1)?.value&#10;&#10;        fun containsAny(triggerKey: String): Boolean {&#10;            return getTriggers(triggerKey).any { lower.contains(it) }&#10;        }&#10;&#10;        fun extractAfter(triggerKey: String): String? {&#10;            val triggers = getTriggers(triggerKey).map { &quot;$it &quot; }&#10;            for (k in triggers) {&#10;                val idx = lower.indexOf(k)&#10;                if (idx &gt;= 0) {&#10;                    return text.substring(idx + k.length).trim().trim('&quot;', '\'')&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Limpiar frases comunes que no son parte del artista/canción&#10;        fun cleanQuery(query: String): String {&#10;            val patterns = listOf(&#10;                // English&#10;                &quot;something from &quot;, &quot;something by &quot;, &quot;something of &quot;,&#10;                &quot;anything from &quot;, &quot;anything by &quot;, &quot;a song from &quot;, &quot;a song by &quot;,&#10;                &quot;songs from &quot;, &quot;songs by &quot;, &quot;music from &quot;, &quot;music by &quot;,&#10;                // Spanish&#10;                &quot;algo de &quot;, &quot;algo del &quot;, &quot;una canción de &quot;, &quot;canciones de &quot;,&#10;                &quot;música de &quot;, &quot;una de &quot;,&#10;                // Catalan&#10;                &quot;alguna cosa de &quot;, &quot;una cançó de &quot;, &quot;cançons de &quot;, &quot;música de &quot;&#10;            )&#10;            var cleaned = query.lowercase()&#10;            for (pattern in patterns) {&#10;                if (cleaned.startsWith(pattern)) {&#10;                    cleaned = cleaned.substring(pattern.length)&#10;                    break&#10;                }&#10;                // También buscar en medio del texto&#10;                val idx = cleaned.indexOf(pattern)&#10;                if (idx &gt;= 0) {&#10;                    cleaned = cleaned.substring(idx + pattern.length)&#10;                    break&#10;                }&#10;            }&#10;            return cleaned.trim()&#10;        }&#10;&#10;        // Extraer número del texto (para volumen, temporizador, etc.)&#10;        fun extractNumber(): Int? {&#10;            val numberRegex = &quot;(\\d+)&quot;.toRegex()&#10;            return numberRegex.find(lower)?.groups?.get(1)?.value?.toIntOrNull()&#10;        }&#10;&#10;        // Extraer tiempo para sleep timer&#10;        fun extractTime(): Pair&lt;Int, String&gt;? {&#10;            // &quot;en 30 minutos&quot;, &quot;in 30 minutes&quot;&#10;            val minutesRegex = &quot;(\\d+)\\s*(minuto|minute|min)&quot;.toRegex()&#10;            val hoursRegex = &quot;(\\d+)\\s*(hora|hour|h)&quot;.toRegex()&#10;            val atTimeRegex = &quot;(\\d{1,2})[:\\.]?(\\d{2})?&quot;.toRegex()&#10;&#10;            minutesRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;minutes&quot;)&#10;            }&#10;            hoursRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;hours&quot;)&#10;            }&#10;            // &quot;a las 11&quot;, &quot;at 11&quot;&#10;            if (lower.contains(&quot;a las&quot;) || lower.contains(&quot;at &quot;)) {&#10;                atTimeRegex.find(lower)?.let {&#10;                    val hour = it.groups[1]?.value?.toIntOrNull() ?: return null&#10;                    val minute = it.groups[2]?.value?.toIntOrNull() ?: 0&#10;                    return Pair(hour * 60 + minute, &quot;absolute&quot;)&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Detectar comandos compuestos&#10;        val hasNext = containsAny(&quot;assistant_triggers_next&quot;)&#10;        val hasVolumeUp = containsAny(&quot;assistant_triggers_volume_up&quot;)&#10;        val hasVolumeDown = containsAny(&quot;assistant_triggers_volume_down&quot;)&#10;&#10;        if (hasNext &amp;&amp; (hasVolumeUp || hasVolumeDown)) {&#10;            return IntentResult(&quot;compound&quot;, 0.9f, mapOf(&#10;                &quot;actions&quot; to if (hasVolumeUp) &quot;next,volume_up&quot; else &quot;next,volume_down&quot;&#10;            ))&#10;        }&#10;&#10;        return when {&#10;            // Comandos de ayuda&#10;            containsAny(&quot;assistant_triggers_help&quot;) -&gt; IntentResult(&quot;help&quot;)&#10;&#10;            // Información contextual&#10;            containsAny(&quot;assistant_triggers_who_sings&quot;) -&gt; IntentResult(&quot;who_sings&quot;)&#10;            containsAny(&quot;assistant_triggers_what_album&quot;) -&gt; IntentResult(&quot;what_album&quot;)&#10;            containsAny(&quot;assistant_triggers_how_long&quot;) -&gt; IntentResult(&quot;how_long&quot;)&#10;&#10;            // Control de volumen&#10;            containsAny(&quot;assistant_triggers_mute&quot;) -&gt; IntentResult(&quot;mute&quot;)&#10;            containsAny(&quot;assistant_triggers_volume_up&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_up&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_down&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_down&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_set&quot;) -&gt; {&#10;                val level = extractNumber()&#10;                if (level != null) IntentResult(&quot;volume_set&quot;, 0.9f, mapOf(&quot;level&quot; to level.toString()))&#10;                else IntentResult(&quot;volume_set&quot;, 0.6f)&#10;            }&#10;&#10;            // Sleep timer&#10;            containsAny(&quot;assistant_triggers_sleep_timer&quot;) -&gt; {&#10;                val time = extractTime()&#10;                if (time != null) {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.9f, mapOf(&#10;                        &quot;value&quot; to time.first.toString(),&#10;                        &quot;unit&quot; to time.second&#10;                    ))&#10;                } else {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.6f)&#10;                }&#10;            }&#10;            containsAny(&quot;assistant_triggers_cancel_timer&quot;) -&gt; IntentResult(&quot;cancel_timer&quot;)&#10;&#10;            // Comandos de playlist&#10;            containsAny(&quot;assistant_triggers_create_playlist&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_create_playlist&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;create_playlist&quot;, 0.9f, mapOf(&quot;name&quot; to after))&#10;                else IntentResult(&quot;create_playlist&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_add_favorites&quot;) -&gt; IntentResult(&quot;add_favorites&quot;)&#10;            containsAny(&quot;assistant_triggers_shuffle&quot;) -&gt; IntentResult(&quot;shuffle&quot;)&#10;            containsAny(&quot;assistant_triggers_save_song&quot;) -&gt; IntentResult(&quot;save_song&quot;)&#10;&#10;            // Comandos naturales con género/artista&#10;            containsAny(&quot;assistant_triggers_play_genre&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_genre&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play_mood&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_mood&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to &quot;$after music&quot;))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;&#10;            // Comandos básicos existentes&#10;            containsAny(&quot;assistant_triggers_whats_playing&quot;) -&gt; IntentResult(&quot;whats_playing&quot;)&#10;            containsAny(&quot;assistant_triggers_next&quot;) -&gt; IntentResult(&quot;next&quot;)&#10;            containsAny(&quot;assistant_triggers_previous&quot;) -&gt; IntentResult(&quot;previous&quot;)&#10;            containsAny(&quot;assistant_triggers_pause&quot;) -&gt; IntentResult(&quot;pause&quot;)&#10;            containsAny(&quot;assistant_triggers_repeat&quot;) -&gt; IntentResult(&quot;repeat&quot;)&#10;            containsAny(&quot;assistant_triggers_add_queue&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_add_queue&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;add_queue&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;add_queue&quot;)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) {&#10;                    val cleanedQuery = cleanQuery(after)&#10;                    IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to cleanedQuery))&#10;                }&#10;                else IntentResult(&quot;play&quot;, 0.9f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_resume&quot;) -&gt; IntentResult(&quot;play&quot;)&#10;            containsAny(&quot;assistant_triggers_search&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_search&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;search&quot;, 0.95f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_settings&quot;) -&gt; IntentResult(&quot;settings&quot;)&#10;            else -&gt; {&#10;                if (!quoted.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to quoted))&#10;                else IntentResult(&quot;unknown&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun searchSpotifyTrack(query: String): SpotifyTrack? = withContext(Dispatchers.IO) {&#10;        val token = SpotifyTokenManager.getValidAccessToken(context) ?: return@withContext null&#10;        suspendCoroutine { cont -&gt;&#10;            SpotifyRepository.searchAll(token, query) { response, error -&gt;&#10;                if (error != null || response == null) cont.resume(null)&#10;                else cont.resume(response.tracks?.items?.firstOrNull())&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createTrackFromSpotify(query: String, playlistId: String): TrackEntity? {&#10;        val spotifyTrack = searchSpotifyTrack(query)&#10;        val searchQuery = if (spotifyTrack != null) {&#10;            &quot;${spotifyTrack.name} ${spotifyTrack.artists.joinToString(&quot; &quot;) { it.name }}&quot;&#10;        } else query&#10;&#10;        val videoId = withContext(Dispatchers.IO) {&#10;            try { YouTubeManager.searchVideoId(searchQuery) } catch (_: Exception) { null }&#10;        } ?: return null&#10;&#10;        return TrackEntity(&#10;            id = &quot;assistant_${videoId}_${System.currentTimeMillis()}&quot;,&#10;            playlistId = playlistId,&#10;            spotifyTrackId = spotifyTrack?.id ?: &quot;&quot;,&#10;            name = spotifyTrack?.name ?: query,&#10;            artists = spotifyTrack?.artists?.joinToString(&quot;, &quot;) { it.name } ?: &quot;&quot;,&#10;            youtubeVideoId = videoId,&#10;            audioUrl = null,&#10;            position = 0,&#10;            lastSyncTime = System.currentTimeMillis()&#10;        )&#10;    }&#10;&#10;    private fun getAvailableCommands(): List&lt;Pair&lt;String, String&gt;&gt; {&#10;        return listOf(&#10;            t(&quot;assistant_cmd_play&quot;) to t(&quot;assistant_resume_playback&quot;),&#10;            t(&quot;assistant_cmd_pause&quot;) to t(&quot;assistant_pause_playback&quot;),&#10;            t(&quot;assistant_cmd_next&quot;) to t(&quot;assistant_next_song&quot;),&#10;            t(&quot;assistant_cmd_previous&quot;) to t(&quot;assistant_previous_song&quot;),&#10;            t(&quot;assistant_cmd_play_song&quot;) to t(&quot;assistant_search_play&quot;),&#10;            t(&quot;assistant_cmd_search&quot;) to t(&quot;assistant_search_song&quot;),&#10;            t(&quot;assistant_cmd_add_queue&quot;) to t(&quot;assistant_add_queue&quot;),&#10;            t(&quot;assistant_cmd_repeat&quot;) to t(&quot;assistant_repeat_mode&quot;),&#10;            t(&quot;assistant_cmd_whats_playing&quot;) to t(&quot;assistant_current_song&quot;),&#10;            t(&quot;assistant_cmd_help&quot;) to t(&quot;assistant_see_commands&quot;),&#10;            // Nuevos comandos&#10;            t(&quot;assistant_cmd_volume&quot;) to t(&quot;assistant_volume_desc&quot;),&#10;            t(&quot;assistant_cmd_shuffle&quot;) to t(&quot;assistant_shuffle_desc&quot;),&#10;            t(&quot;assistant_cmd_favorites&quot;) to t(&quot;assistant_favorites_desc&quot;),&#10;            t(&quot;assistant_cmd_who_sings&quot;) to t(&quot;assistant_who_sings_desc&quot;),&#10;            t(&quot;assistant_cmd_sleep_timer&quot;) to t(&quot;assistant_sleep_timer_desc&quot;)&#10;        )&#10;    }&#10;&#10;    private fun getAudioManager(): AudioManager {&#10;        return context.getSystemService(Context.AUDIO_SERVICE) as AudioManager&#10;    }&#10;&#10;    private fun setVolume(level: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val newVolume = (level * maxVolume / 100).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun adjustVolume(delta: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        val change = (delta * maxVolume / 100).coerceAtLeast(1)&#10;        val newVolume = (currentVolume + change).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun getCurrentVolumePercent(): Int {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        return (currentVolume * 100 / maxVolume)&#10;    }&#10;&#10;    private fun startSleepTimer(minutes: Int, playerViewModel: PlayerViewModel) {&#10;        cancelSleepTimer()&#10;        sleepTimerEndTime = System.currentTimeMillis() + (minutes * 60 * 1000L)&#10;        sleepTimer = Timer().apply {&#10;            schedule(object : TimerTask() {&#10;                override fun run() {&#10;                    playerViewModel.pausePlayer()&#10;                    sleepTimer = null&#10;                    sleepTimerEndTime = 0&#10;                }&#10;            }, minutes * 60 * 1000L)&#10;        }&#10;    }&#10;&#10;    private fun cancelSleepTimer() {&#10;        sleepTimer?.cancel()&#10;        sleepTimer = null&#10;        sleepTimerEndTime = 0&#10;    }&#10;&#10;    fun getSleepTimerRemainingMinutes(): Int {&#10;        if (sleepTimerEndTime == 0L) return 0&#10;        val remaining = sleepTimerEndTime - System.currentTimeMillis()&#10;        return if (remaining &gt; 0) (remaining / 60000).toInt() else 0&#10;    }&#10;&#10;    private fun formatDuration(durationMs: Long): String {&#10;        val totalSeconds = durationMs / 1000&#10;        val minutes = totalSeconds / 60&#10;        val seconds = totalSeconds % 60&#10;        return &quot;$minutes:${seconds.toString().padStart(2, '0')}&quot;&#10;    }&#10;&#10;    suspend fun perform(result: IntentResult, playerViewModel: PlayerViewModel): String {&#10;        setState(AssistantState.PROCESSING)&#10;        lastRecognizedCommand = result.intent&#10;&#10;        return try {&#10;            when (result.intent) {&#10;                &quot;help&quot; -&gt; {&#10;                    val commands = getAvailableCommands()&#10;                    val list = commands.map { it.first }.joinToString(&quot; / &quot;)&#10;                    list&#10;                }&#10;                &quot;whats_playing&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_now_playing&quot;), track.name, artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;play&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.playPlayer() }&#10;                    t(&quot;assistant_playing&quot;)&#10;                }&#10;                &quot;pause&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.pausePlayer() }&#10;                    t(&quot;assistant_paused&quot;)&#10;                }&#10;                &quot;next&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                    t(&quot;assistant_next&quot;)&#10;                }&#10;                &quot;previous&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToPrevious() }&#10;                    t(&quot;assistant_previous&quot;)&#10;                }&#10;                &quot;repeat&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.updateRepeatMode() }&#10;                    t(&quot;assistant_repeat_changed&quot;)&#10;                }&#10;&#10;                // Información contextual&#10;                &quot;who_sings&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_artist_info&quot;), artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;what_album&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Intentar obtener info del álbum desde Spotify&#10;                        val spotifyTrack = if (track.spotifyTrackId.isNotBlank()) {&#10;                            searchSpotifyTrack(track.name)&#10;                        } else null&#10;&#10;                        val albumName = spotifyTrack?.album?.name ?: t(&quot;assistant_unknown_album&quot;)&#10;                        String.format(t(&quot;assistant_album_info&quot;), albumName)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;how_long&quot; -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player != null &amp;&amp; player.duration &gt; 0) {&#10;                        val duration = formatDuration(player.duration)&#10;                        val position = formatDuration(player.currentPosition)&#10;                        String.format(t(&quot;assistant_duration_info&quot;), position, duration)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;&#10;                // Control de volumen&#10;                &quot;mute&quot; -&gt; {&#10;                    setVolume(0)&#10;                    t(&quot;assistant_muted&quot;)&#10;                }&#10;                &quot;volume_up&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_down&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(-amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_set&quot; -&gt; {&#10;                    val level = result.entities[&quot;level&quot;]?.toIntOrNull()&#10;                    if (level != null) {&#10;                        setVolume(level.coerceIn(0, 100))&#10;                        String.format(t(&quot;assistant_volume_set_to&quot;), level)&#10;                    } else t(&quot;assistant_what_volume&quot;)&#10;                }&#10;&#10;                // Sleep timer&#10;                &quot;sleep_timer&quot; -&gt; {&#10;                    val value = result.entities[&quot;value&quot;]?.toIntOrNull()&#10;                    val unit = result.entities[&quot;unit&quot;] ?: &quot;minutes&quot;&#10;&#10;                    if (value != null) {&#10;                        val minutes = when (unit) {&#10;                            &quot;hours&quot; -&gt; value * 60&#10;                            &quot;absolute&quot; -&gt; {&#10;                                // Calcular minutos hasta la hora especificada&#10;                                val now = Calendar.getInstance()&#10;                                val target = Calendar.getInstance().apply {&#10;                                    set(Calendar.HOUR_OF_DAY, value / 60)&#10;                                    set(Calendar.MINUTE, value % 60)&#10;                                    set(Calendar.SECOND, 0)&#10;                                    if (before(now)) add(Calendar.DAY_OF_MONTH, 1)&#10;                                }&#10;                                ((target.timeInMillis - now.timeInMillis) / 60000).toInt()&#10;                            }&#10;                            else -&gt; value&#10;                        }&#10;                        startSleepTimer(minutes, playerViewModel)&#10;                        String.format(t(&quot;assistant_sleep_timer_set&quot;), minutes)&#10;                    } else t(&quot;assistant_what_time&quot;)&#10;                }&#10;                &quot;cancel_timer&quot; -&gt; {&#10;                    cancelSleepTimer()&#10;                    t(&quot;assistant_timer_cancelled&quot;)&#10;                }&#10;&#10;                // Comandos de playlist&#10;                &quot;shuffle&quot; -&gt; {&#10;                    val playlist = playerViewModel.currentPlaylist.value&#10;                    if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;                        val shuffled = playlist.shuffled()&#10;                        withContext(Dispatchers.Main) {&#10;                            playerViewModel.setCurrentPlaylist(shuffled, 0)&#10;                        }&#10;                        t(&quot;assistant_shuffled&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;add_favorites&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Guardar en favoritos usando Spotify API&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { success, _ -&gt;&#10;                                    // No hacemos nada con el resultado aquí&#10;                                }&#10;                            }&#10;                            String.format(t(&quot;assistant_added_favorites&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;save_song&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { _, _ -&gt; }&#10;                            }&#10;                            String.format(t(&quot;assistant_song_saved&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;create_playlist&quot; -&gt; {&#10;                    val name = result.entities[&quot;name&quot;]&#10;                    if (!name.isNullOrBlank()) {&#10;                        // TODO: Implementar creación de playlist&#10;                        String.format(t(&quot;assistant_playlist_created&quot;), name)&#10;                    } else t(&quot;assistant_what_playlist_name&quot;)&#10;                }&#10;&#10;                // Comandos compuestos&#10;                &quot;compound&quot; -&gt; {&#10;                    val actions = result.entities[&quot;actions&quot;]?.split(&quot;,&quot;) ?: emptyList()&#10;                    val results = mutableListOf&lt;String&gt;()&#10;                    for (action in actions) {&#10;                        when (action.trim()) {&#10;                            &quot;next&quot; -&gt; {&#10;                                withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                                results.add(t(&quot;assistant_next&quot;))&#10;                            }&#10;                            &quot;volume_up&quot; -&gt; {&#10;                                adjustVolume(10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                            &quot;volume_down&quot; -&gt; {&#10;                                adjustVolume(-10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                        }&#10;                    }&#10;                    results.joinToString(&quot;. &quot;)&#10;                }&#10;&#10;                &quot;settings&quot; -&gt; t(&quot;assistant_open_settings&quot;)&#10;                &quot;play_search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    Log.d(&quot;AssistantManager&quot;, &quot;play_search query: \&quot;$q\&quot;&quot;)&#10;                    if (q.isBlank()) return t(&quot;assistant_what_play&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_${System.currentTimeMillis()}&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val ok = withContext(Dispatchers.Main) {&#10;                        playerViewModel.initializePlayer()&#10;                        playerViewModel.setCurrentPlaylist(listOf(track), 0)&#10;                        try { playerViewModel.loadAudioFromTrack(track) } catch (_: Exception) { false }&#10;                    }&#10;                    if (ok) {&#10;                        val artists = track.artists.ifBlank { &quot;&quot; }&#10;                        if (artists.isNotBlank()) String.format(t(&quot;assistant_playing_song&quot;), track.name, artists)&#10;                        else String.format(t(&quot;assistant_playing_song_no_artist&quot;), track.name)&#10;                    } else String.format(t(&quot;assistant_error_play&quot;), q)&#10;                }&#10;                &quot;search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_search&quot;)&#10;                    val spotifyTrack = searchSpotifyTrack(q)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val artists = spotifyTrack.artists.joinToString(&quot;, &quot;) { it.name }&#10;                    String.format(t(&quot;assistant_found&quot;), spotifyTrack.name, artists)&#10;                }&#10;                &quot;add_queue&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_add&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_queue&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    withContext(Dispatchers.Main) { playerViewModel.addToQueue(track) }&#10;                    val artists = track.artists.ifBlank { &quot;&quot; }&#10;                    if (artists.isNotBlank()) String.format(t(&quot;assistant_added_queue&quot;), track.name, artists)&#10;                    else String.format(t(&quot;assistant_added_queue_no_artist&quot;), track.name)&#10;                }&#10;                else -&gt; t(&quot;assistant_not_understand&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AssistantManager&quot;, &quot;perform action error&quot;, e)&#10;            t(&quot;assistant_error&quot;)&#10;        }&#10;    }&#10;&#10;    fun close() {&#10;        cancelSleepTimer()&#10;        try { sessionIntent?.close() } catch (_: Exception) {}&#10;        try { sessionNer?.close() } catch (_: Exception) {}&#10;        sessionIntent = null&#10;        sessionNer = null&#10;        try { ortEnv = null } catch (_: Exception) {}&#10;        onnxAvailable = false&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.assistant&#10;&#10;import android.content.Context&#10;import android.media.AudioManager&#10;import android.util.Log&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.utils.SpotifyTokenManager&#10;import com.plyr.utils.Translations&#10;&#10;import java.util.Collections&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.Calendar&#10;&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;import ai.onnxruntime.OnnxTensor&#10;import ai.onnxruntime.OrtEnvironment&#10;import ai.onnxruntime.OrtSession&#10;&#10;/**&#10; * Lightweight on-device assistant manager with enhanced NLU capabilities.&#10; */&#10;class AssistantManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AssistantManager&quot;&#10;&#10;        // Umbral de similitud para fuzzy matching (0.0 - 1.0)&#10;        private const val FUZZY_THRESHOLD = 0.7f&#10;    }&#10;&#10;    data class IntentResult(&#10;        val intent: String,&#10;        val score: Float = 1.0f,&#10;        val entities: Map&lt;String, String&gt; = emptyMap()&#10;    )&#10;&#10;    // Estado del asistente&#10;    enum class AssistantState {&#10;        IDLE, LISTENING, PROCESSING, SPEAKING&#10;    }&#10;&#10;    private var onnxAvailable = false&#10;    private var ortEnv: OrtEnvironment? = null&#10;    private var sessionIntent: OrtSession? = null&#10;    private var sessionNer: OrtSession? = null&#10;&#10;    // Sleep timer&#10;    private var sleepTimer: Timer? = null&#10;    private var sleepTimerEndTime: Long = 0&#10;&#10;    // Estado actual&#10;    var currentState: AssistantState = AssistantState.IDLE&#10;        private set&#10;&#10;    // Callback para cambios de estado&#10;    var onStateChange: ((AssistantState) -&gt; Unit)? = null&#10;&#10;    // Último comando entendido (para feedback visual)&#10;    var lastRecognizedCommand: String = &quot;&quot;&#10;        private set&#10;&#10;    private fun t(key: String) = Translations.get(context, key)&#10;&#10;    private fun getTriggers(key: String): List&lt;String&gt; {&#10;        return t(key).split(&quot;|&quot;).map { it.trim().lowercase() }&#10;    }&#10;&#10;    fun setState(state: AssistantState) {&#10;        currentState = state&#10;        onStateChange?.invoke(state)&#10;    }&#10;&#10;    // ==================== FUZZY MATCHING ====================&#10;&#10;    /**&#10;     * Calcula la distancia de Levenshtein entre dos strings&#10;     */&#10;    private fun levenshteinDistance(s1: String, s2: String): Int {&#10;        val m = s1.length&#10;        val n = s2.length&#10;        val dp = Array(m + 1) { IntArray(n + 1) }&#10;&#10;        for (i in 0..m) dp[i][0] = i&#10;        for (j in 0..n) dp[0][j] = j&#10;&#10;        for (i in 1..m) {&#10;            for (j in 1..n) {&#10;                dp[i][j] = if (s1[i-1] == s2[j-1]) {&#10;                    dp[i-1][j-1]&#10;                } else {&#10;                    minOf(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1&#10;                }&#10;            }&#10;        }&#10;        return dp[m][n]&#10;    }&#10;&#10;    /**&#10;     * Calcula similitud entre dos strings (0.0 - 1.0)&#10;     */&#10;    private fun similarity(s1: String, s2: String): Float {&#10;        val maxLen = maxOf(s1.length, s2.length)&#10;        if (maxLen == 0) return 1.0f&#10;        return 1.0f - (levenshteinDistance(s1, s2).toFloat() / maxLen)&#10;    }&#10;&#10;    /**&#10;     * Busca si alguna palabra del texto es similar a algún trigger (fuzzy match)&#10;     */&#10;    private fun fuzzyContains(text: String, triggers: List&lt;String&gt;): Pair&lt;Boolean, Float&gt; {&#10;        val words = text.lowercase().split(&quot; &quot;, &quot;,&quot;, &quot;.&quot;, &quot;?&quot;, &quot;!&quot;)&#10;        var bestScore = 0f&#10;&#10;        for (trigger in triggers) {&#10;            // Match exacto&#10;            if (text.lowercase().contains(trigger)) {&#10;                return Pair(true, 1.0f)&#10;            }&#10;&#10;            // Fuzzy match por palabras&#10;            val triggerWords = trigger.split(&quot; &quot;)&#10;            for (word in words) {&#10;                if (word.length &lt; 3) continue // Ignorar palabras muy cortas&#10;&#10;                for (tw in triggerWords) {&#10;                    if (tw.length &lt; 3) continue&#10;                    val sim = similarity(word, tw)&#10;                    if (sim &gt; bestScore) bestScore = sim&#10;                }&#10;            }&#10;&#10;            // También comparar frases completas si el trigger tiene múltiples palabras&#10;            if (triggerWords.size &gt; 1) {&#10;                val sim = similarity(text.lowercase(), trigger)&#10;                if (sim &gt; bestScore) bestScore = sim&#10;            }&#10;        }&#10;&#10;        return Pair(bestScore &gt;= FUZZY_THRESHOLD, bestScore)&#10;    }&#10;&#10;    // ==================== SEMANTIC PATTERNS ====================&#10;&#10;    /**&#10;     * Patrones semánticos para detectar intenciones de forma más natural&#10;     */&#10;    private data class SemanticPattern(&#10;        val intent: String,&#10;        val patterns: List&lt;Regex&gt;,&#10;        val entityExtractor: ((MatchResult) -&gt; Map&lt;String, String&gt;)? = null&#10;    )&#10;&#10;    private val semanticPatterns: List&lt;SemanticPattern&gt; by lazy {&#10;        listOf(&#10;            // Reproducir música - patrones muy flexibles&#10;            SemanticPattern(&#10;                &quot;play_search&quot;,&#10;                listOf(&#10;                    // &quot;quiero escuchar X&quot;, &quot;I want to hear X&quot;, &quot;me apetece X&quot;&#10;                    Regex(&quot;(?:quiero|want|wanna|me apetece|me gustaría|i'd like to).*(?:escuchar|oír|oir|hear|listen)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;ponme X&quot;, &quot;play X&quot;, &quot;pon X&quot;&#10;                    Regex(&quot;(?:ponme|pon|play|put on|reproduce|toca)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;algo de X&quot;, &quot;something from X&quot;, &quot;música de X&quot;&#10;                    Regex(&quot;(?:algo|something|anything|música|music)\\s+(?:de|from|by|del)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;X por favor&quot;, &quot;X please&quot;&#10;                    Regex(&quot;(.+?)\\s+(?:por favor|please|porfavor|porfa)$&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;escucha X&quot;, &quot;reproduce X&quot;&#10;                    Regex(&quot;(?:escucha|reproduce|listen to)\\s+(.+)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ) { match -&gt;&#10;                val query = cleanQueryText(match.groupValues[1])&#10;                if (query.isNotBlank()) mapOf(&quot;query&quot; to query) else emptyMap()&#10;            },&#10;&#10;            // Control de reproducción&#10;            SemanticPattern(&#10;                &quot;pause&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:para|stop|detén|deten|calla|silencio|quiet|pause|pausa|wait|espera)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;play&quot;,&#10;                listOf(&#10;                    Regex(&quot;^(?:play|resume|continua|continue|sigue|dale|go|start|empieza|comienza)$&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:sigue|continúa|resume)\\s*(?:la música|playing|reproduciendo)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;next&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:siguiente|next|skip|salta|pasa|otra|another|cambia|change)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;previous&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:anterior|previous|back|atrás|atras|vuelve|go back|última|ultima|last)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Volumen - IMPORTANTE: volume_set debe ir ANTES que volume_up/down&#10;            SemanticPattern(&#10;                &quot;volume_set&quot;,&#10;                listOf(&#10;                    // &quot;volumen al 50&quot;, &quot;volume to 50&quot;, &quot;set volume to 50&quot;&#10;                    Regex(&quot;(?:volumen|volume|sonido|sound)\\s*(?:al?|to|at)\\s*(\\d+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;pon el volumen al 50&quot;, &quot;set volume at 50&quot;&#10;                    Regex(&quot;(?:pon|set|put).*(?:volumen|volume).*(?:al?|to|at)\\s*(\\d+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;50 percent volume&quot;, &quot;50% volume&quot;&#10;                    Regex(&quot;(\\d+)\\s*(?:%|percent|por ?ciento)?\\s*(?:de )?(?:volumen|volume)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;volumen 50&quot;, &quot;volume 50&quot; (número después de volumen)&#10;                    Regex(&quot;(?:volumen|volume)\\s+(\\d+)(?:\\s*%)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ) { match -&gt;&#10;                val level = match.groupValues.getOrNull(1)?.toIntOrNull()&#10;                if (level != null) mapOf(&quot;level&quot; to level.toString()) else emptyMap()&#10;            },&#10;&#10;            SemanticPattern(&#10;                &quot;volume_up&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:sube|subir|más alto|louder|turn up|volume up|aumenta|increase).*(?:volumen|volume|sonido|sound)?&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:volumen|volume|sonido).*(?:arriba|up|más|more|alto)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;volume_down&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:baja|bajar|más bajo|quieter|softer|turn down|volume down|reduce|disminuye).*(?:volumen|volume|sonido|sound)?&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:volumen|volume|sonido).*(?:abajo|down|menos|less|bajo)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Información&#10;            SemanticPattern(&#10;                &quot;whats_playing&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:qué|que|what|which).*(?:suena|canción|song|playing|sonando|escuchando|track)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:cómo|como|how).*(?:llama|call|nombre|name).*(?:canción|song|esta|this)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:dime|tell me).*(?:canción|song|qué|what)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;who_sings&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:quién|quien|who).*(?:canta|sings|artista|artist|interpreta)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:de quién|de quien|whose|by whom).*(?:es|is).*(?:canción|song|esta|this)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Shuffle&#10;            SemanticPattern(&#10;                &quot;shuffle&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:mezcla|shuffle|random|aleatorio|mix|revuelve|desordena)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Ayuda&#10;            SemanticPattern(&#10;                &quot;help&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:ayuda|help|comandos|commands|qué puedo|what can|opciones|options)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            )&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Limpia el texto de query eliminando palabras innecesarias&#10;     */&#10;    private fun cleanQueryText(query: String): String {&#10;        val stopWords = listOf(&#10;            // English&#10;            &quot;something&quot;, &quot;anything&quot;, &quot;some&quot;, &quot;a&quot;, &quot;the&quot;, &quot;from&quot;, &quot;by&quot;, &quot;of&quot;,&#10;            &quot;please&quot;, &quot;pls&quot;, &quot;plz&quot;, &quot;thanks&quot;, &quot;thank you&quot;,&#10;            &quot;i want&quot;, &quot;i wanna&quot;, &quot;i'd like&quot;, &quot;can you&quot;, &quot;could you&quot;,&#10;            &quot;play me&quot;, &quot;put on&quot;, &quot;give me&quot;,&#10;            // Spanish&#10;            &quot;algo&quot;, &quot;alguna&quot;, &quot;algún&quot;, &quot;algun&quot;, &quot;una&quot;, &quot;un&quot;, &quot;el&quot;, &quot;la&quot;, &quot;los&quot;, &quot;las&quot;,&#10;            &quot;de&quot;, &quot;del&quot;, &quot;por favor&quot;, &quot;porfa&quot;, &quot;porfavor&quot;, &quot;gracias&quot;,&#10;            &quot;quiero&quot;, &quot;quisiera&quot;, &quot;me gustaría&quot;, &quot;puedes&quot;, &quot;podrías&quot;,&#10;            &quot;ponme&quot;, &quot;dame&quot;, &quot;pon&quot;,&#10;            // Catalan&#10;            &quot;alguna cosa&quot;, &quot;una&quot;, &quot;un&quot;, &quot;el&quot;, &quot;la&quot;, &quot;els&quot;, &quot;les&quot;,&#10;            &quot;de&quot;, &quot;del&quot;, &quot;si us plau&quot;, &quot;sisplau&quot;, &quot;gràcies&quot;&#10;        )&#10;&#10;        var cleaned = query.lowercase().trim()&#10;&#10;        // Eliminar stop words del inicio&#10;        for (sw in stopWords.sortedByDescending { it.length }) {&#10;            if (cleaned.startsWith(&quot;$sw &quot;)) {&#10;                cleaned = cleaned.removePrefix(&quot;$sw &quot;).trim()&#10;            }&#10;        }&#10;&#10;        // Eliminar stop words del final&#10;        for (sw in stopWords.sortedByDescending { it.length }) {&#10;            if (cleaned.endsWith(&quot; $sw&quot;)) {&#10;                cleaned = cleaned.removeSuffix(&quot; $sw&quot;).trim()&#10;            }&#10;        }&#10;&#10;        return cleaned.trim()&#10;    }&#10;&#10;    /**&#10;     * Intenta hacer match con patrones semánticos&#10;     */&#10;    private fun matchSemanticPatterns(text: String): IntentResult? {&#10;        for (pattern in semanticPatterns) {&#10;            for (regex in pattern.patterns) {&#10;                val match = regex.find(text)&#10;                if (match != null) {&#10;                    val entities = pattern.entityExtractor?.invoke(match) ?: emptyMap()&#10;                    Log.d(TAG, &quot;Semantic match: ${pattern.intent} with entities: $entities&quot;)&#10;                    return IntentResult(pattern.intent, 0.85f, entities)&#10;                }&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    // ==================== INTENT INFERENCE ====================&#10;&#10;    init {&#10;        try {&#10;            Class.forName(&quot;ai.onnxruntime.OnnxTensor&quot;)&#10;            onnxAvailable = true&#10;        } catch (_: Exception) {&#10;            onnxAvailable = false&#10;        }&#10;&#10;        if (onnxAvailable) {&#10;            try {&#10;                ortEnv = OrtEnvironment.getEnvironment()&#10;                val am = context.assets&#10;                fun loadSession(assetName: String): OrtSession? {&#10;                    return try {&#10;                        val bytes = am.open(assetName).use { it.readBytes() }&#10;                        ortEnv?.createSession(bytes)&#10;                    } catch (ex: Exception) {&#10;                        // Models are optional - silently skip if not found&#10;                        Log.v(TAG, &quot;Optional model $assetName not available&quot;)&#10;                        null&#10;                    }&#10;                }&#10;                sessionIntent = loadSession(&quot;assistant_intent.onnx&quot;)&#10;                sessionNer = loadSession(&quot;assistant_ner.onnx&quot;)&#10;                if (sessionIntent == null &amp;&amp; sessionNer == null) {&#10;                    onnxAvailable = false&#10;                    Log.d(TAG, &quot;ONNX models not found, using rule-based NLU&quot;)&#10;                }&#10;            } catch (ex: Throwable) {&#10;                Log.d(TAG, &quot;ONNX runtime not available, using rule-based NLU&quot;)&#10;                onnxAvailable = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun analyze(text: String): IntentResult {&#10;        val trimmed = text.trim()&#10;        if (trimmed.isEmpty()) return IntentResult(&quot;none&quot;, 1f)&#10;&#10;        Log.d(TAG, &quot;Analyzing: \&quot;$trimmed\&quot;&quot;)&#10;&#10;        // 1. Intentar con ONNX si está disponible&#10;        if (onnxAvailable &amp;&amp; sessionIntent != null &amp;&amp; ortEnv != null) {&#10;            try {&#10;                val inputName = sessionIntent!!.inputNames.iterator().next()&#10;                val tensor = OnnxTensor.createTensor(ortEnv!!, arrayOf(trimmed))&#10;                val res = sessionIntent!!.run(Collections.singletonMap(inputName, tensor))&#10;                try {&#10;                    if (res.size() &gt; 0) {&#10;                        val first = res.get(0)&#10;                        val value = first.value&#10;                        if (value is Array&lt;*&gt;) {&#10;                            val maybe = value.firstOrNull() as? String&#10;                            if (!maybe.isNullOrBlank()) {&#10;                                Log.d(TAG, &quot;ONNX result: $maybe&quot;)&#10;                                return IntentResult(maybe, 0.95f)&#10;                            }&#10;                        } else if (value is String) {&#10;                            if (value.isNotBlank()) {&#10;                                Log.d(TAG, &quot;ONNX result: $value&quot;)&#10;                                return IntentResult(value, 0.95f)&#10;                            }&#10;                        }&#10;                    }&#10;                } finally {&#10;                    try { res.close() } catch (_: Exception) {}&#10;                    try { tensor.close() } catch (_: Exception) {}&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.i(TAG, &quot;ONNX intent inference failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        // 2. Intentar con patrones semánticos (más flexibles)&#10;        val semanticResult = matchSemanticPatterns(trimmed)&#10;        if (semanticResult != null) {&#10;            return semanticResult&#10;        }&#10;&#10;        // 3. Fallback a análisis basado en reglas con fuzzy matching&#10;        return ruleBasedAnalysis(trimmed)&#10;    }&#10;&#10;    private fun ruleBasedAnalysis(text: String): IntentResult {&#10;        val lower = text.lowercase()&#10;&#10;        val quoteRegex = &quot;\&quot;(.*?)\&quot;&quot;.toRegex()&#10;        val quoted = quoteRegex.find(text)?.groups?.get(1)?.value&#10;&#10;        fun containsAny(triggerKey: String): Boolean {&#10;            val triggers = getTriggers(triggerKey)&#10;            // Primero intentar match exacto&#10;            if (triggers.any { lower.contains(it) }) return true&#10;            // Luego fuzzy match&#10;            val (found, score) = fuzzyContains(lower, triggers)&#10;            if (found) {&#10;                Log.d(TAG, &quot;Fuzzy match for $triggerKey with score $score&quot;)&#10;            }&#10;            return found&#10;        }&#10;&#10;        fun containsAnyExact(triggerKey: String): Boolean {&#10;            return getTriggers(triggerKey).any { lower.contains(it) }&#10;        }&#10;&#10;        fun extractAfter(triggerKey: String): String? {&#10;            val triggers = getTriggers(triggerKey).map { &quot;$it &quot; }&#10;            for (k in triggers) {&#10;                val idx = lower.indexOf(k)&#10;                if (idx &gt;= 0) {&#10;                    return text.substring(idx + k.length).trim().trim('&quot;', '\'')&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Extractor de entidades mejorado&#10;        fun extractMusicEntity(text: String): String? {&#10;            // Patrones para extraer artista/canción&#10;            val patterns = listOf(&#10;                // &quot;de X&quot;, &quot;by X&quot;, &quot;from X&quot;&#10;                Regex(&quot;(?:de|by|from|del)\\s+(.+?)(?:\\s+(?:por favor|please))?$&quot;, RegexOption.IGNORE_CASE),&#10;                // Contenido entre comillas&#10;                Regex(&quot;\&quot;(.+?)\&quot;&quot;),&#10;                Regex(&quot;'(.+?)'&quot;),&#10;                // Después de verbos de reproducción&#10;                Regex(&quot;(?:play|pon|reproduce|escucha|toca)\\s+(.+?)(?:\\s+(?:por favor|please))?$&quot;, RegexOption.IGNORE_CASE)&#10;            )&#10;&#10;            for (pattern in patterns) {&#10;                val match = pattern.find(text)&#10;                if (match != null &amp;&amp; match.groupValues.size &gt; 1) {&#10;                    val extracted = cleanQueryText(match.groupValues[1])&#10;                    if (extracted.isNotBlank() &amp;&amp; extracted.length &gt; 1) {&#10;                        return extracted&#10;                    }&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Limpiar frases comunes que no son parte del artista/canción&#10;        fun cleanQuery(query: String): String {&#10;            return cleanQueryText(query)&#10;        }&#10;&#10;        // Extraer número del texto&#10;        fun extractNumber(): Int? {&#10;            val numberRegex = &quot;(\\d+)&quot;.toRegex()&#10;            return numberRegex.find(lower)?.groups?.get(1)?.value?.toIntOrNull()&#10;        }&#10;&#10;        // Extraer tiempo para sleep timer&#10;        fun extractTime(): Pair&lt;Int, String&gt;? {&#10;            val minutesRegex = &quot;(\\d+)\\s*(minuto|minute|min)&quot;.toRegex()&#10;            val hoursRegex = &quot;(\\d+)\\s*(hora|hour|h)&quot;.toRegex()&#10;            val atTimeRegex = &quot;(\\d{1,2})[:\\.]?(\\d{2})?&quot;.toRegex()&#10;&#10;            minutesRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;minutes&quot;)&#10;            }&#10;            hoursRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;hours&quot;)&#10;            }&#10;            if (lower.contains(&quot;a las&quot;) || lower.contains(&quot;at &quot;)) {&#10;                atTimeRegex.find(lower)?.let {&#10;                    val hour = it.groups[1]?.value?.toIntOrNull() ?: return null&#10;                    val minute = it.groups[2]?.value?.toIntOrNull() ?: 0&#10;                    return Pair(hour * 60 + minute, &quot;absolute&quot;)&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Detectar comandos compuestos&#10;        val hasNext = containsAnyExact(&quot;assistant_triggers_next&quot;)&#10;        val hasVolumeUp = containsAnyExact(&quot;assistant_triggers_volume_up&quot;)&#10;        val hasVolumeDown = containsAnyExact(&quot;assistant_triggers_volume_down&quot;)&#10;&#10;        if (hasNext &amp;&amp; (hasVolumeUp || hasVolumeDown)) {&#10;            return IntentResult(&quot;compound&quot;, 0.9f, mapOf(&#10;                &quot;actions&quot; to if (hasVolumeUp) &quot;next,volume_up&quot; else &quot;next,volume_down&quot;&#10;            ))&#10;        }&#10;&#10;        return when {&#10;            // Comandos de ayuda&#10;            containsAny(&quot;assistant_triggers_help&quot;) -&gt; IntentResult(&quot;help&quot;)&#10;&#10;            // Información contextual&#10;            containsAny(&quot;assistant_triggers_who_sings&quot;) -&gt; IntentResult(&quot;who_sings&quot;)&#10;            containsAny(&quot;assistant_triggers_what_album&quot;) -&gt; IntentResult(&quot;what_album&quot;)&#10;            containsAny(&quot;assistant_triggers_how_long&quot;) -&gt; IntentResult(&quot;how_long&quot;)&#10;&#10;            // Control de volumen&#10;            containsAny(&quot;assistant_triggers_mute&quot;) -&gt; IntentResult(&quot;mute&quot;)&#10;            containsAny(&quot;assistant_triggers_volume_up&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_up&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_down&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_down&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_set&quot;) -&gt; {&#10;                val level = extractNumber()&#10;                if (level != null) IntentResult(&quot;volume_set&quot;, 0.9f, mapOf(&quot;level&quot; to level.toString()))&#10;                else IntentResult(&quot;volume_set&quot;, 0.6f)&#10;            }&#10;&#10;            // Sleep timer&#10;            containsAny(&quot;assistant_triggers_sleep_timer&quot;) -&gt; {&#10;                val time = extractTime()&#10;                if (time != null) {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.9f, mapOf(&#10;                        &quot;value&quot; to time.first.toString(),&#10;                        &quot;unit&quot; to time.second&#10;                    ))&#10;                } else {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.6f)&#10;                }&#10;            }&#10;            containsAny(&quot;assistant_triggers_cancel_timer&quot;) -&gt; IntentResult(&quot;cancel_timer&quot;)&#10;&#10;            // Comandos de playlist&#10;            containsAny(&quot;assistant_triggers_create_playlist&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_create_playlist&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;create_playlist&quot;, 0.9f, mapOf(&quot;name&quot; to after))&#10;                else IntentResult(&quot;create_playlist&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_add_favorites&quot;) -&gt; IntentResult(&quot;add_favorites&quot;)&#10;            containsAny(&quot;assistant_triggers_shuffle&quot;) -&gt; IntentResult(&quot;shuffle&quot;)&#10;            containsAny(&quot;assistant_triggers_save_song&quot;) -&gt; IntentResult(&quot;save_song&quot;)&#10;&#10;            // Comandos naturales con género/artista&#10;            containsAny(&quot;assistant_triggers_play_genre&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_genre&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play_mood&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_mood&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to &quot;$after music&quot;))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;&#10;            // Comandos básicos existentes&#10;            containsAny(&quot;assistant_triggers_whats_playing&quot;) -&gt; IntentResult(&quot;whats_playing&quot;)&#10;            containsAny(&quot;assistant_triggers_next&quot;) -&gt; IntentResult(&quot;next&quot;)&#10;            containsAny(&quot;assistant_triggers_previous&quot;) -&gt; IntentResult(&quot;previous&quot;)&#10;            containsAny(&quot;assistant_triggers_pause&quot;) -&gt; IntentResult(&quot;pause&quot;)&#10;            containsAny(&quot;assistant_triggers_repeat&quot;) -&gt; IntentResult(&quot;repeat&quot;)&#10;            containsAny(&quot;assistant_triggers_add_queue&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_add_queue&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;add_queue&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;add_queue&quot;)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play&quot;) ?: quoted ?: extractMusicEntity(text)&#10;                if (!after.isNullOrBlank()) {&#10;                    val cleanedQuery = cleanQuery(after)&#10;                    if (cleanedQuery.isNotBlank()) {&#10;                        IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to cleanedQuery))&#10;                    } else {&#10;                        IntentResult(&quot;play&quot;, 0.9f)&#10;                    }&#10;                }&#10;                else IntentResult(&quot;play&quot;, 0.9f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_resume&quot;) -&gt; IntentResult(&quot;play&quot;)&#10;            containsAny(&quot;assistant_triggers_search&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_search&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;search&quot;, 0.95f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_settings&quot;) -&gt; IntentResult(&quot;settings&quot;)&#10;&#10;            // Fallback: si hay comillas, asumir que quiere reproducir&#10;            !quoted.isNullOrBlank() -&gt; IntentResult(&quot;play_search&quot;, 0.8f, mapOf(&quot;query&quot; to quoted))&#10;&#10;            // Último intento: extraer entidad musical del texto completo&#10;            else -&gt; {&#10;                val entity = extractMusicEntity(text)&#10;                if (!entity.isNullOrBlank()) {&#10;                    Log.d(TAG, &quot;Fallback entity extraction: $entity&quot;)&#10;                    IntentResult(&quot;play_search&quot;, 0.7f, mapOf(&quot;query&quot; to entity))&#10;                } else {&#10;                    IntentResult(&quot;unknown&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun searchSpotifyTrack(query: String): SpotifyTrack? = withContext(Dispatchers.IO) {&#10;        val token = SpotifyTokenManager.getValidAccessToken(context) ?: return@withContext null&#10;        suspendCoroutine { cont -&gt;&#10;            SpotifyRepository.searchAll(token, query) { response, error -&gt;&#10;                if (error != null || response == null) cont.resume(null)&#10;                else cont.resume(response.tracks?.items?.firstOrNull())&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createTrackFromSpotify(query: String, playlistId: String): TrackEntity? {&#10;        val spotifyTrack = searchSpotifyTrack(query)&#10;        val searchQuery = if (spotifyTrack != null) {&#10;            &quot;${spotifyTrack.name} ${spotifyTrack.artists.joinToString(&quot; &quot;) { it.name }}&quot;&#10;        } else query&#10;&#10;        val videoId = withContext(Dispatchers.IO) {&#10;            try { YouTubeManager.searchVideoId(searchQuery) } catch (_: Exception) { null }&#10;        } ?: return null&#10;&#10;        return TrackEntity(&#10;            id = &quot;assistant_${videoId}_${System.currentTimeMillis()}&quot;,&#10;            playlistId = playlistId,&#10;            spotifyTrackId = spotifyTrack?.id ?: &quot;&quot;,&#10;            name = spotifyTrack?.name ?: query,&#10;            artists = spotifyTrack?.artists?.joinToString(&quot;, &quot;) { it.name } ?: &quot;&quot;,&#10;            youtubeVideoId = videoId,&#10;            audioUrl = null,&#10;            position = 0,&#10;            lastSyncTime = System.currentTimeMillis()&#10;        )&#10;    }&#10;&#10;    private fun getAvailableCommands(): List&lt;Pair&lt;String, String&gt;&gt; {&#10;        return listOf(&#10;            t(&quot;assistant_cmd_play&quot;) to t(&quot;assistant_resume_playback&quot;),&#10;            t(&quot;assistant_cmd_pause&quot;) to t(&quot;assistant_pause_playback&quot;),&#10;            t(&quot;assistant_cmd_next&quot;) to t(&quot;assistant_next_song&quot;),&#10;            t(&quot;assistant_cmd_previous&quot;) to t(&quot;assistant_previous_song&quot;),&#10;            t(&quot;assistant_cmd_play_song&quot;) to t(&quot;assistant_search_play&quot;),&#10;            t(&quot;assistant_cmd_search&quot;) to t(&quot;assistant_search_song&quot;),&#10;            t(&quot;assistant_cmd_add_queue&quot;) to t(&quot;assistant_add_queue&quot;),&#10;            t(&quot;assistant_cmd_repeat&quot;) to t(&quot;assistant_repeat_mode&quot;),&#10;            t(&quot;assistant_cmd_whats_playing&quot;) to t(&quot;assistant_current_song&quot;),&#10;            t(&quot;assistant_cmd_help&quot;) to t(&quot;assistant_see_commands&quot;),&#10;            // Nuevos comandos&#10;            t(&quot;assistant_cmd_volume&quot;) to t(&quot;assistant_volume_desc&quot;),&#10;            t(&quot;assistant_cmd_shuffle&quot;) to t(&quot;assistant_shuffle_desc&quot;),&#10;            t(&quot;assistant_cmd_favorites&quot;) to t(&quot;assistant_favorites_desc&quot;),&#10;            t(&quot;assistant_cmd_who_sings&quot;) to t(&quot;assistant_who_sings_desc&quot;),&#10;            t(&quot;assistant_cmd_sleep_timer&quot;) to t(&quot;assistant_sleep_timer_desc&quot;)&#10;        )&#10;    }&#10;&#10;    private fun getAudioManager(): AudioManager {&#10;        return context.getSystemService(Context.AUDIO_SERVICE) as AudioManager&#10;    }&#10;&#10;    private fun setVolume(level: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val newVolume = (level * maxVolume / 100).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun adjustVolume(delta: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        val change = (delta * maxVolume / 100).coerceAtLeast(1)&#10;        val newVolume = (currentVolume + change).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun getCurrentVolumePercent(): Int {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        return (currentVolume * 100 / maxVolume)&#10;    }&#10;&#10;    private fun startSleepTimer(minutes: Int, playerViewModel: PlayerViewModel) {&#10;        cancelSleepTimer()&#10;        sleepTimerEndTime = System.currentTimeMillis() + (minutes * 60 * 1000L)&#10;        sleepTimer = Timer().apply {&#10;            schedule(object : TimerTask() {&#10;                override fun run() {&#10;                    playerViewModel.pausePlayer()&#10;                    sleepTimer = null&#10;                    sleepTimerEndTime = 0&#10;                }&#10;            }, minutes * 60 * 1000L)&#10;        }&#10;    }&#10;&#10;    private fun cancelSleepTimer() {&#10;        sleepTimer?.cancel()&#10;        sleepTimer = null&#10;        sleepTimerEndTime = 0&#10;    }&#10;&#10;    fun getSleepTimerRemainingMinutes(): Int {&#10;        if (sleepTimerEndTime == 0L) return 0&#10;        val remaining = sleepTimerEndTime - System.currentTimeMillis()&#10;        return if (remaining &gt; 0) (remaining / 60000).toInt() else 0&#10;    }&#10;&#10;    private fun formatDuration(durationMs: Long): String {&#10;        val totalSeconds = durationMs / 1000&#10;        val minutes = totalSeconds / 60&#10;        val seconds = totalSeconds % 60&#10;        return &quot;$minutes:${seconds.toString().padStart(2, '0')}&quot;&#10;    }&#10;&#10;    suspend fun perform(result: IntentResult, playerViewModel: PlayerViewModel): String {&#10;        setState(AssistantState.PROCESSING)&#10;        lastRecognizedCommand = result.intent&#10;&#10;        return try {&#10;            when (result.intent) {&#10;                &quot;help&quot; -&gt; {&#10;                    val commands = getAvailableCommands()&#10;                    val list = commands.map { it.first }.joinToString(&quot; / &quot;)&#10;                    list&#10;                }&#10;                &quot;whats_playing&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_now_playing&quot;), track.name, artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;play&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.playPlayer() }&#10;                    t(&quot;assistant_playing&quot;)&#10;                }&#10;                &quot;pause&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.pausePlayer() }&#10;                    t(&quot;assistant_paused&quot;)&#10;                }&#10;                &quot;next&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                    t(&quot;assistant_next&quot;)&#10;                }&#10;                &quot;previous&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToPrevious() }&#10;                    t(&quot;assistant_previous&quot;)&#10;                }&#10;                &quot;repeat&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.updateRepeatMode() }&#10;                    t(&quot;assistant_repeat_changed&quot;)&#10;                }&#10;&#10;                // Información contextual&#10;                &quot;who_sings&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_artist_info&quot;), artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;what_album&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Intentar obtener info del álbum desde Spotify&#10;                        val spotifyTrack = if (track.spotifyTrackId.isNotBlank()) {&#10;                            searchSpotifyTrack(track.name)&#10;                        } else null&#10;&#10;                        val albumName = spotifyTrack?.album?.name ?: t(&quot;assistant_unknown_album&quot;)&#10;                        String.format(t(&quot;assistant_album_info&quot;), albumName)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;how_long&quot; -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player != null &amp;&amp; player.duration &gt; 0) {&#10;                        val duration = formatDuration(player.duration)&#10;                        val position = formatDuration(player.currentPosition)&#10;                        String.format(t(&quot;assistant_duration_info&quot;), position, duration)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;&#10;                // Control de volumen&#10;                &quot;mute&quot; -&gt; {&#10;                    setVolume(0)&#10;                    t(&quot;assistant_muted&quot;)&#10;                }&#10;                &quot;volume_up&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_down&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(-amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_set&quot; -&gt; {&#10;                    val level = result.entities[&quot;level&quot;]?.toIntOrNull()&#10;                    if (level != null) {&#10;                        setVolume(level.coerceIn(0, 100))&#10;                        String.format(t(&quot;assistant_volume_set_to&quot;), level)&#10;                    } else t(&quot;assistant_what_volume&quot;)&#10;                }&#10;&#10;                // Sleep timer&#10;                &quot;sleep_timer&quot; -&gt; {&#10;                    val value = result.entities[&quot;value&quot;]?.toIntOrNull()&#10;                    val unit = result.entities[&quot;unit&quot;] ?: &quot;minutes&quot;&#10;&#10;                    if (value != null) {&#10;                        val minutes = when (unit) {&#10;                            &quot;hours&quot; -&gt; value * 60&#10;                            &quot;absolute&quot; -&gt; {&#10;                                // Calcular minutos hasta la hora especificada&#10;                                val now = Calendar.getInstance()&#10;                                val target = Calendar.getInstance().apply {&#10;                                    set(Calendar.HOUR_OF_DAY, value / 60)&#10;                                    set(Calendar.MINUTE, value % 60)&#10;                                    set(Calendar.SECOND, 0)&#10;                                    if (before(now)) add(Calendar.DAY_OF_MONTH, 1)&#10;                                }&#10;                                ((target.timeInMillis - now.timeInMillis) / 60000).toInt()&#10;                            }&#10;                            else -&gt; value&#10;                        }&#10;                        startSleepTimer(minutes, playerViewModel)&#10;                        String.format(t(&quot;assistant_sleep_timer_set&quot;), minutes)&#10;                    } else t(&quot;assistant_what_time&quot;)&#10;                }&#10;                &quot;cancel_timer&quot; -&gt; {&#10;                    cancelSleepTimer()&#10;                    t(&quot;assistant_timer_cancelled&quot;)&#10;                }&#10;&#10;                // Comandos de playlist&#10;                &quot;shuffle&quot; -&gt; {&#10;                    val playlist = playerViewModel.currentPlaylist.value&#10;                    if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;                        val shuffled = playlist.shuffled()&#10;                        withContext(Dispatchers.Main) {&#10;                            playerViewModel.setCurrentPlaylist(shuffled, 0)&#10;                        }&#10;                        t(&quot;assistant_shuffled&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;add_favorites&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Guardar en favoritos usando Spotify API&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { success, _ -&gt;&#10;                                    // No hacemos nada con el resultado aquí&#10;                                }&#10;                            }&#10;                            String.format(t(&quot;assistant_added_favorites&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;save_song&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { _, _ -&gt; }&#10;                            }&#10;                            String.format(t(&quot;assistant_song_saved&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;create_playlist&quot; -&gt; {&#10;                    val name = result.entities[&quot;name&quot;]&#10;                    if (!name.isNullOrBlank()) {&#10;                        // TODO: Implementar creación de playlist&#10;                        String.format(t(&quot;assistant_playlist_created&quot;), name)&#10;                    } else t(&quot;assistant_what_playlist_name&quot;)&#10;                }&#10;&#10;                // Comandos compuestos&#10;                &quot;compound&quot; -&gt; {&#10;                    val actions = result.entities[&quot;actions&quot;]?.split(&quot;,&quot;) ?: emptyList()&#10;                    val results = mutableListOf&lt;String&gt;()&#10;                    for (action in actions) {&#10;                        when (action.trim()) {&#10;                            &quot;next&quot; -&gt; {&#10;                                withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                                results.add(t(&quot;assistant_next&quot;))&#10;                            }&#10;                            &quot;volume_up&quot; -&gt; {&#10;                                adjustVolume(10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                            &quot;volume_down&quot; -&gt; {&#10;                                adjustVolume(-10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                        }&#10;                    }&#10;                    results.joinToString(&quot;. &quot;)&#10;                }&#10;&#10;                &quot;settings&quot; -&gt; t(&quot;assistant_open_settings&quot;)&#10;                &quot;play_search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    Log.d(&quot;AssistantManager&quot;, &quot;play_search query: \&quot;$q\&quot;&quot;)&#10;                    if (q.isBlank()) return t(&quot;assistant_what_play&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_${System.currentTimeMillis()}&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val ok = withContext(Dispatchers.Main) {&#10;                        playerViewModel.initializePlayer()&#10;                        playerViewModel.setCurrentPlaylist(listOf(track), 0)&#10;                        try { playerViewModel.loadAudioFromTrack(track) } catch (_: Exception) { false }&#10;                    }&#10;                    if (ok) {&#10;                        val artists = track.artists.ifBlank { &quot;&quot; }&#10;                        if (artists.isNotBlank()) String.format(t(&quot;assistant_playing_song&quot;), track.name, artists)&#10;                        else String.format(t(&quot;assistant_playing_song_no_artist&quot;), track.name)&#10;                    } else String.format(t(&quot;assistant_error_play&quot;), q)&#10;                }&#10;                &quot;search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_search&quot;)&#10;                    val spotifyTrack = searchSpotifyTrack(q)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val artists = spotifyTrack.artists.joinToString(&quot;, &quot;) { it.name }&#10;                    String.format(t(&quot;assistant_found&quot;), spotifyTrack.name, artists)&#10;                }&#10;                &quot;add_queue&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_add&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_queue&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    withContext(Dispatchers.Main) { playerViewModel.addToQueue(track) }&#10;                    val artists = track.artists.ifBlank { &quot;&quot; }&#10;                    if (artists.isNotBlank()) String.format(t(&quot;assistant_added_queue&quot;), track.name, artists)&#10;                    else String.format(t(&quot;assistant_added_queue_no_artist&quot;), track.name)&#10;                }&#10;                else -&gt; t(&quot;assistant_not_understand&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AssistantManager&quot;, &quot;perform action error&quot;, e)&#10;            t(&quot;assistant_error&quot;)&#10;        }&#10;    }&#10;&#10;    fun close() {&#10;        cancelSleepTimer()&#10;        try { sessionIntent?.close() } catch (_: Exception) {}&#10;        try { sessionNer?.close() } catch (_: Exception) {}&#10;        sessionIntent = null&#10;        sessionNer = null&#10;        try { ortEnv = null } catch (_: Exception) {}&#10;        onnxAvailable = false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantTTSHelper.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantTTSHelper.kt" />
              <option name="originalContent" value="package com.plyr.assistant&#10;&#10;import android.content.Context&#10;import android.speech.tts.TextToSpeech&#10;import android.speech.tts.UtteranceProgressListener&#10;import com.plyr.utils.Config&#10;import java.util.Locale&#10;&#10;/**&#10; * Helper wrapper around Android TextToSpeech for speaking assistant responses.&#10; */&#10;class AssistantTTSHelper(private val context: Context) {&#10;    private var tts: TextToSpeech? = null&#10;    private var isInitialized = false&#10;    private var pendingText: String? = null&#10;    private var listener: TTSListener? = null&#10;&#10;    interface TTSListener {&#10;        fun onStart() {}&#10;        fun onDone() {}&#10;        fun onError() {}&#10;    }&#10;&#10;    /**&#10;     * Convierte el idioma de la app al Locale para TTS&#10;     */&#10;    private fun getLocaleFromConfig(): Locale {&#10;        return when (Config.getLanguage(context)) {&#10;            &quot;español&quot; -&gt; Locale(&quot;es&quot;, &quot;ES&quot;)&#10;            &quot;english&quot; -&gt; Locale.US&#10;            &quot;català&quot; -&gt; Locale(&quot;ca&quot;, &quot;ES&quot;)&#10;            &quot;日本語&quot; -&gt; Locale.JAPAN&#10;            else -&gt; Locale(&quot;es&quot;, &quot;ES&quot;)&#10;        }&#10;    }&#10;&#10;    init {&#10;        tts = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                isInitialized = true&#10;                // Set language from app config&#10;                val locale = getLocaleFromConfig()&#10;                val result = tts?.setLanguage(locale)&#10;                if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                    // Fallback to default if language not available&#10;                    tts?.language = Locale.getDefault()&#10;                }&#10;                tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {&#10;                    override fun onStart(utteranceId: String?) {&#10;                        listener?.onStart()&#10;                    }&#10;                    override fun onDone(utteranceId: String?) {&#10;                        listener?.onDone()&#10;                    }&#10;                    @Deprecated(&quot;Deprecated in Java&quot;)&#10;                    override fun onError(utteranceId: String?) {&#10;                        listener?.onError()&#10;                    }&#10;                    override fun onError(utteranceId: String?, errorCode: Int) {&#10;                        listener?.onError()&#10;                    }&#10;                })&#10;                // Speak pending text if any&#10;                pendingText?.let { speak(it) }&#10;                pendingText = null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setListener(l: TTSListener?) {&#10;        listener = l&#10;    }&#10;&#10;    fun speak(text: String) {&#10;        if (!isInitialized) {&#10;            pendingText = text&#10;            return&#10;        }&#10;        // Update language before speaking in case it changed&#10;        val locale = getLocaleFromConfig()&#10;        tts?.setLanguage(locale)&#10;        tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, &quot;assistant_response&quot;)&#10;    }&#10;&#10;    fun stop() {&#10;        tts?.stop()&#10;    }&#10;&#10;    fun isSpeaking(): Boolean {&#10;        return tts?.isSpeaking == true&#10;    }&#10;&#10;    fun destroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        tts = null&#10;        isInitialized = false&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.assistant&#10;&#10;import android.annotation.SuppressLint&#10;import android.content.Context&#10;import android.speech.tts.TextToSpeech&#10;import android.speech.tts.UtteranceProgressListener&#10;import com.plyr.utils.Config&#10;import java.util.Locale&#10;&#10;/**&#10; * Helper wrapper around Android TextToSpeech for speaking assistant responses.&#10; */&#10;class AssistantTTSHelper private constructor(private val context: Context) {&#10;    private var tts: TextToSpeech? = null&#10;    private var isInitialized = false&#10;    private var pendingText: String? = null&#10;    private var listener: TTSListener? = null&#10;&#10;    interface TTSListener {&#10;        fun onStart() {}&#10;        fun onDone() {}&#10;        fun onError() {}&#10;    }&#10;&#10;    /**&#10;     * Convierte el idioma de la app al Locale para TTS&#10;     */&#10;    private fun getLocaleFromConfig(): Locale {&#10;        return when (Config.getLanguage(context)) {&#10;            &quot;español&quot; -&gt; Locale(&quot;es&quot;, &quot;ES&quot;)&#10;            &quot;english&quot; -&gt; Locale.US&#10;            &quot;català&quot; -&gt; Locale(&quot;ca&quot;, &quot;ES&quot;)&#10;            &quot;日本語&quot; -&gt; Locale.JAPAN&#10;            else -&gt; Locale(&quot;es&quot;, &quot;ES&quot;)&#10;        }&#10;    }&#10;&#10;    init {&#10;        tts = TextToSpeech(context) { status -&gt;&#10;            if (status == TextToSpeech.SUCCESS) {&#10;                isInitialized = true&#10;                // Set language from app config&#10;                val locale = getLocaleFromConfig()&#10;                val result = tts?.setLanguage(locale)&#10;                if (result == TextToSpeech.LANG_MISSING_DATA || result == TextToSpeech.LANG_NOT_SUPPORTED) {&#10;                    // Fallback to default if language not available&#10;                    tts?.language = Locale.getDefault()&#10;                }&#10;                tts?.setOnUtteranceProgressListener(object : UtteranceProgressListener() {&#10;                    override fun onStart(utteranceId: String?) {&#10;                        listener?.onStart()&#10;                    }&#10;                    override fun onDone(utteranceId: String?) {&#10;                        listener?.onDone()&#10;                    }&#10;                    @Deprecated(&quot;Deprecated in Java&quot;)&#10;                    override fun onError(utteranceId: String?) {&#10;                        listener?.onError()&#10;                    }&#10;                    override fun onError(utteranceId: String?, errorCode: Int) {&#10;                        listener?.onError()&#10;                    }&#10;                })&#10;                // Speak pending text if any&#10;                pendingText?.let { speak(it) }&#10;                pendingText = null&#10;            }&#10;        }&#10;    }&#10;&#10;    fun setListener(l: TTSListener?) {&#10;        listener = l&#10;    }&#10;&#10;    fun speak(text: String) {&#10;        if (!isInitialized) {&#10;            pendingText = text&#10;            return&#10;        }&#10;        // Update language before speaking in case it changed&#10;        val locale = getLocaleFromConfig()&#10;        tts?.setLanguage(locale)&#10;        tts?.speak(text, TextToSpeech.QUEUE_FLUSH, null, &quot;assistant_response&quot;)&#10;    }&#10;&#10;    fun stop() {&#10;        tts?.stop()&#10;    }&#10;&#10;    fun isSpeaking(): Boolean {&#10;        return tts?.isSpeaking == true&#10;    }&#10;&#10;    fun destroy() {&#10;        tts?.stop()&#10;        tts?.shutdown()&#10;        tts = null&#10;        isInitialized = false&#10;    }&#10;&#10;    companion object {&#10;        @SuppressLint(&quot;StaticFieldLeak&quot;)&#10;        @Volatile&#10;        private var INSTANCE: AssistantTTSHelper? = null&#10;&#10;        /** Initialize the singleton if not already created. Safe to call multiple times. */&#10;        fun initializeIfNeeded(context: Context) {&#10;            if (INSTANCE == null) {&#10;                synchronized(this) {&#10;                    if (INSTANCE == null) {&#10;                        // Store applicationContext to avoid leaking activities&#10;                        INSTANCE = AssistantTTSHelper(context.applicationContext)&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        /** Shutdown and clear the singleton if present. */&#10;        fun shutdownIfNeeded() {&#10;            INSTANCE?.let {&#10;                it.destroy()&#10;                INSTANCE = null&#10;            }&#10;        }&#10;&#10;        /** Convenience to speak text if the TTS is initialized. Initializes if needed. */&#10;        fun speakIfReady(context: Context, text: String) {&#10;            initializeIfNeeded(context)&#10;            INSTANCE?.speak(text)&#10;        }&#10;&#10;        /** Stop the current TTS playback if instance exists. */&#10;        fun stopIfNeeded() {&#10;            INSTANCE?.stop()&#10;        }&#10;&#10;        /** Check whether the TTS is currently speaking. */&#10;        fun isSpeaking(): Boolean {&#10;            return INSTANCE?.isSpeaking() == true&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/ConfigScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.MultiToggle&#10;import com.plyr.ui.components.Titulo&#10;import com.plyr.ui.components.AsciiWaveActionButton&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify - se actualiza cada vez que se abre la pantalla&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var spotifyUserName by remember { mutableStateOf(Config.getSpotifyUserName(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Actualizar el estado de Spotify cuando la pantalla es visible&#10;    LaunchedEffect(Unit) {&#10;        isSpotifyConnected = Config.isSpotifyConnected(context)&#10;        spotifyUserName = Config.getSpotifyUserName(context)&#10;        android.util.Log.d(&quot;ConfigScreen&quot;, &quot; Estado actualizado - Conectado: $isSpotifyConnected, Usuario: $spotifyUserName&quot;)&#10;    }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Reemplazado BinaryToggle por TernaryToggle para soportar &quot;system&quot;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_system&quot;),&#10;                option2 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option3 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = when (selectedTheme) {&#10;                    &quot;system&quot; -&gt; 0&#10;                    &quot;dark&quot; -&gt; 1&#10;                    &quot;light&quot; -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedTheme = when (selectedIndex) {&#10;                        0 -&gt; &quot;system&quot;&#10;                        1 -&gt; &quot;dark&quot;&#10;                        2 -&gt; &quot;light&quot;&#10;                        else -&gt; &quot;system&quot;&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;lang_spanish&quot;),&#10;                    Translations.get(context, &quot;lang_english&quot;),&#10;                    Translations.get(context, &quot;lang_catalan&quot;),&#10;                    Translations.get(context, &quot;lang_japanese&quot;)&#10;                ),&#10;                initialIndex = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    Config.LANGUAGE_JAPANESE -&gt; 3&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        3 -&gt; Config.LANGUAGE_JAPANESE&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;                    Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de acciones de swipe&#10;            Text(&#10;                text = Translations.get(context, &quot;swipe_actions&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Selector de acción para swipe izquierdo&#10;            var selectedSwipeLeftAction by remember { mutableStateOf(Config.getSwipeLeftAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeLeftAction) {&#10;                Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_left&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeLeftAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeLeftAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                    }&#10;                    Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Selector de acción para swipe derecho&#10;            var selectedSwipeRightAction by remember { mutableStateOf(Config.getSwipeRightAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeRightAction) {&#10;                Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_right&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeRightAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeRightAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                    }&#10;                    Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    connectionMessage = message ?: if (success) Translations.get(context, &quot;connected&quot;) else &quot;error&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                // Botón de Spotify Login/Logout&#10;                Text(&#10;                    text = when {&#10;                        isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; {&#10;                            val userName = Config.getSpotifyUserName(context)&#10;                            if (!userName.isNullOrBlank()) {&#10;                                &quot;Hello $userName!&quot;&#10;                            } else {&#10;                                Translations.get(context, &quot;configured&quot;)&#10;                            }&#10;                        }&#10;                        else -&gt; Translations.get(context, &quot;login&quot;)&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = when {&#10;                            isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; MaterialTheme.colorScheme.primary&#10;                            else -&gt; MaterialTheme.colorScheme.error&#10;                        }&#10;                    ),&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                Config.clearSpotifyUserName(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AcoustidApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            LastfmApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;spotify_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.tertiary&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AcoustidApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getAcoustidApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;acoustid_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;&#10;            Text(&#10;                text = if (Config.hasAcoustidApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasAcoustidApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setAcoustidApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_acoustid_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre AcoustID&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;acoustid_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LastfmApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getLastfmApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;lastfm_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasLastfmApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasLastfmApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campo de entrada de API Key&#10;                Text(&#10;                    text = &quot;      api_key:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setLastfmApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_lastfm_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre Last.fm&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;lastfm_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.TextStyle&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.PasswordVisualTransformation&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.Translations&#10;import com.plyr.utils.SpotifyAuthEvent&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.ui.components.BinaryToggle&#10;import com.plyr.ui.components.TernaryToggle&#10;import com.plyr.ui.components.MultiToggle&#10;import com.plyr.ui.components.Titulo&#10;import com.plyr.ui.components.AsciiWaveActionButton&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.text.style.TextAlign&#10;import com.plyr.assistant.AssistantTTSHelper&#10;&#10;&#10;&#10;@Composable&#10;fun ConfigScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    onThemeChanged: (String) -&gt; Unit = {}&#10;) {&#10;    var selectedTheme by remember { mutableStateOf(Config.getTheme(context)) }&#10;    var selectedSearchEngine by remember { mutableStateOf(Config.getSearchEngine(context)) }&#10;    var selectedLanguage by remember { mutableStateOf(Config.getLanguage(context)) }&#10;&#10;    // Estado para Spotify - se actualiza cada vez que se abre la pantalla&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var spotifyUserName by remember { mutableStateOf(Config.getSpotifyUserName(context)) }&#10;    var connectionMessage by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Actualizar el estado de Spotify cuando la pantalla es visible&#10;    LaunchedEffect(Unit) {&#10;        isSpotifyConnected = Config.isSpotifyConnected(context)&#10;        spotifyUserName = Config.getSpotifyUserName(context)&#10;        android.util.Log.d(&quot;ConfigScreen&quot;, &quot; Estado actualizado - Conectado: $isSpotifyConnected, Usuario: $spotifyUserName&quot;)&#10;    }&#10;&#10;    LaunchedEffect(selectedTheme) {&#10;        Config.setTheme(context, selectedTheme)&#10;        onThemeChanged(selectedTheme)&#10;    }&#10;&#10;    LaunchedEffect(selectedSearchEngine) {&#10;        Config.setSearchEngine(context, selectedSearchEngine)&#10;    }&#10;&#10;    LaunchedEffect(selectedLanguage) {&#10;        Config.setLanguage(context, selectedLanguage)&#10;    }&#10;&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    // Usar key para forzar la recomposición cuando cambia el idioma&#10;    key(selectedLanguage) {&#10;        Column(&#10;            Modifier&#10;                .fillMaxSize()&#10;                .verticalScroll(rememberScrollState())&#10;                .padding(16.dp)&#10;        ) {&#10;            // Header&#10;            Titulo(Translations.get(context, &quot;config_title&quot;))&#10;&#10;            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;            // Selector de tema&#10;            Text(&#10;                text = Translations.get(context, &quot;theme&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Reemplazado BinaryToggle por TernaryToggle para soportar &quot;system&quot;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;theme_system&quot;),&#10;                option2 = Translations.get(context, &quot;theme_dark&quot;),&#10;                option3 = Translations.get(context, &quot;theme_light&quot;),&#10;                initialValue = when (selectedTheme) {&#10;                    &quot;system&quot; -&gt; 0&#10;                    &quot;dark&quot; -&gt; 1&#10;                    &quot;light&quot; -&gt; 2&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedTheme = when (selectedIndex) {&#10;                        0 -&gt; &quot;system&quot;&#10;                        1 -&gt; &quot;dark&quot;&#10;                        2 -&gt; &quot;light&quot;&#10;                        else -&gt; &quot;system&quot;&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de motor de búsqueda&#10;            Text(&#10;                text = Translations.get(context, &quot;search_engine&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            BinaryToggle(&#10;                option1 = Translations.get(context, &quot;search_spotify&quot;),&#10;                option2 = Translations.get(context, &quot;search_youtube&quot;),&#10;                initialValue = selectedSearchEngine == &quot;spotify&quot;,&#10;                onChange = { isSpotify -&gt;&#10;                    selectedSearchEngine = if (isSpotify) &quot;spotify&quot; else &quot;youtube&quot;&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de calidad de audio&#10;            Text(&#10;                text = Translations.get(context, &quot;audio_quality&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            var selectedAudioQuality by remember { mutableStateOf(Config.getAudioQuality(context)) }&#10;&#10;            LaunchedEffect(selectedAudioQuality) {&#10;                Config.setAudioQuality(context, selectedAudioQuality)&#10;            }&#10;&#10;            TernaryToggle(&#10;                option1 = Translations.get(context, &quot;quality_low&quot;),&#10;                option2 = Translations.get(context, &quot;quality_med&quot;),&#10;                option3 = Translations.get(context, &quot;quality_high&quot;),&#10;                initialValue = when (selectedAudioQuality) {&#10;                    Config.AUDIO_QUALITY_WORST -&gt; 0&#10;                    Config.AUDIO_QUALITY_MEDIUM -&gt; 1&#10;                    Config.AUDIO_QUALITY_BEST -&gt; 2&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedAudioQuality = when (selectedIndex) {&#10;                        0 -&gt; Config.AUDIO_QUALITY_WORST&#10;                        1 -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                        2 -&gt; Config.AUDIO_QUALITY_BEST&#10;                        else -&gt; Config.AUDIO_QUALITY_MEDIUM&#10;                    }&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Selector de idioma&#10;            Text(&#10;                text = Translations.get(context, &quot;language&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;lang_spanish&quot;),&#10;                    Translations.get(context, &quot;lang_english&quot;),&#10;                    Translations.get(context, &quot;lang_catalan&quot;),&#10;                    Translations.get(context, &quot;lang_japanese&quot;)&#10;                ),&#10;                initialIndex = when (selectedLanguage) {&#10;                    Config.LANGUAGE_SPANISH -&gt; 0&#10;                    Config.LANGUAGE_ENGLISH -&gt; 1&#10;                    Config.LANGUAGE_CATALAN -&gt; 2&#10;                    Config.LANGUAGE_JAPANESE -&gt; 3&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedLanguage = when (selectedIndex) {&#10;                        0 -&gt; Config.LANGUAGE_SPANISH&#10;                        1 -&gt; Config.LANGUAGE_ENGLISH&#10;                        2 -&gt; Config.LANGUAGE_CATALAN&#10;                        3 -&gt; Config.LANGUAGE_JAPANESE&#10;                        else -&gt; Config.LANGUAGE_SPANISH&#10;                    }&#10;                    Config.setLanguage(context, selectedLanguage)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de acciones de swipe&#10;            Text(&#10;                text = Translations.get(context, &quot;swipe_actions&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            // Selector de acción para swipe izquierdo&#10;            var selectedSwipeLeftAction by remember { mutableStateOf(Config.getSwipeLeftAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeLeftAction) {&#10;                Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_left&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeLeftAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 0&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeLeftAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                    }&#10;                    Config.setSwipeLeftAction(context, selectedSwipeLeftAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(16.dp))&#10;&#10;            // Selector de acción para swipe derecho&#10;            var selectedSwipeRightAction by remember { mutableStateOf(Config.getSwipeRightAction(context)) }&#10;&#10;            LaunchedEffect(selectedSwipeRightAction) {&#10;                Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;            }&#10;&#10;            Text(&#10;                text = &quot;    ${Translations.get(context, &quot;swipe_right&quot;)}:&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 14.sp,&#10;                    color = MaterialTheme.colorScheme.onSurfaceVariant&#10;                ),&#10;                modifier = Modifier.padding(bottom = 4.dp)&#10;            )&#10;&#10;            MultiToggle(&#10;                options = listOf(&#10;                    Translations.get(context, &quot;swipe_action_queue&quot;),&#10;                    Translations.get(context, &quot;swipe_action_liked&quot;),&#10;                    Translations.get(context, &quot;swipe_action_playlist&quot;),&#10;                    Translations.get(context, &quot;swipe_action_share&quot;),&#10;                    Translations.get(context, &quot;swipe_action_download&quot;)&#10;                ),&#10;                initialIndex = when (selectedSwipeRightAction) {&#10;                    Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; 0&#10;                    Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; 1&#10;                    Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; 2&#10;                    Config.SWIPE_ACTION_SHARE -&gt; 3&#10;                    Config.SWIPE_ACTION_DOWNLOAD -&gt; 4&#10;                    else -&gt; 1&#10;                },&#10;                onChange = { selectedIndex -&gt;&#10;                    selectedSwipeRightAction = when (selectedIndex) {&#10;                        0 -&gt; Config.SWIPE_ACTION_ADD_TO_QUEUE&#10;                        1 -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                        2 -&gt; Config.SWIPE_ACTION_ADD_TO_PLAYLIST&#10;                        3 -&gt; Config.SWIPE_ACTION_SHARE&#10;                        4 -&gt; Config.SWIPE_ACTION_DOWNLOAD&#10;                        else -&gt; Config.SWIPE_ACTION_ADD_TO_LIKED&#10;                    }&#10;                    Config.setSwipeRightAction(context, selectedSwipeRightAction)&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                }&#10;            )&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Información de uso&#10;            Column {&#10;                Text(&#10;                    text = Translations.get(context, &quot;info&quot;),&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 8.dp)&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;info_text&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 18.sp&#10;                )&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Escuchar eventos de autenticación de Spotify&#10;            LaunchedEffect(Unit) {&#10;                SpotifyAuthEvent.setAuthCallback { success, message -&gt;&#10;                    isSpotifyConnected = success&#10;                    connectionMessage = message ?: if (success) Translations.get(context, &quot;connected&quot;) else &quot;error&quot;&#10;                }&#10;            }&#10;&#10;            // Limpiar callback al salir&#10;            DisposableEffect(Unit) {&#10;                onDispose {&#10;                    SpotifyAuthEvent.clearCallback()&#10;                }&#10;            }&#10;&#10;            // Status unificado de plyr y Spotify&#10;            Column {&#10;                // Botón de Spotify Login/Logout&#10;                Text(&#10;                    text = when {&#10;                        isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; {&#10;                            val userName = Config.getSpotifyUserName(context)&#10;                            if (!userName.isNullOrBlank()) {&#10;                                &quot;Hello $userName!&quot;&#10;                            } else {&#10;                                Translations.get(context, &quot;configured&quot;)&#10;                            }&#10;                        }&#10;                        else -&gt; Translations.get(context, &quot;login&quot;)&#10;                    },&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 14.sp,&#10;                        color = when {&#10;                            isSpotifyConnected &amp;&amp; Config.hasSpotifyCredentials(context) -&gt; MaterialTheme.colorScheme.primary&#10;                            else -&gt; MaterialTheme.colorScheme.error&#10;                        }&#10;                    ),&#10;                    textAlign = TextAlign.Center,&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .clickable {&#10;                            if (isSpotifyConnected) {&#10;                                // Desconectar Spotify&#10;                                Config.clearSpotifyTokens(context)&#10;                                Config.clearSpotifyUserName(context)&#10;                                isSpotifyConnected = false&#10;                                connectionMessage = Translations.get(context, &quot;disconnected&quot;)&#10;                            } else {&#10;                                // Verificar que las credenciales estén configuradas&#10;                                if (!Config.hasSpotifyCredentials(context)) {&#10;                                    connectionMessage = &quot;credentials_required&quot;&#10;                                } else {&#10;                                    // Conectar con Spotify&#10;                                    connectionMessage = Translations.get(context, &quot;opening_browser&quot;)&#10;                                    try {&#10;                                        val success = SpotifyRepository.startOAuthFlow(context)&#10;                                        connectionMessage = if (success) {&#10;                                            Translations.get(context, &quot;check_browser&quot;)&#10;                                        } else {&#10;                                            Translations.get(context, &quot;error_starting_oauth&quot;)&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        connectionMessage = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                )&#10;&#10;                // Mostrar mensaje de conexión si existe&#10;                if (connectionMessage.isNotBlank()) {&#10;                    Spacer(modifier = Modifier.height(6.dp))&#10;                    Text(&#10;                        text = connectionMessage,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        modifier = Modifier.fillMaxWidth(),&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;&#10;            // Configuración de API de Spotify&#10;            SpotifyApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AcoustidApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            LastfmApiConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(10.dp))&#10;&#10;            AssistantConfigSection(context = context)&#10;&#10;            Spacer(modifier = Modifier.height(30.dp))&#10;        }&#10;    }&#10;}&#10;&#10;&#10;@Composable&#10;fun SpotifyApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var clientId by remember { mutableStateOf(Config.getSpotifyClientId(context) ?: &quot;&quot;) }&#10;    var clientSecret by remember { mutableStateOf(Config.getSpotifyClientSecret(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;spotify_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasSpotifyCredentials(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasSpotifyCredentials(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campos de entrada&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_id&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientId,&#10;                    onValueChange = {&#10;                        clientId = it&#10;                        Config.setSpotifyClientId(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 8.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_id&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;client_secret&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = clientSecret,&#10;                    onValueChange = {&#10;                        clientSecret = it&#10;                        Config.setSpotifyClientSecret(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    visualTransformation = PasswordVisualTransformation(),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_client_secret&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;how_to_get_credentials&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 11.sp,&#10;                            color = MaterialTheme.colorScheme.tertiary&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 8.dp)&#10;                    )&#10;&#10;                    listOf(&#10;                        &quot;instruction_1&quot;, &quot;instruction_2&quot;, &quot;instruction_3&quot;,&#10;                        &quot;instruction_4&quot;, &quot;instruction_5&quot;, &quot;instruction_6&quot;,&#10;                        &quot;instruction_7&quot;, &quot;instruction_8&quot;, &quot;instruction_9&quot;&#10;                    ).forEach { instructionKey -&gt;&#10;                        Text(&#10;                            text = &quot;        ${Translations.get(context, instructionKey)}&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 10.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 2.dp)&#10;                        )&#10;                    }&#10;&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;note_local_storage&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AcoustidApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getAcoustidApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;acoustid_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;&#10;            Text(&#10;                text = if (Config.hasAcoustidApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasAcoustidApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setAcoustidApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_acoustid_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.5f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre AcoustID&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;acoustid_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun LastfmApiConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var apiKey by remember { mutableStateOf(Config.getLastfmApiKey(context) ?: &quot;&quot;) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        // Campo principal de API - similar al formato del cliente&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;lastfm_status&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (Config.hasLastfmApiKey(context)) Translations.get(context, &quot;configured&quot;) else Translations.get(context, &quot;not_configured&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (Config.hasLastfmApiKey(context)) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        // Desplegable con campos de configuración&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                // Campo de entrada de API Key&#10;                Text(&#10;                    text = &quot;      api_key:&quot;,&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    modifier = Modifier.padding(bottom = 4.dp)&#10;                )&#10;&#10;                OutlinedTextField(&#10;                    value = apiKey,&#10;                    onValueChange = {&#10;                        apiKey = it&#10;                        Config.setLastfmApiKey(context, it)&#10;                    },&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(bottom = 16.dp),&#10;                    textStyle = TextStyle(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 11.sp&#10;                    ),&#10;                    colors = OutlinedTextFieldDefaults.colors(&#10;                        focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedBorderColor = MaterialTheme.colorScheme.onSurfaceVariant,&#10;                        focusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        unfocusedTextColor = MaterialTheme.colorScheme.onBackground,&#10;                        focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                        unfocusedLabelColor = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    placeholder = {&#10;                        Text(&#10;                            text = Translations.get(context, &quot;enter_lastfm_api_key&quot;),&#10;                            style = TextStyle(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 11.sp,&#10;                                color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                            )&#10;                        )&#10;                    }&#10;                )&#10;&#10;                // Explicación detallada sobre Last.fm&#10;                Column(&#10;                    modifier = Modifier.padding(bottom = 16.dp)&#10;                ) {&#10;                    Text(&#10;                        text = Translations.get(context, &quot;lastfm_info&quot;),&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 10.sp,&#10;                            color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                        ),&#10;                        lineHeight = 14.sp&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun AssistantConfigSection(context: Context) {&#10;    var isExpanded by remember { mutableStateOf(false) }&#10;    var assistantEnabled by remember { mutableStateOf(Config.isAssistantEnabled(context)) }&#10;    var useSameLanguage by remember { mutableStateOf(Config.isAssistantSameLanguage(context)) }&#10;    var ttsEnabled by remember { mutableStateOf(Config.isAssistantTtsEnabled(context)) }&#10;    // assistant-specific language (only used when useSameLanguage == false)&#10;    var assistantLanguage by remember { mutableStateOf(Config.getAssistantLanguage(context)) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    Column {&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .clickable {&#10;                    isExpanded = !isExpanded&#10;                    haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                }&#10;                .padding(vertical = 4.dp),&#10;            horizontalArrangement = Arrangement.SpaceBetween&#10;        ) {&#10;            Text(&#10;                text = Translations.get(context, &quot;assistant_settings&quot;),&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;&#10;            Text(&#10;                text = if (assistantEnabled) Translations.get(context, &quot;enabled&quot;) else Translations.get(context, &quot;disabled&quot;),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 12.sp,&#10;                    color = if (assistantEnabled) MaterialTheme.colorScheme.primary else MaterialTheme.colorScheme.error&#10;                )&#10;            )&#10;        }&#10;&#10;        if (isExpanded) {&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .padding(start = 16.dp, top = 8.dp)&#10;            ) {&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_assistant&quot;),&#10;                    checked = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        assistantEnabled = it&#10;                        Config.setAssistantEnabled(context, it)&#10;                        // When disabling assistant, force it to use app language&#10;                        if (!it) {&#10;                            useSameLanguage = true&#10;                            Config.setAssistantSameLanguage(context, true)&#10;                            // sync assistant language to app language&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;assistant_same_language&quot;),&#10;                    checked = useSameLanguage,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        useSameLanguage = it&#10;                        Config.setAssistantSameLanguage(context, it)&#10;                        // if now using same language, sync assistant language to app language&#10;                        if (it) {&#10;                            val appLang = Config.getLanguage(context)&#10;                            assistantLanguage = appLang&#10;                            Config.setAssistantLanguage(context, appLang)&#10;                        }&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    }&#10;                )&#10;&#10;                Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                CheckboxOption(&#10;                    label = Translations.get(context, &quot;enable_tts&quot;),&#10;                    checked = ttsEnabled,&#10;                    enabled = assistantEnabled,&#10;                    onCheckedChange = {&#10;                        ttsEnabled = it&#10;                        Config.setAssistantTtsEnabled(context, it)&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        // Optionally start/stop TTS engine&#10;                        if (it) {&#10;                            AssistantTTSHelper.initializeIfNeeded(context)&#10;                        } else {&#10;                            AssistantTTSHelper.shutdownIfNeeded()&#10;                        }&#10;                    }&#10;                )&#10;&#10;                // If not using app language, show a language selector identical to the main one&#10;                if (assistantEnabled &amp;&amp; !useSameLanguage) {&#10;                    Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                    Text(&#10;                        text = Translations.get(context, &quot;language&quot;),&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 14.sp,&#10;                        ),&#10;                        modifier = Modifier.padding(bottom = 6.dp)&#10;                    )&#10;&#10;                    // Map current assistantLanguage to an index&#10;                    var assistantLangIndex by remember {&#10;                        mutableStateOf(&#10;                            when (assistantLanguage) {&#10;                                Config.LANGUAGE_SPANISH -&gt; 0&#10;                                Config.LANGUAGE_ENGLISH -&gt; 1&#10;                                Config.LANGUAGE_CATALAN -&gt; 2&#10;                                Config.LANGUAGE_JAPANESE -&gt; 3&#10;                                else -&gt; 0&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    MultiToggle(&#10;                        options = listOf(&#10;                            Translations.get(context, &quot;lang_spanish&quot;),&#10;                            Translations.get(context, &quot;lang_english&quot;),&#10;                            Translations.get(context, &quot;lang_catalan&quot;),&#10;                            Translations.get(context, &quot;lang_japanese&quot;)&#10;                        ),&#10;                        initialIndex = assistantLangIndex,&#10;                        onChange = { selectedIndex -&gt;&#10;                            assistantLangIndex = selectedIndex&#10;                            val newLang = when (selectedIndex) {&#10;                                0 -&gt; Config.LANGUAGE_SPANISH&#10;                                1 -&gt; Config.LANGUAGE_ENGLISH&#10;                                2 -&gt; Config.LANGUAGE_CATALAN&#10;                                3 -&gt; Config.LANGUAGE_JAPANESE&#10;                                else -&gt; Config.LANGUAGE_SPANISH&#10;                            }&#10;                            assistantLanguage = newLang&#10;                            Config.setAssistantLanguage(context, newLang)&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        }&#10;                    )&#10;                }&#10;&#10;                // Keep description&#10;                Spacer(modifier = Modifier.height(12.dp))&#10;&#10;                Text(&#10;                    text = Translations.get(context, &quot;assistant_description&quot;),&#10;                    style = MaterialTheme.typography.bodySmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 10.sp,&#10;                        color = MaterialTheme.colorScheme.onBackground.copy(alpha = 0.6f)&#10;                    ),&#10;                    lineHeight = 14.sp&#10;                )&#10;            }&#10;        }&#10;&#10;        // Ensure assistant language stays synced to app language when using same language&#10;        LaunchedEffect(key1 = Config.getLanguage(context), key2 = useSameLanguage) {&#10;            if (useSameLanguage) {&#10;                val appLang = Config.getLanguage(context)&#10;                assistantLanguage = appLang&#10;                Config.setAssistantLanguage(context, appLang)&#10;            }&#10;        }&#10;&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CheckboxOption(&#10;    label: String,&#10;    checked: Boolean,&#10;    enabled: Boolean = true,&#10;    onCheckedChange: (Boolean) -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable(enabled = enabled) { onCheckedChange(!checked) }&#10;            .padding(vertical = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        Text(&#10;            text = if (checked) &quot;[x]&quot; else &quot;[ ]&quot;,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (enabled) {&#10;                    if (checked) MaterialTheme.colorScheme.primary&#10;                    else MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;&#10;        Spacer(modifier = Modifier.width(8.dp))&#10;&#10;        Text(&#10;            text = label,&#10;            style = MaterialTheme.typography.bodySmall.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 12.sp,&#10;                color = if (enabled) {&#10;                    MaterialTheme.colorScheme.onBackground&#10;                } else {&#10;                    MaterialTheme.colorScheme.onBackground.copy(alpha = 0.4f)&#10;                }&#10;            )&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import com.plyr.assistant.AssistantTTSHelper&#10;import kotlinx.coroutines.withContext&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    // Animación CAVA para escucha y procesamiento&#10;    val animationFrames = listOf(&#10;        &quot;▃▇▁▆▂█▄&quot;,&#10;        &quot;▆▂▅▁▇▃█&quot;,&#10;        &quot;▁▄█▃▆▅▂&quot;,&#10;        &quot;▇▅▂▄▁█▃&quot;,&#10;        &quot;▂█▆▇▄▁▅&quot;,&#10;        &quot;▅▁▃▂▇▄▆&quot;,&#10;        &quot;█▃▄▅▂▆▁&quot;,&#10;        &quot;▄▆▇▁▅▂█&quot;,&#10;        &quot;▃▂▆▄█▇▁&quot;,&#10;        &quot;▆▄▁▇▃▅█&quot;,&#10;        &quot;▁▇▅█▂▃▄&quot;,&#10;        &quot;▇▃█▂▆▁▅&quot;&#10;    )&#10;    var animationFrame by remember { mutableStateOf(0) }&#10;&#10;    // Animar durante escucha o procesamiento&#10;    LaunchedEffect(isListening, isProcessing) {&#10;        if (isListening || isProcessing) {&#10;            while (isListening || isProcessing) {&#10;                delay(100)&#10;                animationFrame = (animationFrame + 1) % animationFrames.size&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-dismiss de la respuesta después de 8 segundos&#10;    LaunchedEffect(displayedResponse, isTyping) {&#10;        if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;            delay(8000)&#10;            if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;                assistantResponse = &quot;&quot;&#10;                displayedResponse = &quot;&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    val assistantTTS = remember { AssistantTTSHelper(context) }&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;            val responseToType = assistantResponse&#10;            for (i in responseToType.indices) {&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20)&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        assistantTTS.stop()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    assistantResponse = reply&#10;                    assistantTTS.speak(reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;            }&#10;            override fun onReady() {&#10;                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;            }&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            assistantTTS.destroy()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { _, dragAmount -&gt;&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                assistantTTS.stop()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_$i&quot;&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = Translations.get(context, &quot;app_logo&quot;),&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = listOf(&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.SEARCH)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.PLAYLISTS)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.QUEUE)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.LOCAL)&#10;                        }&#10;                    )&#10;                )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay with fade animation&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = displayedResponse.isNotEmpty() || isProcessing,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 100.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isProcessing) animationFrames[animationFrame]&#10;                               else displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = overlayVisible || isListening,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp)&#10;                        .align(Alignment.TopCenter)&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        if (isListening) {&#10;                            // Animación CAVA mientras escucha&#10;                            Text(&#10;                                text = animationFrames[animationFrame],&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = Translations.get(context, &quot;cancel&quot;),&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = Translations.get(context, &quot;assistant&quot;),&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.AnimatedVisibility&#10;import androidx.compose.animation.fadeIn&#10;import androidx.compose.animation.fadeOut&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import com.plyr.assistant.AssistantTTSHelper&#10;import kotlinx.coroutines.withContext&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    // Animación CAVA para escucha y procesamiento&#10;    val animationFrames = listOf(&#10;        &quot;▃▇▁▆▂█▄&quot;,&#10;        &quot;▆▂▅▁▇▃█&quot;,&#10;        &quot;▁▄█▃▆▅▂&quot;,&#10;        &quot;▇▅▂▄▁█▃&quot;,&#10;        &quot;▂█▆▇▄▁▅&quot;,&#10;        &quot;▅▁▃▂▇▄▆&quot;,&#10;        &quot;█▃▄▅▂▆▁&quot;,&#10;        &quot;▄▆▇▁▅▂█&quot;,&#10;        &quot;▃▂▆▄█▇▁&quot;,&#10;        &quot;▆▄▁▇▃▅█&quot;,&#10;        &quot;▁▇▅█▂▃▄&quot;,&#10;        &quot;▇▃█▂▆▁▅&quot;&#10;    )&#10;    var animationFrame by remember { mutableStateOf(0) }&#10;&#10;    // Animar durante escucha o procesamiento&#10;    LaunchedEffect(isListening, isProcessing) {&#10;        if (isListening || isProcessing) {&#10;            while (isListening || isProcessing) {&#10;                delay(100)&#10;                animationFrame = (animationFrame + 1) % animationFrames.size&#10;            }&#10;        }&#10;    }&#10;&#10;    // Auto-dismiss de la respuesta después de 8 segundos&#10;    LaunchedEffect(displayedResponse, isTyping) {&#10;        if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;            delay(8000)&#10;            if (displayedResponse.isNotEmpty() &amp;&amp; !isTyping) {&#10;                assistantResponse = &quot;&quot;&#10;                displayedResponse = &quot;&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    // Use the singleton helper methods instead of constructing AssistantTTSHelper directly&#10;    // (AssistantTTSHelper has a private constructor; use initializeIfNeeded / speakIfReady / stopIfNeeded / shutdownIfNeeded)&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;            val responseToType = assistantResponse&#10;            for (i in responseToType.indices) {&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20)&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    assistantResponse = reply&#10;                    com.plyr.assistant.AssistantTTSHelper.speakIfReady(context, reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;            }&#10;            override fun onReady() {&#10;                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;            }&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            com.plyr.assistant.AssistantTTSHelper.shutdownIfNeeded()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { _, dragAmount -&gt;&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                com.plyr.assistant.AssistantTTSHelper.stopIfNeeded()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_$i&quot;&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = Translations.get(context, &quot;app_logo&quot;),&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = listOf(&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.SEARCH)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.PLAYLISTS)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.QUEUE)&#10;                        }&#10;                    ),&#10;                    ActionButtonData(&#10;                        text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        onClick = {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(Screen.LOCAL)&#10;                        }&#10;                    )&#10;                )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay with fade animation&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = displayedResponse.isNotEmpty() || isProcessing,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 100.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                ) {&#10;                    Text(&#10;                        text = if (isProcessing) animationFrames[animationFrame]&#10;                               else displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium,&#10;                        color = MaterialTheme.colorScheme.primary,&#10;                        modifier = Modifier.clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                androidx.compose.animation.AnimatedVisibility(&#10;                    visible = overlayVisible || isListening,&#10;                    enter = fadeIn(),&#10;                    exit = fadeOut(),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp)&#10;                        .align(Alignment.TopCenter)&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    ) {&#10;                        if (isListening) {&#10;                            // Animación CAVA mientras escucha&#10;                            Text(&#10;                                text = animationFrames[animationFrame],&#10;                                style = MaterialTheme.typography.bodyMedium,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;&#10;                            Spacer(modifier = Modifier.height(8.dp))&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f),&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            }&#10;&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = Translations.get(context, &quot;cancel&quot;),&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(20.dp)&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = Translations.get(context, &quot;assistant&quot;),&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_LANGUAGE = &quot;language&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    private const val KEY_SPOTIFY_USER_NAME = &quot;spotify_user_name&quot;&#10;    private const val KEY_ACOUSTID_API_KEY = &quot;acoustid_api_key&quot;&#10;    private const val KEY_LASTFM_API_KEY = &quot;lastfm_api_key&quot;&#10;    private const val KEY_SWIPE_LEFT_ACTION = &quot;swipe_left_action&quot;&#10;    private const val KEY_SWIPE_RIGHT_ACTION = &quot;swipe_right_action&quot;&#10;&#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;system&quot; // Por defecto en nuevas instalaciones seguir el tema del sistema&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;high&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;    private const val DEFAULT_LANGUAGE = &quot;english&quot;&#10;    private const val DEFAULT_SWIPE_LEFT_ACTION = &quot;add_to_queue&quot;&#10;    private const val DEFAULT_SWIPE_RIGHT_ACTION = &quot;add_to_liked_songs&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === CONSTANTES PÚBLICAS DE IDIOMAS ===&#10;&#10;    /** Idiomas disponibles */&#10;    const val LANGUAGE_SPANISH = &quot;español&quot;&#10;    const val LANGUAGE_ENGLISH = &quot;english&quot;&#10;    const val LANGUAGE_CATALAN = &quot;català&quot;&#10;    // Ajuste: usar la misma clave que en Translations (&quot;日本語&quot;) para que coincida la búsqueda&#10;    const val LANGUAGE_JAPANESE = &quot;日本語&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SWIPE ===&#10;&#10;    /** Acciones de swipe disponibles */&#10;    const val SWIPE_ACTION_ADD_TO_QUEUE = &quot;add_to_queue&quot;&#10;    const val SWIPE_ACTION_ADD_TO_LIKED = &quot;add_to_liked_songs&quot;&#10;    const val SWIPE_ACTION_ADD_TO_PLAYLIST = &quot;add_to_playlist&quot;&#10;    const val SWIPE_ACTION_SHARE = &quot;share&quot;&#10;    const val SWIPE_ACTION_DOWNLOAD = &quot;download&quot;&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;system&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;&#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE IDIOMA ===&#10;&#10;    /**&#10;     * Establece el idioma de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param language Idioma a establecer (&quot;español&quot;, &quot;english&quot;, &quot;català&quot;)&#10;     */&#10;    fun setLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LANGUAGE, language)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el idioma actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Idioma actual (por defecto &quot;español&quot;)&#10;     */&#10;    fun getLanguage(context: Context): String {&#10;        val prefs = getPrefs(context)&#10;        val stored = prefs.getString(KEY_LANGUAGE, DEFAULT_LANGUAGE) ?: DEFAULT_LANGUAGE&#10;        // Migrar valor legacy &quot;japanese&quot; (ASCII) a la clave usada en Translations (&quot;日本語&quot;)&#10;        if (stored == &quot;japanese&quot;) {&#10;            // Actualizar la preferencia para futuras lecturas&#10;            setLanguage(context, LANGUAGE_JAPANESE)&#10;            return LANGUAGE_JAPANESE&#10;        }&#10;        return stored&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIONES DE SWIPE ===&#10;&#10;    /**&#10;     * Establece la acción para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeLeftAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_LEFT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_queue&quot;)&#10;     */&#10;    fun getSwipeLeftAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_LEFT_ACTION, DEFAULT_SWIPE_LEFT_ACTION) ?: DEFAULT_SWIPE_LEFT_ACTION&#10;    }&#10;&#10;    /**&#10;     * Establece la acción para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeRightAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_RIGHT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_liked_songs&quot;)&#10;     */&#10;    fun getSwipeRightAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_RIGHT_ACTION, DEFAULT_SWIPE_RIGHT_ACTION) ?: DEFAULT_SWIPE_RIGHT_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACOUSTID API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de AcoustID configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de AcoustID o null si no está configurada&#10;     */&#10;    fun getAcoustidApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de AcoustID del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de AcoustID&#10;     */&#10;    fun setAcoustidApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_ACOUSTID_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de AcoustID configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasAcoustidApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE LASTFM API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de Last.fm configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de Last.fm o null si no está configurada&#10;     */&#10;    fun getLastfmApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de Last.fm del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de Last.fm&#10;     */&#10;    fun setLastfmApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LASTFM_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de Last.fm configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasLastfmApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE NOMBRE DE USUARIO DE SPOTIFY ===&#10;&#10;    /**&#10;     * Obtiene el nombre de usuario de Spotify almacenado.&#10;     * @param context Contexto de la aplicación&#10;     * @return Nombre de usuario de Spotify o null si no está configurado&#10;     */&#10;    fun getSpotifyUserName(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_USER_NAME, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el nombre de usuario de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @param userName Nombre de usuario de Spotify&#10;     */&#10;    fun setSpotifyUserName(context: Context, userName: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_USER_NAME, userName.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Elimina el nombre de usuario de Spotify almacenado.&#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyUserName(context: Context) {&#10;        getPrefs(context).edit {&#10;            remove(KEY_SPOTIFY_USER_NAME)&#10;        }&#10;    }&#10;&#10;}&#10;&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_LANGUAGE = &quot;language&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    private const val KEY_SPOTIFY_USER_NAME = &quot;spotify_user_name&quot;&#10;    private const val KEY_ACOUSTID_API_KEY = &quot;acoustid_api_key&quot;&#10;    private const val KEY_LASTFM_API_KEY = &quot;lastfm_api_key&quot;&#10;    private const val KEY_SWIPE_LEFT_ACTION = &quot;swipe_left_action&quot;&#10;    private const val KEY_SWIPE_RIGHT_ACTION = &quot;swipe_right_action&quot;&#10;&#10;    // Nuevas claves para configuración del asistente&#10;    private const val KEY_ASSISTANT_ENABLED = &quot;assistant_enabled&quot;&#10;    private const val KEY_ASSISTANT_SAME_LANGUAGE = &quot;assistant_same_language&quot;&#10;    private const val KEY_ASSISTANT_TTS_ENABLED = &quot;assistant_tts_enabled&quot;&#10;    private const val KEY_ASSISTANT_LANGUAGE = &quot;assistant_language&quot;&#10;&#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;system&quot; // Por defecto en nuevas instalaciones seguir el tema del sistema&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;high&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;    private const val DEFAULT_LANGUAGE = &quot;english&quot;&#10;    private const val DEFAULT_SWIPE_LEFT_ACTION = &quot;add_to_queue&quot;&#10;    private const val DEFAULT_SWIPE_RIGHT_ACTION = &quot;add_to_liked_songs&quot;&#10;    private const val DEFAULT_ASSISTANT_ENABLED = true&#10;    private const val DEFAULT_ASSISTANT_SAME_LANGUAGE = true&#10;    private const val DEFAULT_ASSISTANT_TTS_ENABLED = false&#10;    private const val DEFAULT_ASSISTANT_LANGUAGE = DEFAULT_LANGUAGE&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === CONSTANTES PÚBLICAS DE IDIOMAS ===&#10;&#10;    /** Idiomas disponibles */&#10;    const val LANGUAGE_SPANISH = &quot;español&quot;&#10;    const val LANGUAGE_ENGLISH = &quot;english&quot;&#10;    const val LANGUAGE_CATALAN = &quot;català&quot;&#10;    // Ajuste: usar la misma clave que en Translations (&quot;日本語&quot;) para que coincida la búsqueda&#10;    const val LANGUAGE_JAPANESE = &quot;日本語&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE ACCIONES DE SWIPE ===&#10;&#10;    /** Acciones de swipe disponibles */&#10;    const val SWIPE_ACTION_ADD_TO_QUEUE = &quot;add_to_queue&quot;&#10;    const val SWIPE_ACTION_ADD_TO_LIKED = &quot;add_to_liked_songs&quot;&#10;    const val SWIPE_ACTION_ADD_TO_PLAYLIST = &quot;add_to_playlist&quot;&#10;    const val SWIPE_ACTION_SHARE = &quot;share&quot;&#10;    const val SWIPE_ACTION_DOWNLOAD = &quot;download&quot;&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;system&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;&#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;&#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE IDIOMA ===&#10;&#10;    /**&#10;     * Establece el idioma de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param language Idioma a establecer (&quot;español&quot;, &quot;english&quot;, &quot;català&quot;)&#10;     */&#10;    fun setLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LANGUAGE, language)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el idioma actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Idioma actual (por defecto &quot;español&quot;)&#10;     */&#10;    fun getLanguage(context: Context): String {&#10;        val prefs = getPrefs(context)&#10;        val stored = prefs.getString(KEY_LANGUAGE, DEFAULT_LANGUAGE) ?: DEFAULT_LANGUAGE&#10;        // Migrar valor legacy &quot;japanese&quot; (ASCII) a la clave usada en Translations (&quot;日本語&quot;)&#10;        if (stored == &quot;japanese&quot;) {&#10;            // Actualizar la preferencia para futuras lecturas&#10;            setLanguage(context, LANGUAGE_JAPANESE)&#10;            return LANGUAGE_JAPANESE&#10;        }&#10;        return stored&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;    // === GESTIÓN DE ACCIONES DE SWIPE ===&#10;&#10;    /**&#10;     * Establece la acción para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeLeftAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_LEFT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe izquierdo.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_queue&quot;)&#10;     */&#10;    fun getSwipeLeftAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_LEFT_ACTION, DEFAULT_SWIPE_LEFT_ACTION) ?: DEFAULT_SWIPE_LEFT_ACTION&#10;    }&#10;&#10;    /**&#10;     * Establece la acción para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @param action Acción a establecer&#10;     */&#10;    fun setSwipeRightAction(context: Context, action: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SWIPE_RIGHT_ACTION, action)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la acción configurada para el swipe derecho.&#10;     * @param context Contexto de la aplicación&#10;     * @return Acción actual (por defecto &quot;add_to_liked_songs&quot;)&#10;     */&#10;    fun getSwipeRightAction(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SWIPE_RIGHT_ACTION, DEFAULT_SWIPE_RIGHT_ACTION) ?: DEFAULT_SWIPE_RIGHT_ACTION&#10;    }&#10;&#10;    // === GESTIÓN DE ACOUSTID API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de AcoustID configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de AcoustID o null si no está configurada&#10;     */&#10;    fun getAcoustidApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de AcoustID del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de AcoustID&#10;     */&#10;    fun setAcoustidApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_ACOUSTID_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de AcoustID configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasAcoustidApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_ACOUSTID_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE LASTFM API KEY ===&#10;&#10;    /**&#10;     * Obtiene la API Key de Last.fm configurada por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return API Key de Last.fm o null si no está configurada&#10;     */&#10;    fun getLastfmApiKey(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;    }&#10;&#10;    /**&#10;     * Establece la API Key de Last.fm del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param apiKey API Key de Last.fm&#10;     */&#10;    fun setLastfmApiKey(context: Context, apiKey: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_LASTFM_API_KEY, apiKey.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene una API Key de Last.fm configurada.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene la API Key configurada, false en caso contrario&#10;     */&#10;    fun hasLastfmApiKey(context: Context): Boolean {&#10;        val apiKey = getPrefs(context).getString(KEY_LASTFM_API_KEY, null)&#10;        return !apiKey.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE NOMBRE DE USUARIO DE SPOTIFY ===&#10;&#10;    /**&#10;     * Obtiene el nombre de usuario de Spotify almacenado.&#10;     * @param context Contexto de la aplicación&#10;     * @return Nombre de usuario de Spotify o null si no está configurado&#10;     */&#10;    fun getSpotifyUserName(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_USER_NAME, null)&#10;    }&#10;&#10;    /**&#10;     * Establece el nombre de usuario de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @param userName Nombre de usuario de Spotify&#10;     */&#10;    fun setSpotifyUserName(context: Context, userName: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_USER_NAME, userName.trim())&#10;        }&#10;    }&#10;    &#10;    /** Elimina el nombre de usuario de Spotify almacenado. */&#10;    fun clearSpotifyUserName(context: Context) {&#10;        getPrefs(context).edit {&#10;            remove(KEY_SPOTIFY_USER_NAME)&#10;        }&#10;    }&#10;&#10;    // === CONFIGURACIÓN DEL ASISTENTE ===&#10;&#10;    /** Comprueba si el asistente está habilitado. */&#10;    fun isAssistantEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_ENABLED, DEFAULT_ASSISTANT_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva el asistente. */&#10;    fun setAssistantEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Comprueba si el asistente debe usar el mismo idioma de la app. */&#10;    fun isAssistantSameLanguage(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_SAME_LANGUAGE, DEFAULT_ASSISTANT_SAME_LANGUAGE)&#10;    }&#10;&#10;    /** Establece si el asistente usa el mismo idioma que la app. */&#10;    fun setAssistantSameLanguage(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_SAME_LANGUAGE, enabled) }&#10;    }&#10;&#10;    /** Comprueba si TTS del asistente está habilitado. */&#10;    fun isAssistantTtsEnabled(context: Context): Boolean {&#10;        return getPrefs(context).getBoolean(KEY_ASSISTANT_TTS_ENABLED, DEFAULT_ASSISTANT_TTS_ENABLED)&#10;    }&#10;&#10;    /** Activa o desactiva TTS para el asistente. */&#10;    fun setAssistantTtsEnabled(context: Context, enabled: Boolean) {&#10;        getPrefs(context).edit { putBoolean(KEY_ASSISTANT_TTS_ENABLED, enabled) }&#10;    }&#10;&#10;    /** Obtiene el idioma específico del asistente (si se usa distinto del de la app). */&#10;    fun getAssistantLanguage(context: Context): String {&#10;        return getPrefs(context).getString(KEY_ASSISTANT_LANGUAGE, DEFAULT_ASSISTANT_LANGUAGE) ?: DEFAULT_ASSISTANT_LANGUAGE&#10;    }&#10;&#10;    /** Establece el idioma específico del asistente. */&#10;    fun setAssistantLanguage(context: Context, language: String) {&#10;        getPrefs(context).edit { putString(KEY_ASSISTANT_LANGUAGE, language) }&#10;    }&#10;&#10; }" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Translations.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Translations.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;&#10;/**&#10; * Sistema de traducciones para la aplicación plyr&#10; * Maneja las traducciones para Español, English y Català&#10; */&#10;object Translations {&#10;&#10;    // Mapa de traducciones por idioma&#10;    private val translations = mapOf(&#10;        // ESPAÑOL&#10;        &quot;español&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_ajustes&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;oscuro&quot;,&#10;            &quot;theme_light&quot; to &quot;claro&quot;,&#10;            &quot;theme_system&quot; to &quot;sistema&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_de_búsqueda&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; calidad_de_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baja&quot;,&#10;            &quot;quality_med&quot; to &quot;media&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#10;            &quot;info&quot; to &quot;&gt; información&quot;,&#10;            &quot;info_text&quot; to &quot;    ● ¡no piratees música!\n    ● cambia el motor con yt: / sp:&quot;,&#10;            &quot;spotify_status&quot; to &quot;&gt; estado_sptfy&quot;,&#10;            &quot;acoustid_status&quot; to &quot;&gt; estado_acoustid&quot;,&#10;            &quot;client&quot; to &quot;    ● cliente:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;conectado&quot;,&#10;            &quot;disconnected&quot; to &quot;desconectado&quot;,&#10;            &quot;configured&quot; to &quot;configurado&quot;,&#10;            &quot;not_configured&quot; to &quot;no configurado&quot;,&#10;            &quot;credentials_required&quot; to &quot;se requieren credenciales&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura las credenciales primero&quot;,&#10;            &quot;opening_browser&quot; to &quot;abriendo navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;revisa el navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error al iniciar oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      id del client:&quot;,&#10;            &quot;client_secret&quot; to &quot;      secreto del client:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introduce tu id del cliente de spotify&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introduce tu secreto del cliente de spotify &quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; cómo obtener credenciales de la api de spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ve a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sesión con tu cuenta de spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. selecciona 'crear aplicación'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. rellena el nombre (por ejemplo, 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. establece el redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' y 'web  pi'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. haz clic en 'guardar'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia el client_id y el client_secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. pegalos en los campos de arriba&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: estas credenciales se guardan localmente&quot;,&#10;            &quot;login&quot; to &quot;&lt;iniciar_sesión&gt;&quot;,&#10;            &quot;albums&quot; to &quot;&gt; álbumes&quot;,&#10;            &quot;similar_songs&quot; to &quot;&gt; recomendaciones&quot;,&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generando recomendaciones...&gt;&quot;,&#10;            &quot;share_with_NFC&quot; to &quot;&lt;compartir con NFC&gt;&quot;,&#10;&#10;            // AcoustID Configuration&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#10;            &quot;enter_acoustid_api_key&quot; to &quot;introduce tu api key de acoustid&quot;,&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID es un servicio gratuito para identificar música.\n      Cómo obtener tu API Key:\n      1. Ve a https://acoustid.org/new-application\n      2. Crea una cuenta o inicia sesión\n      3. Crea una nueva aplicación (nombre: 'plyr')\n      4. Copia tu API Key y pégala arriba\n      5. Esta key te permite identificar canciones desde la app&quot;,&#10;&#10;            // Last.fm Configuration&#10;            &quot;lastfm_status&quot; to &quot;&gt; estado_lastfm&quot;,&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#10;            &quot;enter_lastfm_api_key&quot; to &quot;introduce tu api key de last.fm&quot;,&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm es un servicio de música para obtener recomendaciones.\n      Cómo obtener tu API Key:\n      1. Ve a https://www.last.fm/api/account/create\n      2. Crea una cuenta o inicia sesión\n      3. Rellena los datos de la aplicación (nombre: 'plyr')\n      4. Copia tu API Key y pégala arriba\n      5. Esta key te permite obtener recomendaciones de artistas&quot;,&#10;&#10;            // Swipe Actions Configuration&#10;            &quot;swipe_actions&quot; to &quot;&gt; acciones_de_deslizamiento&quot;,&#10;            &quot;swipe_left&quot; to &quot;deslizar izquierda&quot;,&#10;            &quot;swipe_right&quot; to &quot;deslizar derecha&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;, //QUITAR EL TITLE GENERAL&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;buscar&quot;,&#10;            &quot;home_playlists&quot; to &quot;listas&quot;,&#10;            &quot;home_queue&quot; to &quot;cola&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustes&quot;,&#10;            &quot;exit_message&quot; to &quot;Presiona de nuevo para salir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_buscar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;buscar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;cargando...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no se encontraron resultados&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no está conectado&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de búsqueda no reconocido&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error cargando canciones&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;cargando canciones...&quot;,&#10;            &quot;search_tracks&quot; to &quot;canciones&quot;,&#10;            &quot;search_albums&quot; to &quot;álbumes&quot;,&#10;            &quot;search_artists&quot; to &quot;artistas&quot;,&#10;            &quot;search_playlists&quot; to &quot;listas&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;listas youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatorio&quot;,&#10;            &quot;search_save&quot; to &quot;guardar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;guardado&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al guardar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidores&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oyentes mensuales&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imagen del artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry vacía después del prefijo&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;            &quot;colored by used engine&quot; to &quot;coloreado según el motor usado&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminando...&quot;,&#10;            &quot;search_removed&quot; to &quot;¡eliminado!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;guardando...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hay token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultados youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obteniendo track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obteniendo playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obteniendo álbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obteniendo artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error procesando QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;añadiendo canción a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;siguiente&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;mezclar&quot;,&#10;&#10;            // Playlist / Form labels&#10;            &quot;playlist_name&quot; to &quot;Nombre de la playlist&quot;,&#10;            &quot;description&quot; to &quot;Descripción&quot;,&#10;            &quot;description_optional&quot; to &quot;Descripción (opcional)&quot;,&#10;            &quot;search_tracks_label&quot; to &quot;Buscar canciones&quot;,&#10;            &quot;create_playlist&quot; to &quot;Crear playlist&quot;,&#10;            &quot;playlist_name_placeholder&quot; to &quot;Nombre de la playlist&quot;,&#10;&#10;            // Local Screen&#10;            &quot;plyr_local&quot; to &quot;plyr_local&quot;,&#10;            &quot;unknown error&quot; to &quot;error desconocido&quot;,&#10;            &quot;No tracks downloaded&quot; to &quot;Ninguna canción descargada&quot;,&#10;            &quot;delete track&quot; to &quot;eliminar canción&quot;,&#10;            &quot;Song {{track_name}} will be removed permanently&quot; to &quot;La canción {{track_name}} será eliminada permanentemente&quot;,&#10;            &quot;delete&quot; to &quot;eliminar&quot;,&#10;            &quot;cancel&quot; to &quot;cancelar&quot;,&#10;&#10;            // Queue Screen&#10;            &quot;plyr_queue&quot; to &quot;plyr_cola&quot;,&#10;            &quot;No tracks loaded&quot; to &quot;Ninguna lista cargada&quot;,&#10;            &quot;Play a track to start a playlist&quot; to &quot;Reproduce una canción para iniciar una lista&quot;,&#10;            &quot;player_not_available&quot; to &quot;reproductor_no_disponible&quot;,&#10;&#10;            //Playlists Screen&#10;            &quot;plyr_lists&quot; to &quot;plyr_listas&quot;,&#10;            &quot;&lt;syncing...&gt;&quot; to &quot;&lt;sincronizando...&gt;&quot;,&#10;            &quot;&lt;sync&gt;&quot; to &quot;&lt;sincronizar&gt;&quot;,&#10;            &quot;&lt;new&gt;&quot; to &quot;&lt;crear&gt;&quot;,&#10;            &quot;Spotify not connected&quot; to &quot;Spotify no conectado&quot;,&#10;            &quot;Loading tracks...&quot; to &quot;Cargando canciones...&quot;,&#10;&#10;            // ADDITIONAL KEYS (SPANISH)&#10;            &quot;connected_successfully&quot; to &quot;conectado correctamente&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;intercambio de token fallido&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;cancelado por el usuario&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;No se pudo obtener audio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#10;&#10;            // Playlist actions and dialogs&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#10;            &quot;delete_playlist_title&quot; to &quot;Eliminar playlist&quot;,&#10;            &quot;delete_playlist_confirm&quot; to &quot;¿Seguro que quieres eliminar '%s'? Esta acción no se puede deshacer.&quot;,&#10;            &quot;unsaved_changes_title&quot; to &quot;Cambios sin guardar&quot;,&#10;            &quot;unsaved_changes_text&quot; to &quot;Tienes cambios sin guardar. ¿Seguro que quieres salir?&quot;,&#10;            &quot;exit_label&quot; to &quot;Salir&quot;,&#10;            &quot;cancel_label&quot; to &quot;Cancelar&quot;,&#10;            &quot;delete_label&quot; to &quot;Eliminar&quot;,&#10;&#10;            // SongListItem&#10;            &quot;add_to_playlist&quot; to &quot;añadir a playlist&quot;,&#10;            &quot;add_to_queue&quot; to &quot;añadir a cola&quot;,&#10;            &quot;share&quot; to &quot;compartir&quot;,&#10;            &quot;add_to_liked_songs&quot; to &quot;añadir a favoritos&quot;,&#10;            &quot;remove_from_liked_songs&quot; to &quot;quitar de favoritos&quot;,&#10;            &quot;download&quot; to &quot;descargar&quot;,&#10;&#10;            // Swipe Actions - Short versions for config screen&#10;            &quot;swipe_action_queue&quot; to &quot;cola&quot;,&#10;            &quot;swipe_action_liked&quot; to &quot;fav&quot;,&#10;            &quot;swipe_action_playlist&quot; to &quot;lista&quot;,&#10;            &quot;swipe_action_share&quot; to &quot;share&quot;,&#10;            &quot;swipe_action_download&quot; to &quot;down&quot;,&#10;&#10;            &quot;error_fetching_track_info&quot; to &quot;Error obteniendo info del track&quot;,&#10;            &quot;spotify_token_unavailable&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#10;            &quot;album_colon&quot; to &quot;Álbum: %s&quot;,&#10;            &quot;release_colon&quot; to &quot;Lanzamiento: %s&quot;,&#10;            &quot;duration_colon&quot; to &quot;Duración: %s&quot;,&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#10;            &quot;error_loading_playlists&quot; to &quot;Error cargando playlists&quot;,&#10;            &quot;track_already_downloaded&quot; to &quot;Track ya descargado&quot;,&#10;            &quot;loading_playlists&quot; to &quot;cargando playlists...&quot;,&#10;            &quot;track_added_successfully&quot; to &quot;¡Canción añadida exitosamente!&quot;,&#10;            &quot;no_playlists_found&quot; to &quot;No se encontraron playlists&quot;,&#10;&#10;            // Assistant&#10;            &quot;assistant_commands_available&quot; to &quot;Comandos disponibles:&quot;,&#10;            &quot;assistant_resume_playback&quot; to &quot;Reanudar la reproducción&quot;,&#10;            &quot;assistant_pause_playback&quot; to &quot;Pausar la reproducción&quot;,&#10;            &quot;assistant_next_song&quot; to &quot;Siguiente canción&quot;,&#10;            &quot;assistant_previous_song&quot; to &quot;Canción anterior&quot;,&#10;            &quot;assistant_search_play&quot; to &quot;Buscar y reproducir una canción&quot;,&#10;            &quot;assistant_search_song&quot; to &quot;Buscar una canción&quot;,&#10;            &quot;assistant_add_queue&quot; to &quot;Añadir canción a la cola&quot;,&#10;            &quot;assistant_repeat_mode&quot; to &quot;Cambiar modo de repetición&quot;,&#10;            &quot;assistant_current_song&quot; to &quot;Ver canción actual&quot;,&#10;            &quot;assistant_see_commands&quot; to &quot;Ver todos los comandos&quot;,&#10;            &quot;assistant_playing&quot; to &quot;Reproduciendo&quot;,&#10;            &quot;assistant_paused&quot; to &quot;Pausado&quot;,&#10;            &quot;assistant_next&quot; to &quot;Siguiente canción&quot;,&#10;            &quot;assistant_previous&quot; to &quot;Canción anterior&quot;,&#10;            &quot;assistant_repeat_changed&quot; to &quot;Modo de repetición cambiado&quot;,&#10;            &quot;assistant_open_settings&quot; to &quot;Para abrir ajustes, pulsa el icono de configuración&quot;,&#10;            &quot;assistant_what_play&quot; to &quot;Dime qué quieres reproducir&quot;,&#10;            &quot;assistant_what_search&quot; to &quot;Dime qué quieres buscar&quot;,&#10;            &quot;assistant_what_add&quot; to &quot;Dime qué quieres añadir a la cola&quot;,&#10;            &quot;assistant_no_results&quot; to &quot;No encontré resultados para: %s&quot;,&#10;            &quot;assistant_error_play&quot; to &quot;Error al reproducir: %s&quot;,&#10;            &quot;assistant_playing_song&quot; to &quot;Reproduciendo: %s de %s&quot;,&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Reproduciendo: %s&quot;,&#10;            &quot;assistant_found&quot; to &quot;Encontré: %s de %s&quot;,&#10;            &quot;assistant_added_queue&quot; to &quot;Añadido a la cola: %s de %s&quot;,&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Añadido a la cola: %s&quot;,&#10;            &quot;assistant_now_playing&quot; to &quot;Reproduciendo: %s de %s&quot;,&#10;            &quot;assistant_unknown_artist&quot; to &quot;Artista desconocido&quot;,&#10;            &quot;assistant_nothing_playing&quot; to &quot;No hay ninguna canción en reproducción&quot;,&#10;            &quot;assistant_not_understand&quot; to &quot;No entiendo. Di 'ayuda' para ver los comandos disponibles.&quot;,&#10;            &quot;assistant_error&quot; to &quot;Error al ejecutar la acción&quot;,&#10;            &quot;assistant_listening&quot; to &quot;Escuchando...&quot;,&#10;            &quot;assistant_processing&quot; to &quot;Procesando...&quot;,&#10;&#10;            // Nuevas respuestas del asistente&#10;            &quot;assistant_muted&quot; to &quot;Silenciado&quot;,&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volumen al %d%%&quot;,&#10;            &quot;assistant_what_volume&quot; to &quot;Dime a qué nivel quieres el volumen&quot;,&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Temporizador configurado para %d minutos&quot;,&#10;            &quot;assistant_what_time&quot; to &quot;Dime en cuántos minutos quieres parar la música&quot;,&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Temporizador cancelado&quot;,&#10;            &quot;assistant_shuffled&quot; to &quot;Lista mezclada&quot;,&#10;            &quot;assistant_added_favorites&quot; to &quot;Añadido a favoritos: %s&quot;,&#10;            &quot;assistant_song_saved&quot; to &quot;Canción guardada: %s&quot;,&#10;            &quot;assistant_cannot_save&quot; to &quot;No se puede guardar esta canción&quot;,&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' creada&quot;,&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Dime el nombre de la playlist&quot;,&#10;            &quot;assistant_artist_info&quot; to &quot;Esta canción es de %s&quot;,&#10;            &quot;assistant_album_info&quot; to &quot;Esta canción es del álbum %s&quot;,&#10;            &quot;assistant_unknown_album&quot; to &quot;Álbum desconocido&quot;,&#10;            &quot;assistant_duration_info&quot; to &quot;Vas por %s de %s&quot;,&#10;&#10;            // Nuevas descripciones de comandos&#10;            &quot;assistant_volume_desc&quot; to &quot;Controlar el volumen&quot;,&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Mezclar la playlist&quot;,&#10;            &quot;assistant_favorites_desc&quot; to &quot;Añadir a favoritos&quot;,&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Información del artista&quot;,&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Temporizador de sueño&quot;,&#10;&#10;            // Assistant Triggers (palabras clave que activan cada comando)&#10;            &quot;assistant_triggers_help&quot; to &quot;ayuda|comandos|qué puedo decir|que puedo decir|qué puedes hacer|que puedes hacer|opciones&quot;,&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;qué suena|que suena|qué está sonando|que esta sonando|qué canción es|que cancion es|canción actual|cancion actual|qué estoy escuchando|que estoy escuchando|qué reproduce|que reproduce&quot;,&#10;            &quot;assistant_triggers_next&quot; to &quot;siguiente|sigue|próxima|proxima|siguiente canción|siguiente cancion|pasa|salta|saltar&quot;,&#10;            &quot;assistant_triggers_previous&quot; to &quot;anterior|atrás|atras|canción anterior|cancion anterior|vuelve|regresa|retrocede&quot;,&#10;            &quot;assistant_triggers_pause&quot; to &quot;pausa|pausar|para|parar|detén|deten|detener|stop&quot;,&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repetir|repite|repetición|repeticion|bucle|loop&quot;,&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;añadir a la cola|agregar a la cola|añade a la cola|agrega a la cola|pon en la cola|meter en la cola|encolar&quot;,&#10;            &quot;assistant_triggers_play&quot; to &quot;reproducir|reproduce|pon|ponme|toca|tocar|escuchar|escucha|play|quiero escuchar|quiero oír|quiero oir&quot;,&#10;            &quot;assistant_triggers_resume&quot; to &quot;continuar|continua|reanudar|reanuda|sigue|seguir&quot;,&#10;            &quot;assistant_triggers_search&quot; to &quot;buscar|busca|encuentra|encontrar|búsqueda|busqueda&quot;,&#10;            &quot;assistant_triggers_settings&quot; to &quot;ajustes|configuración|configuracion|config|opciones de configuración&quot;,&#10;&#10;            // Nuevos triggers para volumen&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;sube el volumen|subir volumen|más volumen|mas volumen|más alto|mas alto|volumen arriba&quot;,&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;baja el volumen|bajar volumen|menos volumen|más bajo|mas bajo|volumen abajo&quot;,&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;volumen al|pon el volumen|volumen a&quot;,&#10;            &quot;assistant_triggers_mute&quot; to &quot;silenciar|silencio|mute|mutear|calla&quot;,&#10;&#10;            // Nuevos triggers para información contextual&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;quién canta|quien canta|quién es el artista|quien es el artista|de quién es|de quien es|artista&quot;,&#10;            &quot;assistant_triggers_what_album&quot; to &quot;de qué álbum|de que album|qué álbum|que album|álbum&quot;,&#10;            &quot;assistant_triggers_how_long&quot; to &quot;cuánto dura|cuanto dura|duración|duracion|cuánto queda|cuanto queda|tiempo&quot;,&#10;&#10;            // Nuevos triggers para playlist&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;mezcla|mezclar|aleatorio|shuffle|random|baraja|barajar&quot;,&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;añade a favoritos|agregar a favoritos|me gusta|guardar en favoritos|favorito&quot;,&#10;            &quot;assistant_triggers_save_song&quot; to &quot;guarda esta canción|guardar canción|guarda esta|save&quot;,&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;crea una playlist|crear playlist|nueva playlist|crea lista&quot;,&#10;&#10;            // Nuevos triggers para temporizador de sueño&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;para la música en|apágate en|apagar en|temporizador|para en|apagar en|para a las|apágate a las|apagate a las&quot;,&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancela el temporizador|cancelar temporizador|quita el temporizador|no te apagues&quot;,&#10;&#10;            // Nuevos triggers para comandos naturales&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;ponme algo de|pon algo de|música de|quiero&quot;,&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;algo alegre|algo triste|algo tranquilo|algo animado|algo relajante|música para&quot;,&#10;&#10;            // Assistant Commands (para mostrar en ayuda)&#10;            &quot;assistant_cmd_play&quot; to &quot;play / reproducir&quot;,&#10;            &quot;assistant_cmd_pause&quot; to &quot;pausa / stop&quot;,&#10;            &quot;assistant_cmd_next&quot; to &quot;siguiente / salta&quot;,&#10;            &quot;assistant_cmd_previous&quot; to &quot;anterior / atrás&quot;,&#10;            &quot;assistant_cmd_play_song&quot; to &quot;pon &lt;canción&gt;&quot;,&#10;            &quot;assistant_cmd_search&quot; to &quot;buscar &lt;canción&gt;&quot;,&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;añadir a la cola &lt;canción&gt;&quot;,&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repetir&quot;,&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;qué suena&quot;,&#10;            &quot;assistant_cmd_help&quot; to &quot;ayuda / comandos&quot;,&#10;            &quot;assistant_cmd_volume&quot; to &quot;volumen&quot;,&#10;            &quot;assistant_cmd_shuffle&quot; to &quot;mezclar&quot;,&#10;            &quot;assistant_cmd_favorites&quot; to &quot;favoritos&quot;,&#10;            &quot;assistant_cmd_who_sings&quot; to &quot;quién canta&quot;,&#10;            &quot;assistant_cmd_sleep_timer&quot; to &quot;temporizador&quot;,&#10;&#10;        ),&#10;&#10;        // ENGLISH&#10;        &quot;english&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_config&quot;,&#10;            &quot;theme&quot; to &quot;&gt; theme&quot;,&#10;            &quot;theme_dark&quot; to &quot;dark&quot;,&#10;            &quot;theme_light&quot; to &quot;light&quot;,&#10;            &quot;theme_system&quot; to &quot;system&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; search_engine&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; audio_quality&quot;,&#10;            &quot;quality_low&quot; to &quot;low&quot;,&#10;            &quot;quality_med&quot; to &quot;med&quot;,&#10;            &quot;quality_high&quot; to &quot;high&quot;,&#10;            &quot;language&quot; to &quot;&gt; language&quot;,&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;login&quot; to &quot;&lt;login&gt;&quot;,&#10;            &quot;info_text&quot; to &quot;    ● don't pirate music!\n    ● Change engine with yt: / sp:&quot;,&#10;            &quot;spotify_status&quot; to &quot;&gt; sptfy_status&quot;,&#10;            &quot;acoustid_status&quot; to &quot;&gt; acoustid_status&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connected&quot;,&#10;            &quot;disconnected&quot; to &quot;disconnected&quot;,&#10;            &quot;configured&quot; to &quot;configured&quot;,&#10;            &quot;not_configured&quot; to &quot;not_configured&quot;,&#10;            &quot;credentials_required&quot; to &quot;credentials required&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configure credentials first&quot;,&#10;            &quot;opening_browser&quot; to &quot;opening_browser...&quot;,&#10;            &quot;check_browser&quot; to &quot;check_browser&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_starting_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;enter your spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;enter your spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; how to get spotify api credentials:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. go to https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. log in with your spotify account&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. click 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. fill app name (e.g., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. set redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. select 'mobile' and 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. click 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copy client id and client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. paste them in the fields above&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      note: these credentials are stored locally&quot;,&#10;            &quot;albums&quot; to &quot;&gt; albums&quot;,&#10;            &quot;similar_songs&quot; to &quot;&gt; recommendations&quot;,&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generating recommendations...&gt;&quot;,&#10;            &quot;share_with_NFC&quot; to &quot;&lt;share with NFC&gt;&quot;,&#10;&#10;            // AcoustID Configuration&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#10;            &quot;enter_acoustid_api_key&quot; to &quot;enter your acoustid api key&quot;,&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID is a free service for music identification.\n      How to get your API Key:\n      1. Go to https://acoustid.org/new-application\n      2. Create an account or log in\n      3. Create a new application (name: 'plyr')\n      4. Copy your API Key and paste it above\n      5. This key allows you to identify songs from the app&quot;,&#10;&#10;            // Last.fm Configuration&#10;            &quot;lastfm_status&quot; to &quot;&gt; lastfm_status&quot;,&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#10;            &quot;enter_lastfm_api_key&quot; to &quot;enter your last.fm api key&quot;,&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm is a music service for getting recommendations.\n      How to get your API Key:\n      1. Go to https://www.last.fm/api/account/create\n      2. Create an account or log in\n      3. Fill in the application data (name: 'plyr')\n      4. Copy your API Key and paste it above\n      5. This key allows you to get artist recommendations&quot;,&#10;&#10;            // Swipe Actions Configuration&#10;            &quot;swipe_actions&quot; to &quot;&gt; swipe_actions&quot;,&#10;            &quot;swipe_left&quot; to &quot;swipe left&quot;,&#10;            &quot;swipe_right&quot; to &quot;swipe right&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;search&quot;,&#10;            &quot;home_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;home_queue&quot; to &quot;queue&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;settings&quot;,&#10;            &quot;exit_message&quot; to &quot;Press back again to exit&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_search&quot;,&#10;            &quot;search_placeholder&quot; to &quot;search music...&quot;,&#10;            &quot;search_loading&quot; to &quot;loading...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no results found&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify is not connected&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Spotify token not available&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Search engine not recognized&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error loading tracks&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;loading tracks...&quot;,&#10;            &quot;search_tracks&quot; to &quot;tracks&quot;,&#10;            &quot;search_albums&quot; to &quot;albums&quot;,&#10;            &quot;search_artists&quot; to &quot;artists&quot;,&#10;            &quot;search_playlists&quot; to &quot;playlists&quot;,&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;youtube playlists&quot;,&#10;            &quot;search_start&quot; to &quot;start&quot;,&#10;            &quot;search_random&quot; to &quot;random&quot;,&#10;            &quot;search_save&quot; to &quot;save&quot;,&#10;            &quot;search_share&quot; to &quot;share&quot;,&#10;            &quot;search_saved&quot; to &quot;saved&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error saving&quot;,&#10;            &quot;search_followers&quot; to &quot;followers&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;monthly listeners&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Playlist cover&quot;,&#10;            &quot;artist_image&quot; to &quot;Artist image&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Query empty after prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Album cover&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;            &quot;colored by used engine&quot; to &quot;colored by used engine&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Select playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancel&quot;,&#10;            &quot;search_removing&quot; to &quot;removing...&quot;,&#10;            &quot;search_removed&quot; to &quot;removed!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;saving...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no token&quot;,&#10;            &quot;search_unsave&quot; to &quot;unsave&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error getting track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error getting playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error getting album&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error getting artist&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processing QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;adding song to playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#10;            &quot;play&quot; to &quot;play&quot;,&#10;            &quot;pause&quot; to &quot;pause&quot;,&#10;            &quot;next&quot; to &quot;next&quot;,&#10;            &quot;previous&quot; to &quot;previous&quot;,&#10;            &quot;repeat&quot; to &quot;repeat&quot;,&#10;            &quot;shuffle&quot; to &quot;shuffle&quot;,&#10;&#10;            // ADDITIONAL KEYS (ENGLISH)&#10;            &quot;connected_successfully&quot; to &quot;Connected successfully&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;Token exchange failed&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;Cancelled by user&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;Could not obtain audio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#10;&#10;            // Playlist actions and dialogs&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#10;            &quot;delete_playlist_title&quot; to &quot;Delete playlist&quot;,&#10;            &quot;delete_playlist_confirm&quot; to &quot;Are you sure you want to delete '%s'? This action cannot be undone.&quot;,&#10;            &quot;unsaved_changes_title&quot; to &quot;Unsaved changes&quot;,&#10;            &quot;unsaved_changes_text&quot; to &quot;You have unsaved changes. Are you sure you want to exit?&quot;,&#10;            &quot;exit_label&quot; to &quot;Exit&quot;,&#10;            &quot;cancel_label&quot; to &quot;Cancel&quot;,&#10;            &quot;delete_label&quot; to &quot;Delete&quot;,&#10;&#10;            // SongListItem&#10;            &quot;add_to_playlist&quot; to &quot;add to playlist&quot;,&#10;            &quot;add_to_queue&quot; to &quot;add to queue&quot;,&#10;            &quot;share&quot; to &quot;share&quot;,&#10;            &quot;add_to_liked_songs&quot; to &quot;add to liked songs&quot;,&#10;            &quot;remove_from_liked_songs&quot; to &quot;remove from liked songs&quot;,&#10;            &quot;download&quot; to &quot;download&quot;,&#10;&#10;            // Swipe Actions - Short versions for config screen&#10;            &quot;swipe_action_queue&quot; to &quot;queue&quot;,&#10;            &quot;swipe_action_liked&quot; to &quot;fav&quot;,&#10;            &quot;swipe_action_playlist&quot; to &quot;list&quot;,&#10;            &quot;swipe_action_share&quot; to &quot;share&quot;,&#10;            &quot;swipe_action_download&quot; to &quot;down&quot;,&#10;&#10;            &quot;error_fetching_track_info&quot; to &quot;Error fetching track info&quot;,&#10;            &quot;spotify_token_unavailable&quot; to &quot;Spotify token unavailable&quot;,&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#10;            &quot;album_colon&quot; to &quot;Album: %s&quot;,&#10;            &quot;release_colon&quot; to &quot;Release: %s&quot;,&#10;            &quot;duration_colon&quot; to &quot;Duration: %s&quot;,&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#10;            &quot;error_loading_playlists&quot; to &quot;Error loading playlists&quot;,&#10;            &quot;track_already_downloaded&quot; to &quot;Track already downloaded&quot;,&#10;            &quot;loading_playlists&quot; to &quot;loading playlists...&quot;,&#10;            &quot;track_added_successfully&quot; to &quot;Track added successfully!&quot;,&#10;            &quot;no_playlists_found&quot; to &quot;No playlists found&quot;,&#10;&#10;            // Assistant&#10;            &quot;assistant_commands_available&quot; to &quot;Available commands:&quot;,&#10;            &quot;assistant_resume_playback&quot; to &quot;Resume playback&quot;,&#10;            &quot;assistant_pause_playback&quot; to &quot;Pause playback&quot;,&#10;            &quot;assistant_next_song&quot; to &quot;Next song&quot;,&#10;            &quot;assistant_previous_song&quot; to &quot;Previous song&quot;,&#10;            &quot;assistant_search_play&quot; to &quot;Search and play a song&quot;,&#10;            &quot;assistant_search_song&quot; to &quot;Search for a song&quot;,&#10;            &quot;assistant_add_queue&quot; to &quot;Add song to queue&quot;,&#10;            &quot;assistant_repeat_mode&quot; to &quot;Change repeat mode&quot;,&#10;            &quot;assistant_current_song&quot; to &quot;View current song&quot;,&#10;            &quot;assistant_see_commands&quot; to &quot;View all commands&quot;,&#10;            &quot;assistant_playing&quot; to &quot;Playing&quot;,&#10;            &quot;assistant_paused&quot; to &quot;Paused&quot;,&#10;            &quot;assistant_next&quot; to &quot;Next song&quot;,&#10;            &quot;assistant_previous&quot; to &quot;Previous song&quot;,&#10;            &quot;assistant_repeat_changed&quot; to &quot;Repeat mode changed&quot;,&#10;            &quot;assistant_open_settings&quot; to &quot;To open settings, tap the settings icon&quot;,&#10;            &quot;assistant_what_play&quot; to &quot;Tell me what you want to play&quot;,&#10;            &quot;assistant_what_search&quot; to &quot;Tell me what you want to search&quot;,&#10;            &quot;assistant_what_add&quot; to &quot;Tell me what you want to add to the queue&quot;,&#10;            &quot;assistant_no_results&quot; to &quot;No results found for: %s&quot;,&#10;            &quot;assistant_error_play&quot; to &quot;Error playing: %s&quot;,&#10;            &quot;assistant_playing_song&quot; to &quot;Playing: %s by %s&quot;,&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Playing: %s&quot;,&#10;            &quot;assistant_found&quot; to &quot;Found: %s by %s&quot;,&#10;            &quot;assistant_added_queue&quot; to &quot;Added to queue: %s by %s&quot;,&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Added to queue: %s&quot;,&#10;            &quot;assistant_now_playing&quot; to &quot;Now playing: %s by %s&quot;,&#10;            &quot;assistant_unknown_artist&quot; to &quot;Unknown artist&quot;,&#10;            &quot;assistant_nothing_playing&quot; to &quot;No song is currently playing&quot;,&#10;            &quot;assistant_not_understand&quot; to &quot;I don't understand. Say 'help' to see available commands.&quot;,&#10;            &quot;assistant_error&quot; to &quot;Error executing action&quot;,&#10;            &quot;assistant_listening&quot; to &quot;Listening...&quot;,&#10;            &quot;assistant_processing&quot; to &quot;Processing...&quot;,&#10;&#10;            // New assistant responses&#10;            &quot;assistant_muted&quot; to &quot;Muted&quot;,&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volume at %d%%&quot;,&#10;            &quot;assistant_what_volume&quot; to &quot;Tell me what volume level you want&quot;,&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Sleep timer set for %d minutes&quot;,&#10;            &quot;assistant_what_time&quot; to &quot;Tell me in how many minutes to stop the music&quot;,&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Timer cancelled&quot;,&#10;            &quot;assistant_shuffled&quot; to &quot;Playlist shuffled&quot;,&#10;            &quot;assistant_added_favorites&quot; to &quot;Added to favorites: %s&quot;,&#10;            &quot;assistant_song_saved&quot; to &quot;Song saved: %s&quot;,&#10;            &quot;assistant_cannot_save&quot; to &quot;Cannot save this song&quot;,&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' created&quot;,&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Tell me the playlist name&quot;,&#10;            &quot;assistant_artist_info&quot; to &quot;This song is by %s&quot;,&#10;            &quot;assistant_album_info&quot; to &quot;This song is from the album %s&quot;,&#10;            &quot;assistant_unknown_album&quot; to &quot;Unknown album&quot;,&#10;            &quot;assistant_duration_info&quot; to &quot;You're at %s of %s&quot;,&#10;&#10;            // New command descriptions&#10;            &quot;assistant_volume_desc&quot; to &quot;Control volume&quot;,&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Shuffle playlist&quot;,&#10;            &quot;assistant_favorites_desc&quot; to &quot;Add to favorites&quot;,&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Artist info&quot;,&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Sleep timer&quot;,&#10;&#10;            // Assistant Triggers (keywords that trigger each command)&#10;            &quot;assistant_triggers_help&quot; to &quot;help|commands|what can i say|what can you do|options|assist&quot;,&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;what's playing|whats playing|what is playing|current song|now playing|what song is this|what am i listening to|playing now&quot;,&#10;            &quot;assistant_triggers_next&quot; to &quot;next|next song|skip|skip song|play next|forward|next track&quot;,&#10;            &quot;assistant_triggers_previous&quot; to &quot;previous|prev|back|go back|previous song|last song|previous track|rewind&quot;,&#10;            &quot;assistant_triggers_pause&quot; to &quot;pause|stop|halt|hold|freeze&quot;,&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repeat|loop|repeat mode|toggle repeat|cycle repeat&quot;,&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;add to queue|queue|add to the queue|enqueue|put in queue&quot;,&#10;            &quot;assistant_triggers_play&quot; to &quot;play|start|begin|go|i want to listen|i wanna hear|play me|put on&quot;,&#10;            &quot;assistant_triggers_resume&quot; to &quot;resume|continue|unpause|carry on&quot;,&#10;            &quot;assistant_triggers_search&quot; to &quot;search|search for|find|look for|look up&quot;,&#10;            &quot;assistant_triggers_settings&quot; to &quot;settings|config|configuration|preferences|options&quot;,&#10;&#10;            // New volume triggers&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;turn up the volume|volume up|louder|raise volume|increase volume&quot;,&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;turn down the volume|volume down|quieter|lower volume|decrease volume&quot;,&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;set volume to|volume to|volume at&quot;,&#10;            &quot;assistant_triggers_mute&quot; to &quot;mute|silence|quiet|shut up&quot;,&#10;&#10;            // New contextual info triggers&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;who sings|who's the artist|who is the artist|who is this|artist|singer&quot;,&#10;            &quot;assistant_triggers_what_album&quot; to &quot;what album|which album|album name|from what album&quot;,&#10;            &quot;assistant_triggers_how_long&quot; to &quot;how long|duration|how much time|time left|how much is left&quot;,&#10;&#10;            // New playlist triggers&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;shuffle|mix|randomize|random|mix it up&quot;,&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;add to favorites|like this|love this|save to favorites|favorite&quot;,&#10;            &quot;assistant_triggers_save_song&quot; to &quot;save this song|save song|save this|save it&quot;,&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;create a playlist|new playlist|make a playlist|create playlist&quot;,&#10;&#10;            // New sleep timer triggers&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;stop music in|turn off in|sleep timer|stop in|turn off at|stop at&quot;,&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancel timer|cancel the timer|remove timer|don't turn off&quot;,&#10;&#10;            // New natural command triggers&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;play me some|play some|i want|give me some&quot;,&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;something happy|something sad|something calm|something upbeat|something relaxing|music for&quot;,&#10;&#10;            // Assistant Commands (for help display)&#10;            &quot;assistant_cmd_play&quot; to &quot;play&quot;,&#10;            &quot;assistant_cmd_pause&quot; to &quot;pause / stop&quot;,&#10;            &quot;assistant_cmd_next&quot; to &quot;next / skip&quot;,&#10;            &quot;assistant_cmd_previous&quot; to &quot;previous / back&quot;,&#10;            &quot;assistant_cmd_play_song&quot; to &quot;play &lt;song&gt;&quot;,&#10;            &quot;assistant_cmd_search&quot; to &quot;search &lt;song&gt;&quot;,&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;add to queue &lt;song&gt;&quot;,&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repeat / loop&quot;,&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;what's playing&quot;,&#10;            &quot;assistant_cmd_help&quot; to &quot;help / commands&quot;,&#10;&#10;        ),&#10;&#10;        // CATALÀ&#10;        &quot;català&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;config_title&quot; to &quot;plyr_configuració&quot;,&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#10;            &quot;theme_dark&quot; to &quot;fosc&quot;,&#10;            &quot;theme_light&quot; to &quot;clar&quot;,&#10;            &quot;theme_system&quot; to &quot;sistema&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; motor_cerca&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; qualitat_audio&quot;,&#10;            &quot;quality_low&quot; to &quot;baixa&quot;,&#10;            &quot;quality_med&quot; to &quot;mitjana&quot;,&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#10;            &quot;info_text&quot; to &quot;    ● no piratejis música!\n    ● Canvia motor amb yt: / sp:&quot;,&#10;            &quot;spotify_status&quot; to &quot;&gt; estat_sptfy&quot;,&#10;            &quot;acoustid_status&quot; to &quot;&gt; estat_acoustid&quot;,&#10;            &quot;login&quot; to &quot;&lt;iniciar_sessió&gt;&quot;,&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#10;            &quot;connected&quot; to &quot;connectat&quot;,&#10;            &quot;disconnected&quot; to &quot;desconnectat&quot;,&#10;            &quot;configured&quot; to &quot;configurat&quot;,&#10;            &quot;not_configurat&quot; to &quot;no_configurat&quot;,&#10;            &quot;credentials_required&quot; to &quot;credencials requerides&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;configura les credencials primer&quot;,&#10;            &quot;opening_browser&quot; to &quot;obrint_navegador...&quot;,&#10;            &quot;check_browser&quot; to &quot;comprova_navegador&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;error_iniciant_oauth&quot;,&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;introdueix el teu spotify client id&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;introdueix el teu spotify client secret&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; com obtenir credencials api spotify:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. ves a https://developer.spotify.com/dashboard&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. inicia sessió amb el teu compte spotify&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. clica 'create app'&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. omple el nom app (ex., 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. estableix redirect uri: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' i 'web api'&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. clica 'save'&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. copia client id i client secret&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. enganxa'ls als camps de dalt&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      nota: aquestes credencials es guarden localment&quot;,&#10;            &quot;albums&quot; to &quot;&gt; àlbums&quot;,&#10;            &quot;similar_songs&quot; to &quot;&gt; recomanacions&quot;,&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generant recomanacions...&gt;&quot;,&#10;            &quot;share_with_NFC&quot; to &quot;&lt;compartir amb NFC&gt;&quot;,&#10;&#10;            // AcoustID Configuration&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#10;            &quot;enter_acoustid_api_key&quot; to &quot;introdueix la teva api key de acoustid&quot;,&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID és un servei gratuït per identificar música.\n      Com obtenir la teva API Key:\n      1. Ves a https://acoustid.org/new-application\n      2. Crea un compte o inicia sessió\n      3. Crea una nova aplicació (nom: 'plyr')\n      4. Copia la teva API Key i enganxa-la a dalt\n      5. Aquesta key et permet identificar cançons des de l'app&quot;,&#10;&#10;            // Last.fm Configuration&#10;            &quot;lastfm_status&quot; to &quot;&gt; estat_lastfm&quot;,&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#10;            &quot;enter_lastfm_api_key&quot; to &quot;introdueix la teva api key de last.fm&quot;,&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm és un servei de música per obtenir recomanacions.\n      Com obtenir la teva API Key:\n      1. Ves a https://www.last.fm/api/account/create\n      2. Crea un compte o inicia sessió\n      3. Omple les dades de l'aplicació (nom: 'plyr')\n      4. Copia la teva API Key i enganxa-la a dalt\n      5. Aquesta key et permet obtenir recomanacions d'artistes&quot;,&#10;&#10;            // Swipe Actions Configuration&#10;            &quot;swipe_actions&quot; to &quot;&gt; swipe_actions&quot;,&#10;            &quot;swipe_left&quot; to &quot;swipe left&quot;,&#10;            &quot;swipe_right&quot; to &quot;swipe right&quot;,&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;cercar...&quot;,&#10;            &quot;no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;loading&quot; to &quot;carregant...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;cercar&quot;,&#10;            &quot;home_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;home_queue&quot; to &quot;cua&quot;,&#10;            &quot;home_local&quot; to &quot;local&quot;,&#10;            &quot;home_settings&quot; to &quot;ajustos&quot;,&#10;            &quot;exit_message&quot; to &quot;Prem de nou per sortir&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_cercar&quot;,&#10;            &quot;search_placeholder&quot; to &quot;cercar música...&quot;,&#10;            &quot;search_loading&quot; to &quot;carregant...&quot;,&#10;            &quot;search_no_results&quot; to &quot;no s'han trobat resultats&quot;,&#10;            &quot;search_error&quot; to &quot;error&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no està connectat&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de cerca no reconegut&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error carregant cançons&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;carregant cançons...&quot;,&#10;            &quot;search_tracks&quot; to &quot;cançons&quot;,&#10;            &quot;search_albums&quot; to &quot;àlbums&quot;,&#10;            &quot;search_artists&quot; to &quot;artistes&quot;,&#10;            &quot;search_playlists&quot; to &quot;llistes&quot;,&#10;            &quot;search_videos&quot; to &quot;vídeos&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;llistes youtube&quot;,&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#10;            &quot;search_random&quot; to &quot;aleatori&quot;,&#10;            &quot;search_save&quot; to &quot;desar&quot;,&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#10;            &quot;search_saved&quot; to &quot;desat&quot;,&#10;            &quot;search_error_saving&quot; to &quot;error al desar&quot;,&#10;            &quot;search_followers&quot; to &quot;seguidors&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;oients mensuals&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#10;            &quot;artist_image&quot; to &quot;Imatge de l'artista&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry buida després del prefix&quot;,&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats de youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;            &quot;colored by used engine&quot; to &quot;colorejat segons el motor utilitzat&quot;,&#10;&#10;            // Search Screen - Additional translations&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#10;            &quot;search_removing&quot; to &quot;eliminant...&quot;,&#10;            &quot;search_removed&quot; to &quot;eliminat!&quot;,&#10;            &quot;search_saving_status&quot; to &quot;desant...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;error: no hi ha token&quot;,&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;resultats youtube&quot;,&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;Error obtenint track&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obtenint playlist&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;Error obtenint àlbum&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obtenint artista&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processant QR&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;afegint cançó a la playlist&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;reproduint ara&quot;,&#10;            &quot;play&quot; to &quot;reproduir&quot;,&#10;            &quot;pause&quot; to &quot;pausa&quot;,&#10;            &quot;next&quot; to &quot;següent&quot;,&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#10;            &quot;shuffle&quot; to &quot;aleatori&quot;,&#10;&#10;            // ADDITIONAL KEYS (CATALAN)&#10;            &quot;connected_successfully&quot; to &quot;connectat correctament&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;intercanvi de token fallit&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;cancel·lat per l'usuari&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;No s'ha pogut obtenir l'àudio&quot;,&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#10;&#10;            // Playlist actions and dialogs&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#10;            &quot;delete_playlist_title&quot; to &quot;Eliminar playlist&quot;,&#10;            &quot;delete_playlist_confirm&quot; to &quot;Segur que vols eliminar '%s'? Aquesta acció no es pot desfer.&quot;,&#10;            &quot;unsaved_changes_title&quot; to &quot;Canvis sense desar&quot;,&#10;            &quot;unsaved_changes_text&quot; to &quot;Tens canvis sense desar. Segur que vols sortir?&quot;,&#10;            &quot;exit_label&quot; to &quot;Sortir&quot;,&#10;            &quot;cancel_label&quot; to &quot;Cancel·la&quot;,&#10;            &quot;delete_label&quot; to &quot;Eliminar&quot;,&#10;&#10;            // SongListItem&#10;            &quot;add_to_playlist&quot; to &quot;afegir a playlist&quot;,&#10;            &quot;add_to_queue&quot; to &quot;afegir a cua&quot;,&#10;            &quot;share&quot; to &quot;compartir&quot;,&#10;            &quot;add_to_liked_songs&quot; to &quot;afegir a favorits&quot;,&#10;            &quot;remove_from_liked_songs&quot; to &quot;treure de favorits&quot;,&#10;            &quot;download&quot; to &quot;descarregar&quot;,&#10;            &quot;error_fetching_track_info&quot; to &quot;Error obtenint info del track&quot;,&#10;            &quot;spotify_token_unavailable&quot; to &quot;Token de Spotify no disponible&quot;,&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#10;            &quot;album_colon&quot; to &quot;Àlbum: %s&quot;,&#10;            &quot;release_colon&quot; to &quot;Llançament: %s&quot;,&#10;            &quot;duration_colon&quot; to &quot;Durada: %s&quot;,&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#10;            &quot;error_loading_playlists&quot; to &quot;Error carregant playlists&quot;,&#10;            &quot;track_already_downloaded&quot; to &quot;Track ja descarregat&quot;,&#10;            &quot;loading_playlists&quot; to &quot;carregant playlists...&quot;,&#10;            &quot;track_added_successfully&quot; to &quot;Cançó afegida correctament!&quot;,&#10;            &quot;no_playlists_found&quot; to &quot;No s'han trobat playlists&quot;,&#10;&#10;            // Swipe Actions - Short versions for config screen&#10;            &quot;swipe_action_queue&quot; to &quot;cua&quot;,&#10;            &quot;swipe_action_liked&quot; to &quot;pref&quot;,&#10;            &quot;swipe_action_playlist&quot; to &quot;llista&quot;,&#10;            &quot;swipe_action_share&quot; to &quot;comprti&quot;,&#10;            &quot;swipe_action_download&quot; to &quot;desc&quot;,&#10;            // Assistant&#10;            &quot;assistant_commands_available&quot; to &quot;Comandes disponibles:&quot;,&#10;            &quot;assistant_resume_playback&quot; to &quot;Reprendre la reproducció&quot;,&#10;            &quot;assistant_pause_playback&quot; to &quot;Pausar la reproducció&quot;,&#10;            &quot;assistant_next_song&quot; to &quot;Següent cançó&quot;,&#10;            &quot;assistant_previous_song&quot; to &quot;Cançó anterior&quot;,&#10;            &quot;assistant_search_play&quot; to &quot;Cercar i reproduir una cançó&quot;,&#10;            &quot;assistant_search_song&quot; to &quot;Cercar una cançó&quot;,&#10;            &quot;assistant_add_queue&quot; to &quot;Afegir cançó a la cua&quot;,&#10;            &quot;assistant_repeat_mode&quot; to &quot;Canviar mode de repetició&quot;,&#10;            &quot;assistant_current_song&quot; to &quot;Veure cançó actual&quot;,&#10;            &quot;assistant_see_commands&quot; to &quot;Veure totes les comandes&quot;,&#10;            &quot;assistant_playing&quot; to &quot;Reproduint&quot;,&#10;            &quot;assistant_paused&quot; to &quot;Pausat&quot;,&#10;            &quot;assistant_next&quot; to &quot;Següent cançó&quot;,&#10;            &quot;assistant_previous&quot; to &quot;Cançó anterior&quot;,&#10;            &quot;assistant_repeat_changed&quot; to &quot;Mode de repetició canviat&quot;,&#10;            &quot;assistant_open_settings&quot; to &quot;Per obrir ajustos, prem la icona de configuració&quot;,&#10;            &quot;assistant_what_play&quot; to &quot;Digues què vols reproduir&quot;,&#10;            &quot;assistant_what_search&quot; to &quot;Digues què vols cercar&quot;,&#10;            &quot;assistant_what_add&quot; to &quot;Digues què vols afegir a la cua&quot;,&#10;            &quot;assistant_no_results&quot; to &quot;No he trobat resultats per: %s&quot;,&#10;            &quot;assistant_error_play&quot; to &quot;Error al reproduir: %s&quot;,&#10;            &quot;assistant_playing_song&quot; to &quot;Reproduint: %s de %s&quot;,&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Reproduint: %s&quot;,&#10;            &quot;assistant_found&quot; to &quot;He trobat: %s de %s&quot;,&#10;            &quot;assistant_added_queue&quot; to &quot;Afegit a la cua: %s de %s&quot;,&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Afegit a la cua: %s&quot;,&#10;            &quot;assistant_now_playing&quot; to &quot;Reproduint: %s de %s&quot;,&#10;            &quot;assistant_unknown_artist&quot; to &quot;Artista desconegut&quot;,&#10;            &quot;assistant_nothing_playing&quot; to &quot;No hi ha cap cançó en reproducció&quot;,&#10;            &quot;assistant_not_understand&quot; to &quot;No entenc. Digues 'ajuda' per veure les comandes disponibles.&quot;,&#10;            &quot;assistant_error&quot; to &quot;Error al executar l'acció&quot;,&#10;            &quot;assistant_listening&quot; to &quot;Escoltant...&quot;,&#10;            &quot;assistant_processing&quot; to &quot;Processant...&quot;,&#10;&#10;            // Noves respostes de l'assistent&#10;            &quot;assistant_muted&quot; to &quot;Silenciat&quot;,&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volum al %d%%&quot;,&#10;            &quot;assistant_what_volume&quot; to &quot;Digues a quin nivell vols el volum&quot;,&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Temporitzador configurat per %d minuts&quot;,&#10;            &quot;assistant_what_time&quot; to &quot;Digues en quants minuts vols aturar la música&quot;,&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Temporitzador cancel·lat&quot;,&#10;            &quot;assistant_shuffled&quot; to &quot;Llista barrejada&quot;,&#10;            &quot;assistant_added_favorites&quot; to &quot;Afegit a favorits: %s&quot;,&#10;            &quot;assistant_song_saved&quot; to &quot;Cançó guardada: %s&quot;,&#10;            &quot;assistant_cannot_save&quot; to &quot;No es pot guardar aquesta cançó&quot;,&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' creada&quot;,&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Digues el nom de la playlist&quot;,&#10;            &quot;assistant_artist_info&quot; to &quot;Aquesta cançó és de %s&quot;,&#10;            &quot;assistant_album_info&quot; to &quot;Aquesta cançó és de l'àlbum %s&quot;,&#10;            &quot;assistant_unknown_album&quot; to &quot;Àlbum desconegut&quot;,&#10;            &quot;assistant_duration_info&quot; to &quot;Vas per %s de %s&quot;,&#10;&#10;            // Noves descripcions de comandes&#10;            &quot;assistant_volume_desc&quot; to &quot;Controlar el volum&quot;,&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Barrejar la playlist&quot;,&#10;            &quot;assistant_favorites_desc&quot; to &quot;Afegir a favorits&quot;,&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Informació de l'artista&quot;,&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Temporitzador de son&quot;,&#10;&#10;            // Assistant Triggers (paraules clau que activen cada comanda)&#10;            &quot;assistant_triggers_help&quot; to &quot;ajuda|comandes|què puc dir|que puc dir|què pots fer|que pots fer|opcions&quot;,&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;què sona|que sona|què està sonant|que esta sonant|quina cançó és|quina canco es|cançó actual|canco actual|què estic escoltant|que estic escoltant|què reprodueix|que reprodueix&quot;,&#10;            &quot;assistant_triggers_next&quot; to &quot;següent|seguent|pròxima|proxima|següent cançó|seguent canco|passa|salta|saltar&quot;,&#10;            &quot;assistant_triggers_previous&quot; to &quot;anterior|enrere|cançó anterior|canco anterior|torna|retrocedeix&quot;,&#10;            &quot;assistant_triggers_pause&quot; to &quot;pausa|pausar|para|parar|atura|aturar|stop&quot;,&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repetir|repeteix|repetició|repeticio|bucle|loop&quot;,&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;afegir a la cua|afegeix a la cua|posa a la cua|ficar a la cua|encuar&quot;,&#10;            &quot;assistant_triggers_play&quot; to &quot;reproduir|reprodueix|posa|posa'm|toca|tocar|escoltar|escolta|play|vull escoltar|vull sentir|vull oir&quot;,&#10;            &quot;assistant_triggers_resume&quot; to &quot;continuar|continua|reprendre|reprèn|segueix|seguir&quot;,&#10;            &quot;assistant_triggers_search&quot; to &quot;cercar|cerca|buscar|busca|troba|trobar&quot;,&#10;            &quot;assistant_triggers_settings&quot; to &quot;ajustos|configuració|configuracio|config|opcions de configuració&quot;,&#10;&#10;            // Nous triggers per volum&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;puja el volum|pujar volum|més volum|mas volum|més alt|mas alt|volum amunt&quot;,&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;baixa el volum|baixar volum|menys volum|més baix|mas baix|volum avall&quot;,&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;volum al|posa el volum|volum a&quot;,&#10;            &quot;assistant_triggers_mute&quot; to &quot;silencia|silenci|mutejar|calla&quot;,&#10;&#10;            // Nous triggers per informació contextual&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;qui canta|quien canta|quién és l'artista|quien es el artista|de qui és|de quien es|artista&quot;,&#10;            &quot;assistant_triggers_what_album&quot; to &quot;de què àlbum|de que album|què àlbum|que album|àlbum&quot;,&#10;            &quot;assistant_triggers_how_long&quot; to &quot;quant dura|cuanto dura|duració|duracion|quant queda|cuanto queda|temps&quot;,&#10;&#10;            // Nous triggers per playlist&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;barreja|barrejar|aleatori|shuffle|random|mescla|mesclar&quot;,&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;afegeix a favorits|agregar a favoritos|m'agrada|guardar en favoritos|favorit&quot;,&#10;            &quot;assistant_triggers_save_song&quot; to &quot;guarda aquesta cançó|guardar canción|guarda aquesta|save&quot;,&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;crea una playlist|crear playlist|nova playlist|crea llista&quot;,&#10;&#10;            // Nous triggers per temporitzador de son&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;atura la música en|apaga't en|apagar en|temporitzador|atura en|apagar en|atura a les|apaga't a les|apagate a les&quot;,&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancela el temporitzador|cancel·lar temporitzador|treu el temporitzador|no t'apagues&quot;,&#10;&#10;            // Nous triggers per comandes naturals&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;posa'm alguna cosa de|pon algo de|música de|vull&quot;,&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;alguna cosa alegre|alguna cosa trista|alguna cosa tranquil·la|alguna cosa animada|alguna cosa relaxant|música per&quot;,&#10;&#10;            // Assistant Commands (per mostrar a l'ajuda)&#10;            &quot;assistant_cmd_play&quot; to &quot;reprodueix / play&quot;,&#10;            &quot;assistant_cmd_pause&quot; to &quot;pausa / atura&quot;,&#10;            &quot;assistant_cmd_next&quot; to &quot;següent / salta&quot;,&#10;            &quot;assistant_cmd_previous&quot; to &quot;anterior / enrere&quot;,&#10;            &quot;assistant_cmd_play_song&quot; to &quot;posa &lt;cançó&gt;&quot;,&#10;            &quot;assistant_cmd_search&quot; to &quot;cerca &lt;cançó&gt;&quot;,&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;afegeix a la cua &lt;cançó&gt;&quot;,&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repetir&quot;,&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;què sona&quot;,&#10;            &quot;assistant_cmd_help&quot; to &quot;ajuda / comandes&quot;,&#10;            &quot;assistant_cmd_volume&quot; to &quot;volum&quot;,&#10;            &quot;assistant_cmd_shuffle&quot; to &quot;barrejar&quot;,&#10;            &quot;assistant_cmd_favorites&quot; to &quot;favorits&quot;,&#10;            &quot;assistant_cmd_who_sings&quot; to &quot;qui canta&quot;,&#10;            &quot;assistant_cmd_sleep_timer&quot; to &quot;temporitzador&quot;,&#10;&#10;        ),&#10;&#10;        // JAPANESE&#10;        &quot;日本語&quot; to mapOf(&#10;            // Config Screen&#10;            &quot;login&quot; to &quot;&lt;ログイン&gt;&quot;,&#10;            &quot;config_title&quot; to &quot;plyr_設定&quot;,&#10;            &quot;theme&quot; to &quot;&gt; テーマ&quot;,&#10;            &quot;theme_dark&quot; to &quot;ダーク&quot;,&#10;            &quot;theme_light&quot; to &quot;ライト&quot;,&#10;            &quot;theme_system&quot; to &quot;システム&quot;,&#10;            &quot;search_engine&quot; to &quot;&gt; 検索エンジン&quot;,&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#10;            &quot;audio_quality&quot; to &quot;&gt; 音質&quot;,&#10;            &quot;quality_low&quot; to &quot;低&quot;,&#10;            &quot;quality_med&quot; to &quot;中&quot;,&#10;            &quot;quality_high&quot; to &quot;高&quot;,&#10;            &quot;language&quot; to &quot;&gt; 言語&quot;,&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#10;            &quot;info&quot; to &quot;&gt; 情報&quot;,&#10;            &quot;info_text&quot; to &quot;    ● 音楽を違法にダウンロードしないでください！\n    ● エンジンを変更するには yt: / sp: を使用&quot;,&#10;            &quot;spotify_status&quot; to &quot;&gt; sptfy_ステータス&quot;,&#10;            &quot;acoustid_status&quot; to &quot;&gt; acoustid_ステータス&quot;,&#10;            &quot;client&quot; to &quot;    ● クライアント:&quot;,&#10;            &quot;api&quot; to &quot;    ● API:&quot;,&#10;            &quot;connected&quot; to &quot;接続済み&quot;,&#10;            &quot;disconnected&quot; to &quot;未接続&quot;,&#10;            &quot;configured&quot; to &quot;設定済み&quot;,&#10;            &quot;not_configured&quot; to &quot;未設定&quot;,&#10;            &quot;credentials_required&quot; to &quot;認証情報が必要です&quot;,&#10;            &quot;configure_credentials_first&quot; to &quot;先に認証情報を設定してください&quot;,&#10;            &quot;opening_browser&quot; to &quot;ブラウザを開いています...&quot;,&#10;            &quot;check_browser&quot; to &quot;ブラウザを確認してください&quot;,&#10;            &quot;error_starting_oauth&quot; to &quot;OAuth の開始エラー&quot;,&#10;            &quot;client_id&quot; to &quot;      クライアントID:&quot;,&#10;            &quot;client_secret&quot; to &quot;      クライアントシークレット:&quot;,&#10;            &quot;enter_client_id&quot; to &quot;Spotify クライアントIDを入力してください&quot;,&#10;            &quot;enter_client_secret&quot; to &quot;Spotify クライアントシークレットを入力してください&quot;,&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; Spotify API の認証情報を取得する方法:&quot;,&#10;            &quot;instruction_1&quot; to &quot;1. https://developer.spotify.com/dashboard にアクセス&quot;,&#10;            &quot;instruction_2&quot; to &quot;2. Spotify アカウントでログイン&quot;,&#10;            &quot;instruction_3&quot; to &quot;3. 「アプリを作成」をクリック&quot;,&#10;            &quot;instruction_4&quot; to &quot;4. アプリ名を入力 (例: 'plyr mobile')&quot;,&#10;            &quot;instruction_5&quot; to &quot;5. リダイレクトURIを設定: 'plyr://spotify/callback'&quot;,&#10;            &quot;instruction_6&quot; to &quot;6. 「mobile」と「web api」を選択&quot;,&#10;            &quot;instruction_7&quot; to &quot;7. 「保存」をクリック&quot;,&#10;            &quot;instruction_8&quot; to &quot;8. client_id と client_secret をコピー&quot;,&#10;            &quot;instruction_9&quot; to &quot;9. 上のフィールドに貼り付ける&quot;,&#10;            &quot;note_local_storage&quot; to &quot;      注: 認証情報はローカルに保存されます&quot;,&#10;            &quot;albums&quot; to &quot;&gt; アルバム&quot;,&#10;            &quot;similar_songs&quot; to &quot;&gt; おすすめ曲&quot;,&#10;            &quot;loading_recommendations&quot; to &quot;&lt;おすすめを生成しています...&gt;&quot;,&#10;            &quot;share_with_NFC&quot; to &quot;&lt;NFCで共有&gt;&quot;,&#10;&#10;            // AcoustID Configuration&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#10;            &quot;enter_acoustid_api_key&quot; to &quot;AcoustID APIキーを入力してください&quot;,&#10;            &quot;acoustid_info&quot; to &quot;      AcoustIDは音楽識別のための無料サービスです。\n      APIキーの取得方法:\n      1. https://acoustid.org/new-application にアクセス\n      2. アカウントを作成またはログイン\n      3. 新しいアプリケーションを作成 (名前: 'plyr')\n      4. APIキーをコピーして上に貼り付け\n      5. このキーでアプリから曲を識別できます&quot;,&#10;&#10;            // Last.fm Configuration&#10;            &quot;lastfm_status&quot; to &quot;&gt; lastfm_status&quot;,&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#10;            &quot;enter_lastfm_api_key&quot; to &quot;Last.fm APIキーを入力してください&quot;,&#10;            &quot;lastfm_info&quot; to &quot;      Last.fmは音楽の推薦を得るためのサービスです。\n      APIキーの取得方法:\n      1. https://www.last.fm/api/account/create にアクセス\n      2. アカウントを作成またはログイン\n      3. アプリケーションデータを入力 (名前: 'plyr')\n      4. APIキーをコピーして上に貼り付け\n      5. このキーでアーティストの推薦を得ることができます&quot;,&#10;&#10;&#10;            // Main Screen&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#10;            &quot;search_hint&quot; to &quot;検索...&quot;,&#10;            &quot;no_results&quot; to &quot;結果が見つかりません&quot;,&#10;            &quot;loading&quot; to &quot;読み込み中...&quot;,&#10;&#10;            // Home Screen&#10;            &quot;home_search&quot; to &quot;検索&quot;,&#10;            &quot;home_playlists&quot; to &quot;プレイリスト&quot;,&#10;            &quot;home_queue&quot; to &quot;キュー&quot;,&#10;            &quot;home_local&quot; to &quot;ローカル&quot;,&#10;            &quot;home_settings&quot; to &quot;設定&quot;,&#10;            &quot;exit_message&quot; to &quot;もう一度押すと終了します&quot;,&#10;&#10;            // Search Screen&#10;            &quot;search_title&quot; to &quot;plyr_検索&quot;,&#10;            &quot;search_placeholder&quot; to &quot;音楽を検索...&quot;,&#10;            &quot;search_loading&quot; to &quot;読み込み中...&quot;,&#10;            &quot;search_no_results&quot; to &quot;結果が見つかりません&quot;,&#10;            &quot;search_error&quot; to &quot;エラー&quot;,&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify が接続されていません&quot;,&#10;            &quot;search_token_not_available&quot; to &quot;Spotify トークンが利用できません&quot;,&#10;            &quot;search_engine_not_recognized&quot; to &quot;検索エンジンが認識されません&quot;,&#10;            &quot;search_error_loading_tracks&quot; to &quot;曲の読み込みエラー&quot;,&#10;            &quot;search_loading_tracks&quot; to &quot;曲を読み込み中...&quot;,&#10;            &quot;search_tracks&quot; to &quot;曲&quot;,&#10;            &quot;search_albums&quot; to &quot;アルバム&quot;,&#10;            &quot;search_artists&quot; to &quot;アーティスト&quot;,&#10;            &quot;search_playlists&quot; to &quot;プレイリスト&quot;,&#10;            &quot;search_videos&quot; to &quot;動画&quot;,&#10;            &quot;search_youtube_playlists&quot; to &quot;YouTube プレイリスト&quot;,&#10;            &quot;search_start&quot; to &quot;開始&quot;,&#10;            &quot;search_random&quot; to &quot;ランダム&quot;,&#10;            &quot;search_save&quot; to &quot;保存&quot;,&#10;            &quot;search_share&quot; to &quot;共有&quot;,&#10;            &quot;search_saved&quot; to &quot;保存しました&quot;,&#10;            &quot;search_error_saving&quot; to &quot;保存中にエラー&quot;,&#10;            &quot;search_followers&quot; to &quot;フォロワー&quot;,&#10;            &quot;search_monthly_listeners&quot; to &quot;月間リスナー&quot;,&#10;            &quot;search_scan_qr&quot; to &quot;QR&quot;,&#10;            &quot;playlist_cover&quot; to &quot;プレイリストのカバー&quot;,&#10;            &quot;artist_image&quot; to &quot;アーティスト画像&quot;,&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;プレフィックス後のクエリが空です&quot;,&#10;            &quot;album_cover&quot; to &quot;アルバムカバー&quot;,&#10;            &quot;search_youtube_results&quot; to &quot;YouTube の結果&quot;,&#10;            &quot;search_load_more&quot; to &quot;もっと読み込む&quot;,&#10;            &quot;colored by used engine&quot; to &quot;検索エンジン別の色&quot;,&#10;&#10;            // Search Screen - Additional&#10;            &quot;search_select_playlist&quot; to &quot;プレイリストを選択&quot;,&#10;            &quot;search_cancel&quot; to &quot;キャンセル&quot;,&#10;            &quot;search_removing&quot; to &quot;削除中...&quot;,&#10;            &quot;search_removed&quot; to &quot;削除しました！&quot;,&#10;            &quot;search_saving_status&quot; to &quot;保存中...&quot;,&#10;            &quot;search_error_no_token&quot; to &quot;エラー: トークンがありません&quot;,&#10;            &quot;search_unsave&quot; to &quot;保存を解除&quot;,&#10;            &quot;search_error_getting_track&quot; to &quot;曲の取得エラー&quot;,&#10;            &quot;search_error_getting_playlist&quot; to &quot;プレイリストの取得エラー&quot;,&#10;            &quot;search_error_getting_album&quot; to &quot;アルバムの取得エラー&quot;,&#10;            &quot;search_error_getting_artist&quot; to &quot;アーティストの取得エラー&quot;,&#10;            &quot;search_error_processing_qr&quot; to &quot;QR の処理中にエラー&quot;,&#10;            &quot;search_adding_to_playlist&quot; to &quot;プレイリストに曲を追加中...&quot;,&#10;&#10;            // Player&#10;            &quot;now_playing&quot; to &quot;再生中&quot;,&#10;            &quot;play&quot; to &quot;再生&quot;,&#10;            &quot;pause&quot; to &quot;一時停止&quot;,&#10;            &quot;next&quot; to &quot;次へ&quot;,&#10;            &quot;previous&quot; to &quot;前へ&quot;,&#10;            &quot;repeat&quot; to &quot;リピート&quot;,&#10;            &quot;shuffle&quot; to &quot;シャッフル&quot;,&#10;&#10;            // Playlist actions and dialogs&#10;            &quot;btn_start&quot; to &quot;&lt;開始&gt;&quot;,&#10;            &quot;btn_stop&quot; to &quot;&lt;停止&gt;&quot;,&#10;            &quot;btn_rand&quot; to &quot;&lt;ランダム&gt;&quot;,&#10;            &quot;btn_share&quot; to &quot;&lt;共有&gt;&quot;,&#10;            &quot;btn_save&quot; to &quot;&lt;保存&gt;&quot;,&#10;            &quot;btn_edit&quot; to &quot;&lt;編集&gt;&quot;,&#10;            &quot;btn_delete&quot; to &quot;&lt;削除&gt;&quot;,&#10;            &quot;creating&quot; to &quot;&lt;作成中...&gt;&quot;,&#10;            &quot;create&quot; to &quot;&lt;作成&gt;&quot;,&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#10;            &quot;delete_playlist_title&quot; to &quot;プレイリストを削除&quot;,&#10;            &quot;delete_playlist_confirm&quot; to &quot;「%s」を削除してもよろしいですか？この操作は元に戻せません。&quot;,&#10;            &quot;unsaved_changes_title&quot; to &quot;未保存の変更&quot;,&#10;            &quot;unsaved_changes_text&quot; to &quot;未保存の変更があります。本当に終了しますか？&quot;,&#10;            &quot;exit_label&quot; to &quot;終了&quot;,&#10;            &quot;cancel_label&quot; to &quot;キャンセル&quot;,&#10;            &quot;delete_label&quot; to &quot;削除&quot;,&#10;&#10;            // Additional&#10;            &quot;connected_successfully&quot; to &quot;正常に接続されました&quot;,&#10;            &quot;token_exchange_failed&quot; to &quot;トークンの交換に失敗しました&quot;,&#10;            &quot;cancelled_by_user&quot; to &quot;ユーザーによりキャンセルされました&quot;,&#10;            &quot;error_obtaining_audio&quot; to &quot;音声を取得できませんでした&quot;,&#10;            &quot;error_prefix&quot; to &quot;エラー: &quot;,&#10;&#10;            // Local Screen&#10;            &quot;plyr_local&quot; to &quot;plyr_ローカル&quot;,&#10;            &quot;unknown error&quot; to &quot;不明なエラー&quot;,&#10;            &quot;No tracks downloaded&quot; to &quot;ダウンロードされた曲はありません&quot;,&#10;            &quot;delete track&quot; to &quot;曲を削除&quot;,&#10;            &quot;Song {{track_name}} will be removed permanently&quot; to &quot;曲 {{track_name}} は完全に削除されます&quot;,&#10;            &quot;delete&quot; to &quot;削除&quot;,&#10;            &quot;cancel&quot; to &quot;キャンセル&quot;,&#10;&#10;            // Queue Screen&#10;            &quot;plyr_queue&quot; to &quot;plyr_キュー&quot;,&#10;            &quot;No tracks loaded&quot; to &quot;曲が読み込まれていません&quot;,&#10;            &quot;Play a track to start a playlist&quot; to &quot;曲を再生してプレイリストを開始します&quot;,&#10;            &quot;player_not_available&quot; to &quot;プレイヤーが利用できません&quot;,&#10;&#10;            // Playlists Screen&#10;            &quot;plyr_lists&quot; to &quot;plyr_リスト&quot;,&#10;            &quot;&lt;syncing...&gt;&quot; to &quot;&lt;同期中...&gt;&quot;,&#10;            &quot;&lt;sync&gt;&quot; to &quot;&lt;同期&gt;&quot;,&#10;            &quot;&lt;new&gt;&quot; to &quot;&lt;新規作成&gt;&quot;,&#10;            &quot;Spotify not connected&quot; to &quot;Spotify が接続されていません&quot;,&#10;            &quot;Loading tracks...&quot; to &quot;曲を読み込み中...&quot;,&#10;&#10;            // SongListItem&#10;            &quot;add_to_playlist&quot; to &quot;プレイリストに追加&quot;,&#10;            &quot;add_to_queue&quot; to &quot;キューに追加&quot;,&#10;            &quot;share&quot; to &quot;共有&quot;,&#10;            &quot;add_to_liked_songs&quot; to &quot;お気に入りに追加&quot;,&#10;            &quot;remove_from_liked_songs&quot; to &quot;お気に入りから削除&quot;,&#10;            &quot;download&quot; to &quot;ダウンロード&quot;,&#10;&#10;&#10;&#9;&#9;&#9;// Swipe Actions - Short versions for config screen (Japanese)&#10;&#9;&#9;&#9;&quot;swipe_action_queue&quot; to &quot;キュー&quot;,       // queue&#10;&#9;&#9;&#9;&quot;swipe_action_liked&quot; to &quot;お気に&quot;,       // fav (abreviado de お気に入り)&#10;&#9;&#9;&#9;&quot;swipe_action_playlist&quot; to &quot;リスト&quot;,    // list&#10;&#9;&#9;&#9;&quot;swipe_action_share&quot; to &quot;共有&quot;,        // share&#10;&#9;&#9;&#9;&quot;swipe_action_download&quot; to &quot;ダウン&quot;,    // down (abreviado de ダウンロード)&#10;&#10;            &quot;error_fetching_track_info&quot; to &quot;トラック情報の取得エラー&quot;,&#10;            &quot;spotify_token_unavailable&quot; to &quot;Spotify トークンが利用できません&quot;,&#10;            &quot;error_generic&quot; to &quot;エラー&quot;,&#10;            &quot;album_colon&quot; to &quot;アルバム: %s&quot;,&#10;            &quot;release_colon&quot; to &quot;リリース: %s&quot;,&#10;            &quot;duration_colon&quot; to &quot;再生時間: %s&quot;,&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#10;            &quot;error_loading_playlists&quot; to &quot;プレイリストの読み込みエラー&quot;,&#10;            &quot;track_already_downloaded&quot; to &quot;トラックは既にダウンロードされています&quot;,&#10;            &quot;loading_playlists&quot; to &quot;プレイリストを読み込み中...&quot;,&#10;            &quot;track_added_successfully&quot; to &quot;トラックが正常に追加されました！&quot;,&#10;            &quot;no_playlists_found&quot; to &quot;プレイリストが見つかりません&quot;,&#10;&#10;            // Assistant&#10;            &quot;assistant_commands_available&quot; to &quot;利用可能なコマンド:&quot;,&#10;            &quot;assistant_resume_playback&quot; to &quot;再生を再開&quot;,&#10;            &quot;assistant_pause_playback&quot; to &quot;再生を一時停止&quot;,&#10;            &quot;assistant_next_song&quot; to &quot;次の曲&quot;,&#10;            &quot;assistant_previous_song&quot; to &quot;前の曲&quot;,&#10;            &quot;assistant_search_play&quot; to &quot;曲を検索して再生&quot;,&#10;            &quot;assistant_search_song&quot; to &quot;曲を検索&quot;,&#10;            &quot;assistant_add_queue&quot; to &quot;キューに曲を追加&quot;,&#10;            &quot;assistant_repeat_mode&quot; to &quot;リピートモードを変更&quot;,&#10;            &quot;assistant_current_song&quot; to &quot;現在の曲を表示&quot;,&#10;            &quot;assistant_see_commands&quot; to &quot;すべてのコマンドを表示&quot;,&#10;            &quot;assistant_playing&quot; to &quot;再生中&quot;,&#10;            &quot;assistant_paused&quot; to &quot;一時停止&quot;,&#10;            &quot;assistant_next&quot; to &quot;次の曲&quot;,&#10;            &quot;assistant_previous&quot; to &quot;前の曲&quot;,&#10;            &quot;assistant_repeat_changed&quot; to &quot;リピートモードが変更されました&quot;,&#10;            &quot;assistant_open_settings&quot; to &quot;設定を開くには、設定アイコンをタップしてください&quot;,&#10;            &quot;assistant_what_play&quot; to &quot;何を再生しますか？&quot;,&#10;            &quot;assistant_what_search&quot; to &quot;何を検索しますか？&quot;,&#10;            &quot;assistant_what_add&quot; to &quot;キューに何を追加しますか？&quot;,&#10;            &quot;assistant_no_results&quot; to &quot;結果が見つかりません: %s&quot;,&#10;            &quot;assistant_error_play&quot; to &quot;再生エラー: %s&quot;,&#10;            &quot;assistant_playing_song&quot; to &quot;再生中: %s - %s&quot;,&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;再生中: %s&quot;,&#10;            &quot;assistant_found&quot; to &quot;見つかりました: %s - %s&quot;,&#10;            &quot;assistant_added_queue&quot; to &quot;キューに追加: %s - %s&quot;,&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;キューに追加: %s&quot;,&#10;            &quot;assistant_now_playing&quot; to &quot;再生中: %s - %s&quot;,&#10;            &quot;assistant_unknown_artist&quot; to &quot;不明なアーティスト&quot;,&#10;            &quot;assistant_nothing_playing&quot; to &quot;現在再生中の曲はありません&quot;,&#10;            &quot;assistant_not_understand&quot; to &quot;理解できません。「ヘルプ」と言って利用可能なコマンドを確認してください。&quot;,&#10;            &quot;assistant_error&quot; to &quot;アクションの実行エラー&quot;,&#10;            &quot;assistant_listening&quot; to &quot;聞いています...&quot;,&#10;            &quot;assistant_processing&quot; to &quot;処理中...&quot;,&#10;&#10;            // Assistant Triggers (コマンドをトリガーするキーワード)&#10;            &quot;assistant_triggers_help&quot; to &quot;ヘルプ|コマンド|助けて|たすけて|何ができる|なにができる|オプション|使い方|つかいかた&quot;,&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;何が再生中|なにがさいせいちゅう|今の曲|いまのきょく|現在の曲|げんざいのきょく|何を聴いてる|なにをきいてる|再生中|さいせいちゅう&quot;,&#10;            &quot;assistant_triggers_next&quot; to &quot;次|つぎ|次の曲|つぎのきょく|スキップ|次へ|つぎへ|進む|すすむ&quot;,&#10;            &quot;assistant_triggers_previous&quot; to &quot;前|まえ|前の曲|まえのきょく|戻る|もどる|前へ|まえへ|バック&quot;,&#10;            &quot;assistant_triggers_pause&quot; to &quot;一時停止|いちじていし|停止|ていし|止めて|とめて|ストップ|ポーズ&quot;,&#10;            &quot;assistant_triggers_repeat&quot; to &quot;リピート|繰り返し|くりかえし|ループ|繰り返す|くりかえす&quot;,&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;キューに追加|キューについか|待ち行列に追加|まちぎょうれつについか|キューに入れて|キューにいれて&quot;,&#10;            &quot;assistant_triggers_play&quot; to &quot;再生|さいせい|プレイ|かけて|流して|ながして|聴く|きく&quot;,&#10;            &quot;assistant_triggers_resume&quot; to &quot;続ける|つづける|再開|さいかい|続き|つづき&quot;,&#10;            &quot;assistant_triggers_search&quot; to &quot;検索|けんさく|探す|さがす|見つける|みつける&quot;,&#10;            &quot;assistant_triggers_settings&quot; to &quot;設定|せってい|コンフィグ|オプション|環境設定|かんきょうせってい&quot;,&#10;&#10;            // Assistant Commands (ヘルプ表示用)&#10;            &quot;assistant_cmd_play&quot; to &quot;再生 / プレイ&quot;,&#10;            &quot;assistant_cmd_pause&quot; to &quot;一時停止 / ストップ&quot;,&#10;            &quot;assistant_cmd_next&quot; to &quot;次 / スキップ&quot;,&#10;            &quot;assistant_cmd_previous&quot; to &quot;前 / 戻る&quot;,&#10;            &quot;assistant_cmd_play_song&quot; to &quot;再生 &lt;曲名&gt;&quot;,&#10;            &quot;assistant_cmd_search&quot; to &quot;検索 &lt;曲名&gt;&quot;,&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;キューに追加 &lt;曲名&gt;&quot;,&#10;            &quot;assistant_cmd_repeat&quot; to &quot;リピート / ループ&quot;,&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;今の曲&quot;,&#10;            &quot;assistant_cmd_help&quot; to &quot;ヘルプ / コマンド&quot;,&#10;&#10;        ),&#10;&#10;        )&#10;    /**&#10;     * Obtiene una traducción para una clave específica según el idioma actual&#10;     * @param context Contexto de la aplicación&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(context: Context, key: String): String {&#10;        val language = Config.getLanguage(context)&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;&#10;    /**&#10;     * Obtiene una traducción para una clave específica según un idioma específico&#10;     * @param language Idioma deseado&#10;     * @param key Clave de la traducción&#10;     * @return Traducción correspondiente o la clave si no existe&#10;     */&#10;    fun get(language: String, key: String): String {&#10;        return translations[language]?.get(key) ?: key&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#13;&#10;&#13;&#10;import android.content.Context&#13;&#10;&#13;&#10;/**&#13;&#10; * Sistema de traducciones para la aplicación plyr&#13;&#10; * Maneja las traducciones para Español, English y Català&#13;&#10; */&#13;&#10;object Translations {&#13;&#10;&#13;&#10;    // Mapa de traducciones por idioma&#13;&#10;    private val translations = mapOf(&#13;&#10;        // ESPAÑOL&#13;&#10;        &quot;español&quot; to mapOf(&#13;&#10;            // Config Screen&#13;&#10;            &quot;config_title&quot; to &quot;plyr_ajustes&quot;,&#13;&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#13;&#10;            &quot;theme_dark&quot; to &quot;oscuro&quot;,&#13;&#10;            &quot;theme_light&quot; to &quot;claro&quot;,&#13;&#10;            &quot;theme_system&quot; to &quot;sistema&quot;,&#13;&#10;            &quot;search_engine&quot; to &quot;&gt; motor_de_búsqueda&quot;,&#13;&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#13;&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#13;&#10;            &quot;audio_quality&quot; to &quot;&gt; calidad_de_audio&quot;,&#13;&#10;            &quot;quality_low&quot; to &quot;baja&quot;,&#13;&#10;            &quot;quality_med&quot; to &quot;media&quot;,&#13;&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#13;&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#13;&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#13;&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#13;&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#13;&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#13;&#10;            &quot;info&quot; to &quot;&gt; información&quot;,&#13;&#10;            &quot;info_text&quot; to &quot;    ● ¡no piratees música!\n    ● cambia el motor con yt: / sp:&quot;,&#13;&#10;            &quot;spotify_status&quot; to &quot;&gt; estado_sptfy&quot;,&#13;&#10;            &quot;acoustid_status&quot; to &quot;&gt; estado_acoustid&quot;,&#13;&#10;            &quot;client&quot; to &quot;    ● cliente:&quot;,&#13;&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#13;&#10;            &quot;connected&quot; to &quot;conectado&quot;,&#13;&#10;            &quot;disconnected&quot; to &quot;desconectado&quot;,&#13;&#10;            &quot;configured&quot; to &quot;configurado&quot;,&#13;&#10;            &quot;not_configured&quot; to &quot;no configurado&quot;,&#13;&#10;            &quot;credentials_required&quot; to &quot;se requieren credenciales&quot;,&#13;&#10;            &quot;configure_credentials_first&quot; to &quot;configura las credenciales primero&quot;,&#13;&#10;            &quot;opening_browser&quot; to &quot;abriendo navegador...&quot;,&#13;&#10;            &quot;check_browser&quot; to &quot;revisa el navegador&quot;,&#13;&#10;            &quot;error_starting_oauth&quot; to &quot;error al iniciar oauth&quot;,&#13;&#10;            &quot;client_id&quot; to &quot;      id del client:&quot;,&#13;&#10;            &quot;client_secret&quot; to &quot;      secreto del client:&quot;,&#13;&#10;            &quot;enter_client_id&quot; to &quot;introduce tu id del cliente de spotify&quot;,&#13;&#10;            &quot;enter_client_secret&quot; to &quot;introduce tu secreto del cliente de spotify &quot;,&#13;&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; cómo obtener credenciales de la api de spotify:&quot;,&#13;&#10;            &quot;instruction_1&quot; to &quot;1. ve a https://developer.spotify.com/dashboard&quot;,&#13;&#10;            &quot;instruction_2&quot; to &quot;2. inicia sesión con tu cuenta de spotify&quot;,&#13;&#10;            &quot;instruction_3&quot; to &quot;3. selecciona 'crear aplicación'&quot;,&#13;&#10;            &quot;instruction_4&quot; to &quot;4. rellena el nombre (por ejemplo, 'plyr mobile')&quot;,&#13;&#10;            &quot;instruction_5&quot; to &quot;5. establece el redirect uri: 'plyr://spotify/callback'&quot;,&#13;&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' y 'web  pi'&quot;,&#13;&#10;            &quot;instruction_7&quot; to &quot;7. haz clic en 'guardar'&quot;,&#13;&#10;            &quot;instruction_8&quot; to &quot;8. copia el client_id y el client_secret&quot;,&#13;&#10;            &quot;instruction_9&quot; to &quot;9. pegalos en los campos de arriba&quot;,&#13;&#10;            &quot;note_local_storage&quot; to &quot;      nota: estas credenciales se guardan localmente&quot;,&#13;&#10;            &quot;login&quot; to &quot;&lt;iniciar_sesión&gt;&quot;,&#13;&#10;            &quot;albums&quot; to &quot;&gt; álbumes&quot;,&#13;&#10;            &quot;similar_songs&quot; to &quot;&gt; recomendaciones&quot;,&#13;&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generando recomendaciones...&gt;&quot;,&#13;&#10;            &quot;share_with_NFC&quot; to &quot;&lt;compartir con NFC&gt;&quot;,&#13;&#10;&#13;&#10;            // AcoustID Configuration&#13;&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#13;&#10;            &quot;enter_acoustid_api_key&quot; to &quot;introduce tu api key de acoustid&quot;,&#13;&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID es un servicio gratuito para identificar música.\n      Cómo obtener tu API Key:\n      1. Ve a https://acoustid.org/new-application\n      2. Crea una cuenta o inicia sesión\n      3. Crea una nueva aplicación (nombre: 'plyr')\n      4. Copia tu API Key y pégala arriba\n      5. Esta key te permite identificar canciones desde la app&quot;,&#13;&#10;&#13;&#10;            // Last.fm Configuration&#13;&#10;            &quot;lastfm_status&quot; to &quot;&gt; estado_lastfm&quot;,&#13;&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#13;&#10;            &quot;enter_lastfm_api_key&quot; to &quot;introduce tu api key de last.fm&quot;,&#13;&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm es un servicio de música para obtener recomendaciones.\n      Cómo obtener tu API Key:\n      1. Ve a https://www.last.fm/api/account/create\n      2. Crea una cuenta o inicia sesión\n      3. Rellena los datos de la aplicación (nombre: 'plyr')\n      4. Copia tu API Key y pégala arriba\n      5. Esta key te permite obtener recomendaciones de artistas&quot;,&#13;&#10;&#13;&#10;            // Swipe Actions Configuration&#13;&#10;            &quot;swipe_actions&quot; to &quot;&gt; acciones_de_deslizamiento&quot;,&#13;&#10;            &quot;swipe_left&quot; to &quot;deslizar izquierda&quot;,&#13;&#10;            &quot;swipe_right&quot; to &quot;deslizar derecha&quot;,&#13;&#10;&#13;&#10;            // Main Screen&#13;&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;, //QUITAR EL TITLE GENERAL&#13;&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#13;&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#13;&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#13;&#10;&#13;&#10;            // Home Screen&#13;&#10;            &quot;home_search&quot; to &quot;buscar&quot;,&#13;&#10;            &quot;home_playlists&quot; to &quot;listas&quot;,&#13;&#10;            &quot;home_queue&quot; to &quot;cola&quot;,&#13;&#10;            &quot;home_local&quot; to &quot;local&quot;,&#13;&#10;            &quot;home_settings&quot; to &quot;ajustes&quot;,&#13;&#10;            &quot;exit_message&quot; to &quot;Presiona de nuevo para salir&quot;,&#13;&#10;&#13;&#10;            // Search Screen&#13;&#10;            &quot;search_title&quot; to &quot;plyr_buscar&quot;,&#13;&#10;            &quot;search_placeholder&quot; to &quot;buscar música...&quot;,&#13;&#10;            &quot;search_loading&quot; to &quot;cargando...&quot;,&#13;&#10;            &quot;search_no_results&quot; to &quot;no se encontraron resultados&quot;,&#13;&#10;            &quot;search_error&quot; to &quot;error&quot;,&#13;&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no está conectado&quot;,&#13;&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#13;&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de búsqueda no reconocido&quot;,&#13;&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error cargando canciones&quot;,&#13;&#10;            &quot;search_loading_tracks&quot; to &quot;cargando canciones...&quot;,&#13;&#10;            &quot;search_tracks&quot; to &quot;canciones&quot;,&#13;&#10;            &quot;search_albums&quot; to &quot;álbumes&quot;,&#13;&#10;            &quot;search_artists&quot; to &quot;artistas&quot;,&#13;&#10;            &quot;search_playlists&quot; to &quot;listas&quot;,&#13;&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#13;&#10;            &quot;search_youtube_playlists&quot; to &quot;listas youtube&quot;,&#13;&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#13;&#10;            &quot;search_random&quot; to &quot;aleatorio&quot;,&#13;&#10;            &quot;search_save&quot; to &quot;guardar&quot;,&#13;&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#13;&#10;            &quot;search_saved&quot; to &quot;guardado&quot;,&#13;&#10;            &quot;search_error_saving&quot; to &quot;error al guardar&quot;,&#13;&#10;            &quot;search_followers&quot; to &quot;seguidores&quot;,&#13;&#10;            &quot;search_monthly_listeners&quot; to &quot;oyentes mensuales&quot;,&#13;&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#13;&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#13;&#10;            &quot;artist_image&quot; to &quot;Imagen del artista&quot;,&#13;&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry vacía después del prefijo&quot;,&#13;&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;resultados de youtube&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#13;&#10;            &quot;colored by used engine&quot; to &quot;coloreado según el motor usado&quot;,&#13;&#10;&#13;&#10;            // Search Screen - Additional translations&#13;&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#13;&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#13;&#10;            &quot;search_removing&quot; to &quot;eliminando...&quot;,&#13;&#10;            &quot;search_removed&quot; to &quot;¡eliminado!&quot;,&#13;&#10;            &quot;search_saving_status&quot; to &quot;guardando...&quot;,&#13;&#10;            &quot;search_error_no_token&quot; to &quot;error: no hay token&quot;,&#13;&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;resultados youtube&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;cargar más&quot;,&#13;&#10;            &quot;search_error_getting_track&quot; to &quot;Error obteniendo track&quot;,&#13;&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obteniendo playlist&quot;,&#13;&#10;            &quot;search_error_getting_album&quot; to &quot;Error obteniendo álbum&quot;,&#13;&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obteniendo artista&quot;,&#13;&#10;            &quot;search_error_processing_qr&quot; to &quot;Error procesando QR&quot;,&#13;&#10;            &quot;search_adding_to_playlist&quot; to &quot;añadiendo canción a la playlist&quot;,&#13;&#10;&#13;&#10;            // Player&#13;&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#13;&#10;            &quot;play&quot; to &quot;play&quot;,&#13;&#10;            &quot;pause&quot; to &quot;pause&quot;,&#13;&#10;            &quot;next&quot; to &quot;siguiente&quot;,&#13;&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#13;&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#13;&#10;            &quot;shuffle&quot; to &quot;mezclar&quot;,&#13;&#10;&#13;&#10;            // Playlist / Form labels&#13;&#10;            &quot;playlist_name&quot; to &quot;Nombre de la playlist&quot;,&#13;&#10;            &quot;description&quot; to &quot;Descripción&quot;,&#13;&#10;            &quot;description_optional&quot; to &quot;Descripción (opcional)&quot;,&#13;&#10;            &quot;search_tracks_label&quot; to &quot;Buscar canciones&quot;,&#13;&#10;            &quot;create_playlist&quot; to &quot;Crear playlist&quot;,&#13;&#10;            &quot;playlist_name_placeholder&quot; to &quot;Nombre de la playlist&quot;,&#13;&#10;&#13;&#10;            // Local Screen&#13;&#10;            &quot;plyr_local&quot; to &quot;plyr_local&quot;,&#13;&#10;            &quot;unknown error&quot; to &quot;error desconocido&quot;,&#13;&#10;            &quot;No tracks downloaded&quot; to &quot;Ninguna canción descargada&quot;,&#13;&#10;            &quot;delete track&quot; to &quot;eliminar canción&quot;,&#13;&#10;            &quot;Song {{track_name}} will be removed permanently&quot; to &quot;La canción {{track_name}} será eliminada permanentemente&quot;,&#13;&#10;            &quot;delete&quot; to &quot;eliminar&quot;,&#13;&#10;            &quot;cancel&quot; to &quot;cancelar&quot;,&#13;&#10;&#13;&#10;            // Queue Screen&#13;&#10;            &quot;plyr_queue&quot; to &quot;plyr_cola&quot;,&#13;&#10;            &quot;No tracks loaded&quot; to &quot;Ninguna lista cargada&quot;,&#13;&#10;            &quot;Play a track to start a playlist&quot; to &quot;Reproduce una canción para iniciar una lista&quot;,&#13;&#10;            &quot;player_not_available&quot; to &quot;reproductor_no_disponible&quot;,&#13;&#10;&#13;&#10;            //Playlists Screen&#13;&#10;            &quot;plyr_lists&quot; to &quot;plyr_listas&quot;,&#13;&#10;            &quot;&lt;syncing...&gt;&quot; to &quot;&lt;sincronizando...&gt;&quot;,&#13;&#10;            &quot;&lt;sync&gt;&quot; to &quot;&lt;sincronizar&gt;&quot;,&#13;&#10;            &quot;&lt;new&gt;&quot; to &quot;&lt;crear&gt;&quot;,&#13;&#10;            &quot;Spotify not connected&quot; to &quot;Spotify no conectado&quot;,&#13;&#10;            &quot;Loading tracks...&quot; to &quot;Cargando canciones...&quot;,&#13;&#10;&#13;&#10;            // ADDITIONAL KEYS (SPANISH)&#13;&#10;            &quot;connected_successfully&quot; to &quot;conectado correctamente&quot;,&#13;&#10;            &quot;token_exchange_failed&quot; to &quot;intercambio de token fallido&quot;,&#13;&#10;            &quot;cancelled_by_user&quot; to &quot;cancelado por el usuario&quot;,&#13;&#10;            &quot;error_obtaining_audio&quot; to &quot;No se pudo obtener audio&quot;,&#13;&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#13;&#10;&#13;&#10;            // Playlist actions and dialogs&#13;&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#13;&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#13;&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#13;&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#13;&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#13;&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#13;&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#13;&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#13;&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#13;&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#13;&#10;            &quot;delete_playlist_title&quot; to &quot;Eliminar playlist&quot;,&#13;&#10;            &quot;delete_playlist_confirm&quot; to &quot;¿Seguro que quieres eliminar '%s'? Esta acción no se puede deshacer.&quot;,&#13;&#10;            &quot;unsaved_changes_title&quot; to &quot;Cambios sin guardar&quot;,&#13;&#10;            &quot;unsaved_changes_text&quot; to &quot;Tienes cambios sin guardar. ¿Seguro que quieres salir?&quot;,&#13;&#10;            &quot;exit_label&quot; to &quot;Salir&quot;,&#13;&#10;            &quot;cancel_label&quot; to &quot;Cancelar&quot;,&#13;&#10;            &quot;delete_label&quot; to &quot;Eliminar&quot;,&#13;&#10;&#13;&#10;            // SongListItem&#13;&#10;            &quot;add_to_playlist&quot; to &quot;añadir a playlist&quot;,&#13;&#10;            &quot;add_to_queue&quot; to &quot;añadir a cola&quot;,&#13;&#10;            &quot;share&quot; to &quot;compartir&quot;,&#13;&#10;            &quot;add_to_liked_songs&quot; to &quot;añadir a favoritos&quot;,&#13;&#10;            &quot;remove_from_liked_songs&quot; to &quot;quitar de favoritos&quot;,&#13;&#10;            &quot;download&quot; to &quot;descargar&quot;,&#13;&#10;&#13;&#10;            // Swipe Actions - Short versions for config screen&#13;&#10;            &quot;swipe_action_queue&quot; to &quot;cola&quot;,&#13;&#10;            &quot;swipe_action_liked&quot; to &quot;fav&quot;,&#13;&#10;            &quot;swipe_action_playlist&quot; to &quot;lista&quot;,&#13;&#10;            &quot;swipe_action_share&quot; to &quot;share&quot;,&#13;&#10;            &quot;swipe_action_download&quot; to &quot;down&quot;,&#13;&#10;&#13;&#10;            &quot;error_fetching_track_info&quot; to &quot;Error obteniendo info del track&quot;,&#13;&#10;            &quot;spotify_token_unavailable&quot; to &quot;Token de Spotify no disponible&quot;,&#13;&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#13;&#10;            &quot;album_colon&quot; to &quot;Álbum: %s&quot;,&#13;&#10;            &quot;release_colon&quot; to &quot;Lanzamiento: %s&quot;,&#13;&#10;            &quot;duration_colon&quot; to &quot;Duración: %s&quot;,&#13;&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#13;&#10;            &quot;error_loading_playlists&quot; to &quot;Error cargando playlists&quot;,&#13;&#10;            &quot;track_already_downloaded&quot; to &quot;Track ya descargado&quot;,&#13;&#10;            &quot;loading_playlists&quot; to &quot;cargando playlists...&quot;,&#13;&#10;            &quot;track_added_successfully&quot; to &quot;¡Canción añadida exitosamente!&quot;,&#13;&#10;            &quot;no_playlists_found&quot; to &quot;No se encontraron playlists&quot;,&#13;&#10;&#13;&#10;            // Assistant&#13;&#10;            &quot;assistant_settings&quot; to &quot;Asistente&quot;,&#13;&#10;            &quot;enable_assistant&quot; to &quot;Habilitar asistente&quot;,&#13;&#10;            &quot;assistant_same_language&quot; to &quot;Usar idioma de la app&quot;,&#13;&#10;            &quot;enable_tts&quot; to &quot;Respuestas por voz (TTS)&quot;,&#13;&#10;            &quot;auto_suggestions&quot; to &quot;Sugerencias automáticas&quot;,&#13;&#10;            &quot;contextual_help&quot; to &quot;Ayuda contextual&quot;,&#13;&#10;            &quot;assistant_description&quot; to &quot;El asistente te ayuda a navegar y usar la app. TTS lee las respuestas en voz alta.&quot;,&#13;&#10;            &quot;enabled&quot; to &quot;Activo&quot;,&#13;&#10;            &quot;disabled&quot; to &quot;Inactivo&quot;,&#13;&#10;            &quot;assistant_commands_available&quot; to &quot;Comandos disponibles:&quot;,&#13;&#10;            &quot;assistant_resume_playback&quot; to &quot;Reanudar la reproducción&quot;,&#13;&#10;            &quot;assistant_pause_playback&quot; to &quot;Pausar la reproducción&quot;,&#13;&#10;            &quot;assistant_next_song&quot; to &quot;Siguiente canción&quot;,&#13;&#10;            &quot;assistant_previous_song&quot; to &quot;Canción anterior&quot;,&#13;&#10;            &quot;assistant_search_play&quot; to &quot;Buscar y reproducir una canción&quot;,&#13;&#10;            &quot;assistant_search_song&quot; to &quot;Buscar una canción&quot;,&#13;&#10;            &quot;assistant_add_queue&quot; to &quot;Añadir canción a la cola&quot;,&#13;&#10;            &quot;assistant_repeat_mode&quot; to &quot;Cambiar modo de repetición&quot;,&#13;&#10;            &quot;assistant_current_song&quot; to &quot;Ver canción actual&quot;,&#13;&#10;            &quot;assistant_see_commands&quot; to &quot;Ver todos los comandos&quot;,&#13;&#10;            &quot;assistant_playing&quot; to &quot;Reproduciendo&quot;,&#13;&#10;            &quot;assistant_paused&quot; to &quot;Pausado&quot;,&#13;&#10;            &quot;assistant_next&quot; to &quot;Siguiente canción&quot;,&#13;&#10;            &quot;assistant_previous&quot; to &quot;Canción anterior&quot;,&#13;&#10;            &quot;assistant_repeat_changed&quot; to &quot;Modo de repetición cambiado&quot;,&#13;&#10;            &quot;assistant_open_settings&quot; to &quot;Para abrir ajustes, pulsa el icono de configuración&quot;,&#13;&#10;            &quot;assistant_what_play&quot; to &quot;Dime qué quieres reproducir&quot;,&#13;&#10;            &quot;assistant_what_search&quot; to &quot;Dime qué quieres buscar&quot;,&#13;&#10;            &quot;assistant_what_add&quot; to &quot;Dime qué quieres añadir a la cola&quot;,&#13;&#10;            &quot;assistant_no_results&quot; to &quot;No encontré resultados para: %s&quot;,&#13;&#10;            &quot;assistant_error_play&quot; to &quot;Error al reproducir: %s&quot;,&#13;&#10;            &quot;assistant_playing_song&quot; to &quot;Reproduciendo: %s de %s&quot;,&#13;&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Reproduciendo: %s&quot;,&#13;&#10;            &quot;assistant_found&quot; to &quot;Encontré: %s de %s&quot;,&#13;&#10;            &quot;assistant_added_queue&quot; to &quot;Añadido a la cola: %s de %s&quot;,&#13;&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Añadido a la cola: %s&quot;,&#13;&#10;            &quot;assistant_now_playing&quot; to &quot;Reproduciendo: %s de %s&quot;,&#13;&#10;            &quot;assistant_unknown_artist&quot; to &quot;Artista desconocido&quot;,&#13;&#10;            &quot;assistant_nothing_playing&quot; to &quot;No hay ninguna canción en reproducción&quot;,&#13;&#10;            &quot;assistant_not_understand&quot; to &quot;No entiendo. Di 'ayuda' para ver los comandos disponibles.&quot;,&#13;&#10;            &quot;assistant_error&quot; to &quot;Error al ejecutar la acción&quot;,&#13;&#10;            &quot;assistant_listening&quot; to &quot;Escuchando...&quot;,&#13;&#10;            &quot;assistant_processing&quot; to &quot;Procesando...&quot;,&#13;&#10;&#13;&#10;            // Nuevas respuestas del asistente&#13;&#10;            &quot;assistant_muted&quot; to &quot;Silenciado&quot;,&#13;&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volumen al %d%%&quot;,&#13;&#10;            &quot;assistant_what_volume&quot; to &quot;Dime a qué nivel quieres el volumen&quot;,&#13;&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Temporizador configurado para %d minutos&quot;,&#13;&#10;            &quot;assistant_what_time&quot; to &quot;Dime en cuántos minutos quieres parar la música&quot;,&#13;&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Temporizador cancelado&quot;,&#13;&#10;            &quot;assistant_shuffled&quot; to &quot;Lista mezclada&quot;,&#13;&#10;            &quot;assistant_added_favorites&quot; to &quot;Añadido a favoritos: %s&quot;,&#13;&#10;            &quot;assistant_song_saved&quot; to &quot;Canción guardada: %s&quot;,&#13;&#10;            &quot;assistant_cannot_save&quot; to &quot;No se puede guardar esta canción&quot;,&#13;&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' creada&quot;,&#13;&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Dime el nombre de la playlist&quot;,&#13;&#10;            &quot;assistant_artist_info&quot; to &quot;Esta canción es de %s&quot;,&#13;&#10;            &quot;assistant_album_info&quot; to &quot;Esta canción es del álbum %s&quot;,&#13;&#10;            &quot;assistant_unknown_album&quot; to &quot;Álbum desconocido&quot;,&#13;&#10;            &quot;assistant_duration_info&quot; to &quot;Vas por %s de %s&quot;,&#13;&#10;&#13;&#10;            // Nuevas descripciones de comandos&#13;&#10;            &quot;assistant_volume_desc&quot; to &quot;Controlar el volumen&quot;,&#13;&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Mezclar la playlist&quot;,&#13;&#10;            &quot;assistant_favorites_desc&quot; to &quot;Añadir a favoritos&quot;,&#13;&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Información del artista&quot;,&#13;&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Temporizador de sueño&quot;,&#13;&#10;&#13;&#10;            // Assistant Triggers (palabras clave que activan cada comando)&#13;&#10;            &quot;assistant_triggers_help&quot; to &quot;ayuda|comandos|qué puedo decir|que puedo decir|qué puedes hacer|que puedes hacer|opciones&quot;,&#13;&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;qué suena|que suena|qué está sonando|que esta sonando|qué canción es|que cancion es|canción actual|cancion actual|qué estoy escuchando|que estoy escuchando|qué reproduce|que reproduce&quot;,&#13;&#10;            &quot;assistant_triggers_next&quot; to &quot;siguiente|sigue|próxima|proxima|siguiente canción|siguiente cancion|pasa|salta|saltar&quot;,&#13;&#10;            &quot;assistant_triggers_previous&quot; to &quot;anterior|atrás|atras|canción anterior|cancion anterior|vuelve|regresa|retrocede&quot;,&#13;&#10;            &quot;assistant_triggers_pause&quot; to &quot;pausa|pausar|para|parar|detén|deten|detener|stop&quot;,&#13;&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repetir|repite|repetición|repeticion|bucle|loop&quot;,&#13;&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;añadir a la cola|agregar a la cola|añade a la cola|agrega a la cola|pon en la cola|meter en la cola|encolar&quot;,&#13;&#10;            &quot;assistant_triggers_play&quot; to &quot;reproducir|reproduce|pon|ponme|toca|tocar|escuchar|escucha|play|quiero escuchar|quiero oír|quiero oir&quot;,&#13;&#10;            &quot;assistant_triggers_resume&quot; to &quot;continuar|continua|reanudar|reanuda|sigue|seguir&quot;,&#13;&#10;            &quot;assistant_triggers_search&quot; to &quot;buscar|busca|encuentra|encontrar|búsqueda|busqueda&quot;,&#13;&#10;            &quot;assistant_triggers_settings&quot; to &quot;ajustes|configuración|configuracion|config|opciones de configuración&quot;,&#13;&#10;&#13;&#10;            // Nuevos triggers para volumen&#13;&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;sube el volumen|subir volumen|más volumen|mas volumen|más alto|mas alto|volumen arriba&quot;,&#13;&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;baja el volumen|bajar volumen|menos volumen|más bajo|mas bajo|volumen abajo&quot;,&#13;&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;volumen al|pon el volumen|volumen a&quot;,&#13;&#10;            &quot;assistant_triggers_mute&quot; to &quot;silenciar|silencio|mute|mutear|calla&quot;,&#13;&#10;&#13;&#10;            // Nuevos triggers para información contextual&#13;&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;quién canta|quien canta|quién es el artista|quien es el artista|de quién es|de quien es|artista&quot;,&#13;&#10;            &quot;assistant_triggers_what_album&quot; to &quot;de qué álbum|de que album|qué álbum|que album|álbum&quot;,&#13;&#10;            &quot;assistant_triggers_how_long&quot; to &quot;cuánto dura|cuanto dura|duración|duracion|cuánto queda|cuanto queda|tiempo&quot;,&#13;&#10;&#13;&#10;            // Nuevos triggers para playlist&#13;&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;mezcla|mezclar|aleatorio|shuffle|random|baraja|barajar&quot;,&#13;&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;añade a favoritos|agregar a favoritos|me gusta|guardar en favoritos|favorito&quot;,&#13;&#10;            &quot;assistant_triggers_save_song&quot; to &quot;guarda esta canción|guardar canción|guarda esta|save&quot;,&#13;&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;crea una playlist|crear playlist|nueva playlist|crea lista&quot;,&#13;&#10;&#13;&#10;            // Nuevos triggers para temporizador de sueño&#13;&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;para la música en|apágate en|apagar en|temporizador|para en|apagar en|para a las|apágate a las|apagate a las&quot;,&#13;&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancela el temporizador|cancelar temporizador|quita el temporizador|no te apagues&quot;,&#13;&#10;&#13;&#10;            // Nuevos triggers para comandos naturales&#13;&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;ponme algo de|pon algo de|música de|quiero&quot;,&#13;&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;algo alegre|algo triste|algo tranquilo|algo animado|algo relajante|música para&quot;,&#13;&#10;&#13;&#10;            // Assistant Commands (para mostrar en ayuda)&#13;&#10;            &quot;assistant_cmd_play&quot; to &quot;play / reproducir&quot;,&#13;&#10;            &quot;assistant_cmd_pause&quot; to &quot;pausa / stop&quot;,&#13;&#10;            &quot;assistant_cmd_next&quot; to &quot;siguiente / salta&quot;,&#13;&#10;            &quot;assistant_cmd_previous&quot; to &quot;anterior / atrás&quot;,&#13;&#10;            &quot;assistant_cmd_play_song&quot; to &quot;pon &lt;canción&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_search&quot; to &quot;buscar &lt;canción&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;añadir a la cola &lt;canción&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repetir&quot;,&#13;&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;qué suena&quot;,&#13;&#10;            &quot;assistant_cmd_help&quot; to &quot;ayuda / comandos&quot;,&#13;&#10;            &quot;assistant_cmd_volume&quot; to &quot;volumen&quot;,&#13;&#10;            &quot;assistant_cmd_shuffle&quot; to &quot;mezclar&quot;,&#13;&#10;            &quot;assistant_cmd_favorites&quot; to &quot;favoritos&quot;,&#13;&#10;            &quot;assistant_cmd_who_sings&quot; to &quot;quién canta&quot;,&#13;&#10;            &quot;assistant_cmd_sleep_timer&quot; to &quot;temporizador&quot;,&#13;&#10;&#13;&#10;        ),&#13;&#10;&#13;&#10;        // ENGLISH&#13;&#10;        &quot;english&quot; to mapOf(&#13;&#10;            // Config Screen&#13;&#10;            &quot;assistant_settings&quot; to &quot;Assistant&quot;,&#13;&#10;            &quot;enable_assistant&quot; to &quot;Enable assistant&quot;,&#13;&#10;            &quot;assistant_same_language&quot; to &quot;Use app language&quot;,&#13;&#10;            &quot;enable_tts&quot; to &quot;Voice responses (TTS)&quot;,&#13;&#10;            &quot;auto_suggestions&quot; to &quot;Auto suggestions&quot;,&#13;&#10;            &quot;contextual_help&quot; to &quot;Contextual help&quot;,&#13;&#10;            &quot;assistant_description&quot; to &quot;The assistant helps you navigate and use the app. TTS will read responses aloud.&quot;,&#13;&#10;            &quot;enabled&quot; to &quot;Enabled&quot;,&#13;&#10;            &quot;disabled&quot; to &quot;Disabled&quot;,&#13;&#10;            &quot;config_title&quot; to &quot;plyr_config&quot;,&#13;&#10;            &quot;theme&quot; to &quot;&gt; theme&quot;,&#13;&#10;            &quot;theme_dark&quot; to &quot;dark&quot;,&#13;&#10;            &quot;theme_light&quot; to &quot;light&quot;,&#13;&#10;            &quot;theme_system&quot; to &quot;system&quot;,&#13;&#10;            &quot;search_engine&quot; to &quot;&gt; search_engine&quot;,&#13;&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#13;&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#13;&#10;            &quot;audio_quality&quot; to &quot;&gt; audio_quality&quot;,&#13;&#10;            &quot;quality_low&quot; to &quot;low&quot;,&#13;&#10;            &quot;quality_med&quot; to &quot;med&quot;,&#13;&#10;            &quot;quality_high&quot; to &quot;high&quot;,&#13;&#10;            &quot;language&quot; to &quot;&gt; language&quot;,&#13;&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#13;&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#13;&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#13;&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#13;&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#13;&#10;            &quot;login&quot; to &quot;&lt;login&gt;&quot;,&#13;&#10;            &quot;info_text&quot; to &quot;    ● don't pirate music!\n    ● Change engine with yt: / sp:&quot;,&#13;&#10;            &quot;spotify_status&quot; to &quot;&gt; sptfy_status&quot;,&#13;&#10;            &quot;acoustid_status&quot; to &quot;&gt; acoustid_status&quot;,&#13;&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#13;&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#13;&#10;            &quot;connected&quot; to &quot;connected&quot;,&#13;&#10;            &quot;disconnected&quot; to &quot;disconnected&quot;,&#13;&#10;            &quot;configured&quot; to &quot;configured&quot;,&#13;&#10;            &quot;not_configured&quot; to &quot;not_configured&quot;,&#13;&#10;            &quot;credentials_required&quot; to &quot;credentials required&quot;,&#13;&#10;            &quot;configure_credentials_first&quot; to &quot;configure credentials first&quot;,&#13;&#10;            &quot;opening_browser&quot; to &quot;opening_browser...&quot;,&#13;&#10;            &quot;check_browser&quot; to &quot;check_browser&quot;,&#13;&#10;            &quot;error_starting_oauth&quot; to &quot;error_starting_oauth&quot;,&#13;&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#13;&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#13;&#10;            &quot;enter_client_id&quot; to &quot;enter your spotify client id&quot;,&#13;&#10;            &quot;enter_client_secret&quot; to &quot;enter your spotify client secret&quot;,&#13;&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; how to get spotify api credentials:&quot;,&#13;&#10;            &quot;instruction_1&quot; to &quot;1. go to https://developer.spotify.com/dashboard&quot;,&#13;&#10;            &quot;instruction_2&quot; to &quot;2. log in with your spotify account&quot;,&#13;&#10;            &quot;instruction_3&quot; to &quot;3. click 'create app'&quot;,&#13;&#10;            &quot;instruction_4&quot; to &quot;4. fill app name (e.g., 'plyr mobile')&quot;,&#13;&#10;            &quot;instruction_5&quot; to &quot;5. set redirect uri: 'plyr://spotify/callback'&quot;,&#13;&#10;            &quot;instruction_6&quot; to &quot;6. select 'mobile' and 'web api'&quot;,&#13;&#10;            &quot;instruction_7&quot; to &quot;7. click 'save'&quot;,&#13;&#10;            &quot;instruction_8&quot; to &quot;8. copy client id and client secret&quot;,&#13;&#10;            &quot;instruction_9&quot; to &quot;9. paste them in the fields above&quot;,&#13;&#10;            &quot;note_local_storage&quot; to &quot;      note: these credentials are stored locally&quot;,&#13;&#10;            &quot;albums&quot; to &quot;&gt; albums&quot;,&#13;&#10;            &quot;similar_songs&quot; to &quot;&gt; recommendations&quot;,&#13;&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generating recommendations...&gt;&quot;,&#13;&#10;            &quot;share_with_NFC&quot; to &quot;&lt;share with NFC&gt;&quot;,&#13;&#10;&#13;&#10;            // AcoustID Configuration&#13;&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#13;&#10;            &quot;enter_acoustid_api_key&quot; to &quot;enter your acoustid api key&quot;,&#13;&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID is a free service for music identification.\n      How to get your API Key:\n      1. Go to https://acoustid.org/new-application\n      2. Create an account or log in\n      3. Create a new application (name: 'plyr')\n      4. Copy your API Key and paste it above\n      5. This key allows you to identify songs from the app&quot;,&#13;&#10;&#13;&#10;            // Last.fm Configuration&#13;&#10;            &quot;lastfm_status&quot; to &quot;&gt; lastfm_status&quot;,&#13;&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#13;&#10;            &quot;enter_lastfm_api_key&quot; to &quot;enter your last.fm api key&quot;,&#13;&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm is a music service for getting recommendations.\n      How to get your API Key:\n      1. Go to https://www.last.fm/api/account/create\n      2. Create an account or log in\n      3. Fill in the application data (name: 'plyr')\n      4. Copy your API Key and paste it above\n      5. This key allows you to get artist recommendations&quot;,&#13;&#10;&#13;&#10;            // Swipe Actions Configuration&#13;&#10;            &quot;swipe_actions&quot; to &quot;&gt; swipe_actions&quot;,&#13;&#10;            &quot;swipe_left&quot; to &quot;swipe left&quot;,&#13;&#10;            &quot;swipe_right&quot; to &quot;swipe right&quot;,&#13;&#10;&#13;&#10;            // Main Screen&#13;&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#13;&#10;            &quot;search_hint&quot; to &quot;search...&quot;,&#13;&#10;            &quot;no_results&quot; to &quot;no results found&quot;,&#13;&#10;            &quot;loading&quot; to &quot;loading...&quot;,&#13;&#10;&#13;&#10;            // Home Screen&#13;&#10;            &quot;home_search&quot; to &quot;search&quot;,&#13;&#10;            &quot;home_playlists&quot; to &quot;playlists&quot;,&#13;&#10;            &quot;home_queue&quot; to &quot;queue&quot;,&#13;&#10;            &quot;home_local&quot; to &quot;local&quot;,&#13;&#10;            &quot;home_settings&quot; to &quot;settings&quot;,&#13;&#10;            &quot;exit_message&quot; to &quot;Press back again to exit&quot;,&#13;&#10;&#13;&#10;            // Search Screen&#13;&#10;            &quot;search_title&quot; to &quot;plyr_search&quot;,&#13;&#10;            &quot;search_placeholder&quot; to &quot;search music...&quot;,&#13;&#10;            &quot;search_loading&quot; to &quot;loading...&quot;,&#13;&#10;            &quot;search_no_results&quot; to &quot;no results found&quot;,&#13;&#10;            &quot;search_error&quot; to &quot;error&quot;,&#13;&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify is not connected&quot;,&#13;&#10;            &quot;search_token_not_available&quot; to &quot;Spotify token not available&quot;,&#13;&#10;            &quot;search_engine_not_recognized&quot; to &quot;Search engine not recognized&quot;,&#13;&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error loading tracks&quot;,&#13;&#10;            &quot;search_loading_tracks&quot; to &quot;loading tracks...&quot;,&#13;&#10;            &quot;search_tracks&quot; to &quot;tracks&quot;,&#13;&#10;            &quot;search_albums&quot; to &quot;albums&quot;,&#13;&#10;            &quot;search_artists&quot; to &quot;artists&quot;,&#13;&#10;            &quot;search_playlists&quot; to &quot;playlists&quot;,&#13;&#10;            &quot;search_videos&quot; to &quot;videos&quot;,&#13;&#10;            &quot;search_youtube_playlists&quot; to &quot;youtube playlists&quot;,&#13;&#10;            &quot;search_start&quot; to &quot;start&quot;,&#13;&#10;            &quot;search_random&quot; to &quot;random&quot;,&#13;&#10;            &quot;search_save&quot; to &quot;save&quot;,&#13;&#10;            &quot;search_share&quot; to &quot;share&quot;,&#13;&#10;            &quot;search_saved&quot; to &quot;saved&quot;,&#13;&#10;            &quot;search_error_saving&quot; to &quot;error saving&quot;,&#13;&#10;            &quot;search_followers&quot; to &quot;followers&quot;,&#13;&#10;            &quot;search_monthly_listeners&quot; to &quot;monthly listeners&quot;,&#13;&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#13;&#10;            &quot;playlist_cover&quot; to &quot;Playlist cover&quot;,&#13;&#10;            &quot;artist_image&quot; to &quot;Artist image&quot;,&#13;&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Query empty after prefix&quot;,&#13;&#10;            &quot;album_cover&quot; to &quot;Album cover&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#13;&#10;            &quot;colored by used engine&quot; to &quot;colored by used engine&quot;,&#13;&#10;&#13;&#10;            // Search Screen - Additional translations&#13;&#10;            &quot;search_select_playlist&quot; to &quot;Select playlist&quot;,&#13;&#10;            &quot;search_cancel&quot; to &quot;Cancel&quot;,&#13;&#10;            &quot;search_removing&quot; to &quot;removing...&quot;,&#13;&#10;            &quot;search_removed&quot; to &quot;removed!&quot;,&#13;&#10;            &quot;search_saving_status&quot; to &quot;saving...&quot;,&#13;&#10;            &quot;search_error_no_token&quot; to &quot;error: no token&quot;,&#13;&#10;            &quot;search_unsave&quot; to &quot;unsave&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;youtube results&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;load more&quot;,&#13;&#10;            &quot;search_error_getting_track&quot; to &quot;Error getting track&quot;,&#13;&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error getting playlist&quot;,&#13;&#10;            &quot;search_error_getting_album&quot; to &quot;Error getting album&quot;,&#13;&#10;            &quot;search_error_getting_artist&quot; to &quot;Error getting artist&quot;,&#13;&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processing QR&quot;,&#13;&#10;            &quot;search_adding_to_playlist&quot; to &quot;adding song to playlist&quot;,&#13;&#10;&#13;&#10;            // Player&#13;&#10;            &quot;now_playing&quot; to &quot;now playing&quot;,&#13;&#10;            &quot;play&quot; to &quot;play&quot;,&#13;&#10;            &quot;pause&quot; to &quot;pause&quot;,&#13;&#10;            &quot;next&quot; to &quot;next&quot;,&#13;&#10;            &quot;previous&quot; to &quot;previous&quot;,&#13;&#10;            &quot;repeat&quot; to &quot;repeat&quot;,&#13;&#10;            &quot;shuffle&quot; to &quot;shuffle&quot;,&#13;&#10;&#13;&#10;            // ADDITIONAL KEYS (ENGLISH)&#13;&#10;            &quot;connected_successfully&quot; to &quot;Connected successfully&quot;,&#13;&#10;            &quot;token_exchange_failed&quot; to &quot;Token exchange failed&quot;,&#13;&#10;            &quot;cancelled_by_user&quot; to &quot;Cancelled by user&quot;,&#13;&#10;            &quot;error_obtaining_audio&quot; to &quot;Could not obtain audio&quot;,&#13;&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#13;&#10;&#13;&#10;            // Playlist actions and dialogs&#13;&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#13;&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#13;&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#13;&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#13;&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#13;&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#13;&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#13;&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#13;&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#13;&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#13;&#10;            &quot;delete_playlist_title&quot; to &quot;Delete playlist&quot;,&#13;&#10;            &quot;delete_playlist_confirm&quot; to &quot;Are you sure you want to delete '%s'? This action cannot be undone.&quot;,&#13;&#10;            &quot;unsaved_changes_title&quot; to &quot;Unsaved changes&quot;,&#13;&#10;            &quot;unsaved_changes_text&quot; to &quot;You have unsaved changes. Are you sure you want to exit?&quot;,&#13;&#10;            &quot;exit_label&quot; to &quot;Exit&quot;,&#13;&#10;            &quot;cancel_label&quot; to &quot;Cancel&quot;,&#13;&#10;            &quot;delete_label&quot; to &quot;Delete&quot;,&#13;&#10;&#13;&#10;            // SongListItem&#13;&#10;            &quot;add_to_playlist&quot; to &quot;add to playlist&quot;,&#13;&#10;            &quot;add_to_queue&quot; to &quot;add to queue&quot;,&#13;&#10;            &quot;share&quot; to &quot;share&quot;,&#13;&#10;            &quot;add_to_liked_songs&quot; to &quot;add to liked songs&quot;,&#13;&#10;            &quot;remove_from_liked_songs&quot; to &quot;remove from liked songs&quot;,&#13;&#10;            &quot;download&quot; to &quot;download&quot;,&#13;&#10;&#13;&#10;            // Swipe Actions - Short versions for config screen&#13;&#10;            &quot;swipe_action_queue&quot; to &quot;queue&quot;,&#13;&#10;            &quot;swipe_action_liked&quot; to &quot;fav&quot;,&#13;&#10;            &quot;swipe_action_playlist&quot; to &quot;list&quot;,&#13;&#10;            &quot;swipe_action_share&quot; to &quot;share&quot;,&#13;&#10;            &quot;swipe_action_download&quot; to &quot;down&quot;,&#13;&#10;&#13;&#10;            &quot;error_fetching_track_info&quot; to &quot;Error fetching track info&quot;,&#13;&#10;            &quot;spotify_token_unavailable&quot; to &quot;Spotify token unavailable&quot;,&#13;&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#13;&#10;            &quot;album_colon&quot; to &quot;Album: %s&quot;,&#13;&#10;            &quot;release_colon&quot; to &quot;Release: %s&quot;,&#13;&#10;            &quot;duration_colon&quot; to &quot;Duration: %s&quot;,&#13;&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#13;&#10;            &quot;error_loading_playlists&quot; to &quot;Error loading playlists&quot;,&#13;&#10;            &quot;track_already_downloaded&quot; to &quot;Track already downloaded&quot;,&#13;&#10;            &quot;loading_playlists&quot; to &quot;loading playlists...&quot;,&#13;&#10;            &quot;track_added_successfully&quot; to &quot;Track added successfully!&quot;,&#13;&#10;            &quot;no_playlists_found&quot; to &quot;No playlists found&quot;,&#13;&#10;&#13;&#10;            // Assistant&#13;&#10;            &quot;assistant_settings&quot; to &quot;Assistant&quot;,&#13;&#10;            &quot;enable_assistant&quot; to &quot;Enable assistant&quot;,&#13;&#10;            &quot;assistant_same_language&quot; to &quot;Use app language&quot;,&#13;&#10;            &quot;enable_tts&quot; to &quot;Voice responses (TTS)&quot;,&#13;&#10;            &quot;auto_suggestions&quot; to &quot;Auto suggestions&quot;,&#13;&#10;            &quot;contextual_help&quot; to &quot;Contextual help&quot;,&#13;&#10;            &quot;assistant_description&quot; to &quot;The assistant helps you navigate and use the app. TTS will read responses aloud.&quot;,&#13;&#10;            &quot;enabled&quot; to &quot;Enabled&quot;,&#13;&#10;            &quot;disabled&quot; to &quot;Disabled&quot;,&#13;&#10;            &quot;assistant_commands_available&quot; to &quot;Available commands:&quot;,&#13;&#10;            &quot;assistant_resume_playback&quot; to &quot;Resume playback&quot;,&#13;&#10;            &quot;assistant_pause_playback&quot; to &quot;Pause playback&quot;,&#13;&#10;            &quot;assistant_next_song&quot; to &quot;Next song&quot;,&#13;&#10;            &quot;assistant_previous_song&quot; to &quot;Previous song&quot;,&#13;&#10;            &quot;assistant_search_play&quot; to &quot;Search and play a song&quot;,&#13;&#10;            &quot;assistant_search_song&quot; to &quot;Search for a song&quot;,&#13;&#10;            &quot;assistant_add_queue&quot; to &quot;Add song to queue&quot;,&#13;&#10;            &quot;assistant_repeat_mode&quot; to &quot;Change repeat mode&quot;,&#13;&#10;            &quot;assistant_current_song&quot; to &quot;View current song&quot;,&#13;&#10;            &quot;assistant_see_commands&quot; to &quot;View all commands&quot;,&#13;&#10;            &quot;assistant_playing&quot; to &quot;Playing&quot;,&#13;&#10;            &quot;assistant_paused&quot; to &quot;Paused&quot;,&#13;&#10;            &quot;assistant_next&quot; to &quot;Next song&quot;,&#13;&#10;            &quot;assistant_previous&quot; to &quot;Previous song&quot;,&#13;&#10;            &quot;assistant_repeat_changed&quot; to &quot;Repeat mode changed&quot;,&#13;&#10;            &quot;assistant_open_settings&quot; to &quot;To open settings, tap the settings icon&quot;,&#13;&#10;            &quot;assistant_what_play&quot; to &quot;Tell me what you want to play&quot;,&#13;&#10;            &quot;assistant_what_search&quot; to &quot;Tell me what you want to search&quot;,&#13;&#10;            &quot;assistant_what_add&quot; to &quot;Tell me what you want to add to the queue&quot;,&#13;&#10;            &quot;assistant_no_results&quot; to &quot;No results found for: %s&quot;,&#13;&#10;            &quot;assistant_error_play&quot; to &quot;Error playing: %s&quot;,&#13;&#10;            &quot;assistant_playing_song&quot; to &quot;Playing: %s by %s&quot;,&#13;&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Playing: %s&quot;,&#13;&#10;            &quot;assistant_found&quot; to &quot;Found: %s by %s&quot;,&#13;&#10;            &quot;assistant_added_queue&quot; to &quot;Added to queue: %s by %s&quot;,&#13;&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Added to queue: %s&quot;,&#13;&#10;            &quot;assistant_now_playing&quot; to &quot;Now playing: %s by %s&quot;,&#13;&#10;            &quot;assistant_unknown_artist&quot; to &quot;Unknown artist&quot;,&#13;&#10;            &quot;assistant_nothing_playing&quot; to &quot;No song is currently playing&quot;,&#13;&#10;            &quot;assistant_not_understand&quot; to &quot;I don't understand. Say 'help' to see available commands.&quot;,&#13;&#10;            &quot;assistant_error&quot; to &quot;Error executing action&quot;,&#13;&#10;            &quot;assistant_listening&quot; to &quot;Listening...&quot;,&#13;&#10;            &quot;assistant_processing&quot; to &quot;Processing...&quot;,&#13;&#10;&#13;&#10;            // New assistant responses&#13;&#10;            &quot;assistant_muted&quot; to &quot;Muted&quot;,&#13;&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volume at %d%%&quot;,&#13;&#10;            &quot;assistant_what_volume&quot; to &quot;Tell me what volume level you want&quot;,&#13;&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Sleep timer set for %d minutes&quot;,&#13;&#10;            &quot;assistant_what_time&quot; to &quot;Tell me in how many minutes to stop the music&quot;,&#13;&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Timer cancelled&quot;,&#13;&#10;            &quot;assistant_shuffled&quot; to &quot;Playlist shuffled&quot;,&#13;&#10;            &quot;assistant_added_favorites&quot; to &quot;Added to favorites: %s&quot;,&#13;&#10;            &quot;assistant_song_saved&quot; to &quot;Song saved: %s&quot;,&#13;&#10;            &quot;assistant_cannot_save&quot; to &quot;Cannot save this song&quot;,&#13;&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' created&quot;,&#13;&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Tell me the playlist name&quot;,&#13;&#10;            &quot;assistant_artist_info&quot; to &quot;This song is by %s&quot;,&#13;&#10;            &quot;assistant_album_info&quot; to &quot;This song is from the album %s&quot;,&#13;&#10;            &quot;assistant_unknown_album&quot; to &quot;Unknown album&quot;,&#13;&#10;            &quot;assistant_duration_info&quot; to &quot;You're at %s of %s&quot;,&#13;&#10;&#13;&#10;            // New command descriptions&#13;&#10;            &quot;assistant_volume_desc&quot; to &quot;Control volume&quot;,&#13;&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Shuffle playlist&quot;,&#13;&#10;            &quot;assistant_favorites_desc&quot; to &quot;Add to favorites&quot;,&#13;&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Artist info&quot;,&#13;&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Sleep timer&quot;,&#13;&#10;&#13;&#10;            // Assistant Triggers (keywords that trigger each command)&#13;&#10;            &quot;assistant_triggers_help&quot; to &quot;help|commands|what can i say|what can you do|options|assist&quot;,&#13;&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;what's playing|whats playing|what is playing|current song|now playing|what song is this|what am i listening to|playing now&quot;,&#13;&#10;            &quot;assistant_triggers_next&quot; to &quot;next|next song|skip|skip song|play next|forward|next track&quot;,&#13;&#10;            &quot;assistant_triggers_previous&quot; to &quot;previous|prev|back|go back|previous song|last song|previous track|rewind&quot;,&#13;&#10;            &quot;assistant_triggers_pause&quot; to &quot;pause|stop|halt|hold|freeze&quot;,&#13;&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repeat|loop|repeat mode|toggle repeat|cycle repeat&quot;,&#13;&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;add to queue|queue|add to the queue|enqueue|put in queue&quot;,&#13;&#10;            &quot;assistant_triggers_play&quot; to &quot;play|start|begin|go|i want to listen|i wanna hear|play me|put on&quot;,&#13;&#10;            &quot;assistant_triggers_resume&quot; to &quot;resume|continue|unpause|carry on&quot;,&#13;&#10;            &quot;assistant_triggers_search&quot; to &quot;search|search for|find|look for|look up&quot;,&#13;&#10;            &quot;assistant_triggers_settings&quot; to &quot;settings|config|configuration|preferences|options&quot;,&#13;&#10;&#13;&#10;            // New volume triggers&#13;&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;turn up the volume|volume up|louder|raise volume|increase volume&quot;,&#13;&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;turn down the volume|volume down|quieter|lower volume|decrease volume&quot;,&#13;&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;set volume to|volume to|volume at&quot;,&#13;&#10;            &quot;assistant_triggers_mute&quot; to &quot;mute|silence|quiet|shut up&quot;,&#13;&#10;&#13;&#10;            // New contextual info triggers&#13;&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;who sings|who's the artist|who is the artist|who is this|artist|singer&quot;,&#13;&#10;            &quot;assistant_triggers_what_album&quot; to &quot;what album|which album|album name|from what album&quot;,&#13;&#10;            &quot;assistant_triggers_how_long&quot; to &quot;how long|duration|how much time|time left|how much is left&quot;,&#13;&#10;&#13;&#10;            // New playlist triggers&#13;&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;shuffle|mix|randomize|random|mix it up&quot;,&#13;&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;add to favorites|like this|love this|save to favorites|favorite&quot;,&#13;&#10;            &quot;assistant_triggers_save_song&quot; to &quot;save this song|save song|save this|save it&quot;,&#13;&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;create a playlist|new playlist|make a playlist|create playlist&quot;,&#13;&#10;&#13;&#10;            // New sleep timer triggers&#13;&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;stop music in|turn off in|sleep timer|stop in|turn off at|stop at&quot;,&#13;&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancel timer|cancel the timer|remove timer|don't turn off&quot;,&#13;&#10;&#13;&#10;            // New natural command triggers&#13;&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;play me some|play some|i want|give me some&quot;,&#13;&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;something happy|something sad|something calm|something upbeat|something relaxing|music for&quot;,&#13;&#10;&#13;&#10;            // Assistant Commands (for help display)&#13;&#10;            &quot;assistant_cmd_play&quot; to &quot;play&quot;,&#13;&#10;            &quot;assistant_cmd_pause&quot; to &quot;pause / stop&quot;,&#13;&#10;            &quot;assistant_cmd_next&quot; to &quot;next / skip&quot;,&#13;&#10;            &quot;assistant_cmd_previous&quot; to &quot;previous / back&quot;,&#13;&#10;            &quot;assistant_cmd_play_song&quot; to &quot;play &lt;song&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_search&quot; to &quot;search &lt;song&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;add to queue &lt;song&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repeat / loop&quot;,&#13;&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;what's playing&quot;,&#13;&#10;            &quot;assistant_cmd_help&quot; to &quot;help / commands&quot;,&#13;&#10;&#13;&#10;        ),&#13;&#10;&#13;&#10;        // CATALÀ&#13;&#10;        &quot;català&quot; to mapOf(&#13;&#10;            // Config Screen&#13;&#10;            &quot;assistant_settings&quot; to &quot;Assistent&quot;,&#13;&#10;            &quot;enable_assistant&quot; to &quot;Habilitar assistent&quot;,&#13;&#10;            &quot;assistant_same_language&quot; to &quot;Utilitzar idioma de l'app&quot;,&#13;&#10;            &quot;enable_tts&quot; to &quot;Respostes per veu (TTS)&quot;,&#13;&#10;            &quot;auto_suggestions&quot; to &quot;Suggeriments automàtics&quot;,&#13;&#10;            &quot;contextual_help&quot; to &quot;Ajuda contextual&quot;,&#13;&#10;            &quot;assistant_description&quot; to &quot;L'assistent t'ajuda a navegar i utilitzar l'app. TTS llegeix les respostes en veu alta.&quot;,&#13;&#10;            &quot;enabled&quot; to &quot;Actiu&quot;,&#13;&#10;            &quot;disabled&quot; to &quot;Inactiu&quot;,&#13;&#10;            &quot;config_title&quot; to &quot;plyr_configuració&quot;,&#13;&#10;            &quot;theme&quot; to &quot;&gt; tema&quot;,&#13;&#10;            &quot;theme_dark&quot; to &quot;fosc&quot;,&#13;&#10;            &quot;theme_light&quot; to &quot;clar&quot;,&#13;&#10;            &quot;theme_system&quot; to &quot;sistema&quot;,&#13;&#10;            &quot;search_engine&quot; to &quot;&gt; motor_cerca&quot;,&#13;&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#13;&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#13;&#10;            &quot;audio_quality&quot; to &quot;&gt; qualitat_audio&quot;,&#13;&#10;            &quot;quality_low&quot; to &quot;baixa&quot;,&#13;&#10;            &quot;quality_med&quot; to &quot;mitjana&quot;,&#13;&#10;            &quot;quality_high&quot; to &quot;alta&quot;,&#13;&#10;            &quot;language&quot; to &quot;&gt; idioma&quot;,&#13;&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#13;&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#13;&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#13;&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#13;&#10;            &quot;info&quot; to &quot;&gt; info&quot;,&#13;&#10;            &quot;info_text&quot; to &quot;    ● no piratejis música!\n    ● Canvia motor amb yt: / sp:&quot;,&#13;&#10;            &quot;spotify_status&quot; to &quot;&gt; estat_sptfy&quot;,&#13;&#10;            &quot;acoustid_status&quot; to &quot;&gt; estat_acoustid&quot;,&#13;&#10;            &quot;login&quot; to &quot;&lt;iniciar_sessió&gt;&quot;,&#13;&#10;            &quot;client&quot; to &quot;    ● client:&quot;,&#13;&#10;            &quot;api&quot; to &quot;    ● api:&quot;,&#13;&#10;            &quot;connected&quot; to &quot;connectat&quot;,&#13;&#10;            &quot;disconnected&quot; to &quot;desconnectat&quot;,&#13;&#10;            &quot;configured&quot; to &quot;configurat&quot;,&#13;&#10;            &quot;not_configurat&quot; to &quot;no_configurat&quot;,&#13;&#10;            &quot;credentials_required&quot; to &quot;credencials requerides&quot;,&#13;&#10;            &quot;configure_credentials_first&quot; to &quot;configura les credencials primer&quot;,&#13;&#10;            &quot;opening_browser&quot; to &quot;obrint_navegador...&quot;,&#13;&#10;            &quot;check_browser&quot; to &quot;comprova_navegador&quot;,&#13;&#10;            &quot;error_starting_oauth&quot; to &quot;error_iniciant_oauth&quot;,&#13;&#10;            &quot;client_id&quot; to &quot;      client_id:&quot;,&#13;&#10;            &quot;client_secret&quot; to &quot;      client_secret:&quot;,&#13;&#10;            &quot;enter_client_id&quot; to &quot;introdueix el teu spotify client id&quot;,&#13;&#10;            &quot;enter_client_secret&quot; to &quot;introdueix el teu spotify client secret&quot;,&#13;&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; com obtenir credencials api spotify:&quot;,&#13;&#10;            &quot;instruction_1&quot; to &quot;1. ves a https://developer.spotify.com/dashboard&quot;,&#13;&#10;            &quot;instruction_2&quot; to &quot;2. inicia sessió amb el teu compte spotify&quot;,&#13;&#10;            &quot;instruction_3&quot; to &quot;3. clica 'create app'&quot;,&#13;&#10;            &quot;instruction_4&quot; to &quot;4. omple el nom app (ex., 'plyr mobile')&quot;,&#13;&#10;            &quot;instruction_5&quot; to &quot;5. estableix redirect uri: 'plyr://spotify/callback'&quot;,&#13;&#10;            &quot;instruction_6&quot; to &quot;6. selecciona 'mobile' i 'web api'&quot;,&#13;&#10;            &quot;instruction_7&quot; to &quot;7. clica 'save'&quot;,&#13;&#10;            &quot;instruction_8&quot; to &quot;8. copia client id i client secret&quot;,&#13;&#10;            &quot;instruction_9&quot; to &quot;9. enganxa'ls als camps de dalt&quot;,&#13;&#10;            &quot;note_local_storage&quot; to &quot;      nota: aquestes credencials es guarden localment&quot;,&#13;&#10;            &quot;albums&quot; to &quot;&gt; àlbums&quot;,&#13;&#10;            &quot;similar_songs&quot; to &quot;&gt; recomanacions&quot;,&#13;&#10;            &quot;loading_recommendations&quot; to &quot;&lt;generant recomanacions...&gt;&quot;,&#13;&#10;            &quot;share_with_NFC&quot; to &quot;&lt;compartir amb NFC&gt;&quot;,&#13;&#10;&#13;&#10;            // AcoustID Configuration&#13;&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#13;&#10;            &quot;enter_acoustid_api_key&quot; to &quot;introdueix la teva api key de acoustid&quot;,&#13;&#10;            &quot;acoustid_info&quot; to &quot;      AcoustID és un servei gratuït per identificar música.\n      Com obtenir la teva API Key:\n      1. Ves a https://acoustid.org/new-application\n      2. Crea un compte o inicia sessió\n      3. Crea una nova aplicació (nom: 'plyr')\n      4. Copia la teva API Key i enganxa-la a dalt\n      5. Aquesta key et permet identificar cançons des de l'app&quot;,&#13;&#10;&#13;&#10;            // Last.fm Configuration&#13;&#10;            &quot;lastfm_status&quot; to &quot;&gt; estat_lastfm&quot;,&#13;&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#13;&#10;            &quot;enter_lastfm_api_key&quot; to &quot;introdueix la teva api key de last.fm&quot;,&#13;&#10;            &quot;lastfm_info&quot; to &quot;      Last.fm és un servei de música per obtenir recomanacions.\n      Com obtenir la teva API Key:\n      1. Ves a https://www.last.fm/api/account/create\n      2. Crea un compte o inicia sessió\n      3. Omple les dades de l'aplicació (nom: 'plyr')\n      4. Copia la teva API Key i enganxa-la a dalt\n      5. Aquesta key et permet obtenir recomanacions d'artistes&quot;,&#13;&#10;&#13;&#10;            // Swipe Actions Configuration&#13;&#10;            &quot;swipe_actions&quot; to &quot;&gt; swipe_actions&quot;,&#13;&#10;            &quot;swipe_left&quot; to &quot;swipe left&quot;,&#13;&#10;            &quot;swipe_right&quot; to &quot;swipe right&quot;,&#13;&#10;&#13;&#10;            // Main Screen&#13;&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#13;&#10;            &quot;search_hint&quot; to &quot;cercar...&quot;,&#13;&#10;            &quot;no_results&quot; to &quot;no s'han trobat resultats&quot;,&#13;&#10;            &quot;loading&quot; to &quot;carregant...&quot;,&#13;&#10;&#13;&#10;            // Home Screen&#13;&#10;            &quot;home_search&quot; to &quot;cercar&quot;,&#13;&#10;            &quot;home_playlists&quot; to &quot;llistes&quot;,&#13;&#10;            &quot;home_queue&quot; to &quot;cua&quot;,&#13;&#10;            &quot;home_local&quot; to &quot;local&quot;,&#13;&#10;            &quot;home_settings&quot; to &quot;ajustos&quot;,&#13;&#10;            &quot;exit_message&quot; to &quot;Prem de nou per sortir&quot;,&#13;&#10;&#13;&#10;            // Search Screen&#13;&#10;            &quot;search_title&quot; to &quot;plyr_cercar&quot;,&#13;&#10;            &quot;search_placeholder&quot; to &quot;cercar música...&quot;,&#13;&#10;            &quot;search_loading&quot; to &quot;carregant...&quot;,&#13;&#10;            &quot;search_no_results&quot; to &quot;no s'han trobat resultats&quot;,&#13;&#10;            &quot;search_error&quot; to &quot;error&quot;,&#13;&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify no està connectat&quot;,&#13;&#10;            &quot;search_token_not_available&quot; to &quot;Token de Spotify no disponible&quot;,&#13;&#10;            &quot;search_engine_not_recognized&quot; to &quot;Motor de cerca no reconegut&quot;,&#13;&#10;            &quot;search_error_loading_tracks&quot; to &quot;Error carregant cançons&quot;,&#13;&#10;            &quot;search_loading_tracks&quot; to &quot;carregant cançons...&quot;,&#13;&#10;            &quot;search_tracks&quot; to &quot;cançons&quot;,&#13;&#10;            &quot;search_albums&quot; to &quot;àlbums&quot;,&#13;&#10;            &quot;search_artists&quot; to &quot;artistes&quot;,&#13;&#10;            &quot;search_playlists&quot; to &quot;llistes&quot;,&#13;&#10;            &quot;search_videos&quot; to &quot;vídeos&quot;,&#13;&#10;            &quot;search_youtube_playlists&quot; to &quot;llistes youtube&quot;,&#13;&#10;            &quot;search_start&quot; to &quot;iniciar&quot;,&#13;&#10;            &quot;search_random&quot; to &quot;aleatori&quot;,&#13;&#10;            &quot;search_save&quot; to &quot;desar&quot;,&#13;&#10;            &quot;search_share&quot; to &quot;compartir&quot;,&#13;&#10;            &quot;search_saved&quot; to &quot;desat&quot;,&#13;&#10;            &quot;search_error_saving&quot; to &quot;error al desar&quot;,&#13;&#10;            &quot;search_followers&quot; to &quot;seguidors&quot;,&#13;&#10;            &quot;search_monthly_listeners&quot; to &quot;oients mensuals&quot;,&#13;&#10;            &quot;search_scan_qr&quot; to &quot;qr&quot;,&#13;&#10;            &quot;playlist_cover&quot; to &quot;Portada de la playlist&quot;,&#13;&#10;            &quot;artist_image&quot; to &quot;Imatge de l'artista&quot;,&#13;&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;Querry buida després del prefix&quot;,&#13;&#10;            &quot;album_cover&quot; to &quot;Portada del album&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;resultats de youtube&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#13;&#10;            &quot;colored by used engine&quot; to &quot;colorejat segons el motor utilitzat&quot;,&#13;&#10;&#13;&#10;            // Search Screen - Additional translations&#13;&#10;            &quot;search_select_playlist&quot; to &quot;Seleccionar playlist&quot;,&#13;&#10;            &quot;search_cancel&quot; to &quot;Cancelar&quot;,&#13;&#10;            &quot;search_removing&quot; to &quot;eliminant...&quot;,&#13;&#10;            &quot;search_removed&quot; to &quot;eliminat!&quot;,&#13;&#10;            &quot;search_saving_status&quot; to &quot;desant...&quot;,&#13;&#10;            &quot;search_error_no_token&quot; to &quot;error: no hi ha token&quot;,&#13;&#10;            &quot;search_unsave&quot; to &quot;desguardar&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;resultats youtube&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;carregar més&quot;,&#13;&#10;            &quot;search_error_getting_track&quot; to &quot;Error obtenint track&quot;,&#13;&#10;            &quot;search_error_getting_playlist&quot; to &quot;Error obtenint playlist&quot;,&#13;&#10;            &quot;search_error_getting_album&quot; to &quot;Error obtenint àlbum&quot;,&#13;&#10;            &quot;search_error_getting_artist&quot; to &quot;Error obtenint artista&quot;,&#13;&#10;            &quot;search_error_processing_qr&quot; to &quot;Error processant QR&quot;,&#13;&#10;            &quot;search_adding_to_playlist&quot; to &quot;afegint cançó a la playlist&quot;,&#13;&#10;&#13;&#10;            // Player&#13;&#10;            &quot;now_playing&quot; to &quot;reproduint ara&quot;,&#13;&#10;            &quot;play&quot; to &quot;reproduir&quot;,&#13;&#10;            &quot;pause&quot; to &quot;pausa&quot;,&#13;&#10;            &quot;next&quot; to &quot;següent&quot;,&#13;&#10;            &quot;previous&quot; to &quot;anterior&quot;,&#13;&#10;            &quot;repeat&quot; to &quot;repetir&quot;,&#13;&#10;            &quot;shuffle&quot; to &quot;aleatori&quot;,&#13;&#10;&#13;&#10;            // ADDITIONAL KEYS (CATALAN)&#13;&#10;            &quot;connected_successfully&quot; to &quot;connectat correctament&quot;,&#13;&#10;            &quot;token_exchange_failed&quot; to &quot;intercanvi de token fallit&quot;,&#13;&#10;            &quot;cancelled_by_user&quot; to &quot;cancel·lat per l'usuari&quot;,&#13;&#10;            &quot;error_obtaining_audio&quot; to &quot;No s'ha pogut obtenir l'àudio&quot;,&#13;&#10;            &quot;error_prefix&quot; to &quot;Error: &quot;,&#13;&#10;&#13;&#10;            // Playlist actions and dialogs&#13;&#10;            &quot;btn_start&quot; to &quot;&lt;start&gt;&quot;,&#13;&#10;            &quot;btn_stop&quot; to &quot;&lt;stop&gt;&quot;,&#13;&#10;            &quot;btn_rand&quot; to &quot;&lt;rand&gt;&quot;,&#13;&#10;            &quot;btn_share&quot; to &quot;&lt;share&gt;&quot;,&#13;&#10;            &quot;btn_save&quot; to &quot;&lt;save&gt;&quot;,&#13;&#10;            &quot;btn_edit&quot; to &quot;&lt;edit&gt;&quot;,&#13;&#10;            &quot;btn_delete&quot; to &quot;&lt;delete&gt;&quot;,&#13;&#10;            &quot;creating&quot; to &quot;&lt;creating...&gt;&quot;,&#13;&#10;            &quot;create&quot; to &quot;&lt;create&gt;&quot;,&#13;&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#13;&#10;            &quot;delete_playlist_title&quot; to &quot;Eliminar playlist&quot;,&#13;&#10;            &quot;delete_playlist_confirm&quot; to &quot;Segur que vols eliminar '%s'? Aquesta acció no es pot desfer.&quot;,&#13;&#10;            &quot;unsaved_changes_title&quot; to &quot;Canvis sense desar&quot;,&#13;&#10;            &quot;unsaved_changes_text&quot; to &quot;Tens canvis sense desar. Segur que vols sortir?&quot;,&#13;&#10;            &quot;exit_label&quot; to &quot;Sortir&quot;,&#13;&#10;            &quot;cancel_label&quot; to &quot;Cancel·la&quot;,&#13;&#10;            &quot;delete_label&quot; to &quot;Eliminar&quot;,&#13;&#10;&#13;&#10;            // SongListItem&#13;&#10;            &quot;add_to_playlist&quot; to &quot;afegir a playlist&quot;,&#13;&#10;            &quot;add_to_queue&quot; to &quot;afegir a cua&quot;,&#13;&#10;            &quot;share&quot; to &quot;compartir&quot;,&#13;&#10;            &quot;add_to_liked_songs&quot; to &quot;afegir a favorits&quot;,&#13;&#10;            &quot;remove_from_liked_songs&quot; to &quot;treure de favorits&quot;,&#13;&#10;            &quot;download&quot; to &quot;descarregar&quot;,&#13;&#10;            &quot;error_fetching_track_info&quot; to &quot;Error obtenint info del track&quot;,&#13;&#10;            &quot;spotify_token_unavailable&quot; to &quot;Token de Spotify no disponible&quot;,&#13;&#10;            &quot;error_generic&quot; to &quot;Error&quot;,&#13;&#10;            &quot;album_colon&quot; to &quot;Àlbum: %s&quot;,&#13;&#10;            &quot;release_colon&quot; to &quot;Llançament: %s&quot;,&#13;&#10;            &quot;duration_colon&quot; to &quot;Durada: %s&quot;,&#13;&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#13;&#10;            &quot;error_loading_playlists&quot; to &quot;Error carregant playlists&quot;,&#13;&#10;            &quot;track_already_downloaded&quot; to &quot;Track ja descarregat&quot;,&#13;&#10;            &quot;loading_playlists&quot; to &quot;carregant playlists...&quot;,&#13;&#10;            &quot;track_added_successfully&quot; to &quot;Cançó afegida correctament!&quot;,&#13;&#10;            &quot;no_playlists_found&quot; to &quot;No s'han trobat playlists&quot;,&#13;&#10;&#13;&#10;            // Assistant&#13;&#10;            &quot;assistant_settings&quot; to &quot;Assistent&quot;,&#13;&#10;            &quot;enable_assistant&quot; to &quot;Habilitar assistent&quot;,&#13;&#10;            &quot;assistant_same_language&quot; to &quot;Utilitzar idioma de l'app&quot;,&#13;&#10;            &quot;enable_tts&quot; to &quot;Respostes per veu (TTS)&quot;,&#13;&#10;            &quot;auto_suggestions&quot; to &quot;Suggeriments automàtics&quot;,&#13;&#10;            &quot;contextual_help&quot; to &quot;Ajuda contextual&quot;,&#13;&#10;            &quot;assistant_description&quot; to &quot;L'assistent t'ajuda a navegar i utilitzar l'app. TTS llegeix les respostes en veu alta.&quot;,&#13;&#10;            &quot;enabled&quot; to &quot;Actiu&quot;,&#13;&#10;            &quot;disabled&quot; to &quot;Inactiu&quot;,&#13;&#10;            &quot;assistant_commands_available&quot; to &quot;Comandes disponibles:&quot;,&#13;&#10;            &quot;assistant_resume_playback&quot; to &quot;Reprendre la reproducció&quot;,&#13;&#10;            &quot;assistant_pause_playback&quot; to &quot;Pausar la reproducció&quot;,&#13;&#10;            &quot;assistant_next_song&quot; to &quot;Següent cançó&quot;,&#13;&#10;            &quot;assistant_previous_song&quot; to &quot;Cançó anterior&quot;,&#13;&#10;            &quot;assistant_search_play&quot; to &quot;Cercar i reproduir una cançó&quot;,&#13;&#10;            &quot;assistant_search_song&quot; to &quot;Cercar una cançó&quot;,&#13;&#10;            &quot;assistant_add_queue&quot; to &quot;Afegir cançó a la cua&quot;,&#13;&#10;            &quot;assistant_repeat_mode&quot; to &quot;Canviar mode de repetició&quot;,&#13;&#10;            &quot;assistant_current_song&quot; to &quot;Veure cançó actual&quot;,&#13;&#10;            &quot;assistant_see_commands&quot; to &quot;Veure totes les comandes&quot;,&#13;&#10;            &quot;assistant_playing&quot; to &quot;Reproduint&quot;,&#13;&#10;            &quot;assistant_paused&quot; to &quot;Pausat&quot;,&#13;&#10;            &quot;assistant_next&quot; to &quot;Següent cançó&quot;,&#13;&#10;            &quot;assistant_previous&quot; to &quot;Cançó anterior&quot;,&#13;&#10;            &quot;assistant_repeat_changed&quot; to &quot;Mode de repetició canviat&quot;,&#13;&#10;            &quot;assistant_open_settings&quot; to &quot;Per obrir ajustos, prem la icona de configuració&quot;,&#13;&#10;            &quot;assistant_what_play&quot; to &quot;Digues què vols reproduir&quot;,&#13;&#10;            &quot;assistant_what_search&quot; to &quot;Digues què vols cercar&quot;,&#13;&#10;            &quot;assistant_what_add&quot; to &quot;Digues què vols afegir a la cua&quot;,&#13;&#10;            &quot;assistant_no_results&quot; to &quot;No he trobat resultats per: %s&quot;,&#13;&#10;            &quot;assistant_error_play&quot; to &quot;Error al reproduir: %s&quot;,&#13;&#10;            &quot;assistant_playing_song&quot; to &quot;Reproduint: %s de %s&quot;,&#13;&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;Reproduint: %s&quot;,&#13;&#10;            &quot;assistant_found&quot; to &quot;He trobat: %s de %s&quot;,&#13;&#10;            &quot;assistant_added_queue&quot; to &quot;Afegit a la cua: %s de %s&quot;,&#13;&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;Afegit a la cua: %s&quot;,&#13;&#10;            &quot;assistant_now_playing&quot; to &quot;Reproduint: %s de %s&quot;,&#13;&#10;            &quot;assistant_unknown_artist&quot; to &quot;Artista desconegut&quot;,&#13;&#10;            &quot;assistant_nothing_playing&quot; to &quot;No hi ha cap cançó en reproducció&quot;,&#13;&#10;            &quot;assistant_not_understand&quot; to &quot;No entenc. Digues 'ajuda' per veure les comandes disponibles.&quot;,&#13;&#10;            &quot;assistant_error&quot; to &quot;Error al executar l'acció&quot;,&#13;&#10;            &quot;assistant_listening&quot; to &quot;Escoltant...&quot;,&#13;&#10;            &quot;assistant_processing&quot; to &quot;Processant...&quot;,&#13;&#10;&#13;&#10;            // Noves respostes de l'assistent&#13;&#10;            &quot;assistant_muted&quot; to &quot;Silenciat&quot;,&#13;&#10;            &quot;assistant_volume_set_to&quot; to &quot;Volum al %d%%&quot;,&#13;&#10;            &quot;assistant_what_volume&quot; to &quot;Digues a quin nivell vols el volum&quot;,&#13;&#10;            &quot;assistant_sleep_timer_set&quot; to &quot;Temporitzador configurat per %d minuts&quot;,&#13;&#10;            &quot;assistant_what_time&quot; to &quot;Digues en quants minuts vols aturar la música&quot;,&#13;&#10;            &quot;assistant_timer_cancelled&quot; to &quot;Temporitzador cancel·lat&quot;,&#13;&#10;            &quot;assistant_shuffled&quot; to &quot;Llista barrejada&quot;,&#13;&#10;            &quot;assistant_added_favorites&quot; to &quot;Afegit a favorits: %s&quot;,&#13;&#10;            &quot;assistant_song_saved&quot; to &quot;Cançó guardada: %s&quot;,&#13;&#10;            &quot;assistant_cannot_save&quot; to &quot;No es pot guardar aquesta cançó&quot;,&#13;&#10;            &quot;assistant_playlist_created&quot; to &quot;Playlist '%s' creada&quot;,&#13;&#10;            &quot;assistant_what_playlist_name&quot; to &quot;Digues el nom de la playlist&quot;,&#13;&#10;            &quot;assistant_artist_info&quot; to &quot;Aquesta cançó és de %s&quot;,&#13;&#10;            &quot;assistant_album_info&quot; to &quot;Aquesta cançó és de l'àlbum %s&quot;,&#13;&#10;            &quot;assistant_unknown_album&quot; to &quot;Àlbum desconegut&quot;,&#13;&#10;            &quot;assistant_duration_info&quot; to &quot;Vas per %s de %s&quot;,&#13;&#10;&#13;&#10;            // Noves descripcions de comandes&#13;&#10;            &quot;assistant_volume_desc&quot; to &quot;Controlar el volum&quot;,&#13;&#10;            &quot;assistant_shuffle_desc&quot; to &quot;Barrejar la playlist&quot;,&#13;&#10;            &quot;assistant_favorites_desc&quot; to &quot;Afegir a favorits&quot;,&#13;&#10;            &quot;assistant_who_sings_desc&quot; to &quot;Informació de l'artista&quot;,&#13;&#10;            &quot;assistant_sleep_timer_desc&quot; to &quot;Temporitzador de son&quot;,&#13;&#10;&#13;&#10;            // Assistant Triggers (paraules clau que activen cada comanda)&#13;&#10;            &quot;assistant_triggers_help&quot; to &quot;ajuda|comandes|què puc dir|que puc dir|què pots fer|que pots fer|opcions&quot;,&#13;&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;què sona|que sona|què està sonant|que esta sonant|quina cançó és|quina canco es|cançó actual|canco actual|què estic escoltant|que estic escoltant|què reprodueix|que reprodueix&quot;,&#13;&#10;            &quot;assistant_triggers_next&quot; to &quot;següent|seguent|pròxima|proxima|següent cançó|seguent canco|passa|salta|saltar&quot;,&#13;&#10;            &quot;assistant_triggers_previous&quot; to &quot;anterior|enrere|cançó anterior|canco anterior|torna|retrocedeix&quot;,&#13;&#10;            &quot;assistant_triggers_pause&quot; to &quot;pausa|pausar|para|parar|atura|aturar|stop&quot;,&#13;&#10;            &quot;assistant_triggers_repeat&quot; to &quot;repetir|repeteix|repetició|repeticio|bucle|loop&quot;,&#13;&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;afegir a la cua|afegeix a la cua|posa a la cua|ficar a la cua|encuar&quot;,&#13;&#10;            &quot;assistant_triggers_play&quot; to &quot;reproduir|reprodueix|posa|posa'm|toca|tocar|escoltar|escolta|play|vull escoltar|vull sentir|vull oir&quot;,&#13;&#10;            &quot;assistant_triggers_resume&quot; to &quot;continuar|continua|reprendre|reprèn|segueix|seguir&quot;,&#13;&#10;            &quot;assistant_triggers_search&quot; to &quot;cercar|cerca|buscar|busca|troba|trobar&quot;,&#13;&#10;            &quot;assistant_triggers_settings&quot; to &quot;ajustos|configuració|configuracio|config|opcions de configuració&quot;,&#13;&#10;&#13;&#10;            // Nous triggers per volum&#13;&#10;            &quot;assistant_triggers_volume_up&quot; to &quot;puja el volum|pujar volum|més volum|mas volum|més alt|mas alt|volum amunt&quot;,&#13;&#10;            &quot;assistant_triggers_volume_down&quot; to &quot;baixa el volum|baixar volum|menys volum|més baix|mas baix|volum avall&quot;,&#13;&#10;            &quot;assistant_triggers_volume_set&quot; to &quot;volum al|posa el volum|volum a&quot;,&#13;&#10;            &quot;assistant_triggers_mute&quot; to &quot;silencia|silenci|mutejar|calla&quot;,&#13;&#10;&#13;&#10;            // Nous triggers per informació contextual&#13;&#10;            &quot;assistant_triggers_who_sings&quot; to &quot;qui canta|quien canta|quién és l'artista|quien es el artista|de qui és|de quien es|artista&quot;,&#13;&#10;            &quot;assistant_triggers_what_album&quot; to &quot;de què àlbum|de que album|què àlbum|que album|àlbum&quot;,&#13;&#10;            &quot;assistant_triggers_how_long&quot; to &quot;quant dura|cuanto dura|duració|duracion|quant queda|cuanto queda|temps&quot;,&#13;&#10;&#13;&#10;            // Nous triggers per playlist&#13;&#10;            &quot;assistant_triggers_shuffle&quot; to &quot;barreja|barrejar|aleatori|shuffle|random|mescla|mesclar&quot;,&#13;&#10;            &quot;assistant_triggers_add_favorites&quot; to &quot;afegeix a favorits|agregar a favoritos|m'agrada|guardar en favoritos|favorit&quot;,&#13;&#10;            &quot;assistant_triggers_save_song&quot; to &quot;guarda aquesta cançó|guardar canción|guarda aquesta|save&quot;,&#13;&#10;            &quot;assistant_triggers_create_playlist&quot; to &quot;crea una playlist|crear playlist|nova playlist|crea llista&quot;,&#13;&#10;&#13;&#10;            // Nous triggers per temporitzador de son&#13;&#10;            &quot;assistant_triggers_sleep_timer&quot; to &quot;atura la música en|apaga't en|apagar en|temporitzador|atura en|apagar en|atura a les|apaga't a les|apagate a les&quot;,&#13;&#10;            &quot;assistant_triggers_cancel_timer&quot; to &quot;cancela el temporitzador|cancel·lar temporitzador|treu el temporitzador|no t'apagues&quot;,&#13;&#10;&#13;&#10;            // Nous triggers per comandes naturals&#13;&#10;            &quot;assistant_triggers_play_genre&quot; to &quot;posa'm alguna cosa de|pon algo de|música de|vull&quot;,&#13;&#10;            &quot;assistant_triggers_play_mood&quot; to &quot;alguna cosa alegre|alguna cosa trista|alguna cosa tranquil·la|alguna cosa animada|alguna cosa relaxant|música per&quot;,&#13;&#10;&#13;&#10;            // Assistant Commands (per mostrar a l'ajuda)&#13;&#10;            &quot;assistant_cmd_play&quot; to &quot;reprodueix / play&quot;,&#13;&#10;            &quot;assistant_cmd_pause&quot; to &quot;pausa / atura&quot;,&#13;&#10;            &quot;assistant_cmd_next&quot; to &quot;següent / salta&quot;,&#13;&#10;            &quot;assistant_cmd_previous&quot; to &quot;anterior / enrere&quot;,&#13;&#10;            &quot;assistant_cmd_play_song&quot; to &quot;posa &lt;cançó&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_search&quot; to &quot;cerca &lt;cançó&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;afegeix a la cua &lt;cançó&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_repeat&quot; to &quot;repetir&quot;,&#13;&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;què sona&quot;,&#13;&#10;            &quot;assistant_cmd_help&quot; to &quot;ajuda / comandes&quot;,&#13;&#10;            &quot;assistant_cmd_volume&quot; to &quot;volum&quot;,&#13;&#10;            &quot;assistant_cmd_shuffle&quot; to &quot;barrejar&quot;,&#13;&#10;            &quot;assistant_cmd_favorites&quot; to &quot;favorits&quot;,&#13;&#10;            &quot;assistant_cmd_who_sings&quot; to &quot;qui canta&quot;,&#13;&#10;            &quot;assistant_cmd_sleep_timer&quot; to &quot;temporitzador&quot;,&#13;&#10;&#13;&#10;        ),&#13;&#10;&#13;&#10;        // JAPANESE&#13;&#10;        &quot;日本語&quot; to mapOf(&#13;&#10;            // Config Screen&#13;&#10;            &quot;login&quot; to &quot;&lt;ログイン&gt;&quot;,&#13;&#10;            &quot;config_title&quot; to &quot;plyr_設定&quot;,&#13;&#10;            &quot;theme&quot; to &quot;&gt; テーマ&quot;,&#13;&#10;            &quot;theme_dark&quot; to &quot;ダーク&quot;,&#13;&#10;            &quot;theme_light&quot; to &quot;ライト&quot;,&#13;&#10;            &quot;theme_system&quot; to &quot;システム&quot;,&#13;&#10;            &quot;search_engine&quot; to &quot;&gt; 検索エンジン&quot;,&#13;&#10;            &quot;search_spotify&quot; to &quot;spotify&quot;,&#13;&#10;            &quot;search_youtube&quot; to &quot;youtube&quot;,&#13;&#10;            &quot;audio_quality&quot; to &quot;&gt; 音質&quot;,&#13;&#10;            &quot;quality_low&quot; to &quot;低&quot;,&#13;&#10;            &quot;quality_med&quot; to &quot;中&quot;,&#13;&#10;            &quot;quality_high&quot; to &quot;高&quot;,&#13;&#10;            &quot;language&quot; to &quot;&gt; 言語&quot;,&#13;&#10;            &quot;lang_spanish&quot; to &quot;es&quot;,&#13;&#10;            &quot;lang_english&quot; to &quot;en&quot;,&#13;&#10;            &quot;lang_catalan&quot; to &quot;ca&quot;,&#13;&#10;            &quot;lang_japanese&quot; to &quot;ja&quot;,&#13;&#10;            &quot;info&quot; to &quot;&gt; 情報&quot;,&#13;&#10;            &quot;info_text&quot; to &quot;    ● 音楽を違法にダウンロードしないでください！\n    ● エンジンを変更するには yt: / sp: を使用&quot;,&#13;&#10;            &quot;spotify_status&quot; to &quot;&gt; sptfy_ステータス&quot;,&#13;&#10;            &quot;acoustid_status&quot; to &quot;&gt; acoustid_ステータス&quot;,&#13;&#10;            &quot;client&quot; to &quot;    ● クライアント:&quot;,&#13;&#10;            &quot;api&quot; to &quot;    ● API:&quot;,&#13;&#10;            &quot;connected&quot; to &quot;接続済み&quot;,&#13;&#10;            &quot;disconnected&quot; to &quot;未接続&quot;,&#13;&#10;            &quot;configured&quot; to &quot;設定済み&quot;,&#13;&#10;            &quot;not_configured&quot; to &quot;未設定&quot;,&#13;&#10;            &quot;credentials_required&quot; to &quot;認証情報が必要です&quot;,&#13;&#10;            &quot;configure_credentials_first&quot; to &quot;先に認証情報を設定してください&quot;,&#13;&#10;            &quot;opening_browser&quot; to &quot;ブラウザを開いています...&quot;,&#13;&#10;            &quot;check_browser&quot; to &quot;ブラウザを確認してください&quot;,&#13;&#10;            &quot;error_starting_oauth&quot; to &quot;OAuth の開始エラー&quot;,&#13;&#10;            &quot;client_id&quot; to &quot;      クライアントID:&quot;,&#13;&#10;            &quot;client_secret&quot; to &quot;      クライアントシークレット:&quot;,&#13;&#10;            &quot;enter_client_id&quot; to &quot;Spotify クライアントIDを入力してください&quot;,&#13;&#10;            &quot;enter_client_secret&quot; to &quot;Spotify クライアントシークレットを入力してください&quot;,&#13;&#10;            &quot;how_to_get_credentials&quot; to &quot;      &gt; Spotify API の認証情報を取得する方法:&quot;,&#13;&#10;            &quot;instruction_1&quot; to &quot;1. https://developer.spotify.com/dashboard にアクセス&quot;,&#13;&#10;            &quot;instruction_2&quot; to &quot;2. Spotify アカウントでログイン&quot;,&#13;&#10;            &quot;instruction_3&quot; to &quot;3. 「アプリを作成」をクリック&quot;,&#13;&#10;            &quot;instruction_4&quot; to &quot;4. アプリ名を入力 (例: 'plyr mobile')&quot;,&#13;&#10;            &quot;instruction_5&quot; to &quot;5. リダイレクトURIを設定: 'plyr://spotify/callback'&quot;,&#13;&#10;            &quot;instruction_6&quot; to &quot;6. 「mobile」と「web api」を選択&quot;,&#13;&#10;            &quot;instruction_7&quot; to &quot;7. 「保存」をクリック&quot;,&#13;&#10;            &quot;instruction_8&quot; to &quot;8. client_id と client_secret をコピー&quot;,&#13;&#10;            &quot;instruction_9&quot; to &quot;9. 上のフィールドに貼り付ける&quot;,&#13;&#10;            &quot;note_local_storage&quot; to &quot;      注: 認証情報はローカルに保存されます&quot;,&#13;&#10;            &quot;albums&quot; to &quot;&gt; アルバム&quot;,&#13;&#10;            &quot;similar_songs&quot; to &quot;&gt; おすすめ曲&quot;,&#13;&#10;            &quot;loading_recommendations&quot; to &quot;&lt;おすすめを生成しています...&gt;&quot;,&#13;&#10;            &quot;share_with_NFC&quot; to &quot;&lt;NFCで共有&gt;&quot;,&#13;&#10;&#13;&#10;            // AcoustID Configuration&#13;&#10;            &quot;acoustid_api_key&quot; to &quot;    ● acoustid_api_key:&quot;,&#13;&#10;            &quot;enter_acoustid_api_key&quot; to &quot;AcoustID APIキーを入力してください&quot;,&#13;&#10;            &quot;acoustid_info&quot; to &quot;      AcoustIDは音楽識別のための無料サービスです。\n      APIキーの取得方法:\n      1. https://acoustid.org/new-application にアクセス\n      2. アカウントを作成またはログイン\n      3. 新しいアプリケーションを作成 (名前: 'plyr')\n      4. APIキーをコピーして上に貼り付け\n      5. このキーでアプリから曲を識別できます&quot;,&#13;&#10;&#13;&#10;            // Last.fm Configuration&#13;&#10;            &quot;lastfm_status&quot; to &quot;&gt; lastfm_status&quot;,&#13;&#10;            &quot;lastfm_api_key&quot; to &quot;    ● lastfm_api_key:&quot;,&#13;&#10;            &quot;enter_lastfm_api_key&quot; to &quot;Last.fm APIキーを入力してください&quot;,&#13;&#10;            &quot;lastfm_info&quot; to &quot;      Last.fmは音楽の推薦を得るためのサービスです。\n      APIキーの取得方法:\n      1. https://www.last.fm/api/account/create にアクセス\n      2. アカウントを作成またはログイン\n      3. アプリケーションデータを入力 (名前: 'plyr')\n      4. APIキーをコピーして上に貼り付け\n      5. このキーでアーティストの推薦を得ることができます&quot;,&#13;&#10;&#13;&#10;&#13;&#10;            // Main Screen&#13;&#10;            &quot;plyr_title&quot; to &quot;$ plyr&quot;,&#13;&#10;            &quot;search_hint&quot; to &quot;検索...&quot;,&#13;&#10;            &quot;no_results&quot; to &quot;結果が見つかりません&quot;,&#13;&#10;            &quot;loading&quot; to &quot;読み込み中...&quot;,&#13;&#10;&#13;&#10;            // Home Screen&#13;&#10;            &quot;home_search&quot; to &quot;検索&quot;,&#13;&#10;            &quot;home_playlists&quot; to &quot;プレイリスト&quot;,&#13;&#10;            &quot;home_queue&quot; to &quot;キュー&quot;,&#13;&#10;            &quot;home_local&quot; to &quot;ローカル&quot;,&#13;&#10;            &quot;home_settings&quot; to &quot;設定&quot;,&#13;&#10;            &quot;exit_message&quot; to &quot;もう一度押すと終了します&quot;,&#13;&#10;&#13;&#10;            // Search Screen&#13;&#10;            &quot;search_title&quot; to &quot;plyr_検索&quot;,&#13;&#10;            &quot;search_placeholder&quot; to &quot;音楽を検索...&quot;,&#13;&#10;            &quot;search_loading&quot; to &quot;読み込み中...&quot;,&#13;&#10;            &quot;search_no_results&quot; to &quot;結果が見つかりません&quot;,&#13;&#10;            &quot;search_error&quot; to &quot;エラー&quot;,&#13;&#10;            &quot;search_spotify_not_connected&quot; to &quot;Spotify が接続されていません&quot;,&#13;&#10;            &quot;search_token_not_available&quot; to &quot;Spotify トークンが利用できません&quot;,&#13;&#10;            &quot;search_engine_not_recognized&quot; to &quot;検索エンジンが認識されません&quot;,&#13;&#10;            &quot;search_error_loading_tracks&quot; to &quot;曲の読み込みエラー&quot;,&#13;&#10;            &quot;search_loading_tracks&quot; to &quot;曲を読み込み中...&quot;,&#13;&#10;            &quot;search_tracks&quot; to &quot;曲&quot;,&#13;&#10;            &quot;search_albums&quot; to &quot;アルバム&quot;,&#13;&#10;            &quot;search_artists&quot; to &quot;アーティスト&quot;,&#13;&#10;            &quot;search_playlists&quot; to &quot;プレイリスト&quot;,&#13;&#10;            &quot;search_videos&quot; to &quot;動画&quot;,&#13;&#10;            &quot;search_youtube_playlists&quot; to &quot;YouTube プレイリスト&quot;,&#13;&#10;            &quot;search_start&quot; to &quot;開始&quot;,&#13;&#10;            &quot;search_random&quot; to &quot;ランダム&quot;,&#13;&#10;            &quot;search_save&quot; to &quot;保存&quot;,&#13;&#10;            &quot;search_share&quot; to &quot;共有&quot;,&#13;&#10;            &quot;search_saved&quot; to &quot;保存しました&quot;,&#13;&#10;            &quot;search_error_saving&quot; to &quot;保存中にエラー&quot;,&#13;&#10;            &quot;search_followers&quot; to &quot;フォロワー&quot;,&#13;&#10;            &quot;search_monthly_listeners&quot; to &quot;月間リスナー&quot;,&#13;&#10;            &quot;search_scan_qr&quot; to &quot;QR&quot;,&#13;&#10;            &quot;playlist_cover&quot; to &quot;プレイリストのカバー&quot;,&#13;&#10;            &quot;artist_image&quot; to &quot;アーティスト画像&quot;,&#13;&#10;            &quot;search_query_empty_after_prefix&quot; to &quot;プレフィックス後のクエリが空です&quot;,&#13;&#10;            &quot;album_cover&quot; to &quot;アルバムカバー&quot;,&#13;&#10;            &quot;search_youtube_results&quot; to &quot;YouTube の結果&quot;,&#13;&#10;            &quot;search_load_more&quot; to &quot;もっと読み込む&quot;,&#13;&#10;            &quot;colored by used engine&quot; to &quot;検索エンジン別の色&quot;,&#13;&#10;&#13;&#10;            // Search Screen - Additional&#13;&#10;            &quot;search_select_playlist&quot; to &quot;プレイリストを選択&quot;,&#13;&#10;            &quot;search_cancel&quot; to &quot;キャンセル&quot;,&#13;&#10;            &quot;search_removing&quot; to &quot;削除中...&quot;,&#13;&#10;            &quot;search_removed&quot; to &quot;削除しました！&quot;,&#13;&#10;            &quot;search_saving_status&quot; to &quot;保存中...&quot;,&#13;&#10;            &quot;search_error_no_token&quot; to &quot;エラー: トークンがありません&quot;,&#13;&#10;            &quot;search_unsave&quot; to &quot;保存を解除&quot;,&#13;&#10;            &quot;search_error_getting_track&quot; to &quot;曲の取得エラー&quot;,&#13;&#10;            &quot;search_error_getting_playlist&quot; to &quot;プレイリストの取得エラー&quot;,&#13;&#10;            &quot;search_error_getting_album&quot; to &quot;アルバムの取得エラー&quot;,&#13;&#10;            &quot;search_error_getting_artist&quot; to &quot;アーティストの取得エラー&quot;,&#13;&#10;            &quot;search_error_processing_qr&quot; to &quot;QR の処理中にエラー&quot;,&#13;&#10;            &quot;search_adding_to_playlist&quot; to &quot;プレイリストに曲を追加中...&quot;,&#13;&#10;&#13;&#10;            // Player&#13;&#10;            &quot;now_playing&quot; to &quot;再生中&quot;,&#13;&#10;            &quot;play&quot; to &quot;再生&quot;,&#13;&#10;            &quot;pause&quot; to &quot;一時停止&quot;,&#13;&#10;            &quot;next&quot; to &quot;次へ&quot;,&#13;&#10;            &quot;previous&quot; to &quot;前へ&quot;,&#13;&#10;            &quot;repeat&quot; to &quot;リピート&quot;,&#13;&#10;            &quot;shuffle&quot; to &quot;シャッフル&quot;,&#13;&#10;&#13;&#10;            // Playlist actions and dialogs&#13;&#10;            &quot;btn_start&quot; to &quot;&lt;開始&gt;&quot;,&#13;&#10;            &quot;btn_stop&quot; to &quot;&lt;停止&gt;&quot;,&#13;&#10;            &quot;btn_rand&quot; to &quot;&lt;ランダム&gt;&quot;,&#13;&#10;            &quot;btn_share&quot; to &quot;&lt;共有&gt;&quot;,&#13;&#10;            &quot;btn_save&quot; to &quot;&lt;保存&gt;&quot;,&#13;&#10;            &quot;btn_edit&quot; to &quot;&lt;編集&gt;&quot;,&#13;&#10;            &quot;btn_delete&quot; to &quot;&lt;削除&gt;&quot;,&#13;&#10;            &quot;creating&quot; to &quot;&lt;作成中...&gt;&quot;,&#13;&#10;            &quot;create&quot; to &quot;&lt;作成&gt;&quot;,&#13;&#10;            &quot;btn_nfc&quot; to &quot;&lt;nfc&gt;&quot;,&#13;&#10;            &quot;delete_playlist_title&quot; to &quot;プレイリストを削除&quot;,&#13;&#10;            &quot;delete_playlist_confirm&quot; to &quot;「%s」を削除してもよろしいですか？この操作は元に戻せません。&quot;,&#13;&#10;            &quot;unsaved_changes_title&quot; to &quot;未保存の変更&quot;,&#13;&#10;            &quot;unsaved_changes_text&quot; to &quot;未保存の変更があります。本当に終了しますか？&quot;,&#13;&#10;            &quot;exit_label&quot; to &quot;終了&quot;,&#13;&#10;            &quot;cancel_label&quot; to &quot;キャンセル&quot;,&#13;&#10;            &quot;delete_label&quot; to &quot;削除&quot;,&#13;&#10;&#13;&#10;            // Additional&#13;&#10;            &quot;connected_successfully&quot; to &quot;正常に接続されました&quot;,&#13;&#10;            &quot;token_exchange_failed&quot; to &quot;トークンの交換に失敗しました&quot;,&#13;&#10;            &quot;cancelled_by_user&quot; to &quot;ユーザーによりキャンセルされました&quot;,&#13;&#10;            &quot;error_obtaining_audio&quot; to &quot;音声を取得できませんでした&quot;,&#13;&#10;            &quot;error_prefix&quot; to &quot;エラー: &quot;,&#13;&#10;&#13;&#10;            // Local Screen&#13;&#10;            &quot;plyr_local&quot; to &quot;plyr_ローカル&quot;,&#13;&#10;            &quot;unknown error&quot; to &quot;不明なエラー&quot;,&#13;&#10;            &quot;No tracks downloaded&quot; to &quot;ダウンロードされた曲はありません&quot;,&#13;&#10;            &quot;delete track&quot; to &quot;曲を削除&quot;,&#13;&#10;            &quot;Song {{track_name}} will be removed permanently&quot; to &quot;曲 {{track_name}} は完全に削除されます&quot;,&#13;&#10;            &quot;delete&quot; to &quot;削除&quot;,&#13;&#10;            &quot;cancel&quot; to &quot;キャンセル&quot;,&#13;&#10;&#13;&#10;            // Queue Screen&#13;&#10;            &quot;plyr_queue&quot; to &quot;plyr_キュー&quot;,&#13;&#10;            &quot;No tracks loaded&quot; to &quot;曲が読み込まれていません&quot;,&#13;&#10;            &quot;Play a track to start a playlist&quot; to &quot;曲を再生してプレイリストを開始します&quot;,&#13;&#10;            &quot;player_not_available&quot; to &quot;プレイヤーが利用できません&quot;,&#13;&#10;&#13;&#10;            // Playlists Screen&#13;&#10;            &quot;plyr_lists&quot; to &quot;plyr_リスト&quot;,&#13;&#10;            &quot;&lt;syncing...&gt;&quot; to &quot;&lt;同期中...&gt;&quot;,&#13;&#10;            &quot;&lt;sync&gt;&quot; to &quot;&lt;同期&gt;&quot;,&#13;&#10;            &quot;&lt;new&gt;&quot; to &quot;&lt;新規作成&gt;&quot;,&#13;&#10;            &quot;Spotify not connected&quot; to &quot;Spotify が接続されていません&quot;,&#13;&#10;            &quot;Loading tracks...&quot; to &quot;曲を読み込み中...&quot;,&#13;&#10;&#13;&#10;            // SongListItem&#13;&#10;            &quot;add_to_playlist&quot; to &quot;プレイリストに追加&quot;,&#13;&#10;            &quot;add_to_queue&quot; to &quot;キューに追加&quot;,&#13;&#10;            &quot;share&quot; to &quot;共有&quot;,&#13;&#10;            &quot;add_to_liked_songs&quot; to &quot;お気に入りに追加&quot;,&#13;&#10;            &quot;remove_from_liked_songs&quot; to &quot;お気に入りから削除&quot;,&#13;&#10;            &quot;download&quot; to &quot;ダウンロード&quot;,&#13;&#10;&#13;&#10;&#13;&#10;&#9;&#9;&#9;// Swipe Actions - Short versions for config screen (Japanese)&#13;&#10;&#9;&#9;&#9;&quot;swipe_action_queue&quot; to &quot;キュー&quot;,       // queue&#13;&#10;&#9;&#9;&#9;&quot;swipe_action_liked&quot; to &quot;お気に&quot;,       // fav (abreviado de お気に入り)&#13;&#10;&#9;&#9;&#9;&quot;swipe_action_playlist&quot; to &quot;リスト&quot;,    // list&#13;&#10;&#9;&#9;&#9;&quot;swipe_action_share&quot; to &quot;共有&quot;,        // share&#13;&#10;&#9;&#9;&#9;&quot;swipe_action_download&quot; to &quot;ダウン&quot;,    // down (abreviado de ダウンロード)&#13;&#10;&#13;&#10;            &quot;error_fetching_track_info&quot; to &quot;トラック情報の取得エラー&quot;,&#13;&#10;            &quot;spotify_token_unavailable&quot; to &quot;Spotify トークンが利用できません&quot;,&#13;&#10;            &quot;error_generic&quot; to &quot;エラー&quot;,&#13;&#10;            &quot;album_colon&quot; to &quot;アルバム: %s&quot;,&#13;&#10;            &quot;release_colon&quot; to &quot;リリース: %s&quot;,&#13;&#10;            &quot;duration_colon&quot; to &quot;再生時間: %s&quot;,&#13;&#10;            &quot;not_available&quot; to &quot;N/A&quot;,&#13;&#10;            &quot;error_loading_playlists&quot; to &quot;プレイリストの読み込みエラー&quot;,&#13;&#10;            &quot;track_already_downloaded&quot; to &quot;トラックは既にダウンロードされています&quot;,&#13;&#10;            &quot;loading_playlists&quot; to &quot;プレイリストを読み込み中...&quot;,&#13;&#10;            &quot;track_added_successfully&quot; to &quot;トラックが正常に追加されました！&quot;,&#13;&#10;            &quot;no_playlists_found&quot; to &quot;プレイリストが見つかりません&quot;,&#13;&#10;&#13;&#10;            // Assistant&#13;&#10;            &quot;assistant_commands_available&quot; to &quot;利用可能なコマンド:&quot;,&#13;&#10;            &quot;assistant_resume_playback&quot; to &quot;再生を再開&quot;,&#13;&#10;            &quot;assistant_pause_playback&quot; to &quot;再生を一時停止&quot;,&#13;&#10;            &quot;assistant_next_song&quot; to &quot;次の曲&quot;,&#13;&#10;            &quot;assistant_previous_song&quot; to &quot;前の曲&quot;,&#13;&#10;            &quot;assistant_search_play&quot; to &quot;曲を検索して再生&quot;,&#13;&#10;            &quot;assistant_search_song&quot; to &quot;曲を検索&quot;,&#13;&#10;            &quot;assistant_add_queue&quot; to &quot;キューに曲を追加&quot;,&#13;&#10;            &quot;assistant_repeat_mode&quot; to &quot;リピートモードを変更&quot;,&#13;&#10;            &quot;assistant_current_song&quot; to &quot;現在の曲を表示&quot;,&#13;&#10;            &quot;assistant_see_commands&quot; to &quot;すべてのコマンドを表示&quot;,&#13;&#10;            &quot;assistant_playing&quot; to &quot;再生中&quot;,&#13;&#10;            &quot;assistant_paused&quot; to &quot;一時停止&quot;,&#13;&#10;            &quot;assistant_next&quot; to &quot;次の曲&quot;,&#13;&#10;            &quot;assistant_previous&quot; to &quot;前の曲&quot;,&#13;&#10;            &quot;assistant_repeat_changed&quot; to &quot;リピートモードが変更されました&quot;,&#13;&#10;            &quot;assistant_open_settings&quot; to &quot;設定を開くには、設定アイコンをタップしてください&quot;,&#13;&#10;            &quot;assistant_what_play&quot; to &quot;何を再生しますか？&quot;,&#13;&#10;            &quot;assistant_what_search&quot; to &quot;何を検索しますか？&quot;,&#13;&#10;            &quot;assistant_what_add&quot; to &quot;キューに何を追加しますか？&quot;,&#13;&#10;            &quot;assistant_no_results&quot; to &quot;結果が見つかりません: %s&quot;,&#13;&#10;            &quot;assistant_error_play&quot; to &quot;再生エラー: %s&quot;,&#13;&#10;            &quot;assistant_playing_song&quot; to &quot;再生中: %s - %s&quot;,&#13;&#10;            &quot;assistant_playing_song_no_artist&quot; to &quot;再生中: %s&quot;,&#13;&#10;            &quot;assistant_found&quot; to &quot;見つかりました: %s - %s&quot;,&#13;&#10;            &quot;assistant_added_queue&quot; to &quot;キューに追加: %s - %s&quot;,&#13;&#10;            &quot;assistant_added_queue_no_artist&quot; to &quot;キューに追加: %s&quot;,&#13;&#10;            &quot;assistant_now_playing&quot; to &quot;再生中: %s - %s&quot;,&#13;&#10;            &quot;assistant_unknown_artist&quot; to &quot;不明なアーティスト&quot;,&#13;&#10;            &quot;assistant_nothing_playing&quot; to &quot;現在再生中の曲はありません&quot;,&#13;&#10;            &quot;assistant_not_understand&quot; to &quot;理解できません。「ヘルプ」と言って利用可能なコマンドを確認してください。&quot;,&#13;&#10;            &quot;assistant_error&quot; to &quot;アクションの実行エラー&quot;,&#13;&#10;            &quot;assistant_listening&quot; to &quot;聞いています...&quot;,&#13;&#10;            &quot;assistant_processing&quot; to &quot;処理中...&quot;,&#13;&#10;&#13;&#10;            // Assistant Triggers (コマンドをトリガーするキーワード)&#13;&#10;            &quot;assistant_triggers_help&quot; to &quot;ヘルプ|コマンド|助けて|たすけて|何ができる|なにができる|オプション|使い方|つかいかた&quot;,&#13;&#10;            &quot;assistant_triggers_whats_playing&quot; to &quot;何が再生中|なにがさいせいちゅう|今の曲|いまのきょく|現在の曲|げんざいのきょく|何を聴いてる|なにをきいてる|再生中|さいせいちゅう&quot;,&#13;&#10;            &quot;assistant_triggers_next&quot; to &quot;次|つぎ|次の曲|つぎのきょく|スキップ|次へ|つぎへ|進む|すすむ&quot;,&#13;&#10;            &quot;assistant_triggers_previous&quot; to &quot;前|まえ|前の曲|まえのきょく|戻る|もどる|前へ|まえへ|バック&quot;,&#13;&#10;            &quot;assistant_triggers_pause&quot; to &quot;一時停止|いちじていし|停止|ていし|止めて|とめて|ストップ|ポーズ&quot;,&#13;&#10;            &quot;assistant_triggers_repeat&quot; to &quot;リピート|繰り返し|くりかえし|ループ|繰り返す|くりかえす&quot;,&#13;&#10;            &quot;assistant_triggers_add_queue&quot; to &quot;キューに追加|キューについか|待ち行列に追加|まちぎょうれつについか|キューに入れて|キューにいれて&quot;,&#13;&#10;            &quot;assistant_triggers_play&quot; to &quot;再生|さいせい|プレイ|かけて|流して|ながして|聴く|きく&quot;,&#13;&#10;            &quot;assistant_triggers_resume&quot; to &quot;続ける|つづける|再開|さいかい|続き|つづき&quot;,&#13;&#10;            &quot;assistant_triggers_search&quot; to &quot;検索|けんさく|探す|さがす|見つける|みつける&quot;,&#13;&#10;            &quot;assistant_triggers_settings&quot; to &quot;設定|せってい|コンフィグ|オプション|環境設定|かんきょうせってい&quot;,&#13;&#10;&#13;&#10;            // Assistant Commands (ヘルプ表示用)&#13;&#10;            &quot;assistant_cmd_play&quot; to &quot;再生 / プレイ&quot;,&#13;&#10;            &quot;assistant_cmd_pause&quot; to &quot;一時停止 / ストップ&quot;,&#13;&#10;            &quot;assistant_cmd_next&quot; to &quot;次 / スキップ&quot;,&#13;&#10;            &quot;assistant_cmd_previous&quot; to &quot;前 / 戻る&quot;,&#13;&#10;            &quot;assistant_cmd_play_song&quot; to &quot;再生 &lt;曲名&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_search&quot; to &quot;検索 &lt;曲名&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_add_queue&quot; to &quot;キューに追加 &lt;曲名&gt;&quot;,&#13;&#10;            &quot;assistant_cmd_repeat&quot; to &quot;リピート / ループ&quot;,&#13;&#10;            &quot;assistant_cmd_whats_playing&quot; to &quot;今の曲&quot;,&#13;&#10;            &quot;assistant_cmd_help&quot; to &quot;ヘルプ / コマンド&quot;,&#13;&#10;&#13;&#10;        ),&#13;&#10;&#13;&#10;        )&#13;&#10;    /**&#13;&#10;     * Obtiene una traducción para una clave específica según el idioma actual&#13;&#10;     * @param context Contexto de la aplicación&#13;&#10;     * @param key Clave de la traducción&#13;&#10;     * @return Traducción correspondiente o la clave si no existe&#13;&#10;     */&#13;&#10;    fun get(context: Context, key: String): String {&#13;&#10;        val language = Config.getLanguage(context)&#13;&#10;        return translations[language]?.get(key) ?: key&#13;&#10;    }&#13;&#10;&#13;&#10;    /**&#13;&#10;     * Obtiene una traducción para una clave específica según un idioma específico&#13;&#10;     * @param language Idioma deseado&#13;&#10;     * @param key Clave de la traducción&#13;&#10;     * @return Traducción correspondiente o la clave si no existe&#13;&#10;     */&#13;&#10;    fun get(language: String, key: String): String {&#13;&#10;        return translations[language]?.get(key) ?: key&#13;&#10;    }&#13;&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>