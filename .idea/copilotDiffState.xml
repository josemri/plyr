<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/assistant/AssistantManager.kt" />
              <option name="originalContent" value="package com.plyr.assistant&#10;&#10;import android.content.Context&#10;import android.media.AudioManager&#10;import android.util.Log&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.utils.SpotifyTokenManager&#10;import com.plyr.utils.Translations&#10;&#10;import java.util.Collections&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.Calendar&#10;&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;import ai.onnxruntime.OnnxTensor&#10;import ai.onnxruntime.OrtEnvironment&#10;import ai.onnxruntime.OrtSession&#10;&#10;/**&#10; * Lightweight on-device assistant manager.&#10; */&#10;class AssistantManager(private val context: Context) {&#10;&#10;    data class IntentResult(&#10;        val intent: String,&#10;        val score: Float = 1.0f,&#10;        val entities: Map&lt;String, String&gt; = emptyMap()&#10;    )&#10;&#10;    // Estado del asistente&#10;    enum class AssistantState {&#10;        IDLE, LISTENING, PROCESSING, SPEAKING&#10;    }&#10;&#10;    private var onnxAvailable = false&#10;    private var ortEnv: OrtEnvironment? = null&#10;    private var sessionIntent: OrtSession? = null&#10;    private var sessionNer: OrtSession? = null&#10;&#10;    // Sleep timer&#10;    private var sleepTimer: Timer? = null&#10;    private var sleepTimerEndTime: Long = 0&#10;&#10;    // Estado actual&#10;    var currentState: AssistantState = AssistantState.IDLE&#10;        private set&#10;&#10;    // Callback para cambios de estado&#10;    var onStateChange: ((AssistantState) -&gt; Unit)? = null&#10;&#10;    // Último comando entendido (para feedback visual)&#10;    var lastRecognizedCommand: String = &quot;&quot;&#10;        private set&#10;&#10;    private fun t(key: String) = Translations.get(context, key)&#10;&#10;    private fun getTriggers(key: String): List&lt;String&gt; {&#10;        return t(key).split(&quot;|&quot;).map { it.trim().lowercase() }&#10;    }&#10;&#10;    fun setState(state: AssistantState) {&#10;        currentState = state&#10;        onStateChange?.invoke(state)&#10;    }&#10;&#10;    init {&#10;        try {&#10;            Class.forName(&quot;ai.onnxruntime.OnnxTensor&quot;)&#10;            onnxAvailable = true&#10;        } catch (_: Exception) {&#10;            onnxAvailable = false&#10;        }&#10;&#10;        if (onnxAvailable) {&#10;            try {&#10;                ortEnv = OrtEnvironment.getEnvironment()&#10;                val am = context.assets&#10;                fun loadSession(assetName: String): OrtSession? {&#10;                    return try {&#10;                        val bytes = am.open(assetName).use { it.readBytes() }&#10;                        ortEnv?.createSession(bytes)&#10;                    } catch (ex: Exception) {&#10;                        Log.i(&quot;AssistantManager&quot;, &quot;Model $assetName not found: ${ex.message}&quot;)&#10;                        null&#10;                    }&#10;                }&#10;                sessionIntent = loadSession(&quot;assistant_intent.onnx&quot;)&#10;                sessionNer = loadSession(&quot;assistant_ner.onnx&quot;)&#10;                if (sessionIntent == null &amp;&amp; sessionNer == null) {&#10;                    onnxAvailable = false&#10;                }&#10;            } catch (ex: Throwable) {&#10;                Log.i(&quot;AssistantManager&quot;, &quot;ONNX init failed: ${ex.message}&quot;)&#10;                onnxAvailable = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun analyze(text: String): IntentResult {&#10;        val trimmed = text.trim()&#10;        if (trimmed.isEmpty()) return IntentResult(&quot;none&quot;, 1f)&#10;&#10;        if (onnxAvailable &amp;&amp; sessionIntent != null &amp;&amp; ortEnv != null) {&#10;            try {&#10;                val inputName = sessionIntent!!.inputNames.iterator().next()&#10;                val tensor = OnnxTensor.createTensor(ortEnv!!, arrayOf(trimmed))&#10;                val res = sessionIntent!!.run(Collections.singletonMap(inputName, tensor))&#10;                try {&#10;                    if (res.size() &gt; 0) {&#10;                        val first = res.get(0)&#10;                        val value = first.value&#10;                        if (value is Array&lt;*&gt;) {&#10;                            val maybe = value.firstOrNull() as? String&#10;                            if (!maybe.isNullOrBlank()) return IntentResult(maybe, 0.95f)&#10;                        } else if (value is String) {&#10;                            if (value.isNotBlank()) return IntentResult(value, 0.95f)&#10;                        }&#10;                    }&#10;                } finally {&#10;                    try { res.close() } catch (_: Exception) {}&#10;                    try { tensor.close() } catch (_: Exception) {}&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.i(&quot;AssistantManager&quot;, &quot;ONNX intent inference failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;        return ruleBasedAnalysis(trimmed)&#10;    }&#10;&#10;    private fun ruleBasedAnalysis(text: String): IntentResult {&#10;        val lower = text.lowercase()&#10;&#10;        val quoteRegex = &quot;\&quot;(.*?)\&quot;&quot;.toRegex()&#10;        val quoted = quoteRegex.find(text)?.groups?.get(1)?.value&#10;&#10;        fun containsAny(triggerKey: String): Boolean {&#10;            return getTriggers(triggerKey).any { lower.contains(it) }&#10;        }&#10;&#10;        fun extractAfter(triggerKey: String): String? {&#10;            val triggers = getTriggers(triggerKey).map { &quot;$it &quot; }&#10;            for (k in triggers) {&#10;                val idx = lower.indexOf(k)&#10;                if (idx &gt;= 0) {&#10;                    return text.substring(idx + k.length).trim().trim('&quot;', '\'')&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Limpiar frases comunes que no son parte del artista/canción&#10;        fun cleanQuery(query: String): String {&#10;            val patterns = listOf(&#10;                // English&#10;                &quot;something from &quot;, &quot;something by &quot;, &quot;something of &quot;,&#10;                &quot;anything from &quot;, &quot;anything by &quot;, &quot;a song from &quot;, &quot;a song by &quot;,&#10;                &quot;songs from &quot;, &quot;songs by &quot;, &quot;music from &quot;, &quot;music by &quot;,&#10;                // Spanish&#10;                &quot;algo de &quot;, &quot;algo del &quot;, &quot;una canción de &quot;, &quot;canciones de &quot;,&#10;                &quot;música de &quot;, &quot;una de &quot;,&#10;                // Catalan&#10;                &quot;alguna cosa de &quot;, &quot;una cançó de &quot;, &quot;cançons de &quot;, &quot;música de &quot;&#10;            )&#10;            var cleaned = query.lowercase()&#10;            for (pattern in patterns) {&#10;                if (cleaned.startsWith(pattern)) {&#10;                    cleaned = cleaned.substring(pattern.length)&#10;                    break&#10;                }&#10;                // También buscar en medio del texto&#10;                val idx = cleaned.indexOf(pattern)&#10;                if (idx &gt;= 0) {&#10;                    cleaned = cleaned.substring(idx + pattern.length)&#10;                    break&#10;                }&#10;            }&#10;            return cleaned.trim()&#10;        }&#10;&#10;        // Extraer número del texto (para volumen, temporizador, etc.)&#10;        fun extractNumber(): Int? {&#10;            val numberRegex = &quot;(\\d+)&quot;.toRegex()&#10;            return numberRegex.find(lower)?.groups?.get(1)?.value?.toIntOrNull()&#10;        }&#10;&#10;        // Extraer tiempo para sleep timer&#10;        fun extractTime(): Pair&lt;Int, String&gt;? {&#10;            // &quot;en 30 minutos&quot;, &quot;in 30 minutes&quot;&#10;            val minutesRegex = &quot;(\\d+)\\s*(minuto|minute|min)&quot;.toRegex()&#10;            val hoursRegex = &quot;(\\d+)\\s*(hora|hour|h)&quot;.toRegex()&#10;            val atTimeRegex = &quot;(\\d{1,2})[:\\.]?(\\d{2})?&quot;.toRegex()&#10;&#10;            minutesRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;minutes&quot;)&#10;            }&#10;            hoursRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;hours&quot;)&#10;            }&#10;            // &quot;a las 11&quot;, &quot;at 11&quot;&#10;            if (lower.contains(&quot;a las&quot;) || lower.contains(&quot;at &quot;)) {&#10;                atTimeRegex.find(lower)?.let {&#10;                    val hour = it.groups[1]?.value?.toIntOrNull() ?: return null&#10;                    val minute = it.groups[2]?.value?.toIntOrNull() ?: 0&#10;                    return Pair(hour * 60 + minute, &quot;absolute&quot;)&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Detectar comandos compuestos&#10;        val hasNext = containsAny(&quot;assistant_triggers_next&quot;)&#10;        val hasVolumeUp = containsAny(&quot;assistant_triggers_volume_up&quot;)&#10;        val hasVolumeDown = containsAny(&quot;assistant_triggers_volume_down&quot;)&#10;&#10;        if (hasNext &amp;&amp; (hasVolumeUp || hasVolumeDown)) {&#10;            return IntentResult(&quot;compound&quot;, 0.9f, mapOf(&#10;                &quot;actions&quot; to if (hasVolumeUp) &quot;next,volume_up&quot; else &quot;next,volume_down&quot;&#10;            ))&#10;        }&#10;&#10;        return when {&#10;            // Comandos de ayuda&#10;            containsAny(&quot;assistant_triggers_help&quot;) -&gt; IntentResult(&quot;help&quot;)&#10;&#10;            // Información contextual&#10;            containsAny(&quot;assistant_triggers_who_sings&quot;) -&gt; IntentResult(&quot;who_sings&quot;)&#10;            containsAny(&quot;assistant_triggers_what_album&quot;) -&gt; IntentResult(&quot;what_album&quot;)&#10;            containsAny(&quot;assistant_triggers_how_long&quot;) -&gt; IntentResult(&quot;how_long&quot;)&#10;&#10;            // Control de volumen&#10;            containsAny(&quot;assistant_triggers_mute&quot;) -&gt; IntentResult(&quot;mute&quot;)&#10;            containsAny(&quot;assistant_triggers_volume_up&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_up&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_down&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_down&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_set&quot;) -&gt; {&#10;                val level = extractNumber()&#10;                if (level != null) IntentResult(&quot;volume_set&quot;, 0.9f, mapOf(&quot;level&quot; to level.toString()))&#10;                else IntentResult(&quot;volume_set&quot;, 0.6f)&#10;            }&#10;&#10;            // Sleep timer&#10;            containsAny(&quot;assistant_triggers_sleep_timer&quot;) -&gt; {&#10;                val time = extractTime()&#10;                if (time != null) {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.9f, mapOf(&#10;                        &quot;value&quot; to time.first.toString(),&#10;                        &quot;unit&quot; to time.second&#10;                    ))&#10;                } else {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.6f)&#10;                }&#10;            }&#10;            containsAny(&quot;assistant_triggers_cancel_timer&quot;) -&gt; IntentResult(&quot;cancel_timer&quot;)&#10;&#10;            // Comandos de playlist&#10;            containsAny(&quot;assistant_triggers_create_playlist&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_create_playlist&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;create_playlist&quot;, 0.9f, mapOf(&quot;name&quot; to after))&#10;                else IntentResult(&quot;create_playlist&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_add_favorites&quot;) -&gt; IntentResult(&quot;add_favorites&quot;)&#10;            containsAny(&quot;assistant_triggers_shuffle&quot;) -&gt; IntentResult(&quot;shuffle&quot;)&#10;            containsAny(&quot;assistant_triggers_save_song&quot;) -&gt; IntentResult(&quot;save_song&quot;)&#10;&#10;            // Comandos naturales con género/artista&#10;            containsAny(&quot;assistant_triggers_play_genre&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_genre&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play_mood&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_mood&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to &quot;$after music&quot;))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;&#10;            // Comandos básicos existentes&#10;            containsAny(&quot;assistant_triggers_whats_playing&quot;) -&gt; IntentResult(&quot;whats_playing&quot;)&#10;            containsAny(&quot;assistant_triggers_next&quot;) -&gt; IntentResult(&quot;next&quot;)&#10;            containsAny(&quot;assistant_triggers_previous&quot;) -&gt; IntentResult(&quot;previous&quot;)&#10;            containsAny(&quot;assistant_triggers_pause&quot;) -&gt; IntentResult(&quot;pause&quot;)&#10;            containsAny(&quot;assistant_triggers_repeat&quot;) -&gt; IntentResult(&quot;repeat&quot;)&#10;            containsAny(&quot;assistant_triggers_add_queue&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_add_queue&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;add_queue&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;add_queue&quot;)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) {&#10;                    val cleanedQuery = cleanQuery(after)&#10;                    IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to cleanedQuery))&#10;                }&#10;                else IntentResult(&quot;play&quot;, 0.9f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_resume&quot;) -&gt; IntentResult(&quot;play&quot;)&#10;            containsAny(&quot;assistant_triggers_search&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_search&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;search&quot;, 0.95f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_settings&quot;) -&gt; IntentResult(&quot;settings&quot;)&#10;            else -&gt; {&#10;                if (!quoted.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to quoted))&#10;                else IntentResult(&quot;unknown&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun searchSpotifyTrack(query: String): SpotifyTrack? = withContext(Dispatchers.IO) {&#10;        val token = SpotifyTokenManager.getValidAccessToken(context) ?: return@withContext null&#10;        suspendCoroutine { cont -&gt;&#10;            SpotifyRepository.searchAll(token, query) { response, error -&gt;&#10;                if (error != null || response == null) cont.resume(null)&#10;                else cont.resume(response.tracks?.items?.firstOrNull())&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createTrackFromSpotify(query: String, playlistId: String): TrackEntity? {&#10;        val spotifyTrack = searchSpotifyTrack(query)&#10;        val searchQuery = if (spotifyTrack != null) {&#10;            &quot;${spotifyTrack.name} ${spotifyTrack.artists.joinToString(&quot; &quot;) { it.name }}&quot;&#10;        } else query&#10;&#10;        val videoId = withContext(Dispatchers.IO) {&#10;            try { YouTubeManager.searchVideoId(searchQuery) } catch (_: Exception) { null }&#10;        } ?: return null&#10;&#10;        return TrackEntity(&#10;            id = &quot;assistant_${videoId}_${System.currentTimeMillis()}&quot;,&#10;            playlistId = playlistId,&#10;            spotifyTrackId = spotifyTrack?.id ?: &quot;&quot;,&#10;            name = spotifyTrack?.name ?: query,&#10;            artists = spotifyTrack?.artists?.joinToString(&quot;, &quot;) { it.name } ?: &quot;&quot;,&#10;            youtubeVideoId = videoId,&#10;            audioUrl = null,&#10;            position = 0,&#10;            lastSyncTime = System.currentTimeMillis()&#10;        )&#10;    }&#10;&#10;    private fun getAvailableCommands(): List&lt;Pair&lt;String, String&gt;&gt; {&#10;        return listOf(&#10;            t(&quot;assistant_cmd_play&quot;) to t(&quot;assistant_resume_playback&quot;),&#10;            t(&quot;assistant_cmd_pause&quot;) to t(&quot;assistant_pause_playback&quot;),&#10;            t(&quot;assistant_cmd_next&quot;) to t(&quot;assistant_next_song&quot;),&#10;            t(&quot;assistant_cmd_previous&quot;) to t(&quot;assistant_previous_song&quot;),&#10;            t(&quot;assistant_cmd_play_song&quot;) to t(&quot;assistant_search_play&quot;),&#10;            t(&quot;assistant_cmd_search&quot;) to t(&quot;assistant_search_song&quot;),&#10;            t(&quot;assistant_cmd_add_queue&quot;) to t(&quot;assistant_add_queue&quot;),&#10;            t(&quot;assistant_cmd_repeat&quot;) to t(&quot;assistant_repeat_mode&quot;),&#10;            t(&quot;assistant_cmd_whats_playing&quot;) to t(&quot;assistant_current_song&quot;),&#10;            t(&quot;assistant_cmd_help&quot;) to t(&quot;assistant_see_commands&quot;),&#10;            // Nuevos comandos&#10;            t(&quot;assistant_cmd_volume&quot;) to t(&quot;assistant_volume_desc&quot;),&#10;            t(&quot;assistant_cmd_shuffle&quot;) to t(&quot;assistant_shuffle_desc&quot;),&#10;            t(&quot;assistant_cmd_favorites&quot;) to t(&quot;assistant_favorites_desc&quot;),&#10;            t(&quot;assistant_cmd_who_sings&quot;) to t(&quot;assistant_who_sings_desc&quot;),&#10;            t(&quot;assistant_cmd_sleep_timer&quot;) to t(&quot;assistant_sleep_timer_desc&quot;)&#10;        )&#10;    }&#10;&#10;    private fun getAudioManager(): AudioManager {&#10;        return context.getSystemService(Context.AUDIO_SERVICE) as AudioManager&#10;    }&#10;&#10;    private fun setVolume(level: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val newVolume = (level * maxVolume / 100).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun adjustVolume(delta: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        val change = (delta * maxVolume / 100).coerceAtLeast(1)&#10;        val newVolume = (currentVolume + change).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun getCurrentVolumePercent(): Int {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        return (currentVolume * 100 / maxVolume)&#10;    }&#10;&#10;    private fun startSleepTimer(minutes: Int, playerViewModel: PlayerViewModel) {&#10;        cancelSleepTimer()&#10;        sleepTimerEndTime = System.currentTimeMillis() + (minutes * 60 * 1000L)&#10;        sleepTimer = Timer().apply {&#10;            schedule(object : TimerTask() {&#10;                override fun run() {&#10;                    playerViewModel.pausePlayer()&#10;                    sleepTimer = null&#10;                    sleepTimerEndTime = 0&#10;                }&#10;            }, minutes * 60 * 1000L)&#10;        }&#10;    }&#10;&#10;    private fun cancelSleepTimer() {&#10;        sleepTimer?.cancel()&#10;        sleepTimer = null&#10;        sleepTimerEndTime = 0&#10;    }&#10;&#10;    fun getSleepTimerRemainingMinutes(): Int {&#10;        if (sleepTimerEndTime == 0L) return 0&#10;        val remaining = sleepTimerEndTime - System.currentTimeMillis()&#10;        return if (remaining &gt; 0) (remaining / 60000).toInt() else 0&#10;    }&#10;&#10;    private fun formatDuration(durationMs: Long): String {&#10;        val totalSeconds = durationMs / 1000&#10;        val minutes = totalSeconds / 60&#10;        val seconds = totalSeconds % 60&#10;        return &quot;$minutes:${seconds.toString().padStart(2, '0')}&quot;&#10;    }&#10;&#10;    suspend fun perform(result: IntentResult, playerViewModel: PlayerViewModel): String {&#10;        setState(AssistantState.PROCESSING)&#10;        lastRecognizedCommand = result.intent&#10;&#10;        return try {&#10;            when (result.intent) {&#10;                &quot;help&quot; -&gt; {&#10;                    val commands = getAvailableCommands()&#10;                    val list = commands.map { it.first }.joinToString(&quot; / &quot;)&#10;                    list&#10;                }&#10;                &quot;whats_playing&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_now_playing&quot;), track.name, artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;play&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.playPlayer() }&#10;                    t(&quot;assistant_playing&quot;)&#10;                }&#10;                &quot;pause&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.pausePlayer() }&#10;                    t(&quot;assistant_paused&quot;)&#10;                }&#10;                &quot;next&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                    t(&quot;assistant_next&quot;)&#10;                }&#10;                &quot;previous&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToPrevious() }&#10;                    t(&quot;assistant_previous&quot;)&#10;                }&#10;                &quot;repeat&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.updateRepeatMode() }&#10;                    t(&quot;assistant_repeat_changed&quot;)&#10;                }&#10;&#10;                // Información contextual&#10;                &quot;who_sings&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_artist_info&quot;), artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;what_album&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Intentar obtener info del álbum desde Spotify&#10;                        val spotifyTrack = if (track.spotifyTrackId.isNotBlank()) {&#10;                            searchSpotifyTrack(track.name)&#10;                        } else null&#10;&#10;                        val albumName = spotifyTrack?.album?.name ?: t(&quot;assistant_unknown_album&quot;)&#10;                        String.format(t(&quot;assistant_album_info&quot;), albumName)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;how_long&quot; -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player != null &amp;&amp; player.duration &gt; 0) {&#10;                        val duration = formatDuration(player.duration)&#10;                        val position = formatDuration(player.currentPosition)&#10;                        String.format(t(&quot;assistant_duration_info&quot;), position, duration)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;&#10;                // Control de volumen&#10;                &quot;mute&quot; -&gt; {&#10;                    setVolume(0)&#10;                    t(&quot;assistant_muted&quot;)&#10;                }&#10;                &quot;volume_up&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_down&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(-amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_set&quot; -&gt; {&#10;                    val level = result.entities[&quot;level&quot;]?.toIntOrNull()&#10;                    if (level != null) {&#10;                        setVolume(level.coerceIn(0, 100))&#10;                        String.format(t(&quot;assistant_volume_set_to&quot;), level)&#10;                    } else t(&quot;assistant_what_volume&quot;)&#10;                }&#10;&#10;                // Sleep timer&#10;                &quot;sleep_timer&quot; -&gt; {&#10;                    val value = result.entities[&quot;value&quot;]?.toIntOrNull()&#10;                    val unit = result.entities[&quot;unit&quot;] ?: &quot;minutes&quot;&#10;&#10;                    if (value != null) {&#10;                        val minutes = when (unit) {&#10;                            &quot;hours&quot; -&gt; value * 60&#10;                            &quot;absolute&quot; -&gt; {&#10;                                // Calcular minutos hasta la hora especificada&#10;                                val now = Calendar.getInstance()&#10;                                val target = Calendar.getInstance().apply {&#10;                                    set(Calendar.HOUR_OF_DAY, value / 60)&#10;                                    set(Calendar.MINUTE, value % 60)&#10;                                    set(Calendar.SECOND, 0)&#10;                                    if (before(now)) add(Calendar.DAY_OF_MONTH, 1)&#10;                                }&#10;                                ((target.timeInMillis - now.timeInMillis) / 60000).toInt()&#10;                            }&#10;                            else -&gt; value&#10;                        }&#10;                        startSleepTimer(minutes, playerViewModel)&#10;                        String.format(t(&quot;assistant_sleep_timer_set&quot;), minutes)&#10;                    } else t(&quot;assistant_what_time&quot;)&#10;                }&#10;                &quot;cancel_timer&quot; -&gt; {&#10;                    cancelSleepTimer()&#10;                    t(&quot;assistant_timer_cancelled&quot;)&#10;                }&#10;&#10;                // Comandos de playlist&#10;                &quot;shuffle&quot; -&gt; {&#10;                    val playlist = playerViewModel.currentPlaylist.value&#10;                    if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;                        val shuffled = playlist.shuffled()&#10;                        withContext(Dispatchers.Main) {&#10;                            playerViewModel.setCurrentPlaylist(shuffled, 0)&#10;                        }&#10;                        t(&quot;assistant_shuffled&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;add_favorites&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Guardar en favoritos usando Spotify API&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { success, _ -&gt;&#10;                                    // No hacemos nada con el resultado aquí&#10;                                }&#10;                            }&#10;                            String.format(t(&quot;assistant_added_favorites&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;save_song&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { _, _ -&gt; }&#10;                            }&#10;                            String.format(t(&quot;assistant_song_saved&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;create_playlist&quot; -&gt; {&#10;                    val name = result.entities[&quot;name&quot;]&#10;                    if (!name.isNullOrBlank()) {&#10;                        // TODO: Implementar creación de playlist&#10;                        String.format(t(&quot;assistant_playlist_created&quot;), name)&#10;                    } else t(&quot;assistant_what_playlist_name&quot;)&#10;                }&#10;&#10;                // Comandos compuestos&#10;                &quot;compound&quot; -&gt; {&#10;                    val actions = result.entities[&quot;actions&quot;]?.split(&quot;,&quot;) ?: emptyList()&#10;                    val results = mutableListOf&lt;String&gt;()&#10;                    for (action in actions) {&#10;                        when (action.trim()) {&#10;                            &quot;next&quot; -&gt; {&#10;                                withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                                results.add(t(&quot;assistant_next&quot;))&#10;                            }&#10;                            &quot;volume_up&quot; -&gt; {&#10;                                adjustVolume(10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                            &quot;volume_down&quot; -&gt; {&#10;                                adjustVolume(-10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                        }&#10;                    }&#10;                    results.joinToString(&quot;. &quot;)&#10;                }&#10;&#10;                &quot;settings&quot; -&gt; t(&quot;assistant_open_settings&quot;)&#10;                &quot;play_search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    Log.d(&quot;AssistantManager&quot;, &quot;play_search query: \&quot;$q\&quot;&quot;)&#10;                    if (q.isBlank()) return t(&quot;assistant_what_play&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_${System.currentTimeMillis()}&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val ok = withContext(Dispatchers.Main) {&#10;                        playerViewModel.initializePlayer()&#10;                        playerViewModel.setCurrentPlaylist(listOf(track), 0)&#10;                        try { playerViewModel.loadAudioFromTrack(track) } catch (_: Exception) { false }&#10;                    }&#10;                    if (ok) {&#10;                        val artists = track.artists.ifBlank { &quot;&quot; }&#10;                        if (artists.isNotBlank()) String.format(t(&quot;assistant_playing_song&quot;), track.name, artists)&#10;                        else String.format(t(&quot;assistant_playing_song_no_artist&quot;), track.name)&#10;                    } else String.format(t(&quot;assistant_error_play&quot;), q)&#10;                }&#10;                &quot;search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_search&quot;)&#10;                    val spotifyTrack = searchSpotifyTrack(q)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val artists = spotifyTrack.artists.joinToString(&quot;, &quot;) { it.name }&#10;                    String.format(t(&quot;assistant_found&quot;), spotifyTrack.name, artists)&#10;                }&#10;                &quot;add_queue&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_add&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_queue&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    withContext(Dispatchers.Main) { playerViewModel.addToQueue(track) }&#10;                    val artists = track.artists.ifBlank { &quot;&quot; }&#10;                    if (artists.isNotBlank()) String.format(t(&quot;assistant_added_queue&quot;), track.name, artists)&#10;                    else String.format(t(&quot;assistant_added_queue_no_artist&quot;), track.name)&#10;                }&#10;                else -&gt; t(&quot;assistant_not_understand&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AssistantManager&quot;, &quot;perform action error&quot;, e)&#10;            t(&quot;assistant_error&quot;)&#10;        }&#10;    }&#10;&#10;    fun close() {&#10;        cancelSleepTimer()&#10;        try { sessionIntent?.close() } catch (_: Exception) {}&#10;        try { sessionNer?.close() } catch (_: Exception) {}&#10;        sessionIntent = null&#10;        sessionNer = null&#10;        try { ortEnv = null } catch (_: Exception) {}&#10;        onnxAvailable = false&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.assistant&#10;&#10;import android.content.Context&#10;import android.media.AudioManager&#10;import android.util.Log&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.utils.SpotifyTokenManager&#10;import com.plyr.utils.Translations&#10;&#10;import java.util.Collections&#10;import java.util.Timer&#10;import java.util.TimerTask&#10;import java.util.Calendar&#10;&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;import ai.onnxruntime.OnnxTensor&#10;import ai.onnxruntime.OrtEnvironment&#10;import ai.onnxruntime.OrtSession&#10;&#10;/**&#10; * Lightweight on-device assistant manager with enhanced NLU capabilities.&#10; */&#10;class AssistantManager(private val context: Context) {&#10;&#10;    companion object {&#10;        private const val TAG = &quot;AssistantManager&quot;&#10;&#10;        // Umbral de similitud para fuzzy matching (0.0 - 1.0)&#10;        private const val FUZZY_THRESHOLD = 0.7f&#10;    }&#10;&#10;    data class IntentResult(&#10;        val intent: String,&#10;        val score: Float = 1.0f,&#10;        val entities: Map&lt;String, String&gt; = emptyMap()&#10;    )&#10;&#10;    // Estado del asistente&#10;    enum class AssistantState {&#10;        IDLE, LISTENING, PROCESSING, SPEAKING&#10;    }&#10;&#10;    private var onnxAvailable = false&#10;    private var ortEnv: OrtEnvironment? = null&#10;    private var sessionIntent: OrtSession? = null&#10;    private var sessionNer: OrtSession? = null&#10;&#10;    // Sleep timer&#10;    private var sleepTimer: Timer? = null&#10;    private var sleepTimerEndTime: Long = 0&#10;&#10;    // Estado actual&#10;    var currentState: AssistantState = AssistantState.IDLE&#10;        private set&#10;&#10;    // Callback para cambios de estado&#10;    var onStateChange: ((AssistantState) -&gt; Unit)? = null&#10;&#10;    // Último comando entendido (para feedback visual)&#10;    var lastRecognizedCommand: String = &quot;&quot;&#10;        private set&#10;&#10;    private fun t(key: String) = Translations.get(context, key)&#10;&#10;    private fun getTriggers(key: String): List&lt;String&gt; {&#10;        return t(key).split(&quot;|&quot;).map { it.trim().lowercase() }&#10;    }&#10;&#10;    fun setState(state: AssistantState) {&#10;        currentState = state&#10;        onStateChange?.invoke(state)&#10;    }&#10;&#10;    // ==================== FUZZY MATCHING ====================&#10;&#10;    /**&#10;     * Calcula la distancia de Levenshtein entre dos strings&#10;     */&#10;    private fun levenshteinDistance(s1: String, s2: String): Int {&#10;        val m = s1.length&#10;        val n = s2.length&#10;        val dp = Array(m + 1) { IntArray(n + 1) }&#10;&#10;        for (i in 0..m) dp[i][0] = i&#10;        for (j in 0..n) dp[0][j] = j&#10;&#10;        for (i in 1..m) {&#10;            for (j in 1..n) {&#10;                dp[i][j] = if (s1[i-1] == s2[j-1]) {&#10;                    dp[i-1][j-1]&#10;                } else {&#10;                    minOf(dp[i-1][j], dp[i][j-1], dp[i-1][j-1]) + 1&#10;                }&#10;            }&#10;        }&#10;        return dp[m][n]&#10;    }&#10;&#10;    /**&#10;     * Calcula similitud entre dos strings (0.0 - 1.0)&#10;     */&#10;    private fun similarity(s1: String, s2: String): Float {&#10;        val maxLen = maxOf(s1.length, s2.length)&#10;        if (maxLen == 0) return 1.0f&#10;        return 1.0f - (levenshteinDistance(s1, s2).toFloat() / maxLen)&#10;    }&#10;&#10;    /**&#10;     * Busca si alguna palabra del texto es similar a algún trigger (fuzzy match)&#10;     */&#10;    private fun fuzzyContains(text: String, triggers: List&lt;String&gt;): Pair&lt;Boolean, Float&gt; {&#10;        val words = text.lowercase().split(&quot; &quot;, &quot;,&quot;, &quot;.&quot;, &quot;?&quot;, &quot;!&quot;)&#10;        var bestScore = 0f&#10;&#10;        for (trigger in triggers) {&#10;            // Match exacto&#10;            if (text.lowercase().contains(trigger)) {&#10;                return Pair(true, 1.0f)&#10;            }&#10;&#10;            // Fuzzy match por palabras&#10;            val triggerWords = trigger.split(&quot; &quot;)&#10;            for (word in words) {&#10;                if (word.length &lt; 3) continue // Ignorar palabras muy cortas&#10;&#10;                for (tw in triggerWords) {&#10;                    if (tw.length &lt; 3) continue&#10;                    val sim = similarity(word, tw)&#10;                    if (sim &gt; bestScore) bestScore = sim&#10;                }&#10;            }&#10;&#10;            // También comparar frases completas si el trigger tiene múltiples palabras&#10;            if (triggerWords.size &gt; 1) {&#10;                val sim = similarity(text.lowercase(), trigger)&#10;                if (sim &gt; bestScore) bestScore = sim&#10;            }&#10;        }&#10;&#10;        return Pair(bestScore &gt;= FUZZY_THRESHOLD, bestScore)&#10;    }&#10;&#10;    // ==================== SEMANTIC PATTERNS ====================&#10;&#10;    /**&#10;     * Patrones semánticos para detectar intenciones de forma más natural&#10;     */&#10;    private data class SemanticPattern(&#10;        val intent: String,&#10;        val patterns: List&lt;Regex&gt;,&#10;        val entityExtractor: ((MatchResult) -&gt; Map&lt;String, String&gt;)? = null&#10;    )&#10;&#10;    private val semanticPatterns: List&lt;SemanticPattern&gt; by lazy {&#10;        listOf(&#10;            // Reproducir música - patrones muy flexibles&#10;            SemanticPattern(&#10;                &quot;play_search&quot;,&#10;                listOf(&#10;                    // &quot;quiero escuchar X&quot;, &quot;I want to hear X&quot;, &quot;me apetece X&quot;&#10;                    Regex(&quot;(?:quiero|want|wanna|me apetece|me gustaría|i'd like to).*(?:escuchar|oír|oir|hear|listen)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;ponme X&quot;, &quot;play X&quot;, &quot;pon X&quot;&#10;                    Regex(&quot;(?:ponme|pon|play|put on|reproduce|toca)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;algo de X&quot;, &quot;something from X&quot;, &quot;música de X&quot;&#10;                    Regex(&quot;(?:algo|something|anything|música|music)\\s+(?:de|from|by|del)\\s+(.+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;X por favor&quot;, &quot;X please&quot;&#10;                    Regex(&quot;(.+?)\\s+(?:por favor|please|porfavor|porfa)$&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;escucha X&quot;, &quot;reproduce X&quot;&#10;                    Regex(&quot;(?:escucha|reproduce|listen to)\\s+(.+)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ) { match -&gt;&#10;                val query = cleanQueryText(match.groupValues[1])&#10;                if (query.isNotBlank()) mapOf(&quot;query&quot; to query) else emptyMap()&#10;            },&#10;&#10;            // Control de reproducción&#10;            SemanticPattern(&#10;                &quot;pause&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:para|stop|detén|deten|calla|silencio|quiet|pause|pausa|wait|espera)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;play&quot;,&#10;                listOf(&#10;                    Regex(&quot;^(?:play|resume|continua|continue|sigue|dale|go|start|empieza|comienza)$&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:sigue|continúa|resume)\\s*(?:la música|playing|reproduciendo)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;next&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:siguiente|next|skip|salta|pasa|otra|another|cambia|change)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;previous&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:anterior|previous|back|atrás|atras|vuelve|go back|última|ultima|last)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Volumen - IMPORTANTE: volume_set debe ir ANTES que volume_up/down&#10;            SemanticPattern(&#10;                &quot;volume_set&quot;,&#10;                listOf(&#10;                    // &quot;volumen al 50&quot;, &quot;volume to 50&quot;, &quot;set volume to 50&quot;&#10;                    Regex(&quot;(?:volumen|volume|sonido|sound)\\s*(?:al?|to|at)\\s*(\\d+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;pon el volumen al 50&quot;, &quot;set volume at 50&quot;&#10;                    Regex(&quot;(?:pon|set|put).*(?:volumen|volume).*(?:al?|to|at)\\s*(\\d+)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;50 percent volume&quot;, &quot;50% volume&quot;&#10;                    Regex(&quot;(\\d+)\\s*(?:%|percent|por ?ciento)?\\s*(?:de )?(?:volumen|volume)&quot;, RegexOption.IGNORE_CASE),&#10;                    // &quot;volumen 50&quot;, &quot;volume 50&quot; (número después de volumen)&#10;                    Regex(&quot;(?:volumen|volume)\\s+(\\d+)(?:\\s*%)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ) { match -&gt;&#10;                val level = match.groupValues.getOrNull(1)?.toIntOrNull()&#10;                if (level != null) mapOf(&quot;level&quot; to level.toString()) else emptyMap()&#10;            },&#10;&#10;            SemanticPattern(&#10;                &quot;volume_up&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:sube|subir|más alto|louder|turn up|volume up|aumenta|increase).*(?:volumen|volume|sonido|sound)?&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:volumen|volume|sonido).*(?:arriba|up|más|more|alto)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;volume_down&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:baja|bajar|más bajo|quieter|softer|turn down|volume down|reduce|disminuye).*(?:volumen|volume|sonido|sound)?&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:volumen|volume|sonido).*(?:abajo|down|menos|less|bajo)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Información&#10;            SemanticPattern(&#10;                &quot;whats_playing&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:qué|que|what|which).*(?:suena|canción|song|playing|sonando|escuchando|track)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:cómo|como|how).*(?:llama|call|nombre|name).*(?:canción|song|esta|this)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:dime|tell me).*(?:canción|song|qué|what)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            SemanticPattern(&#10;                &quot;who_sings&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:quién|quien|who).*(?:canta|sings|artista|artist|interpreta)&quot;, RegexOption.IGNORE_CASE),&#10;                    Regex(&quot;(?:de quién|de quien|whose|by whom).*(?:es|is).*(?:canción|song|esta|this)?&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Shuffle&#10;            SemanticPattern(&#10;                &quot;shuffle&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:mezcla|shuffle|random|aleatorio|mix|revuelve|desordena)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            ),&#10;&#10;            // Ayuda&#10;            SemanticPattern(&#10;                &quot;help&quot;,&#10;                listOf(&#10;                    Regex(&quot;(?:ayuda|help|comandos|commands|qué puedo|what can|opciones|options)&quot;, RegexOption.IGNORE_CASE)&#10;                )&#10;            )&#10;        )&#10;    }&#10;&#10;    /**&#10;     * Limpia el texto de query eliminando palabras innecesarias&#10;     */&#10;    private fun cleanQueryText(query: String): String {&#10;        val stopWords = listOf(&#10;            // English&#10;            &quot;something&quot;, &quot;anything&quot;, &quot;some&quot;, &quot;a&quot;, &quot;the&quot;, &quot;from&quot;, &quot;by&quot;, &quot;of&quot;,&#10;            &quot;please&quot;, &quot;pls&quot;, &quot;plz&quot;, &quot;thanks&quot;, &quot;thank you&quot;,&#10;            &quot;i want&quot;, &quot;i wanna&quot;, &quot;i'd like&quot;, &quot;can you&quot;, &quot;could you&quot;,&#10;            &quot;play me&quot;, &quot;put on&quot;, &quot;give me&quot;,&#10;            // Spanish&#10;            &quot;algo&quot;, &quot;alguna&quot;, &quot;algún&quot;, &quot;algun&quot;, &quot;una&quot;, &quot;un&quot;, &quot;el&quot;, &quot;la&quot;, &quot;los&quot;, &quot;las&quot;,&#10;            &quot;de&quot;, &quot;del&quot;, &quot;por favor&quot;, &quot;porfa&quot;, &quot;porfavor&quot;, &quot;gracias&quot;,&#10;            &quot;quiero&quot;, &quot;quisiera&quot;, &quot;me gustaría&quot;, &quot;puedes&quot;, &quot;podrías&quot;,&#10;            &quot;ponme&quot;, &quot;dame&quot;, &quot;pon&quot;,&#10;            // Catalan&#10;            &quot;alguna cosa&quot;, &quot;una&quot;, &quot;un&quot;, &quot;el&quot;, &quot;la&quot;, &quot;els&quot;, &quot;les&quot;,&#10;            &quot;de&quot;, &quot;del&quot;, &quot;si us plau&quot;, &quot;sisplau&quot;, &quot;gràcies&quot;&#10;        )&#10;&#10;        var cleaned = query.lowercase().trim()&#10;&#10;        // Eliminar stop words del inicio&#10;        for (sw in stopWords.sortedByDescending { it.length }) {&#10;            if (cleaned.startsWith(&quot;$sw &quot;)) {&#10;                cleaned = cleaned.removePrefix(&quot;$sw &quot;).trim()&#10;            }&#10;        }&#10;&#10;        // Eliminar stop words del final&#10;        for (sw in stopWords.sortedByDescending { it.length }) {&#10;            if (cleaned.endsWith(&quot; $sw&quot;)) {&#10;                cleaned = cleaned.removeSuffix(&quot; $sw&quot;).trim()&#10;            }&#10;        }&#10;&#10;        return cleaned.trim()&#10;    }&#10;&#10;    /**&#10;     * Intenta hacer match con patrones semánticos&#10;     */&#10;    private fun matchSemanticPatterns(text: String): IntentResult? {&#10;        for (pattern in semanticPatterns) {&#10;            for (regex in pattern.patterns) {&#10;                val match = regex.find(text)&#10;                if (match != null) {&#10;                    val entities = pattern.entityExtractor?.invoke(match) ?: emptyMap()&#10;                    Log.d(TAG, &quot;Semantic match: ${pattern.intent} with entities: $entities&quot;)&#10;                    return IntentResult(pattern.intent, 0.85f, entities)&#10;                }&#10;            }&#10;        }&#10;        return null&#10;    }&#10;&#10;    // ==================== INTENT INFERENCE ====================&#10;&#10;    init {&#10;        try {&#10;            Class.forName(&quot;ai.onnxruntime.OnnxTensor&quot;)&#10;            onnxAvailable = true&#10;        } catch (_: Exception) {&#10;            onnxAvailable = false&#10;        }&#10;&#10;        if (onnxAvailable) {&#10;            try {&#10;                ortEnv = OrtEnvironment.getEnvironment()&#10;                val am = context.assets&#10;                fun loadSession(assetName: String): OrtSession? {&#10;                    return try {&#10;                        val bytes = am.open(assetName).use { it.readBytes() }&#10;                        ortEnv?.createSession(bytes)&#10;                    } catch (ex: Exception) {&#10;                        // Models are optional - silently skip if not found&#10;                        Log.v(TAG, &quot;Optional model $assetName not available&quot;)&#10;                        null&#10;                    }&#10;                }&#10;                sessionIntent = loadSession(&quot;assistant_intent.onnx&quot;)&#10;                sessionNer = loadSession(&quot;assistant_ner.onnx&quot;)&#10;                if (sessionIntent == null &amp;&amp; sessionNer == null) {&#10;                    onnxAvailable = false&#10;                    Log.d(TAG, &quot;ONNX models not found, using rule-based NLU&quot;)&#10;                }&#10;            } catch (ex: Throwable) {&#10;                Log.d(TAG, &quot;ONNX runtime not available, using rule-based NLU&quot;)&#10;                onnxAvailable = false&#10;            }&#10;        }&#10;    }&#10;&#10;    fun analyze(text: String): IntentResult {&#10;        val trimmed = text.trim()&#10;        if (trimmed.isEmpty()) return IntentResult(&quot;none&quot;, 1f)&#10;&#10;        Log.d(TAG, &quot;Analyzing: \&quot;$trimmed\&quot;&quot;)&#10;&#10;        // 1. Intentar con ONNX si está disponible&#10;        if (onnxAvailable &amp;&amp; sessionIntent != null &amp;&amp; ortEnv != null) {&#10;            try {&#10;                val inputName = sessionIntent!!.inputNames.iterator().next()&#10;                val tensor = OnnxTensor.createTensor(ortEnv!!, arrayOf(trimmed))&#10;                val res = sessionIntent!!.run(Collections.singletonMap(inputName, tensor))&#10;                try {&#10;                    if (res.size() &gt; 0) {&#10;                        val first = res.get(0)&#10;                        val value = first.value&#10;                        if (value is Array&lt;*&gt;) {&#10;                            val maybe = value.firstOrNull() as? String&#10;                            if (!maybe.isNullOrBlank()) {&#10;                                Log.d(TAG, &quot;ONNX result: $maybe&quot;)&#10;                                return IntentResult(maybe, 0.95f)&#10;                            }&#10;                        } else if (value is String) {&#10;                            if (value.isNotBlank()) {&#10;                                Log.d(TAG, &quot;ONNX result: $value&quot;)&#10;                                return IntentResult(value, 0.95f)&#10;                            }&#10;                        }&#10;                    }&#10;                } finally {&#10;                    try { res.close() } catch (_: Exception) {}&#10;                    try { tensor.close() } catch (_: Exception) {}&#10;                }&#10;            } catch (e: Exception) {&#10;                Log.i(TAG, &quot;ONNX intent inference failed: ${e.message}&quot;)&#10;            }&#10;        }&#10;&#10;        // 2. Intentar con patrones semánticos (más flexibles)&#10;        val semanticResult = matchSemanticPatterns(trimmed)&#10;        if (semanticResult != null) {&#10;            return semanticResult&#10;        }&#10;&#10;        // 3. Fallback a análisis basado en reglas con fuzzy matching&#10;        return ruleBasedAnalysis(trimmed)&#10;    }&#10;&#10;    private fun ruleBasedAnalysis(text: String): IntentResult {&#10;        val lower = text.lowercase()&#10;&#10;        val quoteRegex = &quot;\&quot;(.*?)\&quot;&quot;.toRegex()&#10;        val quoted = quoteRegex.find(text)?.groups?.get(1)?.value&#10;&#10;        fun containsAny(triggerKey: String): Boolean {&#10;            val triggers = getTriggers(triggerKey)&#10;            // Primero intentar match exacto&#10;            if (triggers.any { lower.contains(it) }) return true&#10;            // Luego fuzzy match&#10;            val (found, score) = fuzzyContains(lower, triggers)&#10;            if (found) {&#10;                Log.d(TAG, &quot;Fuzzy match for $triggerKey with score $score&quot;)&#10;            }&#10;            return found&#10;        }&#10;&#10;        fun containsAnyExact(triggerKey: String): Boolean {&#10;            return getTriggers(triggerKey).any { lower.contains(it) }&#10;        }&#10;&#10;        fun extractAfter(triggerKey: String): String? {&#10;            val triggers = getTriggers(triggerKey).map { &quot;$it &quot; }&#10;            for (k in triggers) {&#10;                val idx = lower.indexOf(k)&#10;                if (idx &gt;= 0) {&#10;                    return text.substring(idx + k.length).trim().trim('&quot;', '\'')&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Extractor de entidades mejorado&#10;        fun extractMusicEntity(text: String): String? {&#10;            // Patrones para extraer artista/canción&#10;            val patterns = listOf(&#10;                // &quot;de X&quot;, &quot;by X&quot;, &quot;from X&quot;&#10;                Regex(&quot;(?:de|by|from|del)\\s+(.+?)(?:\\s+(?:por favor|please))?$&quot;, RegexOption.IGNORE_CASE),&#10;                // Contenido entre comillas&#10;                Regex(&quot;\&quot;(.+?)\&quot;&quot;),&#10;                Regex(&quot;'(.+?)'&quot;),&#10;                // Después de verbos de reproducción&#10;                Regex(&quot;(?:play|pon|reproduce|escucha|toca)\\s+(.+?)(?:\\s+(?:por favor|please))?$&quot;, RegexOption.IGNORE_CASE)&#10;            )&#10;&#10;            for (pattern in patterns) {&#10;                val match = pattern.find(text)&#10;                if (match != null &amp;&amp; match.groupValues.size &gt; 1) {&#10;                    val extracted = cleanQueryText(match.groupValues[1])&#10;                    if (extracted.isNotBlank() &amp;&amp; extracted.length &gt; 1) {&#10;                        return extracted&#10;                    }&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Limpiar frases comunes que no son parte del artista/canción&#10;        fun cleanQuery(query: String): String {&#10;            return cleanQueryText(query)&#10;        }&#10;&#10;        // Extraer número del texto&#10;        fun extractNumber(): Int? {&#10;            val numberRegex = &quot;(\\d+)&quot;.toRegex()&#10;            return numberRegex.find(lower)?.groups?.get(1)?.value?.toIntOrNull()&#10;        }&#10;&#10;        // Extraer tiempo para sleep timer&#10;        fun extractTime(): Pair&lt;Int, String&gt;? {&#10;            val minutesRegex = &quot;(\\d+)\\s*(minuto|minute|min)&quot;.toRegex()&#10;            val hoursRegex = &quot;(\\d+)\\s*(hora|hour|h)&quot;.toRegex()&#10;            val atTimeRegex = &quot;(\\d{1,2})[:\\.]?(\\d{2})?&quot;.toRegex()&#10;&#10;            minutesRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;minutes&quot;)&#10;            }&#10;            hoursRegex.find(lower)?.let {&#10;                return Pair(it.groups[1]?.value?.toIntOrNull() ?: 0, &quot;hours&quot;)&#10;            }&#10;            if (lower.contains(&quot;a las&quot;) || lower.contains(&quot;at &quot;)) {&#10;                atTimeRegex.find(lower)?.let {&#10;                    val hour = it.groups[1]?.value?.toIntOrNull() ?: return null&#10;                    val minute = it.groups[2]?.value?.toIntOrNull() ?: 0&#10;                    return Pair(hour * 60 + minute, &quot;absolute&quot;)&#10;                }&#10;            }&#10;            return null&#10;        }&#10;&#10;        // Detectar comandos compuestos&#10;        val hasNext = containsAnyExact(&quot;assistant_triggers_next&quot;)&#10;        val hasVolumeUp = containsAnyExact(&quot;assistant_triggers_volume_up&quot;)&#10;        val hasVolumeDown = containsAnyExact(&quot;assistant_triggers_volume_down&quot;)&#10;&#10;        if (hasNext &amp;&amp; (hasVolumeUp || hasVolumeDown)) {&#10;            return IntentResult(&quot;compound&quot;, 0.9f, mapOf(&#10;                &quot;actions&quot; to if (hasVolumeUp) &quot;next,volume_up&quot; else &quot;next,volume_down&quot;&#10;            ))&#10;        }&#10;&#10;        return when {&#10;            // Comandos de ayuda&#10;            containsAny(&quot;assistant_triggers_help&quot;) -&gt; IntentResult(&quot;help&quot;)&#10;&#10;            // Información contextual&#10;            containsAny(&quot;assistant_triggers_who_sings&quot;) -&gt; IntentResult(&quot;who_sings&quot;)&#10;            containsAny(&quot;assistant_triggers_what_album&quot;) -&gt; IntentResult(&quot;what_album&quot;)&#10;            containsAny(&quot;assistant_triggers_how_long&quot;) -&gt; IntentResult(&quot;how_long&quot;)&#10;&#10;            // Control de volumen&#10;            containsAny(&quot;assistant_triggers_mute&quot;) -&gt; IntentResult(&quot;mute&quot;)&#10;            containsAny(&quot;assistant_triggers_volume_up&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_up&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_down&quot;) -&gt; {&#10;                val amount = extractNumber() ?: 10&#10;                IntentResult(&quot;volume_down&quot;, 0.9f, mapOf(&quot;amount&quot; to amount.toString()))&#10;            }&#10;            containsAny(&quot;assistant_triggers_volume_set&quot;) -&gt; {&#10;                val level = extractNumber()&#10;                if (level != null) IntentResult(&quot;volume_set&quot;, 0.9f, mapOf(&quot;level&quot; to level.toString()))&#10;                else IntentResult(&quot;volume_set&quot;, 0.6f)&#10;            }&#10;&#10;            // Sleep timer&#10;            containsAny(&quot;assistant_triggers_sleep_timer&quot;) -&gt; {&#10;                val time = extractTime()&#10;                if (time != null) {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.9f, mapOf(&#10;                        &quot;value&quot; to time.first.toString(),&#10;                        &quot;unit&quot; to time.second&#10;                    ))&#10;                } else {&#10;                    IntentResult(&quot;sleep_timer&quot;, 0.6f)&#10;                }&#10;            }&#10;            containsAny(&quot;assistant_triggers_cancel_timer&quot;) -&gt; IntentResult(&quot;cancel_timer&quot;)&#10;&#10;            // Comandos de playlist&#10;            containsAny(&quot;assistant_triggers_create_playlist&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_create_playlist&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;create_playlist&quot;, 0.9f, mapOf(&quot;name&quot; to after))&#10;                else IntentResult(&quot;create_playlist&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_add_favorites&quot;) -&gt; IntentResult(&quot;add_favorites&quot;)&#10;            containsAny(&quot;assistant_triggers_shuffle&quot;) -&gt; IntentResult(&quot;shuffle&quot;)&#10;            containsAny(&quot;assistant_triggers_save_song&quot;) -&gt; IntentResult(&quot;save_song&quot;)&#10;&#10;            // Comandos naturales con género/artista&#10;            containsAny(&quot;assistant_triggers_play_genre&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_genre&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play_mood&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play_mood&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to &quot;$after music&quot;))&#10;                else IntentResult(&quot;play_search&quot;, 0.6f)&#10;            }&#10;&#10;            // Comandos básicos existentes&#10;            containsAny(&quot;assistant_triggers_whats_playing&quot;) -&gt; IntentResult(&quot;whats_playing&quot;)&#10;            containsAny(&quot;assistant_triggers_next&quot;) -&gt; IntentResult(&quot;next&quot;)&#10;            containsAny(&quot;assistant_triggers_previous&quot;) -&gt; IntentResult(&quot;previous&quot;)&#10;            containsAny(&quot;assistant_triggers_pause&quot;) -&gt; IntentResult(&quot;pause&quot;)&#10;            containsAny(&quot;assistant_triggers_repeat&quot;) -&gt; IntentResult(&quot;repeat&quot;)&#10;            containsAny(&quot;assistant_triggers_add_queue&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_add_queue&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;add_queue&quot;, 0.9f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;add_queue&quot;)&#10;            }&#10;            containsAny(&quot;assistant_triggers_play&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_play&quot;) ?: quoted ?: extractMusicEntity(text)&#10;                if (!after.isNullOrBlank()) {&#10;                    val cleanedQuery = cleanQuery(after)&#10;                    if (cleanedQuery.isNotBlank()) {&#10;                        IntentResult(&quot;play_search&quot;, 0.9f, mapOf(&quot;query&quot; to cleanedQuery))&#10;                    } else {&#10;                        IntentResult(&quot;play&quot;, 0.9f)&#10;                    }&#10;                }&#10;                else IntentResult(&quot;play&quot;, 0.9f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_resume&quot;) -&gt; IntentResult(&quot;play&quot;)&#10;            containsAny(&quot;assistant_triggers_search&quot;) -&gt; {&#10;                val after = extractAfter(&quot;assistant_triggers_search&quot;) ?: quoted&#10;                if (!after.isNullOrBlank()) IntentResult(&quot;search&quot;, 0.95f, mapOf(&quot;query&quot; to after))&#10;                else IntentResult(&quot;search&quot;, 0.6f)&#10;            }&#10;            containsAny(&quot;assistant_triggers_settings&quot;) -&gt; IntentResult(&quot;settings&quot;)&#10;&#10;            // Fallback: si hay comillas, asumir que quiere reproducir&#10;            !quoted.isNullOrBlank() -&gt; IntentResult(&quot;play_search&quot;, 0.8f, mapOf(&quot;query&quot; to quoted))&#10;&#10;            // Último intento: extraer entidad musical del texto completo&#10;            else -&gt; {&#10;                val entity = extractMusicEntity(text)&#10;                if (!entity.isNullOrBlank()) {&#10;                    Log.d(TAG, &quot;Fallback entity extraction: $entity&quot;)&#10;                    IntentResult(&quot;play_search&quot;, 0.7f, mapOf(&quot;query&quot; to entity))&#10;                } else {&#10;                    IntentResult(&quot;unknown&quot;)&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun searchSpotifyTrack(query: String): SpotifyTrack? = withContext(Dispatchers.IO) {&#10;        val token = SpotifyTokenManager.getValidAccessToken(context) ?: return@withContext null&#10;        suspendCoroutine { cont -&gt;&#10;            SpotifyRepository.searchAll(token, query) { response, error -&gt;&#10;                if (error != null || response == null) cont.resume(null)&#10;                else cont.resume(response.tracks?.items?.firstOrNull())&#10;            }&#10;        }&#10;    }&#10;&#10;    private suspend fun createTrackFromSpotify(query: String, playlistId: String): TrackEntity? {&#10;        val spotifyTrack = searchSpotifyTrack(query)&#10;        val searchQuery = if (spotifyTrack != null) {&#10;            &quot;${spotifyTrack.name} ${spotifyTrack.artists.joinToString(&quot; &quot;) { it.name }}&quot;&#10;        } else query&#10;&#10;        val videoId = withContext(Dispatchers.IO) {&#10;            try { YouTubeManager.searchVideoId(searchQuery) } catch (_: Exception) { null }&#10;        } ?: return null&#10;&#10;        return TrackEntity(&#10;            id = &quot;assistant_${videoId}_${System.currentTimeMillis()}&quot;,&#10;            playlistId = playlistId,&#10;            spotifyTrackId = spotifyTrack?.id ?: &quot;&quot;,&#10;            name = spotifyTrack?.name ?: query,&#10;            artists = spotifyTrack?.artists?.joinToString(&quot;, &quot;) { it.name } ?: &quot;&quot;,&#10;            youtubeVideoId = videoId,&#10;            audioUrl = null,&#10;            position = 0,&#10;            lastSyncTime = System.currentTimeMillis()&#10;        )&#10;    }&#10;&#10;    private fun getAvailableCommands(): List&lt;Pair&lt;String, String&gt;&gt; {&#10;        return listOf(&#10;            t(&quot;assistant_cmd_play&quot;) to t(&quot;assistant_resume_playback&quot;),&#10;            t(&quot;assistant_cmd_pause&quot;) to t(&quot;assistant_pause_playback&quot;),&#10;            t(&quot;assistant_cmd_next&quot;) to t(&quot;assistant_next_song&quot;),&#10;            t(&quot;assistant_cmd_previous&quot;) to t(&quot;assistant_previous_song&quot;),&#10;            t(&quot;assistant_cmd_play_song&quot;) to t(&quot;assistant_search_play&quot;),&#10;            t(&quot;assistant_cmd_search&quot;) to t(&quot;assistant_search_song&quot;),&#10;            t(&quot;assistant_cmd_add_queue&quot;) to t(&quot;assistant_add_queue&quot;),&#10;            t(&quot;assistant_cmd_repeat&quot;) to t(&quot;assistant_repeat_mode&quot;),&#10;            t(&quot;assistant_cmd_whats_playing&quot;) to t(&quot;assistant_current_song&quot;),&#10;            t(&quot;assistant_cmd_help&quot;) to t(&quot;assistant_see_commands&quot;),&#10;            // Nuevos comandos&#10;            t(&quot;assistant_cmd_volume&quot;) to t(&quot;assistant_volume_desc&quot;),&#10;            t(&quot;assistant_cmd_shuffle&quot;) to t(&quot;assistant_shuffle_desc&quot;),&#10;            t(&quot;assistant_cmd_favorites&quot;) to t(&quot;assistant_favorites_desc&quot;),&#10;            t(&quot;assistant_cmd_who_sings&quot;) to t(&quot;assistant_who_sings_desc&quot;),&#10;            t(&quot;assistant_cmd_sleep_timer&quot;) to t(&quot;assistant_sleep_timer_desc&quot;)&#10;        )&#10;    }&#10;&#10;    private fun getAudioManager(): AudioManager {&#10;        return context.getSystemService(Context.AUDIO_SERVICE) as AudioManager&#10;    }&#10;&#10;    private fun setVolume(level: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val newVolume = (level * maxVolume / 100).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun adjustVolume(delta: Int) {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        val change = (delta * maxVolume / 100).coerceAtLeast(1)&#10;        val newVolume = (currentVolume + change).coerceIn(0, maxVolume)&#10;        audioManager.setStreamVolume(AudioManager.STREAM_MUSIC, newVolume, 0)&#10;    }&#10;&#10;    private fun getCurrentVolumePercent(): Int {&#10;        val audioManager = getAudioManager()&#10;        val maxVolume = audioManager.getStreamMaxVolume(AudioManager.STREAM_MUSIC)&#10;        val currentVolume = audioManager.getStreamVolume(AudioManager.STREAM_MUSIC)&#10;        return (currentVolume * 100 / maxVolume)&#10;    }&#10;&#10;    private fun startSleepTimer(minutes: Int, playerViewModel: PlayerViewModel) {&#10;        cancelSleepTimer()&#10;        sleepTimerEndTime = System.currentTimeMillis() + (minutes * 60 * 1000L)&#10;        sleepTimer = Timer().apply {&#10;            schedule(object : TimerTask() {&#10;                override fun run() {&#10;                    playerViewModel.pausePlayer()&#10;                    sleepTimer = null&#10;                    sleepTimerEndTime = 0&#10;                }&#10;            }, minutes * 60 * 1000L)&#10;        }&#10;    }&#10;&#10;    private fun cancelSleepTimer() {&#10;        sleepTimer?.cancel()&#10;        sleepTimer = null&#10;        sleepTimerEndTime = 0&#10;    }&#10;&#10;    fun getSleepTimerRemainingMinutes(): Int {&#10;        if (sleepTimerEndTime == 0L) return 0&#10;        val remaining = sleepTimerEndTime - System.currentTimeMillis()&#10;        return if (remaining &gt; 0) (remaining / 60000).toInt() else 0&#10;    }&#10;&#10;    private fun formatDuration(durationMs: Long): String {&#10;        val totalSeconds = durationMs / 1000&#10;        val minutes = totalSeconds / 60&#10;        val seconds = totalSeconds % 60&#10;        return &quot;$minutes:${seconds.toString().padStart(2, '0')}&quot;&#10;    }&#10;&#10;    suspend fun perform(result: IntentResult, playerViewModel: PlayerViewModel): String {&#10;        setState(AssistantState.PROCESSING)&#10;        lastRecognizedCommand = result.intent&#10;&#10;        return try {&#10;            when (result.intent) {&#10;                &quot;help&quot; -&gt; {&#10;                    val commands = getAvailableCommands()&#10;                    val list = commands.map { it.first }.joinToString(&quot; / &quot;)&#10;                    list&#10;                }&#10;                &quot;whats_playing&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_now_playing&quot;), track.name, artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;play&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.playPlayer() }&#10;                    t(&quot;assistant_playing&quot;)&#10;                }&#10;                &quot;pause&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.pausePlayer() }&#10;                    t(&quot;assistant_paused&quot;)&#10;                }&#10;                &quot;next&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                    t(&quot;assistant_next&quot;)&#10;                }&#10;                &quot;previous&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.navigateToPrevious() }&#10;                    t(&quot;assistant_previous&quot;)&#10;                }&#10;                &quot;repeat&quot; -&gt; {&#10;                    withContext(Dispatchers.Main) { playerViewModel.updateRepeatMode() }&#10;                    t(&quot;assistant_repeat_changed&quot;)&#10;                }&#10;&#10;                // Información contextual&#10;                &quot;who_sings&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val artists = track.artists.ifBlank { t(&quot;assistant_unknown_artist&quot;) }&#10;                        String.format(t(&quot;assistant_artist_info&quot;), artists)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;what_album&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Intentar obtener info del álbum desde Spotify&#10;                        val spotifyTrack = if (track.spotifyTrackId.isNotBlank()) {&#10;                            searchSpotifyTrack(track.name)&#10;                        } else null&#10;&#10;                        val albumName = spotifyTrack?.album?.name ?: t(&quot;assistant_unknown_album&quot;)&#10;                        String.format(t(&quot;assistant_album_info&quot;), albumName)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;how_long&quot; -&gt; {&#10;                    val player = playerViewModel.exoPlayer&#10;                    if (player != null &amp;&amp; player.duration &gt; 0) {&#10;                        val duration = formatDuration(player.duration)&#10;                        val position = formatDuration(player.currentPosition)&#10;                        String.format(t(&quot;assistant_duration_info&quot;), position, duration)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;&#10;                // Control de volumen&#10;                &quot;mute&quot; -&gt; {&#10;                    setVolume(0)&#10;                    t(&quot;assistant_muted&quot;)&#10;                }&#10;                &quot;volume_up&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_down&quot; -&gt; {&#10;                    val amount = result.entities[&quot;amount&quot;]?.toIntOrNull() ?: 10&#10;                    adjustVolume(-amount)&#10;                    String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent())&#10;                }&#10;                &quot;volume_set&quot; -&gt; {&#10;                    val level = result.entities[&quot;level&quot;]?.toIntOrNull()&#10;                    if (level != null) {&#10;                        setVolume(level.coerceIn(0, 100))&#10;                        String.format(t(&quot;assistant_volume_set_to&quot;), level)&#10;                    } else t(&quot;assistant_what_volume&quot;)&#10;                }&#10;&#10;                // Sleep timer&#10;                &quot;sleep_timer&quot; -&gt; {&#10;                    val value = result.entities[&quot;value&quot;]?.toIntOrNull()&#10;                    val unit = result.entities[&quot;unit&quot;] ?: &quot;minutes&quot;&#10;&#10;                    if (value != null) {&#10;                        val minutes = when (unit) {&#10;                            &quot;hours&quot; -&gt; value * 60&#10;                            &quot;absolute&quot; -&gt; {&#10;                                // Calcular minutos hasta la hora especificada&#10;                                val now = Calendar.getInstance()&#10;                                val target = Calendar.getInstance().apply {&#10;                                    set(Calendar.HOUR_OF_DAY, value / 60)&#10;                                    set(Calendar.MINUTE, value % 60)&#10;                                    set(Calendar.SECOND, 0)&#10;                                    if (before(now)) add(Calendar.DAY_OF_MONTH, 1)&#10;                                }&#10;                                ((target.timeInMillis - now.timeInMillis) / 60000).toInt()&#10;                            }&#10;                            else -&gt; value&#10;                        }&#10;                        startSleepTimer(minutes, playerViewModel)&#10;                        String.format(t(&quot;assistant_sleep_timer_set&quot;), minutes)&#10;                    } else t(&quot;assistant_what_time&quot;)&#10;                }&#10;                &quot;cancel_timer&quot; -&gt; {&#10;                    cancelSleepTimer()&#10;                    t(&quot;assistant_timer_cancelled&quot;)&#10;                }&#10;&#10;                // Comandos de playlist&#10;                &quot;shuffle&quot; -&gt; {&#10;                    val playlist = playerViewModel.currentPlaylist.value&#10;                    if (playlist != null &amp;&amp; playlist.isNotEmpty()) {&#10;                        val shuffled = playlist.shuffled()&#10;                        withContext(Dispatchers.Main) {&#10;                            playerViewModel.setCurrentPlaylist(shuffled, 0)&#10;                        }&#10;                        t(&quot;assistant_shuffled&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;add_favorites&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        // Guardar en favoritos usando Spotify API&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { success, _ -&gt;&#10;                                    // No hacemos nada con el resultado aquí&#10;                                }&#10;                            }&#10;                            String.format(t(&quot;assistant_added_favorites&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;save_song&quot; -&gt; {&#10;                    val track = playerViewModel.currentTrack.value&#10;                    if (track != null) {&#10;                        val token = SpotifyTokenManager.getValidAccessToken(context)&#10;                        if (token != null &amp;&amp; track.spotifyTrackId.isNotBlank()) {&#10;                            withContext(Dispatchers.IO) {&#10;                                SpotifyRepository.saveTrack(token, track.spotifyTrackId) { _, _ -&gt; }&#10;                            }&#10;                            String.format(t(&quot;assistant_song_saved&quot;), track.name)&#10;                        } else t(&quot;assistant_cannot_save&quot;)&#10;                    } else t(&quot;assistant_nothing_playing&quot;)&#10;                }&#10;                &quot;create_playlist&quot; -&gt; {&#10;                    val name = result.entities[&quot;name&quot;]&#10;                    if (!name.isNullOrBlank()) {&#10;                        // TODO: Implementar creación de playlist&#10;                        String.format(t(&quot;assistant_playlist_created&quot;), name)&#10;                    } else t(&quot;assistant_what_playlist_name&quot;)&#10;                }&#10;&#10;                // Comandos compuestos&#10;                &quot;compound&quot; -&gt; {&#10;                    val actions = result.entities[&quot;actions&quot;]?.split(&quot;,&quot;) ?: emptyList()&#10;                    val results = mutableListOf&lt;String&gt;()&#10;                    for (action in actions) {&#10;                        when (action.trim()) {&#10;                            &quot;next&quot; -&gt; {&#10;                                withContext(Dispatchers.Main) { playerViewModel.navigateToNext() }&#10;                                results.add(t(&quot;assistant_next&quot;))&#10;                            }&#10;                            &quot;volume_up&quot; -&gt; {&#10;                                adjustVolume(10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                            &quot;volume_down&quot; -&gt; {&#10;                                adjustVolume(-10)&#10;                                results.add(String.format(t(&quot;assistant_volume_set_to&quot;), getCurrentVolumePercent()))&#10;                            }&#10;                        }&#10;                    }&#10;                    results.joinToString(&quot;. &quot;)&#10;                }&#10;&#10;                &quot;settings&quot; -&gt; t(&quot;assistant_open_settings&quot;)&#10;                &quot;play_search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    Log.d(&quot;AssistantManager&quot;, &quot;play_search query: \&quot;$q\&quot;&quot;)&#10;                    if (q.isBlank()) return t(&quot;assistant_what_play&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_${System.currentTimeMillis()}&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val ok = withContext(Dispatchers.Main) {&#10;                        playerViewModel.initializePlayer()&#10;                        playerViewModel.setCurrentPlaylist(listOf(track), 0)&#10;                        try { playerViewModel.loadAudioFromTrack(track) } catch (_: Exception) { false }&#10;                    }&#10;                    if (ok) {&#10;                        val artists = track.artists.ifBlank { &quot;&quot; }&#10;                        if (artists.isNotBlank()) String.format(t(&quot;assistant_playing_song&quot;), track.name, artists)&#10;                        else String.format(t(&quot;assistant_playing_song_no_artist&quot;), track.name)&#10;                    } else String.format(t(&quot;assistant_error_play&quot;), q)&#10;                }&#10;                &quot;search&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_search&quot;)&#10;                    val spotifyTrack = searchSpotifyTrack(q)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    val artists = spotifyTrack.artists.joinToString(&quot;, &quot;) { it.name }&#10;                    String.format(t(&quot;assistant_found&quot;), spotifyTrack.name, artists)&#10;                }&#10;                &quot;add_queue&quot; -&gt; {&#10;                    val q = result.entities[&quot;query&quot;] ?: &quot;&quot;&#10;                    if (q.isBlank()) return t(&quot;assistant_what_add&quot;)&#10;                    val track = createTrackFromSpotify(q, &quot;assistant_queue&quot;)&#10;                        ?: return String.format(t(&quot;assistant_no_results&quot;), q)&#10;                    withContext(Dispatchers.Main) { playerViewModel.addToQueue(track) }&#10;                    val artists = track.artists.ifBlank { &quot;&quot; }&#10;                    if (artists.isNotBlank()) String.format(t(&quot;assistant_added_queue&quot;), track.name, artists)&#10;                    else String.format(t(&quot;assistant_added_queue_no_artist&quot;), track.name)&#10;                }&#10;                else -&gt; t(&quot;assistant_not_understand&quot;)&#10;            }&#10;        } catch (e: Exception) {&#10;            Log.e(&quot;AssistantManager&quot;, &quot;perform action error&quot;, e)&#10;            t(&quot;assistant_error&quot;)&#10;        }&#10;    }&#10;&#10;    fun close() {&#10;        cancelSleepTimer()&#10;        try { sessionIntent?.close() } catch (_: Exception) {}&#10;        try { sessionNer?.close() } catch (_: Exception) {}&#10;        sessionIntent = null&#10;        sessionNer = null&#10;        try { ortEnv = null } catch (_: Exception) {}&#10;        onnxAvailable = false&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/HomeScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.material3.CircularProgressIndicator&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import com.plyr.assistant.AssistantTTSHelper&#10;import kotlinx.coroutines.withContext&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;    var recognizedCommand by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    val pullProgress = (pullOffset / maxPullPx).coerceIn(0f, 1f)&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    val assistantTTS = remember { AssistantTTSHelper(context) }&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            val responseToType = assistantResponse // Store local copy&#10;            for (i in responseToType.indices) {&#10;                // Check if response was cleared during typing&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20) // velocidad de escritura&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        assistantTTS.stop()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                // analyze + perform and show response&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;&#10;                    // Mostrar comando entendido&#10;                    recognizedCommand = when(result.intent) {&#10;                        &quot;play&quot; -&gt; Translations.get(context, &quot;assistant_cmd_play&quot;)&#10;                        &quot;pause&quot; -&gt; Translations.get(context, &quot;assistant_cmd_pause&quot;)&#10;                        &quot;next&quot; -&gt; Translations.get(context, &quot;assistant_cmd_next&quot;)&#10;                        &quot;previous&quot; -&gt; Translations.get(context, &quot;assistant_cmd_previous&quot;)&#10;                        &quot;play_search&quot; -&gt; &quot;${Translations.get(context, &quot;assistant_cmd_play_song&quot;)}: ${result.entities[&quot;query&quot;] ?: &quot;&quot;}&quot;&#10;                        &quot;volume_up&quot; -&gt; Translations.get(context, &quot;assistant_cmd_volume&quot;) + &quot; ↑&quot;&#10;                        &quot;volume_down&quot; -&gt; Translations.get(context, &quot;assistant_cmd_volume&quot;) + &quot; ↓&quot;&#10;                        &quot;shuffle&quot; -&gt; Translations.get(context, &quot;assistant_cmd_shuffle&quot;)&#10;                        &quot;sleep_timer&quot; -&gt; Translations.get(context, &quot;assistant_cmd_sleep_timer&quot;)&#10;                        &quot;who_sings&quot; -&gt; Translations.get(context, &quot;assistant_cmd_who_sings&quot;)&#10;                        else -&gt; result.intent&#10;                    }&#10;&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    recognizedCommand = &quot;&quot;&#10;&#10;                    // Show response with typewriter effect&#10;                    assistantResponse = reply&#10;&#10;                    // Speak the response&#10;                    assistantTTS.speak(reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;                recognizedCommand = &quot;&quot;&#10;            }&#10;            override fun onReady() {}&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            assistantTTS.destroy()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { change, dragAmount -&gt;&#10;                            // If response is visible and user scrolls up, dismiss it&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                assistantTTS.stop()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_&quot; + i&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = null,&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = mutableListOf(&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.SEARCH)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.PLAYLISTS)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.QUEUE)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.LOCAL)&#10;                         }&#10;                     )&#10;                 )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay (positioned at bottom, doesn't affect button layout)&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 50.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                ) {&#10;                    if (isProcessing) {&#10;                        Row(&#10;                            horizontalArrangement = Arrangement.Center,&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            CircularProgressIndicator(&#10;                                modifier = Modifier.size(16.dp),&#10;                                color = MaterialTheme.colorScheme.primary,&#10;                                strokeWidth = 2.dp&#10;                            )&#10;                            Spacer(modifier = Modifier.width(8.dp))&#10;                            Text(&#10;                                text = Translations.get(context, &quot;assistant_processing&quot;),&#10;                                style = MaterialTheme.typography.bodySmall,&#10;                                color = MaterialTheme.colorScheme.primary&#10;                            )&#10;                            if (recognizedCommand.isNotBlank()) {&#10;                                Text(&#10;                                    text = &quot; → $recognizedCommand&quot;,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    color = MaterialTheme.colorScheme.primary&#10;                                )&#10;                            }&#10;                        }&#10;                    } else {&#10;                        Text(&#10;                            text = displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                Box(modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp),&#10;                    contentAlignment = Alignment.TopCenter&#10;                ) {&#10;                    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                        if (isListening) {&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = &quot;Cancel&quot;,&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(24.dp)&#10;                                )&#10;                            }&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            } else {&#10;                                Text(&#10;                                    text = Translations.get(context, &quot;assistant_listening&quot;),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = &quot;Mic&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.Manifest&#10;import androidx.activity.compose.rememberLauncherForActivityResult&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.compose.animation.core.animateFloatAsState&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.background&#10;import androidx.compose.foundation.gestures.detectVerticalDragGestures&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.Text&#10;import androidx.compose.material3.MaterialTheme&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.ColorFilter&#10;import androidx.compose.ui.platform.LocalDensity&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.core.content.ContextCompat&#10;import androidx.compose.ui.res.painterResource&#10;import androidx.compose.foundation.Image&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.ui.layout.ContentScale&#10;import androidx.compose.ui.geometry.Size&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;import com.plyr.ui.components.*&#10;import com.plyr.utils.Translations&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.geometry.Offset&#10;import androidx.compose.material3.Icon&#10;import androidx.compose.material3.IconButton&#10;import androidx.compose.material.icons.Icons&#10;import androidx.compose.material.icons.filled.Settings&#10;import androidx.compose.material.icons.filled.Mic&#10;import androidx.compose.material.icons.filled.Close&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.assistant.AssistantVoiceHelper&#10;import com.plyr.assistant.AssistantManager&#10;import com.plyr.assistant.AssistantTTSHelper&#10;import kotlinx.coroutines.withContext&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    playerViewModel: PlayerViewModel? = null,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // pull-down related states&#10;    val density = LocalDensity.current&#10;    val bottomExclusionPx = with(density) { 120.dp.toPx() }&#10;    val maxPullPx = with(density) { 200.dp.toPx() }&#10;    val activationPx = with(density) { 60.dp.toPx() }&#10;&#10;    var pullOffset by remember { mutableStateOf(0f) }&#10;    var overlayVisible by remember { mutableStateOf(false) }&#10;    var isListening by remember { mutableStateOf(false) }&#10;    var isProcessing by remember { mutableStateOf(false) }&#10;    var interimText by remember { mutableStateOf(&quot;&quot;) }&#10;    var recognizedCommand by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Assistant response with typewriter effect&#10;    var assistantResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var displayedResponse by remember { mutableStateOf(&quot;&quot;) }&#10;    var isTyping by remember { mutableStateOf(false) }&#10;&#10;    // Animación CAVA para procesamiento&#10;    val processingFrames = listOf(&#10;        &quot;▃▇▁▆▂█▄&quot;,&#10;        &quot;▆▂▅▁▇▃█&quot;,&#10;        &quot;▁▄█▃▆▅▂&quot;,&#10;        &quot;▇▅▂▄▁█▃&quot;,&#10;        &quot;▂█▆▇▄▁▅&quot;,&#10;        &quot;▅▁▃▂▇▄▆&quot;,&#10;        &quot;█▃▄▅▂▆▁&quot;,&#10;        &quot;▄▆▇▁▅▂█&quot;,&#10;        &quot;▃▂▆▄█▇▁&quot;,&#10;        &quot;▆▄▁▇▃▅█&quot;,&#10;        &quot;▁▇▅█▂▃▄&quot;,&#10;        &quot;▇▃█▂▆▁▅&quot;&#10;    )&#10;    var processingFrame by remember { mutableStateOf(0) }&#10;&#10;    // Animar el frame de procesamiento&#10;    LaunchedEffect(isProcessing) {&#10;        if (isProcessing) {&#10;            while (isProcessing) {&#10;                delay(100)&#10;                processingFrame = (processingFrame + 1) % processingFrames.size&#10;            }&#10;        }&#10;    }&#10;&#10;    val pullProgress = (pullOffset / maxPullPx).coerceIn(0f, 1f)&#10;    val scope = rememberCoroutineScope()&#10;    val assistantVoiceHelper = remember { AssistantVoiceHelper(context) }&#10;    val assistantManager = remember { AssistantManager(context) }&#10;    val assistantTTS = remember { AssistantTTSHelper(context) }&#10;&#10;    // Typewriter effect&#10;    LaunchedEffect(assistantResponse) {&#10;        if (assistantResponse.isNotEmpty()) {&#10;            isTyping = true&#10;            displayedResponse = &quot;&quot;&#10;            val responseToType = assistantResponse // Store local copy&#10;            for (i in responseToType.indices) {&#10;                // Check if response was cleared during typing&#10;                if (assistantResponse.isEmpty()) {&#10;                    displayedResponse = &quot;&quot;&#10;                    break&#10;                }&#10;                displayedResponse = responseToType.substring(0, i + 1)&#10;                delay(20) // velocidad de escritura&#10;            }&#10;            isTyping = false&#10;        }&#10;    }&#10;&#10;    // Permission launcher&#10;    val permissionLauncher = rememberLauncherForActivityResult(ActivityResultContracts.RequestPermission()) { granted -&gt;&#10;        if (granted) {&#10;            isListening = true&#10;            assistantVoiceHelper.startListening()&#10;        }&#10;    }&#10;&#10;    // Function to dismiss response&#10;    fun dismissResponse() {&#10;        assistantResponse = &quot;&quot;&#10;        displayedResponse = &quot;&quot;&#10;        assistantTTS.stop()&#10;    }&#10;&#10;    // Voice listener setup&#10;    DisposableEffect(Unit) {&#10;        val listener = object : AssistantVoiceHelper.VoiceListener {&#10;            override fun onPartial(text: String) {&#10;                interimText = text&#10;            }&#10;            override fun onResult(text: String) {&#10;                isListening = false&#10;                isProcessing = true&#10;                interimText = &quot;&quot;&#10;&#10;                // analyze + perform and show response&#10;                scope.launch {&#10;                    val result = withContext(Dispatchers.Default) { assistantManager.analyze(text) }&#10;&#10;                    // Mostrar comando entendido&#10;                    recognizedCommand = when(result.intent) {&#10;                        &quot;play&quot; -&gt; Translations.get(context, &quot;assistant_cmd_play&quot;)&#10;                        &quot;pause&quot; -&gt; Translations.get(context, &quot;assistant_cmd_pause&quot;)&#10;                        &quot;next&quot; -&gt; Translations.get(context, &quot;assistant_cmd_next&quot;)&#10;                        &quot;previous&quot; -&gt; Translations.get(context, &quot;assistant_cmd_previous&quot;)&#10;                        &quot;play_search&quot; -&gt; &quot;${Translations.get(context, &quot;assistant_cmd_play_song&quot;)}: ${result.entities[&quot;query&quot;] ?: &quot;&quot;}&quot;&#10;                        &quot;volume_up&quot; -&gt; Translations.get(context, &quot;assistant_cmd_volume&quot;) + &quot; ↑&quot;&#10;                        &quot;volume_down&quot; -&gt; Translations.get(context, &quot;assistant_cmd_volume&quot;) + &quot; ↓&quot;&#10;                        &quot;shuffle&quot; -&gt; Translations.get(context, &quot;assistant_cmd_shuffle&quot;)&#10;                        &quot;sleep_timer&quot; -&gt; Translations.get(context, &quot;assistant_cmd_sleep_timer&quot;)&#10;                        &quot;who_sings&quot; -&gt; Translations.get(context, &quot;assistant_cmd_who_sings&quot;)&#10;                        else -&gt; result.intent&#10;                    }&#10;&#10;                    val vm = playerViewModel ?: return@launch&#10;                    val reply = withContext(Dispatchers.Default) { assistantManager.perform(result, vm) }&#10;&#10;                    isProcessing = false&#10;                    recognizedCommand = &quot;&quot;&#10;&#10;                    // Show response with typewriter effect&#10;                    assistantResponse = reply&#10;&#10;                    // Speak the response&#10;                    assistantTTS.speak(reply)&#10;                }&#10;            }&#10;            override fun onError(errorCode: Int) {&#10;                isListening = false&#10;                isProcessing = false&#10;                interimText = &quot;&quot;&#10;                recognizedCommand = &quot;&quot;&#10;            }&#10;            override fun onReady() {}&#10;        }&#10;        assistantVoiceHelper.setListener(listener)&#10;        onDispose {&#10;            assistantVoiceHelper.cancel()&#10;            assistantVoiceHelper.destroy()&#10;            assistantTTS.destroy()&#10;            assistantManager.close()&#10;        }&#10;    }&#10;&#10;    PlyrScreenContainer {&#10;        Box(&#10;            modifier = Modifier&#10;                .fillMaxSize()&#10;                .pointerInput(Unit) {&#10;                    detectVerticalDragGestures(&#10;                        onDragStart = { offset: Offset -&gt;&#10;                            pullOffset = 0f&#10;                            val screenHeight = size.height.toFloat()&#10;                            if (offset.y &gt; (screenHeight - bottomExclusionPx)) {&#10;                                // ignore - in bottom exclusion zone&#10;                            } else {&#10;                                overlayVisible = true&#10;                            }&#10;                        },&#10;                        onVerticalDrag = { change, dragAmount -&gt;&#10;                            // If response is visible and user scrolls up, dismiss it&#10;                            if (assistantResponse.isNotEmpty() &amp;&amp; dragAmount &lt; 0) {&#10;                                dismissResponse()&#10;                                return@detectVerticalDragGestures&#10;                            }&#10;&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val resistance = 0.3f - (pullOffset / maxPullPx) * 0.2f&#10;                            val dampedDrag = dragAmount * resistance&#10;                            pullOffset = (pullOffset + dampedDrag).coerceIn(0f, maxPullPx * 0.5f)&#10;                        },&#10;                        onDragEnd = {&#10;                            if (!overlayVisible) return@detectVerticalDragGestures&#10;                            val pulledEnough = pullOffset &gt;= activationPx&#10;                            if (pulledEnough) {&#10;                                assistantTTS.stop()&#10;                                dismissResponse()&#10;                                if (ContextCompat.checkSelfPermission(context, Manifest.permission.RECORD_AUDIO) != android.content.pm.PackageManager.PERMISSION_GRANTED) {&#10;                                    permissionLauncher.launch(Manifest.permission.RECORD_AUDIO)&#10;                                } else {&#10;                                    isListening = true&#10;                                    assistantVoiceHelper.startListening()&#10;                                }&#10;                            }&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        },&#10;                        onDragCancel = {&#10;                            pullOffset = 0f&#10;                            overlayVisible = false&#10;                        }&#10;                    )&#10;                }&#10;        ) {&#10;            // Top-right settings icon&#10;            IconButton(&#10;                onClick = {&#10;                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                    onNavigateToScreen(Screen.CONFIG)&#10;                },&#10;                modifier = Modifier&#10;                    .align(Alignment.TopEnd)&#10;                    .padding(12.dp)&#10;            ) {&#10;                Icon(&#10;                    imageVector = Icons.Filled.Settings,&#10;                    contentDescription = Translations.get(context, &quot;settings&quot;),&#10;                    tint = MaterialTheme.colorScheme.primary&#10;                )&#10;            }&#10;&#10;            // ASCII arts list&#10;            val asciiResIds = remember {&#10;                val ids = mutableListOf&lt;Int&gt;()&#10;                for (i in 1..50) {&#10;                    val name = &quot;ascii_&quot; + i&#10;                    val resId = context.resources.getIdentifier(name, &quot;drawable&quot;, context.packageName)&#10;                    if (resId != 0) ids.add(resId)&#10;                }&#10;                ids&#10;            }&#10;            val selectedRes = remember(asciiResIds) {&#10;                if (asciiResIds.isNotEmpty()) asciiResIds.random() else 0&#10;            }&#10;&#10;            // Main content column centered in the screen&#10;            Column(&#10;                modifier = Modifier&#10;                    .fillMaxSize()&#10;                    .padding(horizontal = 16.dp),&#10;                verticalArrangement = Arrangement.Center,&#10;                horizontalAlignment = Alignment.CenterHorizontally&#10;            ) {&#10;                // ASCII image&#10;                if (selectedRes != 0) {&#10;                    val painter = painterResource(id = selectedRes)&#10;                    val intrinsic = painter.intrinsicSize&#10;                    var imgModifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(horizontal = 16.dp)&#10;                    if (intrinsic != Size.Unspecified &amp;&amp; intrinsic.width &gt; 0f &amp;&amp; intrinsic.height &gt; 0f) {&#10;                        imgModifier = imgModifier.aspectRatio(intrinsic.width / intrinsic.height)&#10;                    }&#10;                    Image(&#10;                        painter = painter,&#10;                        contentDescription = null,&#10;                        contentScale = ContentScale.Fit,&#10;                        colorFilter = ColorFilter.tint(MaterialTheme.colorScheme.primary),&#10;                        modifier = imgModifier&#10;                    )&#10;                    Spacer(modifier = Modifier.height(32.dp))&#10;                }&#10;&#10;                // ActionButtonsGroup&#10;                val buttons = mutableListOf(&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_search&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.SEARCH)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_playlists&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.PLAYLISTS)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_queue&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.QUEUE)&#10;                         }&#10;                     ),&#10;                     ActionButtonData(&#10;                         text = &quot;&lt; ${Translations.get(context, &quot;home_local&quot;)} &gt;&quot;,&#10;                         color = MaterialTheme.colorScheme.primary,&#10;                         onClick = {&#10;                             haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                             onNavigateToScreen(Screen.LOCAL)&#10;                         }&#10;                     )&#10;                 )&#10;&#10;                ActionButtonsGroup(&#10;                    buttons = buttons,&#10;                    isHorizontal = false,&#10;                    spacing = 12.dp,&#10;                    modifier = Modifier.wrapContentWidth()&#10;                )&#10;&#10;                if (showExitMessage) {&#10;                    Spacer(modifier = Modifier.height(24.dp))&#10;                    PlyrErrorText(&#10;                        text = Translations.get(context, &quot;exit_message&quot;),&#10;                        modifier = Modifier.align(Alignment.CenterHorizontally)&#10;                    )&#10;                }&#10;            }&#10;&#10;            // Assistant response overlay (positioned at bottom, doesn't affect button layout)&#10;            if (displayedResponse.isNotEmpty() || isProcessing) {&#10;                Box(&#10;                    modifier = Modifier&#10;                        .align(Alignment.BottomCenter)&#10;                        .padding(bottom = 100.dp)&#10;                        .padding(horizontal = 24.dp)&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            dismissResponse()&#10;                        }&#10;                ) {&#10;                    if (isProcessing) {&#10;                        Text(&#10;                            text = processingFrames[processingFrame],&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    } else {&#10;                        Text(&#10;                            text = displayedResponse + if (isTyping) &quot;▌&quot; else &quot;&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium,&#10;                            color = MaterialTheme.colorScheme.primary&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            // Overlay mic animation coming from top&#10;            if (overlayVisible || isListening) {&#10;                Box(modifier = Modifier&#10;                    .fillMaxWidth()&#10;                    .offset(y = if (isListening) 12.dp else (-24).dp + (pullOffset / density.density).dp),&#10;                    contentAlignment = Alignment.TopCenter&#10;                ) {&#10;                    Column(horizontalAlignment = Alignment.CenterHorizontally) {&#10;                        if (isListening) {&#10;                            IconButton(&#10;                                onClick = {&#10;                                    haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    assistantVoiceHelper.cancel()&#10;                                    isListening = false&#10;                                    interimText = &quot;&quot;&#10;                                }&#10;                            ) {&#10;                                Icon(&#10;                                    Icons.Filled.Close,&#10;                                    contentDescription = &quot;Cancel&quot;,&#10;                                    tint = MaterialTheme.colorScheme.primary,&#10;                                    modifier = Modifier.size(24.dp)&#10;                                )&#10;                            }&#10;&#10;                            if (interimText.isNotBlank()) {&#10;                                Text(&#10;                                    text = interimText,&#10;                                    style = MaterialTheme.typography.bodySmall,&#10;                                    modifier = Modifier.padding(horizontal = 16.dp)&#10;                                )&#10;                            } else {&#10;                                Text(&#10;                                    text = Translations.get(context, &quot;assistant_listening&quot;),&#10;                                    style = MaterialTheme.typography.bodySmall&#10;                                )&#10;                            }&#10;                        } else {&#10;                            Icon(&#10;                                Icons.Filled.Mic,&#10;                                contentDescription = &quot;Mic&quot;,&#10;                                tint = MaterialTheme.colorScheme.primary,&#10;                                modifier = Modifier.size(24.dp)&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>