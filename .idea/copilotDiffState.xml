<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/PlaylistScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/PlaylistScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.asFlow&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.*&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyArtistFull&#10;import com.plyr.utils.Config&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.GlobalScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.DelicateCoroutinesApi&#10;import com.plyr.utils.Translations&#10;import com.plyr.ui.components.*&#10;&#10;@OptIn(DelicateCoroutinesApi::class)&#10;@Composable&#10;fun PlaylistsScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Repositorio local y manager de búsqueda&#10;    val localRepository = remember { PlaylistLocalRepository(context) }&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Estado para las playlists y autenticación&#10;    val playlistsFromDB by localRepository.getAllPlaylistsLiveData().asFlow().collectAsStateWithLifecycle(initialValue = emptyList())&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var isSyncing by remember { mutableStateOf(false) }&#10;    var isEditing by remember { mutableStateOf(false) }&#10;&#10;    // Estado para Liked Songs - ahora desde DB&#10;    val likedSongsPlaylist by localRepository.getTracksByPlaylistLiveData(&quot;liked_songs&quot;)&#10;        .asFlow()&#10;        .collectAsStateWithLifecycle(initialValue = emptyList())&#10;    var likedSongsCount by remember { mutableStateOf(0) }&#10;&#10;    // Actualizar contador de Liked Songs&#10;    LaunchedEffect(likedSongsPlaylist) {&#10;        likedSongsCount = likedSongsPlaylist.size&#10;    }&#10;&#10;    // Estado para álbumes guardados&#10;    var savedAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingSavedAlbums by remember { mutableStateOf(false) }&#10;    var savedAlbumsCount by remember { mutableStateOf(0) }&#10;&#10;    // Estado para artistas seguidos&#10;    var followedArtists by remember { mutableStateOf&lt;List&lt;SpotifyArtistFull&gt;&gt;(emptyList()) }&#10;    var isLoadingFollowedArtists by remember { mutableStateOf(false) }&#10;    var followedArtistsCount by remember { mutableStateOf(0) }&#10;&#10;    // Estados para detectar cambios en modo edición (movidos aquí para ser accesibles globalmente)&#10;    var showExitEditDialog by remember { mutableStateOf(false) }&#10;    var hasUnsavedChanges by remember { mutableStateOf(false) }&#10;    var originalTitle by remember { mutableStateOf(&quot;&quot;) }&#10;    var originalDesc by remember { mutableStateOf(&quot;&quot;) }&#10;    var newTitle by remember { mutableStateOf(&quot;&quot;) }&#10;    var newDesc by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Convertir entidades a SpotifyPlaylist para compatibilidad con UI existente&#10;    // Filtrar liked_songs y álbumes para que no aparezcan duplicados (se muestran como items especiales)&#10;    val playlists = playlistsFromDB&#10;        .filter { it.spotifyId != &quot;liked_songs&quot; &amp;&amp; !it.spotifyId.startsWith(&quot;album_&quot;) }&#10;        .map { it.toSpotifyPlaylist() }&#10;&#10;    // Estado para mostrar tracks de una playlist&#10;    var selectedPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedPlaylistEntity by remember { mutableStateOf&lt;PlaylistEntity?&gt;(null) }&#10;    var playlistTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var showCreatePlaylistScreen by remember { mutableStateOf(false) }&#10;&#10;    // Estado para los álbumes del artista seleccionado&#10;    var selectedArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var artistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;    var isViewingAlbumFromArtist by remember { mutableStateOf(false) }&#10;&#10;    // Estado para manejar navegación pendiente cuando hay cambios sin guardar&#10;    var pendingPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;&#10;    // Tracks observados desde la base de datos&#10;    val tracksFromDB by if (selectedPlaylistEntity != null) {&#10;        localRepository.getTracksByPlaylistLiveData(selectedPlaylistEntity!!.spotifyId)&#10;            .asFlow()&#10;            .collectAsStateWithLifecycle(initialValue = emptyList())&#10;    } else {&#10;        remember { mutableStateOf(emptyList()) }&#10;    }&#10;&#10;    // Actualizar tracks cuando cambien en la DB&#10;    LaunchedEffect(tracksFromDB) {&#10;        if (selectedPlaylistEntity != null) {&#10;            playlistTracks = tracksFromDB.map { it.toSpotifyTrack() }&#10;        }&#10;    }&#10;&#10;    // Función para cargar playlists con sincronización automática&#10;    val loadPlaylists = {&#10;        if (isSpotifyConnected) {&#10;            isLoading = true&#10;            coroutineScope.launch {&#10;                localRepository.getPlaylistsWithAutoSync()&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Función para cargar tracks de una playlist&#10;    val loadPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedPlaylist = playlist&#10;        selectedPlaylistEntity = playlistsFromDB.find { it.spotifyId == playlist.id }&#10;        isLoadingTracks = true&#10;&#10;        if (selectedPlaylistEntity == null) {&#10;            isLoadingTracks = false&#10;        } else {&#10;            // Usar corrutina para operaciones asíncronas&#10;            coroutineScope.launch {&#10;                localRepository.getTracksWithAutoSync(playlist.id)&#10;                isLoadingTracks = false&#10;            }&#10;        }&#10;    }&#10;&#10;    //LIKED SONGS&#10;    // Función para cargar las Liked Songs del usuario - ahora sincroniza con la base de datos&#10;    val loadLikedSongs: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Sincronizar Liked Songs con la base de datos local&#10;                localRepository.getLikedSongsWithAutoSync()&#10;                Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Liked Songs sincronizadas desde DB&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception syncing liked songs: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //LIKED SONGS&#10;&#10;&#10;    //ALBUMS&#10;    // Función para cargar los álbumes guardados del usuario&#10;    val loadSavedAlbums: () -&gt; Unit = {&#10;        isLoadingSavedAlbums = true&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener los álbumes guardados usando la API de Spotify&#10;                    SpotifyRepository.getUserSavedAlbums(accessToken) { albums, errorMsg -&gt;&#10;                        isLoadingSavedAlbums = false&#10;                        if (albums != null) {&#10;                            savedAlbums = albums&#10;                            savedAlbumsCount = albums.size&#10;                            Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Saved Albums actualizados: ${albums.size} álbumes&quot;)&#10;                        } else {&#10;                            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading saved albums: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingSavedAlbums = false&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingSavedAlbums = false&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception loading saved albums: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //ALBUMS&#10;&#10;    //ARTISTS&#10;    // Función para cargar los artistas seguidos del usuario&#10;    val loadFollowedArtists: () -&gt; Unit = {&#10;        isLoadingFollowedArtists = true&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener los artistas seguidos usando la API de Spotify&#10;                    SpotifyRepository.getUserFollowedArtists(accessToken) { artists, errorMsg -&gt;&#10;                        isLoadingFollowedArtists = false&#10;                        if (artists != null) {&#10;                            followedArtists = artists&#10;                            followedArtistsCount = artists.size&#10;                            Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Followed Artists actualizados: ${artists.size} artistas&quot;)&#10;                        } else {&#10;                            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading followed artists: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingFollowedArtists = false&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingFollowedArtists = false&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception loading followed artists: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //ARTISTS&#10;&#10;    // Función para forzar sincronización completa&#10;    val forceSyncAll = {&#10;        if (!isSpotifyConnected) {&#10;        } else {&#10;            isSyncing = true&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    localRepository.forceSyncAll()&#10;                    loadLikedSongs()&#10;                    loadSavedAlbums()&#10;                    loadFollowedArtists()&#10;                    isSyncing = false&#10;                } catch (_: Exception) {&#10;                    isSyncing = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cargar si está conectado&#10;    LaunchedEffect(isSpotifyConnected) {&#10;        if (isSpotifyConnected) {&#10;            loadPlaylists()&#10;            loadLikedSongs()&#10;            loadSavedAlbums()&#10;            loadFollowedArtists()&#10;        }&#10;    }&#10;&#10;    // Cleanup del YouTubeSearchManager&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            youtubeSearchManager.cleanup()&#10;        }&#10;    }&#10;&#10;    // Manejar botón de retroceso del sistema&#10;    BackHandler {&#10;        if (selectedPlaylist != null) {&#10;            // Si estamos viendo un álbum que viene de un artista, volver al artista&#10;            if (isViewingAlbumFromArtist &amp;&amp; selectedArtist != null) {&#10;                // Volver a la vista del artista&#10;                isViewingAlbumFromArtist = false&#10;                isLoadingTracks = true&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Cargar top tracks del artista&#10;                    SpotifyRepository.getArtistTopTracks(accessToken, selectedArtist!!.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            // Restaurar la playlist temporal del artista&#10;                            selectedPlaylist = SpotifyPlaylist(&#10;                                id = selectedArtist!!.id,&#10;                                name = selectedArtist!!.name,&#10;                                description = &quot;Top tracks by ${selectedArtist!!.name}&quot;,&#10;                                tracks = com.plyr.network.SpotifyPlaylistTracks(null, tracks.size),&#10;                                images = selectedArtist!!.images&#10;                            )&#10;                            playlistTracks = tracks&#10;                            selectedPlaylistEntity = null&#10;                        } else {&#10;                            Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist tracks: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            } else if (isEditing &amp;&amp; hasUnsavedChanges) {&#10;                // Si estamos en modo edición con cambios sin guardar, mostrar diálogo&#10;                showExitEditDialog = true&#10;            } else {&#10;                // Salir de la playlist y resetear modo edición&#10;                isEditing = false&#10;                hasUnsavedChanges = false&#10;                selectedPlaylist = null&#10;                selectedPlaylistEntity = null&#10;                playlistTracks = emptyList()&#10;                // Limpiar artista y sus álbumes al salir completamente&#10;                selectedArtist = null&#10;                artistAlbums = emptyList()&#10;                isViewingAlbumFromArtist = false&#10;            }&#10;        } else {&#10;            onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        //si se pulsa boton de &lt;new&gt; mostrar CreatePlaylistScreen&#10;        if (showCreatePlaylistScreen) {&#10;            CreateSpotifyPlaylistScreen(&#10;                onBack = { showCreatePlaylistScreen = false },&#10;                onPlaylistCreated = { showCreatePlaylistScreen = false; loadPlaylists() },&#10;                playerViewModel = playerViewModel&#10;            )&#10;            return@Column&#10;        }&#10;        Titulo(if (selectedPlaylist == null) Translations.get(context, &quot;plyr_lists&quot;) else &quot;${selectedPlaylist!!.name}&quot;)&#10;&#10;        // Botón de sincronización manual (solo visible si está conectado y no es una playlist individual)&#10;        if (isSpotifyConnected &amp;&amp; selectedPlaylist == null) {&#10;            ActionButtonsGroup(listOf(&#10;&#9;&#9;    ActionButtonData(&#10;&#9;&#9;        text = Translations.get(context, if (isSyncing) &quot;&lt;syncing...&gt;&quot; else &quot;&lt;sync&gt;&quot;),&#10;&#9;&#9;&#9;&#9;color = if (isSyncing) Color(0xFFFFD93D) else Color(0xFF4ECDC4),&#10;&#9;&#9;        onClick = {&#10;&#9;&#9;            forceSyncAll()&#10;&#9;&#9;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;&#9;&#9;        },&#10;&#9;&#9;        enabled = !isSyncing&#10;&#9;&#9;    ),&#10;&#9;&#9;    ActionButtonData(&#10;&#9;&#9;        text = Translations.get(context, &quot;&lt;new&gt;&quot;),&#10;&#9;&#9;        color = Color(0xFF4ECDC4),&#10;&#9;&#9;        onClick = { showCreatePlaylistScreen = true },&#10;&#9;&#9;        enabled = !isSyncing&#10;&#9;&#9;&#9;&#9;    )&#10;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;    )&#10;        }&#10;&#9;&#9;&#9;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        when { // Estado no conectado&#10;            !isSpotifyConnected -&gt; {&#10;&#9;&#9;&#9;&#9;Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;&#9;&#9;&#9;&#9;    Text(&#10;                        text = Translations.get(context, &quot;Spotify not connected&quot;),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            selectedPlaylist != null -&gt; {&#10;                // Vista de tracks de playlist&#10;                if (isLoadingTracks) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;&#9;&#9;&#9;&#9;        Text(&#10;                            text = Translations.get(context, &quot;Loading tracks...&quot;),&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }   &#10;                } else {&#10;                    // Estados para los botones de control&#10;                    var isRandomizing by remember { mutableStateOf(false) }&#10;                    var isStarting by remember { mutableStateOf(false) }&#10;                    var randomJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;                    var startJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;                    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Función para parar todas las reproducciones&#10;                    fun stopAllPlayback() {&#10;                        isRandomizing = false&#10;                        isStarting = false&#10;                        randomJob?.cancel()&#10;                        startJob?.cancel()&#10;                        randomJob = null&#10;                        startJob = null&#10;                        // Cancelar espera de canción y pausar el reproductor&#10;                        //playerViewModel?.cancelWaitForSong()&#10;                        playerViewModel?.pausePlayer()&#10;                    }&#10;&#10;&#10;                    // Función para randomización simplificada - mezcla toda la playlist&#10;                    fun startRandomizing() {&#10;                        stopAllPlayback()&#10;                        isRandomizing = true&#10;&#10;                        if (playlistTracks.isNotEmpty() &amp;&amp; playerViewModel != null) {&#10;                            randomJob = coroutineScope.launch(kotlinx.coroutines.Dispatchers.Main) {&#10;                                // Mezclar toda la lista de tracks&#10;                                val shuffledTracks = tracksFromDB.shuffled()&#10;                                val firstTrack = shuffledTracks.first()&#10;&#10;                                println(&quot; RANDOM: ${firstTrack.name}&quot;)&#10;&#10;                                // Reproducir la canción usando PlayerViewModel&#10;                                playerViewModel.initializePlayer()&#10;&#10;                                // Establecer la playlist mezclada completa desde el inicio (índice 0)&#10;                                playerViewModel.setCurrentPlaylist(shuffledTracks, 0)&#10;&#10;                                // Cargar y reproducir - PlayerViewModel manejará la navegación automática&#10;                                playerViewModel.loadAudioFromTrack(firstTrack)&#10;&#10;                                isRandomizing = false&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Función para reproducción ordenada simplificada - replica exactamente el comportamiento de hacer clic en la primera canción&#10;                    fun startOrderedPlayback() {&#10;                        stopAllPlayback()&#10;                        isStarting = true&#10;&#10;                        if (playlistTracks.isNotEmpty() &amp;&amp; playerViewModel != null &amp;&amp; tracksFromDB.isNotEmpty()) {&#10;                            startJob = coroutineScope.launch(kotlinx.coroutines.Dispatchers.Main) {&#10;                                // Replicar exactamente la lógica de SongListItem cuando haces clic en una canción&#10;                                playerViewModel.setCurrentPlaylist(tracksFromDB, 0)&#10;                                val selectedTrackEntity = tracksFromDB[0]&#10;&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot; REPRODUCIR TRACK (START)&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;Track: ${selectedTrackEntity.name}&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;AudioUrl: ${selectedTrackEntity.audioUrl}&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;Es archivo local: ${selectedTrackEntity.audioUrl?.startsWith(&quot;/&quot;) == true}&quot;)&#10;&#10;                                try {&#10;                                    playerViewModel.loadAudioFromTrack(selectedTrackEntity)&#10;                                    Log.d(&quot;PlaylistScreen&quot;, &quot;✓ loadAudioFromTrack llamado exitosamente&quot;)&#10;                                } catch (e: Exception) {&#10;                                    Log.e(&quot;PlaylistScreen&quot;, &quot;✗ Error al reproducir track&quot;, e)&#10;                                }&#10;&#10;                                isStarting = false&#10;                            }&#10;                        } else {&#10;                            isStarting = false&#10;                        }&#10;                    }&#10;&#10;                    // Limpiar jobs al salir&#10;                    DisposableEffect(selectedPlaylist) {&#10;                        onDispose {&#10;                            randomJob?.cancel()&#10;                            startJob?.cancel()&#10;                        }&#10;                    }&#10;                    Column {&#10;                        // Botones de control&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(bottom = 16.dp),&#10;                            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                        ) {&#10;                            if (!isEditing) {&#10;                                // Botones visibles solo cuando NO está en modo edición&#10;&#10;                                // Botón &lt;start&gt;&#10;                                Text(&#10;                                    text = if (isStarting) &quot;&lt;stop&gt;&quot; else &quot;&lt;start&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = if (isStarting) Color(0xFFFF6B6B) else Color(0xFF4ECDC4)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            if (isStarting) {&#10;                                                stopAllPlayback()&#10;                                            } else {&#10;                                                startOrderedPlayback()&#10;                                            }&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Botón &lt;rand&gt;&#10;                                Text(&#10;                                    text = if (isRandomizing) &quot;&lt;stop&gt;&quot; else &quot;&lt;rand&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = if (isRandomizing) Color(0xFFFF6B6B) else Color(0xFFFFD93D)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            if (isRandomizing) {&#10;                                                stopAllPlayback()&#10;                                            } else {&#10;                                                startRandomizing()&#10;                                            }&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Botón &lt;share&gt;&#10;                                Text(&#10;                                    text = &quot;&lt;share&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = Color(0xFFFF6B9D)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            showShareDialog = true&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;                            }&#10;&#10;                            // Botón &lt;edit&gt; o &lt;save&gt;&#10;                            Text(&#10;                                text = if (isEditing) &quot;&lt;save&gt;&quot; else &quot;&lt;edit&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 16.sp,&#10;                                    color = if (isEditing) Color(0xFF7FB069) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier&#10;                                    .clickable {&#10;                                        if (isEditing) {&#10;                                            // Al hacer clic en save, verificar si hay cambios sin guardar&#10;                                            if (hasUnsavedChanges) {&#10;                                                // Guardar cambios en Spotify&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    // Mostrar indicador de carga&#10;                                                    isLoadingTracks = true&#10;&#10;                                                    SpotifyRepository.updatePlaylistDetails(&#10;                                                        accessToken = accessToken,&#10;                                                        playlistId = selectedPlaylist!!.id,&#10;                                                        name = if (newTitle != originalTitle) newTitle else null,&#10;                                                        description = if (newDesc != originalDesc) newDesc else null&#10;                                                    ) { success, errorMsg -&gt;&#10;                                                        if (success) {&#10;                                                            // Sincronizar playlists después de EDITAR&#10;                                                            coroutineScope.launch {&#10;                                                                localRepository.syncPlaylistsFromSpotify()&#10;                                                                // Esperar a que termine la sincronización&#10;                                                                kotlinx.coroutines.delay(500)&#10;                                                                isLoadingTracks = false&#10;                                                                // Salir del modo edición y volver al listado&#10;                                                                isEditing = false&#10;                                                                hasUnsavedChanges = false&#10;                                                                selectedPlaylist = null&#10;                                                                playlistTracks = emptyList()&#10;                                                            }&#10;                                                        } else {&#10;                                                            isLoadingTracks = false&#10;                                                            // Mostrar error&#10;                                                            Log.e(&quot;PlaylistScreen&quot;, &quot;Error actualizando playlist: $errorMsg&quot;)&#10;                                                        }&#10;                                                    }&#10;                                                } else {&#10;                                                    // Si no hay token, solo resetear el flag y salir&#10;                                                    hasUnsavedChanges = false&#10;                                                    isEditing = false&#10;                                                }&#10;                                            } else {&#10;                                                // Si no hay cambios, solo salir del modo edición&#10;                                                isEditing = false&#10;                                            }&#10;                                        } else {&#10;                                            // Al entrar al modo edición, guardar valores originales e inicializar campos&#10;                                            originalTitle = selectedPlaylist?.name ?: &quot;&quot;&#10;                                            originalDesc = selectedPlaylist?.description ?: &quot;&quot;&#10;                                            newTitle = originalTitle&#10;                                            newDesc = originalDesc&#10;                                            hasUnsavedChanges = false&#10;                                            isEditing = true&#10;                                        }&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    }&#10;                                    .padding(8.dp)&#10;                            )&#10;&#10;                            // Botón &lt;delete&gt; - solo visible en modo edición&#10;                            if (isEditing) {&#10;                                var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;                                Text(&#10;                                    text = &quot;&lt;delete&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = Color(0xFFFF6B6B)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            showDeleteDialog = true&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Diálogo de confirmación para eliminar playlist&#10;                                if (showDeleteDialog) {&#10;                                    AlertDialog(&#10;                                        onDismissRequest = { showDeleteDialog = false },&#10;                                        title = {&#10;                                            Text(&#10;                                                &quot;Delete playlist&quot;,&#10;                                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                                    fontFamily = FontFamily.Monospace,&#10;                                                    color = Color(0xFF4ECDC4)&#10;                                                )&#10;                                            )&#10;                                        },&#10;                                        text = {&#10;                                            Text(&#10;                                                &quot;Are you sure you want to delete '${selectedPlaylist?.name}'? This action cannot be undone.&quot;,&#10;                                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                    fontFamily = FontFamily.Monospace&#10;                                                )&#10;                                            )&#10;                                        },&#10;                                        confirmButton = {&#10;                                            TextButton(&#10;                                                onClick = {&#10;                                                    showDeleteDialog = false&#10;                                                    // Eliminar la playlist&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                        coroutineScope.launch {&#10;                                                            SpotifyRepository.unfollowPlaylist(&#10;                                                                accessToken,&#10;                                                                selectedPlaylist!!.id&#10;                                                            ) { success: Boolean, errorMsg: String? -&gt;&#10;                                                                if (success) {&#10;                                                                    // Sincronizar playlists después de eliminar&#10;                                                                    coroutineScope.launch {&#10;                                                                        localRepository.syncPlaylistsFromSpotify()&#10;                                                                    }&#10;                                                                    // Salir del modo edición y volver a la lista&#10;                                                                    isEditing = false&#10;                                                                    hasUnsavedChanges = false&#10;                                                                    selectedPlaylist = null&#10;                                                                    playlistTracks = emptyList()&#10;                                                                    // Recargar la lista de playlists&#10;                                                                    loadPlaylists()&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            ) {&#10;                                                Text(&#10;                                                    &quot;Delete&quot;,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        color = Color(0xFFFF6B6B)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        },&#10;                                        dismissButton = {&#10;                                            TextButton(&#10;                                                onClick = { showDeleteDialog = false }&#10;                                            ) {&#10;                                                Text(&#10;                                                    &quot;Cancel&quot;,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        color = Color(0xFF4ECDC4)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                        if (isEditing) {&#10;                            // Estados para el buscador de canciones en edición&#10;                            var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;                            var isSearching by remember { mutableStateOf(false) }&#10;                            var searchResults by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;                            var editError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                            // Detectar cambios en los campos&#10;                            LaunchedEffect(newTitle, newDesc) {&#10;                                hasUnsavedChanges = (newTitle != originalTitle || newDesc != originalDesc)&#10;                            }&#10;&#10;                            // Usar LazyColumn para permitir scroll&#10;                            LazyColumn(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .weight(1f),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                // Título de la sección&#10;                                item {&#10;                                    Text(&#10;                                        text = &quot;&gt; edit_playlist&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 16.sp,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        ),&#10;                                        modifier = Modifier.padding(bottom = 8.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // Cambiar nombre&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = newTitle,&#10;                                        onValueChange = { newTitle = it },&#10;                                        label = { Text(Translations.get(context, &quot;playlist_name&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                    Spacer(Modifier.height(8.dp))&#10;                                }&#10;&#10;                                // Cambiar descripción&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = newDesc,&#10;                                        onValueChange = { newDesc = it },&#10;                                        label = { Text(Translations.get(context, &quot;description&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                    Spacer(Modifier.height(16.dp))&#10;                                }&#10;&#10;                                // Sección de buscador de canciones&#10;                                item {&#10;                                    Text(&#10;                                        text = &quot;&gt; add_tracks&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 16.sp,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        ),&#10;                                        modifier = Modifier.padding(bottom = 8.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // Campo de búsqueda&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = searchQuery,&#10;                                        onValueChange = { searchQuery = it },&#10;                                        label = { Text(Translations.get(context, &quot;search_tracks_label&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        trailingIcon = {&#10;                                            if (searchQuery.isNotEmpty()) {&#10;                                                IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                                                    Text(&#10;                                                        text = &quot;x&quot;,&#10;                                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                                            fontFamily = FontFamily.Monospace&#10;                                                        )&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;                                        keyboardActions = KeyboardActions(&#10;                                            onSearch = {&#10;                                                if (searchQuery.isNotBlank() &amp;&amp; !isSearching) {&#10;                                                    isSearching = true&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        coroutineScope.launch {&#10;                                                            SpotifyRepository.searchAll(accessToken, searchQuery) { results, errorMsg -&gt;&#10;                                                                isSearching = false&#10;                                                                if (results != null) {&#10;                                                                    searchResults = results.tracks.items&#10;                                                                } else {&#10;                                                                    editError = errorMsg&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        ),&#10;                                        enabled = !isSearching&#10;                                    )&#10;                                }&#10;&#10;                                // Mostrar indicador de búsqueda&#10;                                if (isSearching) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&#10;                                            text = &quot;$ searching...&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFFFD93D)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Resultados de búsqueda usando SongListItem&#10;                                if (searchResults.isNotEmpty()) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&#10;                                            text = &quot;results:&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFE0E0E0)&#10;                                            )&#10;                                        )&#10;                                    }&#10;&#10;                                    // Crear trackEntities para los resultados de búsqueda&#10;                                    val searchTrackEntities = searchResults.take(10).mapIndexed { trackIndex, track -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;edit_search_${track.id}_$trackIndex&quot;,&#10;                                            playlistId = &quot;edit_search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = track.id,&#10;                                            name = track.name,&#10;                                            artists = track.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    items(searchResults.take(10).size) { index -&gt;&#10;                                        val track = searchResults[index]&#10;                                        SongListItem(&#10;                                            song = Song(&#10;                                                number = index + 1,&#10;                                                title = track.name,&#10;                                                artist = track.getArtistNames(),&#10;                                                spotifyId = track.id,&#10;                                                spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                            ),&#10;                                            trackEntities = searchTrackEntities,&#10;                                            index = index,&#10;                                            playerViewModel = playerViewModel,&#10;                                            coroutineScope = coroutineScope,&#10;                                            customButtonIcon = &quot;+&quot;,&#10;                                            customButtonAction = {&#10;                                                // Añadir canción a la playlist&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    coroutineScope.launch {&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#10;                                                            accessToken,&#10;                                                            selectedPlaylist!!.id,&#10;                                                            track.id&#10;                                                        ) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                searchResults = emptyList()&#10;                                                                searchQuery = &quot;&quot;&#10;                                                                // Recargar tracks&#10;                                                                coroutineScope.launch {&#10;                                                                    localRepository.syncTracksFromSpotify(selectedPlaylist!!.id)&#10;                                                                }&#10;                                                            } else {&#10;                                                                editError = errorMsg&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                            modifier = Modifier.fillMaxWidth()&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Mostrar error si hay&#10;                                editError?.let {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&quot;${Translations.get(context, &quot;error_prefix&quot;)}$it&quot;, color = Color.Red, style = MaterialTheme.typography.bodySmall.copy(fontFamily = FontFamily.Monospace))&#10;                                    }&#10;                                }&#10;&#10;                                item {&#10;                                    Spacer(Modifier.height(16.dp))&#10;                                }&#10;&#10;                                // Lista de canciones actuales usando SongListItem&#10;                                if (playlistTracks.isNotEmpty()) {&#10;                                    item {&#10;                                        Text(&#10;                                            text = &quot;current tracks [${playlistTracks.size}]:&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFF4ECDC4)&#10;                                            )&#10;                                        )&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                    }&#10;&#10;                                    items(playlistTracks.size) { index -&gt;&#10;                                        val track = playlistTracks[index]&#10;                                        SongListItem(&#10;                                            song = Song(&#10;                                                number = index + 1,&#10;                                                title = track.name,&#10;                                                artist = track.getArtistNames(),&#10;                                                spotifyId = track.id,&#10;                                                spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                            ),&#10;                                            trackEntities = tracksFromDB,&#10;                                            index = index,&#10;                                            playerViewModel = playerViewModel,&#10;                                            coroutineScope = coroutineScope,&#10;                                            customButtonIcon = &quot;x&quot;,&#10;                                            customButtonAction = {&#10;                                                // Eliminar canción de la playlist&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    coroutineScope.launch {&#10;                                                        SpotifyRepository.removeTrackFromPlaylist(&#10;                                                            accessToken,&#10;                                                            selectedPlaylist!!.id,&#10;                                                            track.id&#10;                                                        ) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Recargar tracks&#10;                                                                coroutineScope.launch {&#10;                                                                    localRepository.syncTracksFromSpotify(selectedPlaylist!!.id)&#10;                                                                }&#10;                                                            } else {&#10;                                                                editError = errorMsg&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            onLikedStatusChanged = {&#10;                                                // Recargar las Liked Songs cuando se modifica el estado&#10;                                                loadLikedSongs()&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        // Lista de tracks (solo visible cuando NO está en modo edición)&#10;                        if (!isEditing) {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                contentPadding = PaddingValues(bottom = 16.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                // Prepara trackEntities - si no hay en DB, crear temporales&#10;                                val trackEntitiesList = if (tracksFromDB.isNotEmpty()) {&#10;                                    tracksFromDB&#10;                                } else {&#10;                                    // Crear TrackEntities temporales para álbumes u otras fuentes sin BD&#10;                                    playlistTracks.mapIndexed { trackIndex, track -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;temp_${selectedPlaylist?.id}_${track.id}&quot;,&#10;                                            playlistId = selectedPlaylist?.id ?: &quot;unknown&quot;,&#10;                                            spotifyTrackId = track.id,&#10;                                            name = track.name,&#10;                                            artists = track.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                items(playlistTracks.size) { index -&gt;&#10;                                    val track = playlistTracks[index]&#10;                                    val song = Song(&#10;                                        number = index + 1,&#10;                                        title = track.name,&#10;                                        artist = track.getArtistNames(),&#10;                                        spotifyId = track.id,&#10;                                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                    )&#10;                                    SongListItem(&#10;                                        song = song,&#10;                                        trackEntities = trackEntitiesList,&#10;                                        index = index,&#10;                                        playerViewModel = playerViewModel,&#10;                                        coroutineScope = coroutineScope,&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        onLikedStatusChanged = {&#10;                                            // Recargar las Liked Songs cuando se modifica el estado&#10;                                            loadLikedSongs()&#10;                                        }&#10;                                    )&#10;                                }&#10;&#10;                                // Sección de álbumes del artista (solo si hay un artista seleccionado)&#10;                                if (selectedArtist != null &amp;&amp; artistAlbums.isNotEmpty()) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(24.dp))&#10;                                        Text(&#10;                                            text = &quot;&gt; albums&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFF4ECDC4)&#10;                                            ),&#10;                                            modifier = Modifier.padding(bottom = 12.dp)&#10;                                        )&#10;&#10;                                        LazyRow(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                                            contentPadding = PaddingValues(horizontal = 8.dp)&#10;                                        ) {&#10;                                            items(artistAlbums.size) { index -&gt;&#10;                                                val album = artistAlbums[index]&#10;                                                Column(&#10;                                                    modifier = Modifier&#10;                                                        .width(120.dp)&#10;                                                        .clickable {&#10;                                                            // Cargar los tracks del álbum&#10;                                                            isViewingAlbumFromArtist = true&#10;                                                            isLoadingTracks = true&#10;                                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                            if (accessToken != null) {&#10;                                                                SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                                                                    isLoadingTracks = false&#10;                                                                    if (tracks != null) {&#10;                                                                        // Crear una playlist temporal para mostrar el álbum&#10;                                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                                            id = album.id,&#10;                                                                            name = album.name,&#10;                                                                            description = &quot;Album by ${album.getArtistNames()}&quot;,&#10;                                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, album.totaltracks ?: tracks.size),&#10;                                                                            images = album.images&#10;                                                                        )&#10;                                                                        playlistTracks = tracks&#10;                                                                        selectedPlaylistEntity = null&#10;                                                                        // NO limpiar artista ni álbumes aquí para poder volver&#10;                                                                    } else {&#10;                                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading album tracks: $errorMsg&quot;)&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        },&#10;                                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                                ) {&#10;                                                    AsyncImage(&#10;                                                        model = album.getImageUrl(),&#10;                                                        contentDescription = &quot;Album cover&quot;,&#10;                                                        modifier = Modifier&#10;                                                            .size(120.dp)&#10;                                                            .clip(RoundedCornerShape(8.dp))&#10;                                                    )&#10;&#10;                                                    Text(&#10;                                                        text = album.name,&#10;                                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                                            fontFamily = FontFamily.Monospace,&#10;                                                            color = Color(0xFFE0E0E0)&#10;                                                        ),&#10;                                                        modifier = Modifier.padding(top = 4.dp),&#10;                                                        maxLines = 2,&#10;                                                        overflow = TextOverflow.Ellipsis,&#10;                                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Diálogo de confirmación para salir sin guardar&#10;                    if (showExitEditDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showExitEditDialog = false&#10;                                pendingPlaylist = null&#10;                            },&#10;                            title = {&#10;                                Text(&#10;                                    &quot;Unsaved changes&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF4ECDC4)&#10;                                    )&#10;                                )&#10;                            },&#10;                            text = {&#10;                                Text(&#10;                                    &quot;You have unsaved changes. Are you sure you want to exit?&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace&#10;                                    )&#10;                                )&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(&#10;                                    onClick = {&#10;                                        showExitEditDialog = false&#10;                                        isEditing = false&#10;                                        hasUnsavedChanges = false&#10;&#10;                                        // Si hay una playlist pendiente, cargarla&#10;                                        if (pendingPlaylist != null) {&#10;                                            selectedPlaylist = pendingPlaylist&#10;                                            loadPlaylistTracks(pendingPlaylist!!)&#10;                                            pendingPlaylist = null&#10;                                        } else {&#10;                                            // Si no hay playlist pendiente, salir de la vista actual&#10;                                            selectedPlaylist = null&#10;                                            playlistTracks = emptyList()&#10;                                        }&#10;                                    }&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;Exit&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(&#10;                                    onClick = {&#10;                                        showExitEditDialog = false&#10;                                        pendingPlaylist = null&#10;                                    }&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;Cancel&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Diálogo de compartir - debe estar dentro del mismo scope que showShareDialog&#10;                    if (showShareDialog) {&#10;                        ShareDialog(&#10;                            item = ShareableItem(&#10;                                spotifyId = selectedPlaylist!!.id,&#10;                                spotifyUrl = &quot;https://open.spotify.com/playlist/${selectedPlaylist!!.id}&quot;,&#10;                                youtubeId = null,&#10;                                title = selectedPlaylist!!.name,&#10;                                artist = &quot;Playlist&quot;, //selectedPlaylist!!.owner?.display_name ?: &quot;Playlist&quot;,&#10;                                type = ShareType.PLAYLIST&#10;                            ),&#10;                            onDismiss = { showShareDialog = false }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                    // Estado cuando no está cargando ni sincronizando&#10;                    if (playlists.isEmpty() &amp;&amp; (!isLoading || !isSyncing)) {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No playlists found&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    } else {&#10;                        // Grilla de portadas de playlists&#10;                        LazyVerticalGrid(&#10;                            columns = GridCells.Adaptive(minSize = 150.dp),&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                        ) {&#10;                            // Primer item: Liked Songs&#10;                            if (likedSongsCount &gt; 0) {&#10;                                item {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Mostrar las Liked Songs como una playlist especial desde DB&#10;                                                selectedPlaylist = SpotifyPlaylist(&#10;                                                    id = &quot;liked_songs&quot;,&#10;                                                    name = &quot;Liked Songs&quot;,&#10;                                                    description = &quot;Your favorite tracks on Spotify&quot;,&#10;                                                    tracks = com.plyr.network.SpotifyPlaylistTracks(null, likedSongsCount),&#10;                                                    images = null&#10;                                                )&#10;                                                // Buscar la playlist entity de Liked Songs&#10;                                                selectedPlaylistEntity = playlistsFromDB.find { it.spotifyId == &quot;liked_songs&quot; }&#10;                                                isLoadingTracks = true&#10;&#10;                                                // Cargar tracks desde la base de datos&#10;                                                coroutineScope.launch {&#10;                                                    localRepository.getTracksWithAutoSync(&quot;liked_songs&quot;)&#10;                                                    isLoadingTracks = false&#10;                                                }&#10;                                            },&#10;                                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    ) {&#10;                                        // Icono de corazón para Liked Songs (en lugar de portada)&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(150.dp)&#10;                                                .clip(RoundedCornerShape(8.dp)),&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            // Fondo degradado&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .clip(RoundedCornerShape(8.dp)),&#10;                                                contentAlignment = Alignment.Center&#10;                                            ) {&#10;                                                androidx.compose.foundation.Canvas(&#10;                                                    modifier = Modifier.fillMaxSize()&#10;                                                ) {&#10;                                                    drawRect(&#10;                                                        brush = androidx.compose.ui.graphics.Brush.verticalGradient(&#10;                                                            colors = listOf(&#10;                                                                Color(0xFF4ECDC4),&#10;                                                                Color(0xFF7FB069)&#10;                                                            )&#10;                                                        )&#10;                                                    )&#10;                                                }&#10;                                                // Emoji de corazón&#10;                                                Text(&#10;                                                    text = &quot;♥&quot;,&#10;                                                    style = MaterialTheme.typography.displayLarge.copy(&#10;                                                        fontSize = 64.sp,&#10;                                                        color = Color.White&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;&#10;                                        // Nombre de la playlist&#10;                                        Text(&#10;                                            text = &quot;Liked Songs&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFE0E0E0)&#10;                                            ),&#10;                                            modifier = Modifier.padding(top = 8.dp),&#10;                                            maxLines = 2,&#10;                                            overflow = TextOverflow.Ellipsis,&#10;                                            textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Resto de las playlists&#10;                            items(playlists.size) { index -&gt;&#10;                                val playlist = playlists[index]&#10;                                val playlistEntity = playlistsFromDB.find { it.spotifyId == playlist.id }&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Verificar si hay cambios sin guardar antes de cambiar de playlist&#10;                                            if (isEditing &amp;&amp; hasUnsavedChanges) {&#10;                                                pendingPlaylist = playlist&#10;                                                showExitEditDialog = true&#10;                                            } else {&#10;                                                // Resetear modo edición al cambiar de playlist&#10;                                                isEditing = false&#10;                                                hasUnsavedChanges = false&#10;                                                selectedPlaylist = playlist&#10;                                                loadPlaylistTracks(playlist)&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada de la playlist&#10;                                    AsyncImage(&#10;                                        model = playlistEntity?.imageUrl,&#10;                                        contentDescription = &quot;Portada de ${playlist.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(8.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre de la playlist&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 2,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Álbumes guardados&#10;                            items(savedAlbums.size) { index -&gt;&#10;                                val albumEntity = savedAlbums[index]&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Cargar los tracks del álbum desde Spotify API&#10;                                            isLoadingTracks = true&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                SpotifyRepository.getAlbumTracks(accessToken, albumEntity.id) { tracks, errorMsg -&gt;&#10;                                                    isLoadingTracks = false&#10;                                                    if (tracks != null) {&#10;                                                        // Crear una playlist temporal para mostrar el álbum&#10;                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                            id = albumEntity.id,&#10;                                                            name = albumEntity.name,&#10;                                                            description = &quot;Album by ${albumEntity.getArtistNames()}&quot;,&#10;                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, albumEntity.totaltracks ?: tracks.size),&#10;                                                            images = albumEntity.images&#10;                                                        )&#10;                                                        playlistTracks = tracks&#10;                                                        selectedPlaylistEntity = null&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading album tracks: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                isLoadingTracks = false&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada del álbum&#10;                                    AsyncImage(&#10;                                        model = albumEntity.getImageUrl(),&#10;                                        contentDescription = &quot;Portada de ${albumEntity.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(8.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre del álbum&#10;                                    Text(&#10;                                        text = albumEntity.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;&#10;                                    // Artista del álbum&#10;                                    Text(&#10;                                        text = albumEntity.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 2.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Artistas seguidos&#10;                            items(followedArtists.size) { index -&gt;&#10;                                val artist = followedArtists[index]&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Cargar los tracks y álbumes del artista&#10;                                            isLoadingTracks = true&#10;                                            isLoadingArtistAlbums = true&#10;                                            selectedArtist = artist&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                // Cargar top tracks&#10;                                                SpotifyRepository.getArtistTopTracks(accessToken, artist.id) { tracks, errorMsg -&gt;&#10;                                                    isLoadingTracks = false&#10;                                                    if (tracks != null) {&#10;                                                        // Crear una playlist temporal para mostrar los tracks del artista&#10;                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                            id = artist.id,&#10;                                                            name = artist.name,&#10;                                                            description = &quot;Top tracks by ${artist.name}&quot;,&#10;                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, tracks.size),&#10;                                                            images = artist.images&#10;                                                        )&#10;                                                        playlistTracks = tracks&#10;                                                        selectedPlaylistEntity = null&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist tracks: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Cargar álbumes del artista&#10;                                                SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                                                    isLoadingArtistAlbums = false&#10;                                                    if (albums != null) {&#10;                                                        artistAlbums = albums&#10;                                                        Log.d(&quot;PlaylistScreen&quot;, &quot;Loaded ${albums.size} albums for ${artist.name}&quot;)&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist albums: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada del artista (usar imagen del artista)&#10;                                    AsyncImage(&#10;                                        model = artist.getImageUrl(),&#10;                                        contentDescription = &quot;Artista ${artist.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(75.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre del artista&#10;                                    Text(&#10;                                        text = artist.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CreateSpotifyPlaylistScreen(&#10;    onBack: () -&gt; Unit,&#10;    onPlaylistCreated: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var playlistName by remember { mutableStateOf(&quot;&quot;) }&#10;    var playlistDesc by remember { mutableStateOf(&quot;&quot;) }&#10;    var isPublic by remember { mutableStateOf(true) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para el buscador de canciones&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var isSearching by remember { mutableStateOf(false) }&#10;    var searchResults by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val localRepository = remember { PlaylistLocalRepository(context) }&#10;&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        Titulo(Translations.get(context, &quot;create_playlist&quot;))&#10;        Spacer(Modifier.height(16.dp))&#10;        OutlinedTextField(&#10;            value = playlistName,&#10;            onValueChange = { playlistName = it },&#10;            label = { Text(Translations.get(context, &quot;playlist_name&quot;)) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(Modifier.height(8.dp))&#10;        OutlinedTextField(&#10;            value = playlistDesc,&#10;            onValueChange = { playlistDesc = it },&#10;            label = { Text(Translations.get(context, &quot;description_optional&quot;)) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(Modifier.height(8.dp))&#10;        BinaryToggle(&#10;            option1 = &quot;public&quot;,&#10;            option2 = &quot;private&quot;,&#10;            initialValue = isPublic,&#10;            onChange = { isPublic = it }&#10;        )&#10;        // Campo de búsqueda&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = { searchQuery = it },&#10;            label = { Text(Translations.get(context, &quot;search_tracks_label&quot;)) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                if (searchQuery.isNotEmpty()) {&#10;                    IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                        Text(&#10;                            text = &quot;x&quot;,&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isSearching) {&#10;                        isSearching = true&#10;                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                        if (accessToken != null) {&#10;                            coroutineScope.launch {&#10;                                SpotifyRepository.searchAll(accessToken, searchQuery) { results, errorMsg -&gt;&#10;                                    isSearching = false&#10;                                    if (results != null) {&#10;                                        searchResults = results.tracks.items&#10;                                    } else {&#10;                                        error = errorMsg&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isSearching&#10;        )&#10;&#10;        // Mostrar indicador de búsqueda&#10;        if (isSearching) {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;$ searching...&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFFFD93D)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Resultados de búsqueda&#10;        if (searchResults.isNotEmpty()) {&#10;            val trackEntities = searchResults.take(10).mapIndexed { trackIndex, track -&gt;&#10;                TrackEntity(&#10;                    id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                    playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                    spotifyTrackId = track.id,&#10;                    name = track.name,&#10;                    artists = track.getArtistNames(),&#10;                    youtubeVideoId = null,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;&#10;            searchResults.take(10).forEachIndexed { index, track -&gt;&#10;                SongListItem(&#10;                    song = Song(&#10;                        number = index + 1,&#10;                        title = track.name,&#10;                        artist = track.getArtistNames(),&#10;                        youtubeId = track.id,&#10;                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                    ),&#10;                    trackEntities = trackEntities,&#10;                    index = index,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    isSelected = selectedTracks.contains(track),&#10;                    customButtonIcon = &quot;+&quot;,&#10;                    customButtonAction = {&#10;                        if (!selectedTracks.contains(track)) {&#10;                            selectedTracks = selectedTracks + track&#10;                            searchResults = emptyList()&#10;                            searchQuery = &quot;&quot;&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Lista de canciones seleccionadas&#10;        if (selectedTracks.isNotEmpty()) {&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;selected [${selectedTracks.size}]:&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                )&#10;            )&#10;            val tracksEntities = selectedTracks.mapIndexed { trackIndex, track -&gt;&#10;                TrackEntity(&#10;                    id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                    playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                    spotifyTrackId = track.id,&#10;                    name = track.name,&#10;                    artists = track.getArtistNames(),&#10;                    youtubeVideoId = null,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;&#10;            selectedTracks.forEachIndexed { index, track -&gt;&#10;                SongListItem(&#10;                    song = Song(&#10;                        number = index + 1,&#10;                        title = track.name,&#10;                        artist = track.getArtistNames(),&#10;                        youtubeId = track.id,&#10;                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                    ),&#10;                    trackEntities = tracksEntities,&#10;                    index = index,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    isSelected = true,&#10;                    customButtonIcon = &quot;x&quot;,&#10;                    customButtonAction = {&#10;                        selectedTracks = selectedTracks.filterIndexed { i, _ -&gt; i != index }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(16.dp))&#10;        Text(&#10;            text = if (isLoading) &quot;&lt;creating...&gt;&quot; else &quot;&lt;create&gt;&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (isLoading) Color(0xFFFFD93D) else Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable(enabled = !isLoading &amp;&amp; playlistName.isNotBlank()) {&#10;                    // Acción de crear playlist con las canciones seleccionadas&#10;                    isLoading = true&#10;                    error = null&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        val trackIds = selectedTracks.map { it.id }&#10;                        SpotifyRepository.createPlaylist(&#10;                            accessToken,&#10;                            playlistName,&#10;                            playlistDesc,&#10;                            isPublic,&#10;                            trackIds&#10;                        ) { success, errMsg -&gt;&#10;                            isLoading = false&#10;                            if (success) {&#10;                                // Sincronizar playlists después de crear&#10;                                coroutineScope.launch {&#10;                                    localRepository.syncPlaylistsFromSpotify()&#10;                                }&#10;                                onPlaylistCreated()&#10;                            } else {&#10;                                error = errMsg ?: &quot;Unknown error&quot;&#10;                            }&#10;                        }&#10;                    } else {&#10;                        isLoading = false&#10;                        error = &quot;Spotify not connected&quot;&#10;                    }&#10;                }&#10;                .padding(8.dp)&#10;        )&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&quot;${Translations.get(context, &quot;error_prefix&quot;)}$it&quot;, color = Color.Red)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    trackEntities: List&lt;TrackEntity&gt;? = null,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        Titulo(playlist.name)&#10;&#10;        // Botones de acción&#10;        ActionButtonsGroup(&#10;            buttons = listOf(&#10;                ActionButtonData(&quot;&lt;start&gt;&quot;, Color(0xFF4ECDC4), onStart, tracks.isNotEmpty()),&#10;                ActionButtonData(&quot;&lt;rand&gt;&quot;, Color(0xFFFFD93D), onRandom, tracks.isNotEmpty()),&#10;                ActionButtonData(&quot;&lt;save&gt;&quot;, Color(0xFF7FB069), onSave, true),&#10;                ActionButtonData(&quot;&lt;share&gt;&quot;, Color(0xFFFF6B9D), { showShareDialog = true }, true)&#10;            )&#10;        )&#10;&#10;        // Estados de carga y error&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;        }&#10;&#10;        //listado canciones&#10;        if (tracks.isNotEmpty()) {&#10;            SongList(&#10;                playlist = playlist,&#10;                tracks = tracks,&#10;                trackEntities = trackEntities,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = playlist.id,&#10;                spotifyUrl = &quot;https://open.spotify.com/playlist/${playlist.id}&quot;,&#10;                youtubeId = null,&#10;                title = playlist.name,&#10;                artist = &quot;Playlist&quot;,&#10;                type = ShareType.PLAYLIST&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.grid.GridCells&#10;import androidx.compose.foundation.lazy.grid.LazyVerticalGrid&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.runtime.getValue&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.asFlow&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import coil.compose.AsyncImage&#10;import com.plyr.database.*&#10;import com.plyr.network.SpotifyPlaylist&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.network.SpotifyTrack&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyArtistFull&#10;import com.plyr.utils.Config&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.GlobalScope&#10;import kotlinx.coroutines.Job&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.DelicateCoroutinesApi&#10;import com.plyr.utils.Translations&#10;import com.plyr.ui.components.*&#10;&#10;@OptIn(DelicateCoroutinesApi::class)&#10;@Composable&#10;fun PlaylistsScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;&#10;    // Repositorio local y manager de búsqueda&#10;    val localRepository = remember { PlaylistLocalRepository(context) }&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Estado para las playlists y autenticación&#10;    val playlistsFromDB by localRepository.getAllPlaylistsLiveData().asFlow().collectAsStateWithLifecycle(initialValue = emptyList())&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var isSpotifyConnected by remember { mutableStateOf(Config.isSpotifyConnected(context)) }&#10;    var isSyncing by remember { mutableStateOf(false) }&#10;    var isEditing by remember { mutableStateOf(false) }&#10;&#10;    // Estado para Liked Songs - ahora desde DB&#10;    val likedSongsPlaylist by localRepository.getTracksByPlaylistLiveData(&quot;liked_songs&quot;)&#10;        .asFlow()&#10;        .collectAsStateWithLifecycle(initialValue = emptyList())&#10;    var likedSongsCount by remember { mutableStateOf(0) }&#10;&#10;    // Actualizar contador de Liked Songs&#10;    LaunchedEffect(likedSongsPlaylist) {&#10;        likedSongsCount = likedSongsPlaylist.size&#10;    }&#10;&#10;    // Estado para álbumes guardados&#10;    var savedAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingSavedAlbums by remember { mutableStateOf(false) }&#10;    var savedAlbumsCount by remember { mutableStateOf(0) }&#10;&#10;    // Estado para artistas seguidos&#10;    var followedArtists by remember { mutableStateOf&lt;List&lt;SpotifyArtistFull&gt;&gt;(emptyList()) }&#10;    var isLoadingFollowedArtists by remember { mutableStateOf(false) }&#10;    var followedArtistsCount by remember { mutableStateOf(0) }&#10;&#10;    // Estados para detectar cambios en modo edición (movidos aquí para ser accesibles globalmente)&#10;    var showExitEditDialog by remember { mutableStateOf(false) }&#10;    var hasUnsavedChanges by remember { mutableStateOf(false) }&#10;    var originalTitle by remember { mutableStateOf(&quot;&quot;) }&#10;    var originalDesc by remember { mutableStateOf(&quot;&quot;) }&#10;    var newTitle by remember { mutableStateOf(&quot;&quot;) }&#10;    var newDesc by remember { mutableStateOf(&quot;&quot;) }&#10;&#10;    // Convertir entidades a SpotifyPlaylist para compatibilidad con UI existente&#10;    // Filtrar liked_songs y álbumes para que no aparezcan duplicados (se muestran como items especiales)&#10;    val playlists = playlistsFromDB&#10;        .filter { it.spotifyId != &quot;liked_songs&quot; &amp;&amp; !it.spotifyId.startsWith(&quot;album_&quot;) }&#10;        .map { it.toSpotifyPlaylist() }&#10;&#10;    // Estado para mostrar tracks de una playlist&#10;    var selectedPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedPlaylistEntity by remember { mutableStateOf&lt;PlaylistEntity?&gt;(null) }&#10;    var playlistTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var showCreatePlaylistScreen by remember { mutableStateOf(false) }&#10;&#10;    // Estado para los álbumes del artista seleccionado&#10;    var selectedArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var artistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;    var isViewingAlbumFromArtist by remember { mutableStateOf(false) }&#10;&#10;    // Estado para manejar navegación pendiente cuando hay cambios sin guardar&#10;    var pendingPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;&#10;    // Tracks observados desde la base de datos&#10;    val tracksFromDB by if (selectedPlaylistEntity != null) {&#10;        localRepository.getTracksByPlaylistLiveData(selectedPlaylistEntity!!.spotifyId)&#10;            .asFlow()&#10;            .collectAsStateWithLifecycle(initialValue = emptyList())&#10;    } else {&#10;        remember { mutableStateOf(emptyList()) }&#10;    }&#10;&#10;    // Actualizar tracks cuando cambien en la DB&#10;    LaunchedEffect(tracksFromDB) {&#10;        if (selectedPlaylistEntity != null) {&#10;            playlistTracks = tracksFromDB.map { it.toSpotifyTrack() }&#10;        }&#10;    }&#10;&#10;    // Función para cargar playlists con sincronización automática&#10;    val loadPlaylists = {&#10;        if (isSpotifyConnected) {&#10;            isLoading = true&#10;            coroutineScope.launch {&#10;                localRepository.getPlaylistsWithAutoSync()&#10;                isLoading = false&#10;            }&#10;        }&#10;    }&#10;&#10;    // Función para cargar tracks de una playlist&#10;    val loadPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedPlaylist = playlist&#10;        selectedPlaylistEntity = playlistsFromDB.find { it.spotifyId == playlist.id }&#10;        isLoadingTracks = true&#10;&#10;        if (selectedPlaylistEntity == null) {&#10;            isLoadingTracks = false&#10;        } else {&#10;            // Usar corrutina para operaciones asíncronas&#10;            coroutineScope.launch {&#10;                localRepository.getTracksWithAutoSync(playlist.id)&#10;                isLoadingTracks = false&#10;            }&#10;        }&#10;    }&#10;&#10;    //LIKED SONGS&#10;    // Función para cargar las Liked Songs del usuario - ahora sincroniza con la base de datos&#10;    val loadLikedSongs: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                // Sincronizar Liked Songs con la base de datos local&#10;                localRepository.getLikedSongsWithAutoSync()&#10;                Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Liked Songs sincronizadas desde DB&quot;)&#10;            } catch (e: Exception) {&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception syncing liked songs: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //LIKED SONGS&#10;&#10;&#10;    //ALBUMS&#10;    // Función para cargar los álbumes guardados del usuario&#10;    val loadSavedAlbums: () -&gt; Unit = {&#10;        isLoadingSavedAlbums = true&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener los álbumes guardados usando la API de Spotify&#10;                    SpotifyRepository.getUserSavedAlbums(accessToken) { albums, errorMsg -&gt;&#10;                        isLoadingSavedAlbums = false&#10;                        if (albums != null) {&#10;                            savedAlbums = albums&#10;                            savedAlbumsCount = albums.size&#10;                            Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Saved Albums actualizados: ${albums.size} álbumes&quot;)&#10;                        } else {&#10;                            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading saved albums: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingSavedAlbums = false&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingSavedAlbums = false&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception loading saved albums: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //ALBUMS&#10;&#10;    //ARTISTS&#10;    // Función para cargar los artistas seguidos del usuario&#10;    val loadFollowedArtists: () -&gt; Unit = {&#10;        isLoadingFollowedArtists = true&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener los artistas seguidos usando la API de Spotify&#10;                    SpotifyRepository.getUserFollowedArtists(accessToken) { artists, errorMsg -&gt;&#10;                        isLoadingFollowedArtists = false&#10;                        if (artists != null) {&#10;                            followedArtists = artists&#10;                            followedArtistsCount = artists.size&#10;                            Log.d(&quot;PlaylistsScreen&quot;, &quot;✓ Followed Artists actualizados: ${artists.size} artistas&quot;)&#10;                        } else {&#10;                            Log.e(&quot;PlaylistsScreen&quot;, &quot;Error loading followed artists: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingFollowedArtists = false&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingFollowedArtists = false&#10;                Log.e(&quot;PlaylistsScreen&quot;, &quot;Exception loading followed artists: ${e.message}&quot;)&#10;            }&#10;        }&#10;    }&#10;    //ARTISTS&#10;&#10;    // Función para forzar sincronización completa&#10;    val forceSyncAll = {&#10;        if (!isSpotifyConnected) {&#10;        } else {&#10;            isSyncing = true&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    localRepository.forceSyncAll()&#10;                    loadLikedSongs()&#10;                    loadSavedAlbums()&#10;                    loadFollowedArtists()&#10;                    isSyncing = false&#10;                } catch (_: Exception) {&#10;                    isSyncing = false&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Cargar si está conectado&#10;    LaunchedEffect(isSpotifyConnected) {&#10;        if (isSpotifyConnected) {&#10;            loadPlaylists()&#10;            loadLikedSongs()&#10;            loadSavedAlbums()&#10;            loadFollowedArtists()&#10;        }&#10;    }&#10;&#10;    // Cleanup del YouTubeSearchManager&#10;    DisposableEffect(Unit) {&#10;        onDispose {&#10;            youtubeSearchManager.cleanup()&#10;        }&#10;    }&#10;&#10;    // Manejar botón de retroceso del sistema&#10;    BackHandler {&#10;        if (selectedPlaylist != null) {&#10;            // Si estamos viendo un álbum que viene de un artista, volver al artista&#10;            if (isViewingAlbumFromArtist &amp;&amp; selectedArtist != null) {&#10;                // Volver a la vista del artista&#10;                isViewingAlbumFromArtist = false&#10;                isLoadingTracks = true&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Cargar top tracks del artista&#10;                    SpotifyRepository.getArtistTopTracks(accessToken, selectedArtist!!.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            // Restaurar la playlist temporal del artista&#10;                            selectedPlaylist = SpotifyPlaylist(&#10;                                id = selectedArtist!!.id,&#10;                                name = selectedArtist!!.name,&#10;                                description = &quot;Top tracks by ${selectedArtist!!.name}&quot;,&#10;                                tracks = com.plyr.network.SpotifyPlaylistTracks(null, tracks.size),&#10;                                images = selectedArtist!!.images&#10;                            )&#10;                            playlistTracks = tracks&#10;                            selectedPlaylistEntity = null&#10;                        } else {&#10;                            Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist tracks: $errorMsg&quot;)&#10;                        }&#10;                    }&#10;                }&#10;            } else if (isEditing &amp;&amp; hasUnsavedChanges) {&#10;                // Si estamos en modo edición con cambios sin guardar, mostrar diálogo&#10;                showExitEditDialog = true&#10;            } else {&#10;                // Salir de la playlist y resetear modo edición&#10;                isEditing = false&#10;                hasUnsavedChanges = false&#10;                selectedPlaylist = null&#10;                selectedPlaylistEntity = null&#10;                playlistTracks = emptyList()&#10;                // Limpiar artista y sus álbumes al salir completamente&#10;                selectedArtist = null&#10;                artistAlbums = emptyList()&#10;                isViewingAlbumFromArtist = false&#10;            }&#10;        } else {&#10;            onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        //si se pulsa boton de &lt;new&gt; mostrar CreatePlaylistScreen&#10;        if (showCreatePlaylistScreen) {&#10;            CreateSpotifyPlaylistScreen(&#10;                onBack = { showCreatePlaylistScreen = false },&#10;                onPlaylistCreated = { showCreatePlaylistScreen = false; loadPlaylists() },&#10;                playerViewModel = playerViewModel&#10;            )&#10;            return@Column&#10;        }&#10;        Titulo(if (selectedPlaylist == null) Translations.get(context, &quot;plyr_lists&quot;) else &quot;${selectedPlaylist!!.name}&quot;)&#10;&#10;        // Botón de sincronización manual (solo visible si está conectado y no es una playlist individual)&#10;        if (isSpotifyConnected &amp;&amp; selectedPlaylist == null) {&#10;            ActionButtonsGroup(listOf(&#10;&#9;&#9;    ActionButtonData(&#10;&#9;&#9;        text = Translations.get(context, if (isSyncing) &quot;&lt;syncing...&gt;&quot; else &quot;&lt;sync&gt;&quot;),&#10;&#9;&#9;&#9;&#9;color = if (isSyncing) Color(0xFFFFD93D) else Color(0xFF4ECDC4),&#10;&#9;&#9;        onClick = {&#10;&#9;&#9;            forceSyncAll()&#10;&#9;&#9;            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;&#9;&#9;        },&#10;&#9;&#9;        enabled = !isSyncing&#10;&#9;&#9;    ),&#10;&#9;&#9;    ActionButtonData(&#10;&#9;&#9;        text = Translations.get(context, &quot;&lt;new&gt;&quot;),&#10;&#9;&#9;        color = Color(0xFF4ECDC4),&#10;&#9;&#9;        onClick = { showCreatePlaylistScreen = true },&#10;&#9;&#9;        enabled = !isSyncing&#10;&#9;&#9;&#9;&#9;    )&#10;&#9;&#9;&#9;&#9;)&#10;&#9;&#9;    )&#10;        }&#10;&#9;&#9;&#9;&#10;        Spacer(modifier = Modifier.height(16.dp))&#10;&#10;        when { // Estado no conectado&#10;            !isSpotifyConnected -&gt; {&#10;&#9;&#9;&#9;&#9;Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;&#9;&#9;&#9;&#9;    Text(&#10;                        text = Translations.get(context, &quot;Spotify not connected&quot;),&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF95A5A6)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            selectedPlaylist != null -&gt; {&#10;                // Vista de tracks de playlist&#10;                if (isLoadingTracks) {&#10;                    Box(&#10;                        modifier = Modifier.fillMaxSize(),&#10;                        contentAlignment = Alignment.Center&#10;                    ) {&#10;&#9;&#9;&#9;&#9;        Text(&#10;                            text = Translations.get(context, &quot;Loading tracks...&quot;),&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }   &#10;                } else {&#10;                    // Estados para los botones de control&#10;                    var isRandomizing by remember { mutableStateOf(false) }&#10;                    var isStarting by remember { mutableStateOf(false) }&#10;                    var randomJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;                    var startJob by remember { mutableStateOf&lt;Job?&gt;(null) }&#10;                    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;&#9;&#9;&#9;&#9;&#9;// Función para parar todas las reproducciones&#10;                    fun stopAllPlayback() {&#10;                        isRandomizing = false&#10;                        isStarting = false&#10;                        randomJob?.cancel()&#10;                        startJob?.cancel()&#10;                        randomJob = null&#10;                        startJob = null&#10;                        // Cancelar espera de canción y pausar el reproductor&#10;                        //playerViewModel?.cancelWaitForSong()&#10;                        playerViewModel?.pausePlayer()&#10;                    }&#10;&#10;&#10;                    // Función para randomización simplificada - mezcla toda la playlist&#10;                    fun startRandomizing() {&#10;                        stopAllPlayback()&#10;                        isRandomizing = true&#10;&#10;                        if (playlistTracks.isNotEmpty() &amp;&amp; playerViewModel != null) {&#10;                            randomJob = coroutineScope.launch(kotlinx.coroutines.Dispatchers.Main) {&#10;                                // Limpiar estado previo del reproductor&#10;                                playerViewModel.clearPlayerState()&#10;                                &#10;                                // Mezclar toda la lista de tracks&#10;                                val shuffledTracks = tracksFromDB.shuffled()&#10;                                val firstTrack = shuffledTracks.first()&#10;&#10;                                println(&quot; RANDOM: ${firstTrack.name}&quot;)&#10;&#10;                                // Reproducir la canción usando PlayerViewModel&#10;                                playerViewModel.initializePlayer()&#10;&#10;                                // Establecer la playlist mezclada completa desde el inicio (índice 0)&#10;                                playerViewModel.setCurrentPlaylist(shuffledTracks, 0)&#10;&#10;                                // Cargar y reproducir - PlayerViewModel manejará la navegación automática&#10;                                playerViewModel.loadAudioFromTrack(firstTrack)&#10;&#10;                                isRandomizing = false&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Función para reproducción ordenada simplificada - replica exactamente el comportamiento de hacer clic en la primera canción&#10;                    fun startOrderedPlayback() {&#10;                        stopAllPlayback()&#10;                        isStarting = true&#10;&#10;                        if (playlistTracks.isNotEmpty() &amp;&amp; playerViewModel != null &amp;&amp; tracksFromDB.isNotEmpty()) {&#10;                            startJob = coroutineScope.launch(kotlinx.coroutines.Dispatchers.Main) {&#10;                                // Limpiar estado previo del reproductor&#10;                                playerViewModel.clearPlayerState()&#10;                                &#10;                                // Replicar exactamente la lógica de SongListItem cuando haces clic en una canción&#10;                                playerViewModel.setCurrentPlaylist(tracksFromDB, 0)&#10;                                val selectedTrackEntity = tracksFromDB[0]&#10;&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot; REPRODUCIR TRACK (START)&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;Track: ${selectedTrackEntity.name}&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;AudioUrl: ${selectedTrackEntity.audioUrl}&quot;)&#10;                                Log.d(&quot;PlaylistScreen&quot;, &quot;Es archivo local: ${selectedTrackEntity.audioUrl?.startsWith(&quot;/&quot;) == true}&quot;)&#10;&#10;                                try {&#10;                                    playerViewModel.loadAudioFromTrack(selectedTrackEntity)&#10;                                    Log.d(&quot;PlaylistScreen&quot;, &quot;✓ loadAudioFromTrack llamado exitosamente&quot;)&#10;                                } catch (e: Exception) {&#10;                                    Log.e(&quot;PlaylistScreen&quot;, &quot;✗ Error al reproducir track&quot;, e)&#10;                                }&#10;&#10;                                isStarting = false&#10;                            }&#10;                        } else {&#10;                            isStarting = false&#10;                        }&#10;                    }&#10;&#10;                    // Limpiar jobs al salir&#10;                    DisposableEffect(selectedPlaylist) {&#10;                        onDispose {&#10;                            randomJob?.cancel()&#10;                            startJob?.cancel()&#10;                        }&#10;                    }&#10;                    Column {&#10;                        // Botones de control&#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(bottom = 16.dp),&#10;                            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                        ) {&#10;                            if (!isEditing) {&#10;                                // Botones visibles solo cuando NO está en modo edición&#10;&#10;                                // Botón &lt;start&gt;&#10;                                Text(&#10;                                    text = if (isStarting) &quot;&lt;stop&gt;&quot; else &quot;&lt;start&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = if (isStarting) Color(0xFFFF6B6B) else Color(0xFF4ECDC4)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            if (isStarting) {&#10;                                                stopAllPlayback()&#10;                                            } else {&#10;                                                startOrderedPlayback()&#10;                                            }&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Botón &lt;rand&gt;&#10;                                Text(&#10;                                    text = if (isRandomizing) &quot;&lt;stop&gt;&quot; else &quot;&lt;rand&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = if (isRandomizing) Color(0xFFFF6B6B) else Color(0xFFFFD93D)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            if (isRandomizing) {&#10;                                                stopAllPlayback()&#10;                                            } else {&#10;                                                startRandomizing()&#10;                                            }&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Botón &lt;share&gt;&#10;                                Text(&#10;                                    text = &quot;&lt;share&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = Color(0xFFFF6B9D)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            showShareDialog = true&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;                            }&#10;&#10;                            // Botón &lt;edit&gt; o &lt;save&gt;&#10;                            Text(&#10;                                text = if (isEditing) &quot;&lt;save&gt;&quot; else &quot;&lt;edit&gt;&quot;,&#10;                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 16.sp,&#10;                                    color = if (isEditing) Color(0xFF7FB069) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier&#10;                                    .clickable {&#10;                                        if (isEditing) {&#10;                                            // Al hacer clic en save, verificar si hay cambios sin guardar&#10;                                            if (hasUnsavedChanges) {&#10;                                                // Guardar cambios en Spotify&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    // Mostrar indicador de carga&#10;                                                    isLoadingTracks = true&#10;&#10;                                                    SpotifyRepository.updatePlaylistDetails(&#10;                                                        accessToken = accessToken,&#10;                                                        playlistId = selectedPlaylist!!.id,&#10;                                                        name = if (newTitle != originalTitle) newTitle else null,&#10;                                                        description = if (newDesc != originalDesc) newDesc else null&#10;                                                    ) { success, errorMsg -&gt;&#10;                                                        if (success) {&#10;                                                            // Sincronizar playlists después de EDITAR&#10;                                                            coroutineScope.launch {&#10;                                                                localRepository.syncPlaylistsFromSpotify()&#10;                                                                // Esperar a que termine la sincronización&#10;                                                                kotlinx.coroutines.delay(500)&#10;                                                                isLoadingTracks = false&#10;                                                                // Salir del modo edición y volver al listado&#10;                                                                isEditing = false&#10;                                                                hasUnsavedChanges = false&#10;                                                                selectedPlaylist = null&#10;                                                                playlistTracks = emptyList()&#10;                                                            }&#10;                                                        } else {&#10;                                                            isLoadingTracks = false&#10;                                                            // Mostrar error&#10;                                                            Log.e(&quot;PlaylistScreen&quot;, &quot;Error actualizando playlist: $errorMsg&quot;)&#10;                                                        }&#10;                                                    }&#10;                                                } else {&#10;                                                    // Si no hay token, solo resetear el flag y salir&#10;                                                    hasUnsavedChanges = false&#10;                                                    isEditing = false&#10;                                                }&#10;                                            } else {&#10;                                                // Si no hay cambios, solo salir del modo edición&#10;                                                isEditing = false&#10;                                            }&#10;                                        } else {&#10;                                            // Al entrar al modo edición, guardar valores originales e inicializar campos&#10;                                            originalTitle = selectedPlaylist?.name ?: &quot;&quot;&#10;                                            originalDesc = selectedPlaylist?.description ?: &quot;&quot;&#10;                                            newTitle = originalTitle&#10;                                            newDesc = originalDesc&#10;                                            hasUnsavedChanges = false&#10;                                            isEditing = true&#10;                                        }&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                    }&#10;                                    .padding(8.dp)&#10;                            )&#10;&#10;                            // Botón &lt;delete&gt; - solo visible en modo edición&#10;                            if (isEditing) {&#10;                                var showDeleteDialog by remember { mutableStateOf(false) }&#10;&#10;                                Text(&#10;                                    text = &quot;&lt;delete&gt;&quot;,&#10;                                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        fontSize = 16.sp,&#10;                                        color = Color(0xFFFF6B6B)&#10;                                    ),&#10;                                    modifier = Modifier&#10;                                        .clickable {&#10;                                            showDeleteDialog = true&#10;                                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                                        }&#10;                                        .padding(8.dp)&#10;                                )&#10;&#10;                                // Diálogo de confirmación para eliminar playlist&#10;                                if (showDeleteDialog) {&#10;                                    AlertDialog(&#10;                                        onDismissRequest = { showDeleteDialog = false },&#10;                                        title = {&#10;                                            Text(&#10;                                                &quot;Delete playlist&quot;,&#10;                                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                                    fontFamily = FontFamily.Monospace,&#10;                                                    color = Color(0xFF4ECDC4)&#10;                                                )&#10;                                            )&#10;                                        },&#10;                                        text = {&#10;                                            Text(&#10;                                                &quot;Are you sure you want to delete '${selectedPlaylist?.name}'? This action cannot be undone.&quot;,&#10;                                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                    fontFamily = FontFamily.Monospace&#10;                                                )&#10;                                            )&#10;                                        },&#10;                                        confirmButton = {&#10;                                            TextButton(&#10;                                                onClick = {&#10;                                                    showDeleteDialog = false&#10;                                                    // Eliminar la playlist&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                        coroutineScope.launch {&#10;                                                            SpotifyRepository.unfollowPlaylist(&#10;                                                                accessToken,&#10;                                                                selectedPlaylist!!.id&#10;                                                            ) { success: Boolean, errorMsg: String? -&gt;&#10;                                                                if (success) {&#10;                                                                    // Sincronizar playlists después de eliminar&#10;                                                                    coroutineScope.launch {&#10;                                                                        localRepository.syncPlaylistsFromSpotify()&#10;                                                                    }&#10;                                                                    // Salir del modo edición y volver a la lista&#10;                                                                    isEditing = false&#10;                                                                    hasUnsavedChanges = false&#10;                                                                    selectedPlaylist = null&#10;                                                                    playlistTracks = emptyList()&#10;                                                                    // Recargar la lista de playlists&#10;                                                                    loadPlaylists()&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            ) {&#10;                                                Text(&#10;                                                    &quot;Delete&quot;,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        color = Color(0xFFFF6B6B)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        },&#10;                                        dismissButton = {&#10;                                            TextButton(&#10;                                                onClick = { showDeleteDialog = false }&#10;                                            ) {&#10;                                                Text(&#10;                                                    &quot;Cancel&quot;,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        fontFamily = FontFamily.Monospace,&#10;                                                        color = Color(0xFF4ECDC4)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                        if (isEditing) {&#10;                            // Estados para el buscador de canciones en edición&#10;                            var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;                            var isSearching by remember { mutableStateOf(false) }&#10;                            var searchResults by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;                            var editError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                            // Detectar cambios en los campos&#10;                            LaunchedEffect(newTitle, newDesc) {&#10;                                hasUnsavedChanges = (newTitle != originalTitle || newDesc != originalDesc)&#10;                            }&#10;&#10;                            // Usar LazyColumn para permitir scroll&#10;                            LazyColumn(&#10;                                modifier = Modifier&#10;                                    .fillMaxWidth()&#10;                                    .weight(1f),&#10;                                contentPadding = PaddingValues(vertical = 8.dp)&#10;                            ) {&#10;                                // Título de la sección&#10;                                item {&#10;                                    Text(&#10;                                        text = &quot;&gt; edit_playlist&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 16.sp,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        ),&#10;                                        modifier = Modifier.padding(bottom = 8.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // Cambiar nombre&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = newTitle,&#10;                                        onValueChange = { newTitle = it },&#10;                                        label = { Text(Translations.get(context, &quot;playlist_name&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                    Spacer(Modifier.height(8.dp))&#10;                                }&#10;&#10;                                // Cambiar descripción&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = newDesc,&#10;                                        onValueChange = { newDesc = it },&#10;                                        label = { Text(Translations.get(context, &quot;description&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth()&#10;                                    )&#10;                                    Spacer(Modifier.height(16.dp))&#10;                                }&#10;&#10;                                // Sección de buscador de canciones&#10;                                item {&#10;                                    Text(&#10;                                        text = &quot;&gt; add_tracks&quot;,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 16.sp,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        ),&#10;                                        modifier = Modifier.padding(bottom = 8.dp)&#10;                                    )&#10;                                }&#10;&#10;                                // Campo de búsqueda&#10;                                item {&#10;                                    OutlinedTextField(&#10;                                        value = searchQuery,&#10;                                        onValueChange = { searchQuery = it },&#10;                                        label = { Text(Translations.get(context, &quot;search_tracks_label&quot;)) },&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        trailingIcon = {&#10;                                            if (searchQuery.isNotEmpty()) {&#10;                                                IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                                                    Text(&#10;                                                        text = &quot;x&quot;,&#10;                                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                                            fontFamily = FontFamily.Monospace&#10;                                                        )&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                        keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;                                        keyboardActions = KeyboardActions(&#10;                                            onSearch = {&#10;                                                if (searchQuery.isNotBlank() &amp;&amp; !isSearching) {&#10;                                                    isSearching = true&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        coroutineScope.launch {&#10;                                                            SpotifyRepository.searchAll(accessToken, searchQuery) { results, errorMsg -&gt;&#10;                                                                isSearching = false&#10;                                                                if (results != null) {&#10;                                                                    searchResults = results.tracks.items&#10;                                                                } else {&#10;                                                                    editError = errorMsg&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        ),&#10;                                        enabled = !isSearching&#10;                                    )&#10;                                }&#10;&#10;                                // Mostrar indicador de búsqueda&#10;                                if (isSearching) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&#10;                                            text = &quot;$ searching...&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFFFD93D)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Resultados de búsqueda usando SongListItem&#10;                                if (searchResults.isNotEmpty()) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&#10;                                            text = &quot;results:&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFE0E0E0)&#10;                                            )&#10;                                        )&#10;                                    }&#10;&#10;                                    // Crear trackEntities para los resultados de búsqueda&#10;                                    val searchTrackEntities = searchResults.take(10).mapIndexed { trackIndex, track -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;edit_search_${track.id}_$trackIndex&quot;,&#10;                                            playlistId = &quot;edit_search_${System.currentTimeMillis()}&quot;,&#10;                                            spotifyTrackId = track.id,&#10;                                            name = track.name,&#10;                                            artists = track.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;&#10;                                    items(searchResults.take(10).size) { index -&gt;&#10;                                        val track = searchResults[index]&#10;                                        SongListItem(&#10;                                            song = Song(&#10;                                                number = index + 1,&#10;                                                title = track.name,&#10;                                                artist = track.getArtistNames(),&#10;                                                spotifyId = track.id,&#10;                                                spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                            ),&#10;                                            trackEntities = searchTrackEntities,&#10;                                            index = index,&#10;                                            playerViewModel = playerViewModel,&#10;                                            coroutineScope = coroutineScope,&#10;                                            customButtonIcon = &quot;+&quot;,&#10;                                            customButtonAction = {&#10;                                                // Añadir canción a la playlist&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    coroutineScope.launch {&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#10;                                                            accessToken,&#10;                                                            selectedPlaylist!!.id,&#10;                                                            track.id&#10;                                                        ) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                searchResults = emptyList()&#10;                                                                searchQuery = &quot;&quot;&#10;                                                                // Recargar tracks&#10;                                                                coroutineScope.launch {&#10;                                                                    localRepository.syncTracksFromSpotify(selectedPlaylist!!.id)&#10;                                                                }&#10;                                                            } else {&#10;                                                                editError = errorMsg&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                            modifier = Modifier.fillMaxWidth()&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                // Mostrar error si hay&#10;                                editError?.let {&#10;                                    item {&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                        Text(&quot;${Translations.get(context, &quot;error_prefix&quot;)}$it&quot;, color = Color.Red, style = MaterialTheme.typography.bodySmall.copy(fontFamily = FontFamily.Monospace))&#10;                                    }&#10;                                }&#10;&#10;                                item {&#10;                                    Spacer(Modifier.height(16.dp))&#10;                                }&#10;&#10;                                // Lista de canciones actuales usando SongListItem&#10;                                if (playlistTracks.isNotEmpty()) {&#10;                                    item {&#10;                                        Text(&#10;                                            text = &quot;current tracks [${playlistTracks.size}]:&quot;,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFF4ECDC4)&#10;                                            )&#10;                                        )&#10;                                        Spacer(Modifier.height(8.dp))&#10;                                    }&#10;&#10;                                    items(playlistTracks.size) { index -&gt;&#10;                                        val track = playlistTracks[index]&#10;                                        SongListItem(&#10;                                            song = Song(&#10;                                                number = index + 1,&#10;                                                title = track.name,&#10;                                                artist = track.getArtistNames(),&#10;                                                spotifyId = track.id,&#10;                                                spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                            ),&#10;                                            trackEntities = tracksFromDB,&#10;                                            index = index,&#10;                                            playerViewModel = playerViewModel,&#10;                                            coroutineScope = coroutineScope,&#10;                                            customButtonIcon = &quot;x&quot;,&#10;                                            customButtonAction = {&#10;                                                // Eliminar canción de la playlist&#10;                                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                if (accessToken != null &amp;&amp; selectedPlaylist != null) {&#10;                                                    coroutineScope.launch {&#10;                                                        SpotifyRepository.removeTrackFromPlaylist(&#10;                                                            accessToken,&#10;                                                            selectedPlaylist!!.id,&#10;                                                            track.id&#10;                                                        ) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Recargar tracks&#10;                                                                coroutineScope.launch {&#10;                                                                    localRepository.syncTracksFromSpotify(selectedPlaylist!!.id)&#10;                                                                }&#10;                                                            } else {&#10;                                                                editError = errorMsg&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            onLikedStatusChanged = {&#10;                                                // Recargar las Liked Songs cuando se modifica el estado&#10;                                                loadLikedSongs()&#10;                                            }&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                        // Lista de tracks (solo visible cuando NO está en modo edición)&#10;                        if (!isEditing) {&#10;                            LazyColumn(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                contentPadding = PaddingValues(bottom = 16.dp),&#10;                                verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                            ) {&#10;                                // Prepara trackEntities - si no hay en DB, crear temporales&#10;                                val trackEntitiesList = if (tracksFromDB.isNotEmpty()) {&#10;                                    tracksFromDB&#10;                                } else {&#10;                                    // Crear TrackEntities temporales para álbumes u otras fuentes sin BD&#10;                                    playlistTracks.mapIndexed { trackIndex, track -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;temp_${selectedPlaylist?.id}_${track.id}&quot;,&#10;                                            playlistId = selectedPlaylist?.id ?: &quot;unknown&quot;,&#10;                                            spotifyTrackId = track.id,&#10;                                            name = track.name,&#10;                                            artists = track.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                }&#10;&#10;                                items(playlistTracks.size) { index -&gt;&#10;                                    val track = playlistTracks[index]&#10;                                    val song = Song(&#10;                                        number = index + 1,&#10;                                        title = track.name,&#10;                                        artist = track.getArtistNames(),&#10;                                        spotifyId = track.id,&#10;                                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                    )&#10;                                    SongListItem(&#10;                                        song = song,&#10;                                        trackEntities = trackEntitiesList,&#10;                                        index = index,&#10;                                        playerViewModel = playerViewModel,&#10;                                        coroutineScope = coroutineScope,&#10;                                        modifier = Modifier.fillMaxWidth(),&#10;                                        onLikedStatusChanged = {&#10;                                            // Recargar las Liked Songs cuando se modifica el estado&#10;                                            loadLikedSongs()&#10;                                        }&#10;                                    )&#10;                                }&#10;&#10;                                // Sección de álbumes del artista (solo si hay un artista seleccionado)&#10;                                if (selectedArtist != null &amp;&amp; artistAlbums.isNotEmpty()) {&#10;                                    item {&#10;                                        Spacer(Modifier.height(24.dp))&#10;                                        Text(&#10;                                            text = &quot;&gt; albums&quot;,&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFF4ECDC4)&#10;                                            ),&#10;                                            modifier = Modifier.padding(bottom = 12.dp)&#10;                                        )&#10;&#10;                                        LazyRow(&#10;                                            modifier = Modifier.fillMaxWidth(),&#10;                                            horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                                            contentPadding = PaddingValues(horizontal = 8.dp)&#10;                                        ) {&#10;                                            items(artistAlbums.size) { index -&gt;&#10;                                                val album = artistAlbums[index]&#10;                                                Column(&#10;                                                    modifier = Modifier&#10;                                                        .width(120.dp)&#10;                                                        .clickable {&#10;                                                            // Cargar los tracks del álbum&#10;                                                            isViewingAlbumFromArtist = true&#10;                                                            isLoadingTracks = true&#10;                                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                            if (accessToken != null) {&#10;                                                                SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                                                                    isLoadingTracks = false&#10;                                                                    if (tracks != null) {&#10;                                                                        // Crear una playlist temporal para mostrar el álbum&#10;                                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                                            id = album.id,&#10;                                                                            name = album.name,&#10;                                                                            description = &quot;Album by ${album.getArtistNames()}&quot;,&#10;                                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, album.totaltracks ?: tracks.size),&#10;                                                                            images = album.images&#10;                                                                        )&#10;                                                                        playlistTracks = tracks&#10;                                                                        selectedPlaylistEntity = null&#10;                                                                        // NO limpiar artista ni álbumes aquí para poder volver&#10;                                                                    } else {&#10;                                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading album tracks: $errorMsg&quot;)&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        },&#10;                                                    horizontalAlignment = Alignment.CenterHorizontally&#10;                                                ) {&#10;                                                    AsyncImage(&#10;                                                        model = album.getImageUrl(),&#10;                                                        contentDescription = &quot;Album cover&quot;,&#10;                                                        modifier = Modifier&#10;                                                            .size(120.dp)&#10;                                                            .clip(RoundedCornerShape(8.dp))&#10;                                                    )&#10;&#10;                                                    Text(&#10;                                                        text = album.name,&#10;                                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                                            fontFamily = FontFamily.Monospace,&#10;                                                            color = Color(0xFFE0E0E0)&#10;                                                        ),&#10;                                                        modifier = Modifier.padding(top = 4.dp),&#10;                                                        maxLines = 2,&#10;                                                        overflow = TextOverflow.Ellipsis,&#10;                                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                                    )&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Diálogo de confirmación para salir sin guardar&#10;                    if (showExitEditDialog) {&#10;                        AlertDialog(&#10;                            onDismissRequest = {&#10;                                showExitEditDialog = false&#10;                                pendingPlaylist = null&#10;                            },&#10;                            title = {&#10;                                Text(&#10;                                    &quot;Unsaved changes&quot;,&#10;                                    style = MaterialTheme.typography.titleMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF4ECDC4)&#10;                                    )&#10;                                )&#10;                            },&#10;                            text = {&#10;                                Text(&#10;                                    &quot;You have unsaved changes. Are you sure you want to exit?&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace&#10;                                    )&#10;                                )&#10;                            },&#10;                            confirmButton = {&#10;                                TextButton(&#10;                                    onClick = {&#10;                                        showExitEditDialog = false&#10;                                        isEditing = false&#10;                                        hasUnsavedChanges = false&#10;&#10;                                        // Si hay una playlist pendiente, cargarla&#10;                                        if (pendingPlaylist != null) {&#10;                                            selectedPlaylist = pendingPlaylist&#10;                                            loadPlaylistTracks(pendingPlaylist!!)&#10;                                            pendingPlaylist = null&#10;                                        } else {&#10;                                            // Si no hay playlist pendiente, salir de la vista actual&#10;                                            selectedPlaylist = null&#10;                                            playlistTracks = emptyList()&#10;                                        }&#10;                                    }&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;Exit&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            },&#10;                            dismissButton = {&#10;                                TextButton(&#10;                                    onClick = {&#10;                                        showExitEditDialog = false&#10;                                        pendingPlaylist = null&#10;                                    }&#10;                                ) {&#10;                                    Text(&#10;                                        &quot;Cancel&quot;,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;&#10;                    // Diálogo de compartir - debe estar dentro del mismo scope que showShareDialog&#10;                    if (showShareDialog) {&#10;                        ShareDialog(&#10;                            item = ShareableItem(&#10;                                spotifyId = selectedPlaylist!!.id,&#10;                                spotifyUrl = &quot;https://open.spotify.com/playlist/${selectedPlaylist!!.id}&quot;,&#10;                                youtubeId = null,&#10;                                title = selectedPlaylist!!.name,&#10;                                artist = &quot;Playlist&quot;, //selectedPlaylist!!.owner?.display_name ?: &quot;Playlist&quot;,&#10;                                type = ShareType.PLAYLIST&#10;                            ),&#10;                            onDismiss = { showShareDialog = false }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;&#10;            else -&gt; {&#10;                    // Estado cuando no está cargando ni sincronizando&#10;                    if (playlists.isEmpty() &amp;&amp; (!isLoading || !isSyncing)) {&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(16.dp),&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;No playlists found&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                )&#10;                            )&#10;                        }&#10;                    } else {&#10;                        // Grilla de portadas de playlists&#10;                        LazyVerticalGrid(&#10;                            columns = GridCells.Adaptive(minSize = 150.dp),&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp),&#10;                            verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                        ) {&#10;                            // Primer item: Liked Songs&#10;                            if (likedSongsCount &gt; 0) {&#10;                                item {&#10;                                    Column(&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Mostrar las Liked Songs como una playlist especial desde DB&#10;                                                selectedPlaylist = SpotifyPlaylist(&#10;                                                    id = &quot;liked_songs&quot;,&#10;                                                    name = &quot;Liked Songs&quot;,&#10;                                                    description = &quot;Your favorite tracks on Spotify&quot;,&#10;                                                    tracks = com.plyr.network.SpotifyPlaylistTracks(null, likedSongsCount),&#10;                                                    images = null&#10;                                                )&#10;                                                // Buscar la playlist entity de Liked Songs&#10;                                                selectedPlaylistEntity = playlistsFromDB.find { it.spotifyId == &quot;liked_songs&quot; }&#10;                                                isLoadingTracks = true&#10;&#10;                                                // Cargar tracks desde la base de datos&#10;                                                coroutineScope.launch {&#10;                                                    localRepository.getTracksWithAutoSync(&quot;liked_songs&quot;)&#10;                                                    isLoadingTracks = false&#10;                                                }&#10;                                            },&#10;                                        horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    ) {&#10;                                        // Icono de corazón para Liked Songs (en lugar de portada)&#10;                                        Box(&#10;                                            modifier = Modifier&#10;                                                .size(150.dp)&#10;                                                .clip(RoundedCornerShape(8.dp)),&#10;                                            contentAlignment = Alignment.Center&#10;                                        ) {&#10;                                            // Fondo degradado&#10;                                            Box(&#10;                                                modifier = Modifier&#10;                                                    .fillMaxSize()&#10;                                                    .clip(RoundedCornerShape(8.dp)),&#10;                                                contentAlignment = Alignment.Center&#10;                                            ) {&#10;                                                androidx.compose.foundation.Canvas(&#10;                                                    modifier = Modifier.fillMaxSize()&#10;                                                ) {&#10;                                                    drawRect(&#10;                                                        brush = androidx.compose.ui.graphics.Brush.verticalGradient(&#10;                                                            colors = listOf(&#10;                                                                Color(0xFF4ECDC4),&#10;                                                                Color(0xFF7FB069)&#10;                                                            )&#10;                                                        )&#10;                                                    )&#10;                                                }&#10;                                                // Emoji de corazón&#10;                                                Text(&#10;                                                    text = &quot;♥&quot;,&#10;                                                    style = MaterialTheme.typography.displayLarge.copy(&#10;                                                        fontSize = 64.sp,&#10;                                                        color = Color.White&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;&#10;                                        // Nombre de la playlist&#10;                                        Text(&#10;                                            text = &quot;Liked Songs&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                fontFamily = FontFamily.Monospace,&#10;                                                color = Color(0xFFE0E0E0)&#10;                                            ),&#10;                                            modifier = Modifier.padding(top = 8.dp),&#10;                                            maxLines = 2,&#10;                                            overflow = TextOverflow.Ellipsis,&#10;                                            textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;&#10;                            // Resto de las playlists&#10;                            items(playlists.size) { index -&gt;&#10;                                val playlist = playlists[index]&#10;                                val playlistEntity = playlistsFromDB.find { it.spotifyId == playlist.id }&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Verificar si hay cambios sin guardar antes de cambiar de playlist&#10;                                            if (isEditing &amp;&amp; hasUnsavedChanges) {&#10;                                                pendingPlaylist = playlist&#10;                                                showExitEditDialog = true&#10;                                            } else {&#10;                                                // Resetear modo edición al cambiar de playlist&#10;                                                isEditing = false&#10;                                                hasUnsavedChanges = false&#10;                                                selectedPlaylist = playlist&#10;                                                loadPlaylistTracks(playlist)&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada de la playlist&#10;                                    AsyncImage(&#10;                                        model = playlistEntity?.imageUrl,&#10;                                        contentDescription = &quot;Portada de ${playlist.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(8.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre de la playlist&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 2,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Álbumes guardados&#10;                            items(savedAlbums.size) { index -&gt;&#10;                                val albumEntity = savedAlbums[index]&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Cargar los tracks del álbum desde Spotify API&#10;                                            isLoadingTracks = true&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                SpotifyRepository.getAlbumTracks(accessToken, albumEntity.id) { tracks, errorMsg -&gt;&#10;                                                    isLoadingTracks = false&#10;                                                    if (tracks != null) {&#10;                                                        // Crear una playlist temporal para mostrar el álbum&#10;                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                            id = albumEntity.id,&#10;                                                            name = albumEntity.name,&#10;                                                            description = &quot;Album by ${albumEntity.getArtistNames()}&quot;,&#10;                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, albumEntity.totaltracks ?: tracks.size),&#10;                                                            images = albumEntity.images&#10;                                                        )&#10;                                                        playlistTracks = tracks&#10;                                                        selectedPlaylistEntity = null&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading album tracks: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                isLoadingTracks = false&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada del álbum&#10;                                    AsyncImage(&#10;                                        model = albumEntity.getImageUrl(),&#10;                                        contentDescription = &quot;Portada de ${albumEntity.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(8.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre del álbum&#10;                                    Text(&#10;                                        text = albumEntity.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;&#10;                                    // Artista del álbum&#10;                                    Text(&#10;                                        text = albumEntity.getArtistNames(),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            fontSize = 10.sp,&#10;                                            color = Color(0xFF95A5A6)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 2.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;&#10;                            // Artistas seguidos&#10;                            items(followedArtists.size) { index -&gt;&#10;                                val artist = followedArtists[index]&#10;&#10;                                Column(&#10;                                    modifier = Modifier&#10;                                        .fillMaxWidth()&#10;                                        .clickable {&#10;                                            // Cargar los tracks y álbumes del artista&#10;                                            isLoadingTracks = true&#10;                                            isLoadingArtistAlbums = true&#10;                                            selectedArtist = artist&#10;                                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                                            if (accessToken != null) {&#10;                                                // Cargar top tracks&#10;                                                SpotifyRepository.getArtistTopTracks(accessToken, artist.id) { tracks, errorMsg -&gt;&#10;                                                    isLoadingTracks = false&#10;                                                    if (tracks != null) {&#10;                                                        // Crear una playlist temporal para mostrar los tracks del artista&#10;                                                        selectedPlaylist = SpotifyPlaylist(&#10;                                                            id = artist.id,&#10;                                                            name = artist.name,&#10;                                                            description = &quot;Top tracks by ${artist.name}&quot;,&#10;                                                            tracks = com.plyr.network.SpotifyPlaylistTracks(null, tracks.size),&#10;                                                            images = artist.images&#10;                                                        )&#10;                                                        playlistTracks = tracks&#10;                                                        selectedPlaylistEntity = null&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist tracks: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;&#10;                                                // Cargar álbumes del artista&#10;                                                SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                                                    isLoadingArtistAlbums = false&#10;                                                    if (albums != null) {&#10;                                                        artistAlbums = albums&#10;                                                        Log.d(&quot;PlaylistScreen&quot;, &quot;Loaded ${albums.size} albums for ${artist.name}&quot;)&#10;                                                    } else {&#10;                                                        Log.e(&quot;PlaylistScreen&quot;, &quot;Error loading artist albums: $errorMsg&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        },&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                ) {&#10;                                    // Portada del artista (usar imagen del artista)&#10;                                    AsyncImage(&#10;                                        model = artist.getImageUrl(),&#10;                                        contentDescription = &quot;Artista ${artist.name}&quot;,&#10;                                        modifier = Modifier&#10;                                            .size(150.dp)&#10;                                            .clip(RoundedCornerShape(75.dp)),&#10;                                        placeholder = null,&#10;                                        error = null,&#10;                                        fallback = null&#10;                                    )&#10;&#10;                                    // Nombre del artista&#10;                                    Text(&#10;                                        text = artist.name,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        modifier = Modifier.padding(top = 8.dp),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis,&#10;                                        textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CreateSpotifyPlaylistScreen(&#10;    onBack: () -&gt; Unit,&#10;    onPlaylistCreated: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var playlistName by remember { mutableStateOf(&quot;&quot;) }&#10;    var playlistDesc by remember { mutableStateOf(&quot;&quot;) }&#10;    var isPublic by remember { mutableStateOf(true) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para el buscador de canciones&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var isSearching by remember { mutableStateOf(false) }&#10;    var searchResults by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;&#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    val localRepository = remember { PlaylistLocalRepository(context) }&#10;&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        Titulo(Translations.get(context, &quot;create_playlist&quot;))&#10;        Spacer(Modifier.height(16.dp))&#10;        OutlinedTextField(&#10;            value = playlistName,&#10;            onValueChange = { playlistName = it },&#10;            label = { Text(Translations.get(context, &quot;playlist_name&quot;)) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(Modifier.height(8.dp))&#10;        OutlinedTextField(&#10;            value = playlistDesc,&#10;            onValueChange = { playlistDesc = it },&#10;            label = { Text(Translations.get(context, &quot;description_optional&quot;)) },&#10;            modifier = Modifier.fillMaxWidth()&#10;        )&#10;        Spacer(Modifier.height(8.dp))&#10;        BinaryToggle(&#10;            option1 = &quot;public&quot;,&#10;            option2 = &quot;private&quot;,&#10;            initialValue = isPublic,&#10;            onChange = { isPublic = it }&#10;        )&#10;        // Campo de búsqueda&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = { searchQuery = it },&#10;            label = { Text(Translations.get(context, &quot;search_tracks_label&quot;)) },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                if (searchQuery.isNotEmpty()) {&#10;                    IconButton(onClick = { searchQuery = &quot;&quot; }) {&#10;                        Text(&#10;                            text = &quot;x&quot;,&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isSearching) {&#10;                        isSearching = true&#10;                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                        if (accessToken != null) {&#10;                            coroutineScope.launch {&#10;                                SpotifyRepository.searchAll(accessToken, searchQuery) { results, errorMsg -&gt;&#10;                                    isSearching = false&#10;                                    if (results != null) {&#10;                                        searchResults = results.tracks.items&#10;                                    } else {&#10;                                        error = errorMsg&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isSearching&#10;        )&#10;&#10;        // Mostrar indicador de búsqueda&#10;        if (isSearching) {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                text = &quot;$ searching...&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFFFD93D)&#10;                )&#10;            )&#10;        }&#10;&#10;        // Resultados de búsqueda&#10;        if (searchResults.isNotEmpty()) {&#10;            val trackEntities = searchResults.take(10).mapIndexed { trackIndex, track -&gt;&#10;                TrackEntity(&#10;                    id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                    playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                    spotifyTrackId = track.id,&#10;                    name = track.name,&#10;                    artists = track.getArtistNames(),&#10;                    youtubeVideoId = null,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;&#10;            searchResults.take(10).forEachIndexed { index, track -&gt;&#10;                SongListItem(&#10;                    song = Song(&#10;                        number = index + 1,&#10;                        title = track.name,&#10;                        artist = track.getArtistNames(),&#10;                        youtubeId = track.id,&#10;                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                    ),&#10;                    trackEntities = trackEntities,&#10;                    index = index,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    isSelected = selectedTracks.contains(track),&#10;                    customButtonIcon = &quot;+&quot;,&#10;                    customButtonAction = {&#10;                        if (!selectedTracks.contains(track)) {&#10;                            selectedTracks = selectedTracks + track&#10;                            searchResults = emptyList()&#10;                            searchQuery = &quot;&quot;&#10;                        }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        // Lista de canciones seleccionadas&#10;        if (selectedTracks.isNotEmpty()) {&#10;            Spacer(Modifier.height(16.dp))&#10;            Text(&#10;                text = &quot;selected [${selectedTracks.size}]:&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                )&#10;            )&#10;            val tracksEntities = selectedTracks.mapIndexed { trackIndex, track -&gt;&#10;                TrackEntity(&#10;                    id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                    playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                    spotifyTrackId = track.id,&#10;                    name = track.name,&#10;                    artists = track.getArtistNames(),&#10;                    youtubeVideoId = null,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;&#10;            selectedTracks.forEachIndexed { index, track -&gt;&#10;                SongListItem(&#10;                    song = Song(&#10;                        number = index + 1,&#10;                        title = track.name,&#10;                        artist = track.getArtistNames(),&#10;                        youtubeId = track.id,&#10;                        spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                    ),&#10;                    trackEntities = tracksEntities,&#10;                    index = index,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    isSelected = true,&#10;                    customButtonIcon = &quot;x&quot;,&#10;                    customButtonAction = {&#10;                        selectedTracks = selectedTracks.filterIndexed { i, _ -&gt; i != index }&#10;                    },&#10;                    modifier = Modifier.fillMaxWidth()&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(Modifier.height(16.dp))&#10;        Text(&#10;            text = if (isLoading) &quot;&lt;creating...&gt;&quot; else &quot;&lt;create&gt;&quot;,&#10;            style = MaterialTheme.typography.bodyMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 14.sp,&#10;                color = if (isLoading) Color(0xFFFFD93D) else Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable(enabled = !isLoading &amp;&amp; playlistName.isNotBlank()) {&#10;                    // Acción de crear playlist con las canciones seleccionadas&#10;                    isLoading = true&#10;                    error = null&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        val trackIds = selectedTracks.map { it.id }&#10;                        SpotifyRepository.createPlaylist(&#10;                            accessToken,&#10;                            playlistName,&#10;                            playlistDesc,&#10;                            isPublic,&#10;                            trackIds&#10;                        ) { success, errMsg -&gt;&#10;                            isLoading = false&#10;                            if (success) {&#10;                                // Sincronizar playlists después de crear&#10;                                coroutineScope.launch {&#10;                                    localRepository.syncPlaylistsFromSpotify()&#10;                                }&#10;                                onPlaylistCreated()&#10;                            } else {&#10;                                error = errMsg ?: &quot;Unknown error&quot;&#10;                            }&#10;                        }&#10;                    } else {&#10;                        isLoading = false&#10;                        error = &quot;Spotify not connected&quot;&#10;                    }&#10;                }&#10;                .padding(8.dp)&#10;        )&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&quot;${Translations.get(context, &quot;error_prefix&quot;)}$it&quot;, color = Color.Red)&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SpotifyPlaylistDetailView(&#10;    playlist: SpotifyPlaylist,&#10;    tracks: List&lt;SpotifyTrack&gt;,&#10;    trackEntities: List&lt;TrackEntity&gt;? = null,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onStart: () -&gt; Unit,&#10;    onRandom: () -&gt; Unit,&#10;    onSave: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        Titulo(playlist.name)&#10;&#10;        // Botones de acción&#10;        ActionButtonsGroup(&#10;            buttons = listOf(&#10;                ActionButtonData(&quot;&lt;start&gt;&quot;, Color(0xFF4ECDC4), onStart, tracks.isNotEmpty()),&#10;                ActionButtonData(&quot;&lt;rand&gt;&quot;, Color(0xFFFFD93D), onRandom, tracks.isNotEmpty()),&#10;                ActionButtonData(&quot;&lt;save&gt;&quot;, Color(0xFF7FB069), onSave, true),&#10;                ActionButtonData(&quot;&lt;share&gt;&quot;, Color(0xFFFF6B9D), { showShareDialog = true }, true)&#10;            )&#10;        )&#10;&#10;        // Estados de carga y error&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading tracks...&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                ),&#10;                modifier = Modifier.padding(bottom = 8.dp)&#10;            )&#10;        }&#10;&#10;        //listado canciones&#10;        if (tracks.isNotEmpty()) {&#10;            SongList(&#10;                playlist = playlist,&#10;                tracks = tracks,&#10;                trackEntities = trackEntities,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = playlist.id,&#10;                spotifyUrl = &quot;https://open.spotify.com/playlist/${playlist.id}&quot;,&#10;                youtubeId = null,&#10;                title = playlist.name,&#10;                artist = &quot;Playlist&quot;,&#10;                type = ShareType.PLAYLIST&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/SongListItem.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/SongListItem.kt" />
              <option name="originalContent" value="package com.plyr.ui.components&#10;&#10;import android.util.Log&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextAlign&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.background&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.window.Dialog&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.animation.core.Animatable&#10;import androidx.compose.animation.core.tween&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#10;import androidx.compose.ui.input.pointer.pointerInput&#10;import androidx.compose.ui.unit.IntOffset&#10;import androidx.compose.ui.platform.LocalDensity&#10;import kotlin.math.absoluteValue&#10;import kotlin.math.roundToInt&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.utils.Config&#10;import com.plyr.utils.DownloadManager&#10;import com.plyr.utils.Translations&#10;import com.plyr.database.PlaylistDatabase&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import kotlinx.coroutines.Dispatchers&#10;import com.plyr.ui.theme.PlyrSpacing&#10;import com.plyr.ui.theme.PlyrTextStyles&#10;&#10;// Data class para unificar los datos de la canción&#10;data class Song(&#10;    val number: Int,&#10;    val title: String,&#10;    val artist: String,&#10;    val spotifyId: String? = null,&#10;    val youtubeId: String? = null,&#10;    val spotifyUrl: String? = null&#10;)&#10;&#10;// Helper function para obtener icono y color según la acción&#10;private fun getSwipeIconAndColor(action: String): Pair&lt;String, Color&gt; {&#10;    return when (action) {&#10;        Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; &quot;+&quot; to Color(0xFF3FFFEF)&#10;        Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; &quot;♥&quot; to Color(0xFFFF6B9D)&#10;        Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; &quot;≡&quot; to Color(0xFFFFB84D)&#10;        Config.SWIPE_ACTION_SHARE -&gt; &quot;⤴&quot; to Color(0xFF9B59B6)&#10;        Config.SWIPE_ACTION_DOWNLOAD -&gt; &quot;↓&quot; to Color(0xFF2ECC71)&#10;        else -&gt; &quot;?&quot; to Color(0xFF95A5A6)&#10;    }&#10;}&#10;&#10;@Composable&#10;fun SongListItem(&#10;    song: Song,&#10;    trackEntities: List&lt;TrackEntity&gt;,&#10;    index: Int,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    modifier: Modifier = Modifier,&#10;    isSelected: Boolean = false,&#10;    onLikedStatusChanged: (() -&gt; Unit)? = null,&#10;    customButtonIcon: String? = null, // Nueva: Icono personalizado para el botón (ej: &quot;+&quot;)&#10;    customButtonAction: (() -&gt; Unit)? = null // Nueva: Acción personalizada para el botón&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val context = LocalContext.current&#10;    var showPopup by remember { mutableStateOf(false) }&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;    var showPlaylistDialog by remember { mutableStateOf(false) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;com.plyr.network.SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;    var addToPlaylistError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var addToPlaylistSuccess by remember { mutableStateOf(false) }&#10;    var isLoadingTrackInfo by remember { mutableStateOf(false) }&#10;    var fetchedTrackInfo by remember { mutableStateOf&lt;com.plyr.network.SpotifyTrack?&gt;(null) }&#10;    var fetchInfoError by remember { mutableStateOf&lt;String?&gt;(null) }&#10;    var isLiked by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;&#10;    // Obtener las acciones configuradas y sus iconos/colores&#10;    val swipeRightAction = Config.getSwipeRightAction(context)&#10;    val swipeLeftAction = Config.getSwipeLeftAction(context)&#10;    val (rightIcon, rightColor) = getSwipeIconAndColor(swipeRightAction)&#10;    val (leftIcon, leftColor) = getSwipeIconAndColor(swipeLeftAction)&#10;&#10;    // Swipe gesture state&#10;    val offsetX = remember { Animatable(0f) }&#10;    val density = LocalDensity.current&#10;    val swipeThreshold = with(density) { 30.dp.toPx() } // Umbral muy bajo, solo para detectar intención&#10;&#10;    // Reset swipe position&#10;    fun resetSwipe() {&#10;        coroutineScope.launch {&#10;            offsetX.animateTo(&#10;                targetValue = 0f,&#10;                animationSpec = tween(durationMillis = 300)&#10;            )&#10;        }&#10;    }&#10;&#10;    Box(&#10;        modifier = modifier&#10;            .fillMaxWidth()&#10;            .height(32.dp)&#10;    ) {&#10;        // Background actions - Right swipe (like/favorite)&#10;        if (offsetX.value &gt; 0) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxHeight()&#10;                    .width(with(density) { offsetX.value.toDp() })&#10;                    .background(Color.Transparent),&#10;                contentAlignment = Alignment.CenterStart&#10;            ) {&#10;                Text(&#10;                    text = rightIcon,&#10;                    color = rightColor,&#10;                    style = MaterialTheme.typography.titleMedium,&#10;                    modifier = Modifier.padding(start = 16.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Background actions - Left swipe (add to queue)&#10;        if (offsetX.value &lt; 0) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .fillMaxHeight()&#10;                    .width(with(density) { (-offsetX.value).toDp() })&#10;                    .align(Alignment.CenterEnd)&#10;                    .background(Color.Transparent),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = leftIcon,&#10;                    color = leftColor,&#10;                    style = MaterialTheme.typography.titleLarge,&#10;                    fontWeight = FontWeight.Bold&#10;                )&#10;            }&#10;        }&#10;&#10;        // Main content (draggable)&#10;        Row(&#10;            modifier = Modifier&#10;                .offset { IntOffset(offsetX.value.roundToInt(), 0) }&#10;                .pointerInput(Unit) {&#10;                    detectHorizontalDragGestures(&#10;                        onDragEnd = {&#10;                            Log.d(&quot;SongListItem&quot;, &quot;onDragEnd - offsetX.value = ${offsetX.value}, swipeThreshold = $swipeThreshold&quot;)&#10;                            coroutineScope.launch {&#10;                                when {&#10;                                    offsetX.value &gt; swipeThreshold -&gt; {&#10;                                        // Complete right swipe - Execute configured action&#10;                                        val action = Config.getSwipeRightAction(context)&#10;                                        Log.d(&quot;SongListItem&quot;, &quot; RIGHT SWIPE DETECTED - Action: $action&quot;)&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                        executeSwipeAction(&#10;                                            action = action,&#10;                                            song = song,&#10;                                            context = context,&#10;                                            playerViewModel = playerViewModel,&#10;                                            trackEntities = trackEntities,&#10;                                            index = index,&#10;                                            coroutineScope = coroutineScope,&#10;                                            onLikedStatusChanged = onLikedStatusChanged,&#10;                                            onShowPlaylistDialog = { showPlaylistDialog = true },&#10;                                            onShowShareDialog = { showShareDialog = true }&#10;                                        )&#10;                                        resetSwipe()&#10;                                    }&#10;                                    offsetX.value &lt; -swipeThreshold -&gt; {&#10;                                        // Complete left swipe - Execute configured action&#10;                                        val action = Config.getSwipeLeftAction(context)&#10;                                        Log.d(&quot;SongListItem&quot;, &quot; LEFT SWIPE DETECTED - Action: $action&quot;)&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#10;                                        executeSwipeAction(&#10;                                            action = action,&#10;                                            song = song,&#10;                                            context = context,&#10;                                            playerViewModel = playerViewModel,&#10;                                            trackEntities = trackEntities,&#10;                                            index = index,&#10;                                            coroutineScope = coroutineScope,&#10;                                            onLikedStatusChanged = onLikedStatusChanged,&#10;                                            onShowPlaylistDialog = { showPlaylistDialog = true },&#10;                                            onShowShareDialog = { showShareDialog = true }&#10;                                        )&#10;                                        resetSwipe()&#10;                                    }&#10;                                    else -&gt; {&#10;                                        // Return to center&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;Swipe not enough, returning to center&quot;)&#10;                                        resetSwipe()&#10;                                    }&#10;                                }&#10;                            }&#10;                        },&#10;                        onHorizontalDrag = { _, dragAmount -&gt;&#10;                            coroutineScope.launch {&#10;                                val newValue = (offsetX.value + dragAmount).coerceIn(-200f, 150f)&#10;                                offsetX.snapTo(newValue)&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;                .clickable {&#10;                    if (offsetX.value.absoluteValue &lt; 10f) {&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                        playerViewModel?.let { viewModel -&gt;&#10;                            if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                viewModel.setCurrentPlaylist(trackEntities, index)&#10;                                val selectedTrackEntity = trackEntities[index]&#10;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;SongListItem&quot;, &quot; REPRODUCIR TRACK&quot;)&#10;                                Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Track: ${selectedTrackEntity.name}&quot;)&#10;                                Log.d(&quot;SongListItem&quot;, &quot;AudioUrl: ${selectedTrackEntity.audioUrl}&quot;)&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Es archivo local: ${selectedTrackEntity.audioUrl?.startsWith(&quot;/&quot;) == true}&quot;)&#10;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        viewModel.loadAudioFromTrack(selectedTrackEntity)&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;✓ loadAudioFromTrack llamado exitosamente&quot;)&#10;                                    } catch (e: Exception) {&#10;                                        Log.e(&quot;SongListItem&quot;, &quot;✗ Error al reproducir track&quot;, e)&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    } else {&#10;                        resetSwipe()&#10;                    }&#10;                }&#10;                .fillMaxWidth()&#10;                .height(32.dp)&#10;                .background(Color.Transparent),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Track number&#10;            Text(&#10;                text = song.number.toString(),&#10;                style = PlyrTextStyles.trackArtist(),&#10;                modifier = Modifier.padding(end = PlyrSpacing.small, start = 8.dp)&#10;            )&#10;            // Song title and artist&#10;            Column(&#10;                modifier = Modifier.weight(1f),&#10;                verticalArrangement = Arrangement.Center&#10;            ) {&#10;                Text(&#10;                    text = song.title,&#10;                    style = if (isSelected)&#10;                        PlyrTextStyles.selectableOption(true)&#10;                    else&#10;                        PlyrTextStyles.trackTitle(),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;                Text(&#10;                    text = song.artist,&#10;                    style = PlyrTextStyles.trackArtist(),&#10;                    maxLines = 1,&#10;                    overflow = TextOverflow.Ellipsis,&#10;                    modifier = Modifier.padding(top = 0.dp)&#10;                )&#10;            }&#10;            // Botón personalizable&#10;            IconButton(onClick = {&#10;                if (customButtonAction != null) {&#10;                    customButtonAction()&#10;                } else {&#10;                    showPopup = true&#10;                }&#10;            }, modifier = Modifier.size(32.dp)) {&#10;                Text(&#10;                    text = customButtonIcon ?: &quot;*&quot;,&#10;                    style = PlyrTextStyles.menuOption(),&#10;                    color = Color(0xFF3FFFEF)&#10;                )&#10;            }&#10;        }&#10;    }&#10;&#10;    // Solo mostrar popup si no hay acción personalizada&#10;    if (showPopup &amp;&amp; customButtonAction == null) {&#10;        // Cargar información de la canción cuando se abre el popup&#10;        LaunchedEffect(true) {&#10;            if (showPopup &amp;&amp; song.spotifyId != null) {&#10;                isLoadingTrackInfo = true&#10;                fetchInfoError = null&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    // Obtener info del track&#10;                    SpotifyRepository.getTrackInfo(accessToken, song.spotifyId) { trackInfo, error -&gt;&#10;                        isLoadingTrackInfo = false&#10;                        if (trackInfo != null) {&#10;                            fetchedTrackInfo = trackInfo&#10;                        } else {&#10;                            fetchInfoError = error ?: &quot;Error fetching track info&quot;&#10;                        }&#10;                    }&#10;&#10;                    // Verificar si está en Liked Songs&#10;                    SpotifyRepository.checkSavedTrack(accessToken, song.spotifyId) { liked, error -&gt;&#10;                        if (error == null) {&#10;                            isLiked = liked&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTrackInfo = false&#10;                    fetchInfoError = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            }&#10;        }&#10;&#10;        Dialog(onDismissRequest = {&#10;            showPopup = false&#10;            fetchedTrackInfo = null&#10;            fetchInfoError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Sección de información del track&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(150.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingTrackInfo -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = Translations.get(context, &quot;loading&quot;),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchInfoError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayMedium.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = fetchInfoError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            fetchedTrackInfo != null -&gt; {&#10;                                // Mostrar información de la canción&#10;                                val trackInfo = fetchedTrackInfo&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.name ?: song.title,&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                                color = Color.White,&#10;                                                fontWeight = FontWeight.Bold&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = trackInfo?.artists?.joinToString(&quot;, &quot;) { it.name } ?: song.artist,&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                color = Color(0xFFAAAAAA)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                    trackInfo?.album?.let { album -&gt;&#10;                                        item {&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#10;                                            Text(&#10;                                                text = &quot;Album: ${album.name}&quot;,&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                                    color = Color(0xFF888888)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                        album.releaseDate?.let { date -&gt;&#10;                                            item {&#10;                                                Text(&#10;                                                    text = &quot;Release: $date&quot;,&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#10;                                                        color = Color(0xFF888888)&#10;                                                    )&#10;                                                )&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                    item {&#10;                                        Text(&#10;                                            text = &quot;Duration: ${trackInfo?.durationMs?.let { ms -&gt; &#10;                                                val minutes = ms / 60000&#10;                                                val seconds = &quot;%02d&quot;.format((ms % 60000) / 1000)&#10;                                                &quot;$minutes:$seconds&quot;&#10;                                            } ?: &quot;N/A&quot;}&quot;,&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                color = Color(0xFF888888)&#10;                                            )&#10;                                        )&#10;                                    }&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Mostrar info básica mientras carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.Start,&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    Text(&#10;                                        text = song.title,&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#10;                                            color = Color.White,&#10;                                            fontWeight = FontWeight.Bold&#10;                                        )&#10;                                    )&#10;                                    Text(&#10;                                        text = song.artist,&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFFAAAAAA)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;&#10;                    // Botones de acción&#10;                    Column(&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp),&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        // Add to Playlist&#10;                        Text(&#10;                            text = Translations.get(context, &quot;add_to_playlist&quot;),&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#10;                                        showPopup = false&#10;                                        showPlaylistDialog = true&#10;                                        isLoadingPlaylists = true&#10;                                        addToPlaylistError = null&#10;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null) {&#10;                                            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#10;                                                isLoadingPlaylists = false&#10;                                                if (playlists != null) {&#10;                                                    userPlaylists = playlists&#10;                                                } else {&#10;                                                    addToPlaylistError = error ?: &quot;Error cargando playlists&quot;&#10;                                                }&#10;                                            }&#10;                                        } else {&#10;                                            isLoadingPlaylists = false&#10;                                            addToPlaylistError = &quot;Token de Spotify no disponible&quot;&#10;                                        }&#10;                                    } else {&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#10;                                        showPopup = false&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Add to Queue&#10;                        Text(&#10;                            text = Translations.get(context, &quot;add_to_queue&quot;),&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showPopup = false&#10;                                    playerViewModel?.let { viewModel -&gt;&#10;                                        if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                            val trackToAdd = trackEntities[index]&#10;                                            viewModel.addToQueue(trackToAdd)&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Share&#10;                        Text(&#10;                            text = Translations.get(context, &quot;share&quot;),&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showShareDialog = true&#10;                                    showPopup = false&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Like / Unlike&#10;                        Text(&#10;                            text = if (isLiked == true) Translations.get(context, &quot;remove_from_liked_songs&quot;) else Translations.get(context, &quot;add_to_liked_songs&quot;),&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    // Acción de agregar/quitar de Liked Songs&#10;                                    showPopup = false&#10;                                    isLiked?.let { currentlyLiked -&gt;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                            isLoadingTrackInfo = true&#10;                                            if (currentlyLiked) {&#10;                                                // Quitar de Liked Songs&#10;                                                SpotifyRepository.removeTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = false&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción quitada de Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error quitando canción de Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            } else {&#10;                                                // Añadir a Liked Songs&#10;                                                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                                                    isLoadingTrackInfo = false&#10;                                                    if (success) {&#10;                                                        isLiked = true&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a Liked Songs&quot;)&#10;                                                        onLikedStatusChanged?.invoke()&#10;                                                    } else {&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción a Liked Songs: $error&quot;)&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;&#10;                        // Download&#10;                        Text(&#10;                            text = Translations.get(context, &quot;download&quot;),&#10;                            color = Color(0xFF3FFFEF),&#10;                            fontWeight = FontWeight.Normal,&#10;                            textAlign = TextAlign.Center,&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .clickable {&#10;                                    showPopup = false&#10;                                    coroutineScope.launch {&#10;                                        // Obtener el youtubeId&#10;                                        val trackEntity = if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                                            trackEntities[index]&#10;                                        } else null&#10;&#10;                                        val initialYoutubeId = trackEntity?.youtubeVideoId ?: song.youtubeId&#10;&#10;                                        // Si no tenemos youtubeId, buscarlo&#10;                                        val finalYoutubeId = if (initialYoutubeId == null) {&#10;                                            withContext(Dispatchers.IO) {&#10;                                                val searchQuery = &quot;${song.title} ${song.artist}&quot;&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;YouTube ID not available, searching with query: '$searchQuery'&quot;)&#10;                                                val foundId = com.plyr.network.YouTubeManager.searchVideoId(searchQuery)&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;YouTube search result: ${if (foundId != null) &quot;Found ID: $foundId&quot; else &quot;NOT FOUND&quot;}&quot;)&#10;                                                foundId&#10;                                            }&#10;                                        } else {&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;Using existing YouTube ID: $initialYoutubeId&quot;)&#10;                                            initialYoutubeId&#10;                                        }&#10;&#10;                                        if (finalYoutubeId != null) {&#10;                                            // Verificar si ya está descargada usando YouTube ID&#10;                                            val database = PlaylistDatabase.getDatabase(context)&#10;                                            val alreadyDownloaded = database.downloadedTrackDao()&#10;                                                .isTrackDownloadedByYoutubeId(finalYoutubeId) &gt; 0&#10;&#10;                                            if (alreadyDownloaded) {&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Track already downloaded&quot;)&#10;                                            } else {&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Starting download: ${song.title}&quot;)&#10;                                                DownloadManager.downloadTrack(&#10;                                                    context = context,&#10;                                                    spotifyTrackId = song.spotifyId,&#10;                                                    youtubeVideoId = finalYoutubeId,&#10;                                                    trackName = song.title,&#10;                                                    artists = song.artist,&#10;                                                    onProgress = { progress -&gt;&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;Download progress: $progress%&quot;)&#10;                                                    },&#10;                                                    onComplete = { success, error -&gt;&#10;                                                        if (success) {&#10;                                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Download completed: ${song.title}&quot;)&#10;                                                        } else {&#10;                                                            Log.e(&quot;SongListItem&quot;, &quot;✗ Download failed: $error&quot;)&#10;                                                        }&#10;                                                    }&#10;                                                )&#10;                                            }&#10;                                        } else {&#10;                                            Log.e(&quot;SongListItem&quot;, &quot;Cannot download: YouTube video not found for query: '${song.title} ${song.artist}'&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                                .padding(vertical = 4.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Diálogo de selección de playlist&#10;    if (showPlaylistDialog) {&#10;        Dialog(onDismissRequest = {&#10;            showPlaylistDialog = false&#10;            addToPlaylistSuccess = false&#10;            addToPlaylistError = null&#10;        }) {&#10;            Box(&#10;                modifier = Modifier&#10;                    .clip(RoundedCornerShape(24.dp))&#10;                    .background(Color(0xFF181818))&#10;                    .padding(24.dp)&#10;                    .fillMaxWidth(0.9f)&#10;            ) {&#10;                Column(&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#10;                ) {&#10;                    // Contenido del diálogo&#10;                    Box(&#10;                        modifier = Modifier&#10;                            .fillMaxWidth()&#10;                            .height(300.dp)&#10;                    ) {&#10;                        when {&#10;                            isLoadingPlaylists -&gt; {&#10;                                // Estado de carga&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = Translations.get(context, &quot;loading_playlists&quot;),&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistSuccess -&gt; {&#10;                                // Éxito&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✓&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFF4ECDC4)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = Translations.get(context, &quot;track_added_successfully&quot;),&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color.White&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            addToPlaylistError != null -&gt; {&#10;                                // Error&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = &quot;✗&quot;,&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        )&#10;                                    )&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#10;                                    Text(&#10;                                        text = addToPlaylistError ?: &quot;Error&quot;,&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#10;                                            color = Color(0xFFFF6B6B)&#10;                                        ),&#10;                                        textAlign = TextAlign.Center&#10;                                    )&#10;                                }&#10;                            }&#10;                            userPlaylists.isEmpty() -&gt; {&#10;                                // Sin playlists&#10;                                Column(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#10;                                    verticalArrangement = Arrangement.Center&#10;                                ) {&#10;                                    Text(&#10;                                        text = Translations.get(context, &quot;no_playlists_found&quot;),&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            color = Color(0xFF888888)&#10;                                        )&#10;                                    )&#10;                                }&#10;                            }&#10;                            else -&gt; {&#10;                                // Lista de playlists&#10;                                LazyColumn(&#10;                                    modifier = Modifier.fillMaxSize(),&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#10;                                ) {&#10;                                    items(userPlaylists) { playlist -&gt;&#10;                                        Row(&#10;                                            modifier = Modifier&#10;                                                .fillMaxWidth()&#10;                                                .clip(RoundedCornerShape(8.dp))&#10;                                                .clickable {&#10;                                                    // Añadir la canción a la playlist&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                                                        isLoadingPlaylists = true&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#10;                                                            accessToken,&#10;                                                            playlist.id,&#10;                                                            song.spotifyId&#10;                                                        ) { success, error -&gt;&#10;                                                            isLoadingPlaylists = false&#10;                                                            if (success) {&#10;                                                                addToPlaylistSuccess = true&#10;                                                                Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a '${playlist.name}'&quot;)&#10;                                                                // Cerrar el diálogo después de 1.5 segundos&#10;                                                                coroutineScope.launch {&#10;                                                                    kotlinx.coroutines.delay(1500)&#10;                                                                    showPlaylistDialog = false&#10;                                                                    addToPlaylistSuccess = false&#10;                                                                }&#10;                                                            } else {&#10;                                                                addToPlaylistError = error&#10;                                                                Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción: $error&quot;)&#10;                                                            }&#10;                                                        }&#10;                                                    }&#10;                                                }&#10;                                                .background(Color(0xFF252525))&#10;                                                .padding(12.dp),&#10;                                            verticalAlignment = Alignment.CenterVertically&#10;                                        ) {&#10;                                            Column(&#10;                                                modifier = Modifier.weight(1f)&#10;                                            ) {&#10;                                                Text(&#10;                                                    text = playlist.name,&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                                        color = Color.White&#10;                                                    ),&#10;                                                    maxLines = 1,&#10;                                                    overflow = TextOverflow.Ellipsis&#10;                                                )&#10;                                                playlist.description?.let { desc -&gt;&#10;                                                    if (desc.isNotBlank()) {&#10;                                                        Text(&#10;                                                            text = desc,&#10;                                                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                                                color = Color(0xFF888888)&#10;                                                            ),&#10;                                                            maxLines = 1,&#10;                                                            overflow = TextOverflow.Ellipsis&#10;                                                        )&#10;                                                    }&#10;                                                }&#10;                                            }&#10;                                            Text(&#10;                                                text = &quot;&gt;&quot;,&#10;                                                style = MaterialTheme.typography.bodyLarge.copy(&#10;                                                    color = Color(0xFF4ECDC4)&#10;                                                )&#10;                                            )&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = song.spotifyId,&#10;                spotifyUrl = song.spotifyUrl,&#10;                youtubeId = song.youtubeId,&#10;                title = song.title,&#10;                artist = song.artist,&#10;                type = ShareType.TRACK&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}&#10;&#10;fun executeSwipeAction(&#10;    action: String,&#10;    song: Song,&#10;    context: android.content.Context,&#10;    playerViewModel: PlayerViewModel?,&#10;    trackEntities: List&lt;TrackEntity&gt;,&#10;    index: Int,&#10;    coroutineScope: CoroutineScope,&#10;    onLikedStatusChanged: (() -&gt; Unit)?,&#10;    onShowPlaylistDialog: () -&gt; Unit,&#10;    onShowShareDialog: () -&gt; Unit&#10;) {&#10;    when (action) {&#10;        Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; {&#10;            // Añadir a favoritos&#10;            val accessToken = Config.getSpotifyAccessToken(context)&#10;            if (accessToken != null &amp;&amp; song.spotifyId != null) {&#10;                Log.d(&quot;SongListItem&quot;, &quot;Calling saveTrack with spotifyId: ${song.spotifyId}&quot;)&#10;                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#10;                    if (success) {&#10;                        onLikedStatusChanged?.invoke()&#10;                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a favoritos&quot;)&#10;                    } else {&#10;                        Log.e(&quot;SongListItem&quot;, &quot;✗ Error añadiendo a favoritos: $error&quot;)&#10;                    }&#10;                }&#10;            } else {&#10;                Log.e(&quot;SongListItem&quot;, &quot;✗ No se puede añadir a favoritos: accessToken=${accessToken != null}, spotifyId=${song.spotifyId}&quot;)&#10;            }&#10;        }&#10;        Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; {&#10;            // Añadir a cola&#10;            playerViewModel?.let { viewModel -&gt;&#10;                if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                    val trackToAdd = trackEntities[index]&#10;                    viewModel.addToQueue(trackToAdd)&#10;                    Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#10;                } else {&#10;                    Log.e(&quot;SongListItem&quot;, &quot;✗ Invalid index or empty trackEntities&quot;)&#10;                }&#10;            } ?: Log.e(&quot;SongListItem&quot;, &quot;✗ PlayerViewModel is null&quot;)&#10;        }&#10;        Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; {&#10;            // Añadir a playlist&#10;            if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#10;                onShowPlaylistDialog()&#10;            } else {&#10;                Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#10;            }&#10;        }&#10;        Config.SWIPE_ACTION_SHARE -&gt; {&#10;            // Compartir&#10;            onShowShareDialog()&#10;        }&#10;        Config.SWIPE_ACTION_DOWNLOAD -&gt; {&#10;            // Descargar&#10;            coroutineScope.launch {&#10;                // Obtener el youtubeId&#10;                val trackEntity = if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#10;                    trackEntities[index]&#10;                } else null&#10;&#10;                val initialYoutubeId = trackEntity?.youtubeVideoId ?: song.youtubeId&#10;&#10;                // Si no tenemos youtubeId, buscarlo&#10;                val finalYoutubeId = initialYoutubeId&#10;                    ?: withContext(Dispatchers.IO) {&#10;                        val searchQuery = &quot;${song.title} ${song.artist}&quot;&#10;                        Log.d(&quot;SongListItem&quot;, &quot;YouTube ID not available, searching with query: '$searchQuery'&quot;)&#10;                        com.plyr.network.YouTubeManager.searchVideoId(searchQuery)&#10;                    }&#10;&#10;                if (finalYoutubeId != null) {&#10;                    // Verificar si ya está descargada usando YouTube ID&#10;                    val database = PlaylistDatabase.getDatabase(context)&#10;                    val alreadyDownloaded = database.downloadedTrackDao()&#10;                        .isTrackDownloadedByYoutubeId(finalYoutubeId) &gt; 0&#10;&#10;                    if (alreadyDownloaded) {&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Track already downloaded&quot;)&#10;                    } else {&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Starting download: ${song.title}&quot;)&#10;                        DownloadManager.downloadTrack(&#10;                            context = context,&#10;                            spotifyTrackId = song.spotifyId,&#10;                            youtubeVideoId = finalYoutubeId,&#10;                            trackName = song.title,&#10;                            artists = song.artist,&#10;                            onProgress = { progress -&gt;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Download progress: $progress%&quot;)&#10;                            },&#10;                            onComplete = { success, error -&gt;&#10;                                if (success) {&#10;                                    Log.d(&quot;SongListItem&quot;, &quot;✓ Download completed: ${song.title}&quot;)&#10;                                } else {&#10;                                    Log.e(&quot;SongListItem&quot;, &quot;✗ Download failed: $error&quot;)&#10;                                }&#10;                            }&#10;                        )&#10;                    }&#10;                } else {&#10;                    Log.e(&quot;SongListItem&quot;, &quot;Cannot download: YouTube video not found&quot;)&#10;                }&#10;            }&#10;        }&#10;        else -&gt; {&#10;            Log.w(&quot;SongListItem&quot;, &quot;Acción desconocida para swipe: $action&quot;)&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components&#13;&#10;&#13;&#10;import android.util.Log&#13;&#10;import androidx.compose.foundation.clickable&#13;&#10;import androidx.compose.foundation.layout.*&#13;&#10;import androidx.compose.material3.*&#13;&#10;import androidx.compose.runtime.*&#13;&#10;import androidx.compose.ui.Alignment&#13;&#10;import androidx.compose.ui.Modifier&#13;&#10;import androidx.compose.ui.graphics.Color&#13;&#10;import androidx.compose.ui.unit.dp&#13;&#10;import androidx.compose.ui.text.font.FontWeight&#13;&#10;import androidx.compose.ui.text.style.TextAlign&#13;&#10;import androidx.compose.ui.draw.clip&#13;&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#13;&#10;import androidx.compose.foundation.background&#13;&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#13;&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#13;&#10;import androidx.compose.ui.text.style.TextOverflow&#13;&#10;import androidx.compose.ui.window.Dialog&#13;&#10;import androidx.compose.ui.platform.LocalContext&#13;&#10;import androidx.compose.foundation.lazy.LazyColumn&#13;&#10;import androidx.compose.foundation.lazy.items&#13;&#10;import androidx.compose.animation.core.Animatable&#13;&#10;import androidx.compose.animation.core.tween&#13;&#10;import androidx.compose.foundation.gestures.detectHorizontalDragGestures&#13;&#10;import androidx.compose.ui.input.pointer.pointerInput&#13;&#10;import androidx.compose.ui.unit.IntOffset&#13;&#10;import androidx.compose.ui.platform.LocalDensity&#13;&#10;import kotlin.math.absoluteValue&#13;&#10;import kotlin.math.roundToInt&#13;&#10;import com.plyr.database.TrackEntity&#13;&#10;import com.plyr.viewmodel.PlayerViewModel&#13;&#10;import com.plyr.network.SpotifyRepository&#13;&#10;import com.plyr.utils.Config&#13;&#10;import com.plyr.utils.DownloadManager&#13;&#10;import com.plyr.utils.Translations&#13;&#10;import com.plyr.database.PlaylistDatabase&#13;&#10;import kotlinx.coroutines.CoroutineScope&#13;&#10;import kotlinx.coroutines.launch&#13;&#10;import kotlinx.coroutines.withContext&#13;&#10;import kotlinx.coroutines.Dispatchers&#13;&#10;import com.plyr.ui.theme.PlyrSpacing&#13;&#10;import com.plyr.ui.theme.PlyrTextStyles&#13;&#10;&#13;&#10;// Data class para unificar los datos de la canción&#13;&#10;data class Song(&#13;&#10;    val number: Int,&#13;&#10;    val title: String,&#13;&#10;    val artist: String,&#13;&#10;    val spotifyId: String? = null,&#13;&#10;    val youtubeId: String? = null,&#13;&#10;    val spotifyUrl: String? = null&#13;&#10;)&#13;&#10;&#13;&#10;// Helper function para obtener icono y color según la acción&#13;&#10;private fun getSwipeIconAndColor(action: String): Pair&lt;String, Color&gt; {&#13;&#10;    return when (action) {&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; &quot;+&quot; to Color(0xFF3FFFEF)&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; &quot;♥&quot; to Color(0xFFFF6B9D)&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; &quot;≡&quot; to Color(0xFFFFB84D)&#13;&#10;        Config.SWIPE_ACTION_SHARE -&gt; &quot;⤴&quot; to Color(0xFF9B59B6)&#13;&#10;        Config.SWIPE_ACTION_DOWNLOAD -&gt; &quot;↓&quot; to Color(0xFF2ECC71)&#13;&#10;        else -&gt; &quot;?&quot; to Color(0xFF95A5A6)&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;@Composable&#13;&#10;fun SongListItem(&#13;&#10;    song: Song,&#13;&#10;    trackEntities: List&lt;TrackEntity&gt;,&#13;&#10;    index: Int,&#13;&#10;    playerViewModel: PlayerViewModel?,&#13;&#10;    coroutineScope: CoroutineScope,&#13;&#10;    modifier: Modifier = Modifier,&#13;&#10;    isSelected: Boolean = false,&#13;&#10;    onLikedStatusChanged: (() -&gt; Unit)? = null,&#13;&#10;    customButtonIcon: String? = null, // Nueva: Icono personalizado para el botón (ej: &quot;+&quot;)&#13;&#10;    customButtonAction: (() -&gt; Unit)? = null // Nueva: Acción personalizada para el botón&#13;&#10;) {&#13;&#10;    val haptic = LocalHapticFeedback.current&#13;&#10;    val context = LocalContext.current&#13;&#10;    var showPopup by remember { mutableStateOf(false) }&#13;&#10;    var showShareDialog by remember { mutableStateOf(false) }&#13;&#10;    var showPlaylistDialog by remember { mutableStateOf(false) }&#13;&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;com.plyr.network.SpotifyPlaylist&gt;&gt;(emptyList()) }&#13;&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#13;&#10;    var addToPlaylistError by remember { mutableStateOf&lt;String?&gt;(null) }&#13;&#10;    var addToPlaylistSuccess by remember { mutableStateOf(false) }&#13;&#10;    var isLoadingTrackInfo by remember { mutableStateOf(false) }&#13;&#10;    var fetchedTrackInfo by remember { mutableStateOf&lt;com.plyr.network.SpotifyTrack?&gt;(null) }&#13;&#10;    var fetchInfoError by remember { mutableStateOf&lt;String?&gt;(null) }&#13;&#10;    var isLiked by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#13;&#10;&#13;&#10;    // Obtener las acciones configuradas y sus iconos/colores&#13;&#10;    val swipeRightAction = Config.getSwipeRightAction(context)&#13;&#10;    val swipeLeftAction = Config.getSwipeLeftAction(context)&#13;&#10;    val (rightIcon, rightColor) = getSwipeIconAndColor(swipeRightAction)&#13;&#10;    val (leftIcon, leftColor) = getSwipeIconAndColor(swipeLeftAction)&#13;&#10;&#13;&#10;    // Swipe gesture state&#13;&#10;    val offsetX = remember { Animatable(0f) }&#13;&#10;    val density = LocalDensity.current&#13;&#10;    val swipeThreshold = with(density) { 30.dp.toPx() } // Umbral muy bajo, solo para detectar intención&#13;&#10;&#13;&#10;    // Reset swipe position&#13;&#10;    fun resetSwipe() {&#13;&#10;        coroutineScope.launch {&#13;&#10;            offsetX.animateTo(&#13;&#10;                targetValue = 0f,&#13;&#10;                animationSpec = tween(durationMillis = 300)&#13;&#10;            )&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    Box(&#13;&#10;        modifier = modifier&#13;&#10;            .fillMaxWidth()&#13;&#10;            .height(32.dp)&#13;&#10;    ) {&#13;&#10;        // Background actions - Right swipe (like/favorite)&#13;&#10;        if (offsetX.value &gt; 0) {&#13;&#10;            Box(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxHeight()&#13;&#10;                    .width(with(density) { offsetX.value.toDp() })&#13;&#10;                    .background(Color.Transparent),&#13;&#10;                contentAlignment = Alignment.CenterStart&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    text = rightIcon,&#13;&#10;                    color = rightColor,&#13;&#10;                    style = MaterialTheme.typography.titleMedium,&#13;&#10;                    modifier = Modifier.padding(start = 16.dp)&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Background actions - Left swipe (add to queue)&#13;&#10;        if (offsetX.value &lt; 0) {&#13;&#10;            Box(&#13;&#10;                modifier = Modifier&#13;&#10;                    .fillMaxHeight()&#13;&#10;                    .width(with(density) { (-offsetX.value).toDp() })&#13;&#10;                    .align(Alignment.CenterEnd)&#13;&#10;                    .background(Color.Transparent),&#13;&#10;                contentAlignment = Alignment.Center&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    text = leftIcon,&#13;&#10;                    color = leftColor,&#13;&#10;                    style = MaterialTheme.typography.titleLarge,&#13;&#10;                    fontWeight = FontWeight.Bold&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        // Main content (draggable)&#13;&#10;        Row(&#13;&#10;            modifier = Modifier&#13;&#10;                .offset { IntOffset(offsetX.value.roundToInt(), 0) }&#13;&#10;                .pointerInput(Unit) {&#13;&#10;                    detectHorizontalDragGestures(&#13;&#10;                        onDragEnd = {&#13;&#10;                            Log.d(&quot;SongListItem&quot;, &quot;onDragEnd - offsetX.value = ${offsetX.value}, swipeThreshold = $swipeThreshold&quot;)&#13;&#10;                            coroutineScope.launch {&#13;&#10;                                when {&#13;&#10;                                    offsetX.value &gt; swipeThreshold -&gt; {&#13;&#10;                                        // Complete right swipe - Execute configured action&#13;&#10;                                        val action = Config.getSwipeRightAction(context)&#13;&#10;                                        Log.d(&quot;SongListItem&quot;, &quot; RIGHT SWIPE DETECTED - Action: $action&quot;)&#13;&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#13;&#10;                                        executeSwipeAction(&#13;&#10;                                            action = action,&#13;&#10;                                            song = song,&#13;&#10;                                            context = context,&#13;&#10;                                            playerViewModel = playerViewModel,&#13;&#10;                                            trackEntities = trackEntities,&#13;&#10;                                            index = index,&#13;&#10;                                            coroutineScope = coroutineScope,&#13;&#10;                                            onLikedStatusChanged = onLikedStatusChanged,&#13;&#10;                                            onShowPlaylistDialog = { showPlaylistDialog = true },&#13;&#10;                                            onShowShareDialog = { showShareDialog = true }&#13;&#10;                                        )&#13;&#10;                                        resetSwipe()&#13;&#10;                                    }&#13;&#10;                                    offsetX.value &lt; -swipeThreshold -&gt; {&#13;&#10;                                        // Complete left swipe - Execute configured action&#13;&#10;                                        val action = Config.getSwipeLeftAction(context)&#13;&#10;                                        Log.d(&quot;SongListItem&quot;, &quot; LEFT SWIPE DETECTED - Action: $action&quot;)&#13;&#10;                                        haptic.performHapticFeedback(HapticFeedbackType.LongPress)&#13;&#10;                                        executeSwipeAction(&#13;&#10;                                            action = action,&#13;&#10;                                            song = song,&#13;&#10;                                            context = context,&#13;&#10;                                            playerViewModel = playerViewModel,&#13;&#10;                                            trackEntities = trackEntities,&#13;&#10;                                            index = index,&#13;&#10;                                            coroutineScope = coroutineScope,&#13;&#10;                                            onLikedStatusChanged = onLikedStatusChanged,&#13;&#10;                                            onShowPlaylistDialog = { showPlaylistDialog = true },&#13;&#10;                                            onShowShareDialog = { showShareDialog = true }&#13;&#10;                                        )&#13;&#10;                                        resetSwipe()&#13;&#10;                                    }&#13;&#10;                                    else -&gt; {&#13;&#10;                                        // Return to center&#13;&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;Swipe not enough, returning to center&quot;)&#13;&#10;                                        resetSwipe()&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                        },&#13;&#10;                        onHorizontalDrag = { _, dragAmount -&gt;&#13;&#10;                            coroutineScope.launch {&#13;&#10;                                val newValue = (offsetX.value + dragAmount).coerceIn(-200f, 150f)&#13;&#10;                                offsetX.snapTo(newValue)&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    )&#13;&#10;                }&#13;&#10;                .clickable {&#13;&#10;                    if (offsetX.value.absoluteValue &lt; 10f) {&#13;&#10;                        haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#13;&#10;                        playerViewModel?.let { viewModel -&gt;&#13;&#10;                            if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#13;&#10;                                // Limpiar estado previo del reproductor&#13;&#10;                                viewModel.clearPlayerState()&#13;&#10;                                &#13;&#10;                                viewModel.setCurrentPlaylist(trackEntities, index)&#13;&#10;                                val selectedTrackEntity = trackEntities[index]&#13;&#10;&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot; REPRODUCIR TRACK&quot;)&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;═══════════════════════════════════&quot;)&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Track: ${selectedTrackEntity.name}&quot;)&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;AudioUrl: ${selectedTrackEntity.audioUrl}&quot;)&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Es archivo local: ${selectedTrackEntity.audioUrl?.startsWith(&quot;/&quot;) == true}&quot;)&#13;&#10;&#13;&#10;                                coroutineScope.launch {&#13;&#10;                                    try {&#13;&#10;                                        viewModel.loadAudioFromTrack(selectedTrackEntity)&#13;&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;✓ loadAudioFromTrack llamado exitosamente&quot;)&#13;&#10;                                    } catch (e: Exception) {&#13;&#10;                                        Log.e(&quot;SongListItem&quot;, &quot;✗ Error al reproducir track&quot;, e)&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    } else {&#13;&#10;                        resetSwipe()&#13;&#10;                    }&#13;&#10;                }&#13;&#10;                .fillMaxWidth()&#13;&#10;                .height(32.dp)&#13;&#10;                .background(Color.Transparent),&#13;&#10;            verticalAlignment = Alignment.CenterVertically&#13;&#10;        ) {&#13;&#10;            // Track number&#13;&#10;            Text(&#13;&#10;                text = song.number.toString(),&#13;&#10;                style = PlyrTextStyles.trackArtist(),&#13;&#10;                modifier = Modifier.padding(end = PlyrSpacing.small, start = 8.dp)&#13;&#10;            )&#13;&#10;            // Song title and artist&#13;&#10;            Column(&#13;&#10;                modifier = Modifier.weight(1f),&#13;&#10;                verticalArrangement = Arrangement.Center&#13;&#10;            ) {&#13;&#10;                Text(&#13;&#10;                    text = song.title,&#13;&#10;                    style = if (isSelected)&#13;&#10;                        PlyrTextStyles.selectableOption(true)&#13;&#10;                    else&#13;&#10;                        PlyrTextStyles.trackTitle(),&#13;&#10;                    maxLines = 1,&#13;&#10;                    overflow = TextOverflow.Ellipsis&#13;&#10;                )&#13;&#10;                Text(&#13;&#10;                    text = song.artist,&#13;&#10;                    style = PlyrTextStyles.trackArtist(),&#13;&#10;                    maxLines = 1,&#13;&#10;                    overflow = TextOverflow.Ellipsis,&#13;&#10;                    modifier = Modifier.padding(top = 0.dp)&#13;&#10;                )&#13;&#10;            }&#13;&#10;            // Botón personalizable&#13;&#10;            IconButton(onClick = {&#13;&#10;                if (customButtonAction != null) {&#13;&#10;                    customButtonAction()&#13;&#10;                } else {&#13;&#10;                    showPopup = true&#13;&#10;                }&#13;&#10;            }, modifier = Modifier.size(32.dp)) {&#13;&#10;                Text(&#13;&#10;                    text = customButtonIcon ?: &quot;*&quot;,&#13;&#10;                    style = PlyrTextStyles.menuOption(),&#13;&#10;                    color = Color(0xFF3FFFEF)&#13;&#10;                )&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Solo mostrar popup si no hay acción personalizada&#13;&#10;    if (showPopup &amp;&amp; customButtonAction == null) {&#13;&#10;        // Cargar información de la canción cuando se abre el popup&#13;&#10;        LaunchedEffect(true) {&#13;&#10;            if (showPopup &amp;&amp; song.spotifyId != null) {&#13;&#10;                isLoadingTrackInfo = true&#13;&#10;                fetchInfoError = null&#13;&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#13;&#10;                if (accessToken != null) {&#13;&#10;                    // Obtener info del track&#13;&#10;                    SpotifyRepository.getTrackInfo(accessToken, song.spotifyId) { trackInfo, error -&gt;&#13;&#10;                        isLoadingTrackInfo = false&#13;&#10;                        if (trackInfo != null) {&#13;&#10;                            fetchedTrackInfo = trackInfo&#13;&#10;                        } else {&#13;&#10;                            fetchInfoError = error ?: &quot;Error fetching track info&quot;&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Verificar si está en Liked Songs&#13;&#10;                    SpotifyRepository.checkSavedTrack(accessToken, song.spotifyId) { liked, error -&gt;&#13;&#10;                        if (error == null) {&#13;&#10;                            isLiked = liked&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    isLoadingTrackInfo = false&#13;&#10;                    fetchInfoError = &quot;Token de Spotify no disponible&quot;&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;&#13;&#10;        Dialog(onDismissRequest = {&#13;&#10;            showPopup = false&#13;&#10;            fetchedTrackInfo = null&#13;&#10;            fetchInfoError = null&#13;&#10;        }) {&#13;&#10;            Box(&#13;&#10;                modifier = Modifier&#13;&#10;                    .clip(RoundedCornerShape(24.dp))&#13;&#10;                    .background(Color(0xFF181818))&#13;&#10;                    .padding(24.dp)&#13;&#10;                    .fillMaxWidth(0.9f)&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#13;&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;                ) {&#13;&#10;                    // Sección de información del track&#13;&#10;                    Box(&#13;&#10;                        modifier = Modifier&#13;&#10;                            .fillMaxWidth()&#13;&#10;                            .height(150.dp)&#13;&#10;                    ) {&#13;&#10;                        when {&#13;&#10;                            isLoadingTrackInfo -&gt; {&#13;&#10;                                // Estado de carga&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#13;&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#13;&#10;                                    Text(&#13;&#10;                                        text = Translations.get(context, &quot;loading&quot;),&#13;&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                            color = Color(0xFF888888)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            fetchInfoError != null -&gt; {&#13;&#10;                                // Error&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    Text(&#13;&#10;                                        text = &quot;✗&quot;,&#13;&#10;                                        style = MaterialTheme.typography.displayMedium.copy(&#13;&#10;                                            color = Color(0xFFFF6B6B)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#13;&#10;                                    Text(&#13;&#10;                                        text = fetchInfoError ?: &quot;Error&quot;,&#13;&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                            color = Color(0xFFFF6B6B)&#13;&#10;                                        ),&#13;&#10;                                        textAlign = TextAlign.Center&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            fetchedTrackInfo != null -&gt; {&#13;&#10;                                // Mostrar información de la canción&#13;&#10;                                val trackInfo = fetchedTrackInfo&#13;&#10;                                LazyColumn(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                                ) {&#13;&#10;                                    item {&#13;&#10;                                        Text(&#13;&#10;                                            text = trackInfo?.name ?: song.title,&#13;&#10;                                            style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                                                color = Color.White,&#13;&#10;                                                fontWeight = FontWeight.Bold&#13;&#10;                                            )&#13;&#10;                                        )&#13;&#10;                                    }&#13;&#10;                                    item {&#13;&#10;                                        Text(&#13;&#10;                                            text = trackInfo?.artists?.joinToString(&quot;, &quot;) { it.name } ?: song.artist,&#13;&#10;                                            style = MaterialTheme.typography.bodyMedium.copy(&#13;&#10;                                                color = Color(0xFFAAAAAA)&#13;&#10;                                            )&#13;&#10;                                        )&#13;&#10;                                    }&#13;&#10;                                    trackInfo?.album?.let { album -&gt;&#13;&#10;                                        item {&#13;&#10;                                            Spacer(modifier = Modifier.height(4.dp))&#13;&#10;                                            Text(&#13;&#10;                                                text = &quot;Album: ${album.name}&quot;,&#13;&#10;                                                style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                                    color = Color(0xFF888888)&#13;&#10;                                                )&#13;&#10;                                            )&#13;&#10;                                        }&#13;&#10;                                        album.releaseDate?.let { date -&gt;&#13;&#10;                                            item {&#13;&#10;                                                Text(&#13;&#10;                                                    text = &quot;Release: $date&quot;,&#13;&#10;                                                    style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                                        color = Color(0xFF888888)&#13;&#10;                                                    )&#13;&#10;                                                )&#13;&#10;                                            }&#13;&#10;                                        }&#13;&#10;                                    }&#13;&#10;                                    item {&#13;&#10;                                        Text(&#13;&#10;                                            text = &quot;Duration: ${trackInfo?.durationMs?.let { ms -&gt; &#13;&#10;                                                val minutes = ms / 60000&#13;&#10;                                                val seconds = &quot;%02d&quot;.format((ms % 60000) / 1000)&#13;&#10;                                                &quot;$minutes:$seconds&quot;&#13;&#10;                                            } ?: &quot;N/A&quot;}&quot;,&#13;&#10;                                            style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                                color = Color(0xFF888888)&#13;&#10;                                            )&#13;&#10;                                        )&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            else -&gt; {&#13;&#10;                                // Mostrar info básica mientras carga&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.Start,&#13;&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                                ) {&#13;&#10;                                    Text(&#13;&#10;                                        text = song.title,&#13;&#10;                                        style = MaterialTheme.typography.titleMedium.copy(&#13;&#10;                                            color = Color.White,&#13;&#10;                                            fontWeight = FontWeight.Bold&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                    Text(&#13;&#10;                                        text = song.artist,&#13;&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#13;&#10;                                            color = Color(0xFFAAAAAA)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;&#13;&#10;                    // Botones de acción&#13;&#10;                    Column(&#13;&#10;                        verticalArrangement = Arrangement.spacedBy(12.dp),&#13;&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;                    ) {&#13;&#10;                        // Add to Playlist&#13;&#10;                        Text(&#13;&#10;                            text = Translations.get(context, &quot;add_to_playlist&quot;),&#13;&#10;                            color = Color(0xFF3FFFEF),&#13;&#10;                            fontWeight = FontWeight.Normal,&#13;&#10;                            textAlign = TextAlign.Center,&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .clickable {&#13;&#10;                                    if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#13;&#10;                                        showPopup = false&#13;&#10;                                        showPlaylistDialog = true&#13;&#10;                                        isLoadingPlaylists = true&#13;&#10;                                        addToPlaylistError = null&#13;&#10;&#13;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#13;&#10;                                        if (accessToken != null) {&#13;&#10;                                            SpotifyRepository.getUserPlaylists(accessToken) { playlists, error -&gt;&#13;&#10;                                                isLoadingPlaylists = false&#13;&#10;                                                if (playlists != null) {&#13;&#10;                                                    userPlaylists = playlists&#13;&#10;                                                } else {&#13;&#10;                                                    addToPlaylistError = error ?: &quot;Error cargando playlists&quot;&#13;&#10;                                                }&#13;&#10;                                            }&#13;&#10;                                        } else {&#13;&#10;                                            isLoadingPlaylists = false&#13;&#10;                                            addToPlaylistError = &quot;Token de Spotify no disponible&quot;&#13;&#10;                                        }&#13;&#10;                                    } else {&#13;&#10;                                        Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#13;&#10;                                        showPopup = false&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                                .padding(vertical = 4.dp)&#13;&#10;                        )&#13;&#10;&#13;&#10;                        // Add to Queue&#13;&#10;                        Text(&#13;&#10;                            text = Translations.get(context, &quot;add_to_queue&quot;),&#13;&#10;                            color = Color(0xFF3FFFEF),&#13;&#10;                            fontWeight = FontWeight.Normal,&#13;&#10;                            textAlign = TextAlign.Center,&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .clickable {&#13;&#10;                                    showPopup = false&#13;&#10;                                    playerViewModel?.let { viewModel -&gt;&#13;&#10;                                        if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#13;&#10;                                            val trackToAdd = trackEntities[index]&#13;&#10;                                            viewModel.addToQueue(trackToAdd)&#13;&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#13;&#10;                                        }&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                                .padding(vertical = 4.dp)&#13;&#10;                        )&#13;&#10;&#13;&#10;                        // Share&#13;&#10;                        Text(&#13;&#10;                            text = Translations.get(context, &quot;share&quot;),&#13;&#10;                            color = Color(0xFF3FFFEF),&#13;&#10;                            fontWeight = FontWeight.Normal,&#13;&#10;                            textAlign = TextAlign.Center,&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .clickable {&#13;&#10;                                    showShareDialog = true&#13;&#10;                                    showPopup = false&#13;&#10;                                }&#13;&#10;                                .padding(vertical = 4.dp)&#13;&#10;                        )&#13;&#10;&#13;&#10;                        // Like / Unlike&#13;&#10;                        Text(&#13;&#10;                            text = if (isLiked == true) Translations.get(context, &quot;remove_from_liked_songs&quot;) else Translations.get(context, &quot;add_to_liked_songs&quot;),&#13;&#10;                            color = Color(0xFF3FFFEF),&#13;&#10;                            fontWeight = FontWeight.Normal,&#13;&#10;                            textAlign = TextAlign.Center,&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .clickable {&#13;&#10;                                    // Acción de agregar/quitar de Liked Songs&#13;&#10;                                    showPopup = false&#13;&#10;                                    isLiked?.let { currentlyLiked -&gt;&#13;&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#13;&#10;                                        if (accessToken != null &amp;&amp; song.spotifyId != null) {&#13;&#10;                                            isLoadingTrackInfo = true&#13;&#10;                                            if (currentlyLiked) {&#13;&#10;                                                // Quitar de Liked Songs&#13;&#10;                                                SpotifyRepository.removeTrack(accessToken, song.spotifyId) { success, error -&gt;&#13;&#10;                                                    isLoadingTrackInfo = false&#13;&#10;                                                    if (success) {&#13;&#10;                                                        isLiked = false&#13;&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción quitada de Liked Songs&quot;)&#13;&#10;                                                        onLikedStatusChanged?.invoke()&#13;&#10;                                                    } else {&#13;&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error quitando canción de Liked Songs: $error&quot;)&#13;&#10;                                                    }&#13;&#10;                                                }&#13;&#10;                                            } else {&#13;&#10;                                                // Añadir a Liked Songs&#13;&#10;                                                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#13;&#10;                                                    isLoadingTrackInfo = false&#13;&#10;                                                    if (success) {&#13;&#10;                                                        isLiked = true&#13;&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a Liked Songs&quot;)&#13;&#10;                                                        onLikedStatusChanged?.invoke()&#13;&#10;                                                    } else {&#13;&#10;                                                        Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción a Liked Songs: $error&quot;)&#13;&#10;                                                    }&#13;&#10;                                                }&#13;&#10;                                            }&#13;&#10;                                        }&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                                .padding(vertical = 4.dp)&#13;&#10;                        )&#13;&#10;&#13;&#10;                        // Download&#13;&#10;                        Text(&#13;&#10;                            text = Translations.get(context, &quot;download&quot;),&#13;&#10;                            color = Color(0xFF3FFFEF),&#13;&#10;                            fontWeight = FontWeight.Normal,&#13;&#10;                            textAlign = TextAlign.Center,&#13;&#10;                            modifier = Modifier&#13;&#10;                                .fillMaxWidth()&#13;&#10;                                .clickable {&#13;&#10;                                    showPopup = false&#13;&#10;                                    coroutineScope.launch {&#13;&#10;                                        // Obtener el youtubeId&#13;&#10;                                        val trackEntity = if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#13;&#10;                                            trackEntities[index]&#13;&#10;                                        } else null&#13;&#10;&#13;&#10;                                        val initialYoutubeId = trackEntity?.youtubeVideoId ?: song.youtubeId&#13;&#10;&#13;&#10;                                        // Si no tenemos youtubeId, buscarlo&#13;&#10;                                        val finalYoutubeId = if (initialYoutubeId == null) {&#13;&#10;                                            withContext(Dispatchers.IO) {&#13;&#10;                                                val searchQuery = &quot;${song.title} ${song.artist}&quot;&#13;&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;YouTube ID not available, searching with query: '$searchQuery'&quot;)&#13;&#10;                                                val foundId = com.plyr.network.YouTubeManager.searchVideoId(searchQuery)&#13;&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;YouTube search result: ${if (foundId != null) &quot;Found ID: $foundId&quot; else &quot;NOT FOUND&quot;}&quot;)&#13;&#10;                                                foundId&#13;&#10;                                            }&#13;&#10;                                        } else {&#13;&#10;                                            Log.d(&quot;SongListItem&quot;, &quot;Using existing YouTube ID: $initialYoutubeId&quot;)&#13;&#10;                                            initialYoutubeId&#13;&#10;                                        }&#13;&#10;&#13;&#10;                                        if (finalYoutubeId != null) {&#13;&#10;                                            // Verificar si ya está descargada usando YouTube ID&#13;&#10;                                            val database = PlaylistDatabase.getDatabase(context)&#13;&#10;                                            val alreadyDownloaded = database.downloadedTrackDao()&#13;&#10;                                                .isTrackDownloadedByYoutubeId(finalYoutubeId) &gt; 0&#13;&#10;&#13;&#10;                                            if (alreadyDownloaded) {&#13;&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Track already downloaded&quot;)&#13;&#10;                                            } else {&#13;&#10;                                                Log.d(&quot;SongListItem&quot;, &quot;Starting download: ${song.title}&quot;)&#13;&#10;                                                DownloadManager.downloadTrack(&#13;&#10;                                                    context = context,&#13;&#10;                                                    spotifyTrackId = song.spotifyId,&#13;&#10;                                                    youtubeVideoId = finalYoutubeId,&#13;&#10;                                                    trackName = song.title,&#13;&#10;                                                    artists = song.artist,&#13;&#10;                                                    onProgress = { progress -&gt;&#13;&#10;                                                        Log.d(&quot;SongListItem&quot;, &quot;Download progress: $progress%&quot;)&#13;&#10;                                                    },&#13;&#10;                                                    onComplete = { success, error -&gt;&#13;&#10;                                                        if (success) {&#13;&#10;                                                            Log.d(&quot;SongListItem&quot;, &quot;✓ Download completed: ${song.title}&quot;)&#13;&#10;                                                        } else {&#13;&#10;                                                            Log.e(&quot;SongListItem&quot;, &quot;✗ Download failed: $error&quot;)&#13;&#10;                                                        }&#13;&#10;                                                    }&#13;&#10;                                                )&#13;&#10;                                            }&#13;&#10;                                        } else {&#13;&#10;                                            Log.e(&quot;SongListItem&quot;, &quot;Cannot download: YouTube video not found for query: '${song.title} ${song.artist}'&quot;)&#13;&#10;                                        }&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                                .padding(vertical = 4.dp)&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    // Diálogo de selección de playlist&#13;&#10;    if (showPlaylistDialog) {&#13;&#10;        Dialog(onDismissRequest = {&#13;&#10;            showPlaylistDialog = false&#13;&#10;            addToPlaylistSuccess = false&#13;&#10;            addToPlaylistError = null&#13;&#10;        }) {&#13;&#10;            Box(&#13;&#10;                modifier = Modifier&#13;&#10;                    .clip(RoundedCornerShape(24.dp))&#13;&#10;                    .background(Color(0xFF181818))&#13;&#10;                    .padding(24.dp)&#13;&#10;                    .fillMaxWidth(0.9f)&#13;&#10;            ) {&#13;&#10;                Column(&#13;&#10;                    verticalArrangement = Arrangement.spacedBy(16.dp),&#13;&#10;                    horizontalAlignment = Alignment.CenterHorizontally&#13;&#10;                ) {&#13;&#10;                    // Contenido del diálogo&#13;&#10;                    Box(&#13;&#10;                        modifier = Modifier&#13;&#10;                            .fillMaxWidth()&#13;&#10;                            .height(300.dp)&#13;&#10;                    ) {&#13;&#10;                        when {&#13;&#10;                            isLoadingPlaylists -&gt; {&#13;&#10;                                // Estado de carga&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    CircularProgressIndicator(color = Color(0xFF4ECDC4))&#13;&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#13;&#10;                                    Text(&#13;&#10;                                        text = Translations.get(context, &quot;loading_playlists&quot;),&#13;&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                            color = Color(0xFF888888)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            addToPlaylistSuccess -&gt; {&#13;&#10;                                // Éxito&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    Text(&#13;&#10;                                        text = &quot;✓&quot;,&#13;&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#13;&#10;                                            color = Color(0xFF4ECDC4)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#13;&#10;                                    Text(&#13;&#10;                                        text = Translations.get(context, &quot;track_added_successfully&quot;),&#13;&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#13;&#10;                                            color = Color.White&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            addToPlaylistError != null -&gt; {&#13;&#10;                                // Error&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    Text(&#13;&#10;                                        text = &quot;✗&quot;,&#13;&#10;                                        style = MaterialTheme.typography.displayLarge.copy(&#13;&#10;                                            color = Color(0xFFFF6B6B)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                    Spacer(modifier = Modifier.height(8.dp))&#13;&#10;                                    Text(&#13;&#10;                                        text = addToPlaylistError ?: &quot;Error&quot;,&#13;&#10;                                        style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                            color = Color(0xFFFF6B6B)&#13;&#10;                                        ),&#13;&#10;                                        textAlign = TextAlign.Center&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            userPlaylists.isEmpty() -&gt; {&#13;&#10;                                // Sin playlists&#13;&#10;                                Column(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    horizontalAlignment = Alignment.CenterHorizontally,&#13;&#10;                                    verticalArrangement = Arrangement.Center&#13;&#10;                                ) {&#13;&#10;                                    Text(&#13;&#10;                                        text = Translations.get(context, &quot;no_playlists_found&quot;),&#13;&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#13;&#10;                                            color = Color(0xFF888888)&#13;&#10;                                        )&#13;&#10;                                    )&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                            else -&gt; {&#13;&#10;                                // Lista de playlists&#13;&#10;                                LazyColumn(&#13;&#10;                                    modifier = Modifier.fillMaxSize(),&#13;&#10;                                    verticalArrangement = Arrangement.spacedBy(8.dp)&#13;&#10;                                ) {&#13;&#10;                                    items(userPlaylists) { playlist -&gt;&#13;&#10;                                        Row(&#13;&#10;                                            modifier = Modifier&#13;&#10;                                                .fillMaxWidth()&#13;&#10;                                                .clip(RoundedCornerShape(8.dp))&#13;&#10;                                                .clickable {&#13;&#10;                                                    // Añadir la canción a la playlist&#13;&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#13;&#10;                                                    if (accessToken != null &amp;&amp; song.spotifyId != null) {&#13;&#10;                                                        isLoadingPlaylists = true&#13;&#10;                                                        SpotifyRepository.addTrackToPlaylist(&#13;&#10;                                                            accessToken,&#13;&#10;                                                            playlist.id,&#13;&#10;                                                            song.spotifyId&#13;&#10;                                                        ) { success, error -&gt;&#13;&#10;                                                            isLoadingPlaylists = false&#13;&#10;                                                            if (success) {&#13;&#10;                                                                addToPlaylistSuccess = true&#13;&#10;                                                                Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a '${playlist.name}'&quot;)&#13;&#10;                                                                // Cerrar el diálogo después de 1.5 segundos&#13;&#10;                                                                coroutineScope.launch {&#13;&#10;                                                                    kotlinx.coroutines.delay(1500)&#13;&#10;                                                                    showPlaylistDialog = false&#13;&#10;                                                                    addToPlaylistSuccess = false&#13;&#10;                                                                }&#13;&#10;                                                            } else {&#13;&#10;                                                                addToPlaylistError = error&#13;&#10;                                                                Log.e(&quot;SongListItem&quot;, &quot;Error añadiendo canción: $error&quot;)&#13;&#10;                                                            }&#13;&#10;                                                        }&#13;&#10;                                                    }&#13;&#10;                                                }&#13;&#10;                                                .background(Color(0xFF252525))&#13;&#10;                                                .padding(12.dp),&#13;&#10;                                            verticalAlignment = Alignment.CenterVertically&#13;&#10;                                        ) {&#13;&#10;                                            Column(&#13;&#10;                                                modifier = Modifier.weight(1f)&#13;&#10;                                            ) {&#13;&#10;                                                Text(&#13;&#10;                                                    text = playlist.name,&#13;&#10;                                                    style = MaterialTheme.typography.bodyMedium.copy(&#13;&#10;                                                        color = Color.White&#13;&#10;                                                    ),&#13;&#10;                                                    maxLines = 1,&#13;&#10;                                                    overflow = TextOverflow.Ellipsis&#13;&#10;                                                )&#13;&#10;                                                playlist.description?.let { desc -&gt;&#13;&#10;                                                    if (desc.isNotBlank()) {&#13;&#10;                                                        Text(&#13;&#10;                                                            text = desc,&#13;&#10;                                                            style = MaterialTheme.typography.bodySmall.copy(&#13;&#10;                                                                color = Color(0xFF888888)&#13;&#10;                                                            ),&#13;&#10;                                                            maxLines = 1,&#13;&#10;                                                            overflow = TextOverflow.Ellipsis&#13;&#10;                                                        )&#13;&#10;                                                    }&#13;&#10;                                                }&#13;&#10;                                            }&#13;&#10;                                            Text(&#13;&#10;                                                text = &quot;&gt;&quot;,&#13;&#10;                                                style = MaterialTheme.typography.bodyLarge.copy(&#13;&#10;                                                    color = Color(0xFF4ECDC4)&#13;&#10;                                                )&#13;&#10;                                            )&#13;&#10;                                        }&#13;&#10;                                    }&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                        }&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;    }&#13;&#10;&#13;&#10;    if (showShareDialog) {&#13;&#10;        ShareDialog(&#13;&#10;            item = ShareableItem(&#13;&#10;                spotifyId = song.spotifyId,&#13;&#10;                spotifyUrl = song.spotifyUrl,&#13;&#10;                youtubeId = song.youtubeId,&#13;&#10;                title = song.title,&#13;&#10;                artist = song.artist,&#13;&#10;                type = ShareType.TRACK&#13;&#10;            ),&#13;&#10;            onDismiss = { showShareDialog = false }&#13;&#10;        )&#13;&#10;    }&#13;&#10;}&#13;&#10;&#13;&#10;fun executeSwipeAction(&#13;&#10;    action: String,&#13;&#10;    song: Song,&#13;&#10;    context: android.content.Context,&#13;&#10;    playerViewModel: PlayerViewModel?,&#13;&#10;    trackEntities: List&lt;TrackEntity&gt;,&#13;&#10;    index: Int,&#13;&#10;    coroutineScope: CoroutineScope,&#13;&#10;    onLikedStatusChanged: (() -&gt; Unit)?,&#13;&#10;    onShowPlaylistDialog: () -&gt; Unit,&#13;&#10;    onShowShareDialog: () -&gt; Unit&#13;&#10;) {&#13;&#10;    when (action) {&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_LIKED -&gt; {&#13;&#10;            // Añadir a favoritos&#13;&#10;            val accessToken = Config.getSpotifyAccessToken(context)&#13;&#10;            if (accessToken != null &amp;&amp; song.spotifyId != null) {&#13;&#10;                Log.d(&quot;SongListItem&quot;, &quot;Calling saveTrack with spotifyId: ${song.spotifyId}&quot;)&#13;&#10;                SpotifyRepository.saveTrack(accessToken, song.spotifyId) { success, error -&gt;&#13;&#10;                    if (success) {&#13;&#10;                        onLikedStatusChanged?.invoke()&#13;&#10;                        Log.d(&quot;SongListItem&quot;, &quot;✓ Canción añadida a favoritos&quot;)&#13;&#10;                    } else {&#13;&#10;                        Log.e(&quot;SongListItem&quot;, &quot;✗ Error añadiendo a favoritos: $error&quot;)&#13;&#10;                    }&#13;&#10;                }&#13;&#10;            } else {&#13;&#10;                Log.e(&quot;SongListItem&quot;, &quot;✗ No se puede añadir a favoritos: accessToken=${accessToken != null}, spotifyId=${song.spotifyId}&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_QUEUE -&gt; {&#13;&#10;            // Añadir a cola&#13;&#10;            playerViewModel?.let { viewModel -&gt;&#13;&#10;                if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#13;&#10;                    val trackToAdd = trackEntities[index]&#13;&#10;                    viewModel.addToQueue(trackToAdd)&#13;&#10;                    Log.d(&quot;SongListItem&quot;, &quot;✓ Track added to queue: ${trackToAdd.name}&quot;)&#13;&#10;                } else {&#13;&#10;                    Log.e(&quot;SongListItem&quot;, &quot;✗ Invalid index or empty trackEntities&quot;)&#13;&#10;                }&#13;&#10;            } ?: Log.e(&quot;SongListItem&quot;, &quot;✗ PlayerViewModel is null&quot;)&#13;&#10;        }&#13;&#10;        Config.SWIPE_ACTION_ADD_TO_PLAYLIST -&gt; {&#13;&#10;            // Añadir a playlist&#13;&#10;            if (song.spotifyId != null &amp;&amp; Config.isSpotifyConnected(context)) {&#13;&#10;                onShowPlaylistDialog()&#13;&#10;            } else {&#13;&#10;                Log.d(&quot;SongListItem&quot;, &quot;No se puede añadir a playlist: sin Spotify ID o no conectado&quot;)&#13;&#10;            }&#13;&#10;        }&#13;&#10;        Config.SWIPE_ACTION_SHARE -&gt; {&#13;&#10;            // Compartir&#13;&#10;            onShowShareDialog()&#13;&#10;        }&#13;&#10;        Config.SWIPE_ACTION_DOWNLOAD -&gt; {&#13;&#10;            // Descargar&#13;&#10;            coroutineScope.launch {&#13;&#10;                // Obtener el youtubeId&#13;&#10;                val trackEntity = if (trackEntities.isNotEmpty() &amp;&amp; index in trackEntities.indices) {&#13;&#10;                    trackEntities[index]&#13;&#10;                } else null&#13;&#10;&#13;&#10;                val initialYoutubeId = trackEntity?.youtubeVideoId ?: song.youtubeId&#13;&#10;&#13;&#10;                // Si no tenemos youtubeId, buscarlo&#13;&#10;                val finalYoutubeId = initialYoutubeId&#13;&#10;                    ?: withContext(Dispatchers.IO) {&#13;&#10;                        val searchQuery = &quot;${song.title} ${song.artist}&quot;&#13;&#10;                        Log.d(&quot;SongListItem&quot;, &quot;YouTube ID not available, searching with query: '$searchQuery'&quot;)&#13;&#10;                        com.plyr.network.YouTubeManager.searchVideoId(searchQuery)&#13;&#10;                    }&#13;&#10;&#13;&#10;                if (finalYoutubeId != null) {&#13;&#10;                    // Verificar si ya está descargada usando YouTube ID&#13;&#10;                    val database = PlaylistDatabase.getDatabase(context)&#13;&#10;                    val alreadyDownloaded = database.downloadedTrackDao()&#13;&#10;                        .isTrackDownloadedByYoutubeId(finalYoutubeId) &gt; 0&#13;&#10;&#13;&#10;                    if (alreadyDownloaded) {&#13;&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Track already downloaded&quot;)&#13;&#10;                    } else {&#13;&#10;                        Log.d(&quot;SongListItem&quot;, &quot;Starting download: ${song.title}&quot;)&#13;&#10;                        DownloadManager.downloadTrack(&#13;&#10;                            context = context,&#13;&#10;                            spotifyTrackId = song.spotifyId,&#13;&#10;                            youtubeVideoId = finalYoutubeId,&#13;&#10;                            trackName = song.title,&#13;&#10;                            artists = song.artist,&#13;&#10;                            onProgress = { progress -&gt;&#13;&#10;                                Log.d(&quot;SongListItem&quot;, &quot;Download progress: $progress%&quot;)&#13;&#10;                            },&#13;&#10;                            onComplete = { success, error -&gt;&#13;&#10;                                if (success) {&#13;&#10;                                    Log.d(&quot;SongListItem&quot;, &quot;✓ Download completed: ${song.title}&quot;)&#13;&#10;                                } else {&#13;&#10;                                    Log.e(&quot;SongListItem&quot;, &quot;✗ Download failed: $error&quot;)&#13;&#10;                                }&#13;&#10;                            }&#13;&#10;                        )&#13;&#10;                    }&#13;&#10;                } else {&#13;&#10;                    Log.e(&quot;SongListItem&quot;, &quot;Cannot download: YouTube video not found&quot;)&#13;&#10;                }&#13;&#10;            }&#13;&#10;        }&#13;&#10;        else -&gt; {&#13;&#10;            Log.w(&quot;SongListItem&quot;, &quot;Acción desconocida para swipe: $action&quot;)&#13;&#10;        }&#13;&#10;    }&#13;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/viewmodel/PlayerViewModel.kt" />
              <option name="originalContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import androidx.annotation.OptIn&#10;import androidx.media3.common.util.UnstableApi&#10;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;&#10;    // Queue management&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#10;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#10;&#10;    private var loadingJobsActive = false&#10;&#10;    fun initializePlayer() {&#10;        if (_exoPlayer == null) {&#10;            _exoPlayer = buildPlayer()&#10;        }&#10;    }&#10;&#10;    @OptIn(UnstableApi::class)&#10;    private fun buildPlayer(): ExoPlayer =&#10;        ExoPlayer.Builder(getApplication())&#10;            .setSeekBackIncrementMs(10_000)&#10;            .setSeekForwardIncrementMs(10_000)&#10;            .setHandleAudioBecomingNoisy(true)&#10;            .setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true&#10;            )&#10;            .build().apply {&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#10;                }&#10;&#10;                addListener(object : Player.Listener {&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#10;                    }&#10;&#10;                    override fun onPlayerError(error: PlaybackException) {&#10;                        _isLoading.postValue(false)&#10;                        val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#10;                        val msg = error.message ?: &quot;&quot;&#10;                        _error.postValue(prefix + msg)&#10;                    }&#10;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#10;                        updateCurrentTrackFromPlayer()&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#10;                    }&#10;                })&#10;            }&#10;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            _isLoading.postValue(true)&#10;            _error.postValue(null)&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#10;                // Verificar si audioUrl es una ruta de archivo local&#10;                if (track.audioUrl != null &amp;&amp; (track.audioUrl.startsWith(&quot;/&quot;) || track.audioUrl.startsWith(&quot;file://&quot;))) {&#10;                    val localFile = java.io.File(track.audioUrl.removePrefix(&quot;file://&quot;))&#10;&#10;                    if (localFile.exists()) {&#10;                        return@withContext track.audioUrl&#10;                    }&#10;                }&#10;&#10;                // Si no es archivo local, obtener de YouTube&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;            }&#10;&#10;            if (audioUrl == null) {&#10;                _isLoading.postValue(false)&#10;                _error.postValue(com.plyr.utils.Translations.get(getApplication(), &quot;error_obtaining_audio&quot;))&#10;                return@withContext false&#10;            }&#10;&#10;            initializePlayer()&#10;            _exoPlayer?.let { player -&gt;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#10;                player.prepare()&#10;                player.play()&#10;                _isLoading.postValue(false)&#10;                onMediaSessionUpdate?.invoke(player)&#10;&#10;                // Iniciar carga concurrente de las siguientes canciones&#10;                startLoadingRemainingTracks()&#10;                true&#10;            } ?: false&#10;        } catch (e: Exception) {&#10;            _isLoading.postValue(false)&#10;            val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#10;            _error.postValue(prefix + (e.message ?: &quot;&quot;))&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#10;        MediaItem.Builder()&#10;            .setUri(audioUrl)&#10;            .setMediaId(track.id)&#10;            .setMediaMetadata(&#10;                androidx.media3.common.MediaMetadata.Builder()&#10;                    .setTitle(track.name)&#10;                    .setArtist(track.artists)&#10;                    .build()&#10;            )&#10;            .build()&#10;&#10;    private fun startLoadingRemainingTracks() {&#10;        if (loadingJobsActive) return&#10;        loadingJobsActive = true&#10;&#10;        val playlist = _currentPlaylist.value ?: return&#10;        val currentIndex = _currentTrackIndex.value ?: return&#10;&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            for (i in currentIndex + 1 until playlist.size) {&#10;                val track = playlist[i]&#10;                try {&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                } catch (_: Exception) {&#10;                    // Continuar con la siguiente canción si hay error&#10;                }&#10;            }&#10;            loadingJobsActive = false&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentTrackFromPlayer() {&#10;        val player = _exoPlayer ?: return&#10;        val playlist = _currentPlaylist.value ?: return&#10;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#10;&#10;        if (newIndex &gt;= 0) {&#10;            _currentTrackIndex.postValue(newIndex)&#10;            _currentTrack.postValue(playlist[newIndex])&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#10;        }&#10;    }&#10;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#10;&#10;    fun playPlayer() = _exoPlayer?.play()&#10;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        _currentPlaylist.postValue(playlist)&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#10;        _currentTrackIndex.postValue(validIndex)&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[validIndex])&#10;        }&#10;    }&#10;&#10;    fun navigateToNext() {&#10;        _exoPlayer?.seekToNextMediaItem()&#10;    }&#10;&#10;    fun navigateToPrevious() {&#10;        _exoPlayer?.seekToPreviousMediaItem()&#10;    }&#10;&#10;    fun updateRepeatMode() {&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;            else -&gt; Player.REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // Queue functionality&#10;    fun addToQueue(track: TrackEntity) {&#10;        // Añadir a la lista interna de queue&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#10;        updatedQueue.add(track)&#10;        _queueTracks.postValue(updatedQueue)&#10;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#10;        currentPlaylist.add(track)&#10;        _currentPlaylist.postValue(currentPlaylist)&#10;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;&#10;                if (audioUrl != null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.viewmodel&#10;&#10;import android.app.Application&#10;import androidx.lifecycle.AndroidViewModel&#10;import androidx.lifecycle.LiveData&#10;import androidx.lifecycle.MutableLiveData&#10;import androidx.lifecycle.viewModelScope&#10;import androidx.media3.common.MediaItem&#10;import androidx.media3.common.Player&#10;import androidx.media3.common.PlaybackException&#10;import androidx.media3.common.AudioAttributes&#10;import androidx.media3.common.C&#10;import androidx.media3.exoplayer.ExoPlayer&#10;import com.plyr.network.YouTubeManager&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.withContext&#10;import androidx.annotation.OptIn&#10;import androidx.media3.common.util.UnstableApi&#10;&#10;class PlayerViewModel(application: Application) : AndroidViewModel(application) {&#10;    private var _exoPlayer: ExoPlayer? = null&#10;    val exoPlayer: ExoPlayer? get() = _exoPlayer&#10;&#10;    private val _isLoading = MutableLiveData(false)&#10;    val isLoading: LiveData&lt;Boolean&gt; = _isLoading&#10;&#10;    private val _error = MutableLiveData&lt;String?&gt;()&#10;    val error: LiveData&lt;String?&gt; = _error&#10;&#10;    private val _currentTitle = MutableLiveData&lt;String?&gt;()&#10;    val currentTitle: LiveData&lt;String?&gt; = _currentTitle&#10;&#10;    private val _currentPlaylist = MutableLiveData&lt;List&lt;TrackEntity&gt;?&gt;()&#10;    val currentPlaylist: LiveData&lt;List&lt;TrackEntity&gt;?&gt; = _currentPlaylist&#10;&#10;    private val _currentTrackIndex = MutableLiveData&lt;Int&gt;()&#10;    val currentTrackIndex: LiveData&lt;Int&gt; = _currentTrackIndex&#10;&#10;    private val _currentTrack = MutableLiveData&lt;TrackEntity?&gt;()&#10;    val currentTrack: LiveData&lt;TrackEntity?&gt; = _currentTrack&#10;&#10;    // Queue management&#10;    private val _queueTracks = MutableLiveData&lt;List&lt;TrackEntity&gt;&gt;(emptyList())&#10;&#10;    var onMediaSessionUpdate: ((ExoPlayer) -&gt; Unit)? = null&#10;&#10;    private var loadingJobsActive = false&#10;    private var loadingJob: kotlinx.coroutines.Job? = null&#10;&#10;    fun initializePlayer() {&#10;        if (_exoPlayer == null) {&#10;            _exoPlayer = buildPlayer()&#10;        }&#10;    }&#10;&#10;    @OptIn(UnstableApi::class)&#10;    private fun buildPlayer(): ExoPlayer =&#10;        ExoPlayer.Builder(getApplication())&#10;            .setSeekBackIncrementMs(10_000)&#10;            .setSeekForwardIncrementMs(10_000)&#10;            .setHandleAudioBecomingNoisy(true)&#10;            .setAudioAttributes(&#10;                AudioAttributes.Builder()&#10;                    .setUsage(C.USAGE_MEDIA)&#10;                    .setContentType(C.AUDIO_CONTENT_TYPE_MUSIC)&#10;                    .build(),&#10;                true&#10;            )&#10;            .build().apply {&#10;                repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;                    Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;                    Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;                    else -&gt; Player.REPEAT_MODE_OFF&#10;                }&#10;&#10;                addListener(object : Player.Listener {&#10;                    override fun onPlaybackStateChanged(playbackState: Int) {&#10;                        _isLoading.postValue(playbackState == Player.STATE_BUFFERING)&#10;                    }&#10;&#10;                    override fun onPlayerError(error: PlaybackException) {&#10;                        _isLoading.postValue(false)&#10;                        val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#10;                        val msg = error.message ?: &quot;&quot;&#10;                        _error.postValue(prefix + msg)&#10;                    }&#10;&#10;                    override fun onMediaItemTransition(mediaItem: MediaItem?, reason: Int) {&#10;                        updateCurrentTrackFromPlayer()&#10;                        onMediaSessionUpdate?.invoke(this@apply)&#10;                    }&#10;                })&#10;            }&#10;&#10;    suspend fun loadAudioFromTrack(track: TrackEntity): Boolean = withContext(Dispatchers.Main) {&#10;        try {&#10;            _isLoading.postValue(true)&#10;            _error.postValue(null)&#10;            _currentTitle.postValue(&quot;${track.name} - ${track.artists}&quot;)&#10;&#10;            val audioUrl = withContext(Dispatchers.IO) {&#10;                // Verificar si audioUrl es una ruta de archivo local&#10;                if (track.audioUrl != null &amp;&amp; (track.audioUrl.startsWith(&quot;/&quot;) || track.audioUrl.startsWith(&quot;file://&quot;))) {&#10;                    val localFile = java.io.File(track.audioUrl.removePrefix(&quot;file://&quot;))&#10;&#10;                    if (localFile.exists()) {&#10;                        return@withContext track.audioUrl&#10;                    }&#10;                }&#10;&#10;                // Si no es archivo local, obtener de YouTube&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;            }&#10;&#10;            if (audioUrl == null) {&#10;                _isLoading.postValue(false)&#10;                _error.postValue(com.plyr.utils.Translations.get(getApplication(), &quot;error_obtaining_audio&quot;))&#10;                return@withContext false&#10;            }&#10;&#10;            initializePlayer()&#10;            _exoPlayer?.let { player -&gt;&#10;                player.setMediaItem(createMediaItem(track, audioUrl))&#10;                player.prepare()&#10;                player.play()&#10;                _isLoading.postValue(false)&#10;                onMediaSessionUpdate?.invoke(player)&#10;&#10;                // Iniciar carga concurrente de las siguientes canciones&#10;                startLoadingRemainingTracks()&#10;                true&#10;            } ?: false&#10;        } catch (e: Exception) {&#10;            _isLoading.postValue(false)&#10;            val prefix = com.plyr.utils.Translations.get(getApplication(), &quot;error_prefix&quot;)&#10;            _error.postValue(prefix + (e.message ?: &quot;&quot;))&#10;            false&#10;        }&#10;    }&#10;&#10;    private fun createMediaItem(track: TrackEntity, audioUrl: String) =&#10;        MediaItem.Builder()&#10;            .setUri(audioUrl)&#10;            .setMediaId(track.id)&#10;            .setMediaMetadata(&#10;                androidx.media3.common.MediaMetadata.Builder()&#10;                    .setTitle(track.name)&#10;                    .setArtist(track.artists)&#10;                    .build()&#10;            )&#10;            .build()&#10;&#10;    private fun startLoadingRemainingTracks() {&#10;        if (loadingJobsActive) return&#10;        loadingJobsActive = true&#10;&#10;        val playlist = _currentPlaylist.value ?: return&#10;        val currentIndex = _currentTrackIndex.value ?: return&#10;&#10;        loadingJob = viewModelScope.launch(Dispatchers.IO) {&#10;            for (i in currentIndex + 1 until playlist.size) {&#10;                val track = playlist[i]&#10;                try {&#10;                    val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;) ?: continue&#10;                    val audioUrl = YouTubeManager.getAudioUrl(videoId) ?: continue&#10;&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                } catch (_: Exception) {&#10;                    // Continuar con la siguiente canción si hay error&#10;                }&#10;            }&#10;            loadingJobsActive = false&#10;        }&#10;    }&#10;&#10;    private fun updateCurrentTrackFromPlayer() {&#10;        val player = _exoPlayer ?: return&#10;        val playlist = _currentPlaylist.value ?: return&#10;&#10;        val currentMediaId = player.currentMediaItem?.mediaId ?: return&#10;        val newIndex = playlist.indexOfFirst { it.id == currentMediaId }&#10;&#10;        if (newIndex &gt;= 0) {&#10;            _currentTrackIndex.postValue(newIndex)&#10;            _currentTrack.postValue(playlist[newIndex])&#10;            _currentTitle.postValue(&quot;${playlist[newIndex].name} - ${playlist[newIndex].artists}&quot;)&#10;        }&#10;    }&#10;&#10;    fun pausePlayer() = _exoPlayer?.pause()&#10;&#10;    fun playPlayer() = _exoPlayer?.play()&#10;&#10;    fun setCurrentPlaylist(playlist: List&lt;TrackEntity&gt;, startIndex: Int = 0) {&#10;        _currentPlaylist.postValue(playlist)&#10;        val validIndex = startIndex.coerceIn(0, playlist.size - 1)&#10;        _currentTrackIndex.postValue(validIndex)&#10;        if (playlist.isNotEmpty() &amp;&amp; validIndex in playlist.indices) {&#10;            _currentTrack.postValue(playlist[validIndex])&#10;        }&#10;    }&#10;&#10;    fun navigateToNext() {&#10;        _exoPlayer?.seekToNextMediaItem()&#10;    }&#10;&#10;    fun navigateToPrevious() {&#10;        _exoPlayer?.seekToPreviousMediaItem()&#10;    }&#10;&#10;    fun updateRepeatMode() {&#10;        _exoPlayer?.repeatMode = when (Config.getRepeatMode(getApplication())) {&#10;            Config.REPEAT_MODE_ONE -&gt; Player.REPEAT_MODE_ONE&#10;            Config.REPEAT_MODE_ALL -&gt; Player.REPEAT_MODE_ALL&#10;            else -&gt; Player.REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // Queue functionality&#10;    fun addToQueue(track: TrackEntity) {&#10;        // Añadir a la lista interna de queue&#10;        val updatedQueue = _queueTracks.value?.toMutableList() ?: mutableListOf()&#10;        updatedQueue.add(track)&#10;        _queueTracks.postValue(updatedQueue)&#10;&#10;        // Añadir también a la playlist actual para que se muestre en QueueScreen&#10;        val currentPlaylist = _currentPlaylist.value?.toMutableList() ?: mutableListOf()&#10;        currentPlaylist.add(track)&#10;        _currentPlaylist.postValue(currentPlaylist)&#10;&#10;        // Cargar el audio del track en el reproductor de forma asíncrona&#10;        viewModelScope.launch(Dispatchers.IO) {&#10;            try {&#10;                val videoId = track.youtubeVideoId ?: YouTubeManager.searchVideoId(&quot;${track.name} ${track.artists}&quot;)&#10;                val audioUrl = videoId?.let { YouTubeManager.getAudioUrl(it) }&#10;&#10;                if (audioUrl != null) {&#10;                    withContext(Dispatchers.Main) {&#10;                        _exoPlayer?.addMediaItem(createMediaItem(track, audioUrl))&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Limpia completamente el estado del reproductor:&#10;     * - Cancela todas las cargas de canciones en progreso&#10;     * - Para la reproducción actual&#10;     * - Limpia la cola de reproducción&#10;     * - Resetea el estado del reproductor&#10;     */&#10;    fun clearPlayerState() {&#10;        // Cancelar trabajos de precarga&#10;        loadingJob?.cancel()&#10;        loadingJob = null&#10;        loadingJobsActive = false&#10;&#10;        // Parar y limpiar el reproductor&#10;        _exoPlayer?.let { player -&gt;&#10;            player.stop()&#10;            player.clearMediaItems()&#10;        }&#10;&#10;        // Limpiar estado&#10;        _isLoading.postValue(false)&#10;        _error.postValue(null)&#10;    }&#10;&#10;    override fun onCleared() {&#10;        super.onCleared()&#10;        _exoPlayer?.release()&#10;        _exoPlayer = null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>