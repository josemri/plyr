<?xml version="1.0" encoding="UTF-8"?>
<project version="4">
  <component name="CopilotDiffPersistence">
    <option name="pendingDiffs">
      <map>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/examples/NotificationIntegrationExample.kt" />
              <option name="updatedContent" value="package com.plyr.examples&#10;&#10;import android.Manifest&#10;import android.content.pm.PackageManager&#10;import android.os.Build&#10;import androidx.activity.ComponentActivity&#10;import androidx.activity.result.contract.ActivityResultContracts&#10;import androidx.core.content.ContextCompat&#10;import androidx.lifecycle.lifecycleScope&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Ejemplo de integración del sistema de notificaciones de música&#10; * &#10; * Este archivo muestra cómo implementar las notificaciones en tu MainActivity.&#10; * Copia este código a tu MainActivity existente.&#10; */&#10;class NotificationIntegrationExample {&#10;    &#10;    // En tu MainActivity, agrega estas propiedades:&#10;    private lateinit var notificationManager: MusicNotificationManager&#10;    private lateinit var playerViewModel: PlayerViewModel&#10;    &#10;    // Launcher para pedir permisos de notificación (Android 13+)&#10;    private val notificationPermissionLauncher = registerForActivityResult(&#10;        ActivityResultContracts.RequestPermission()&#10;    ) { isGranted -&gt;&#10;        if (isGranted) {&#10;            // Permiso concedido, continuar con la inicialización&#10;            initializeNotificationSystem()&#10;        } else {&#10;            // Permiso denegado, manejar el caso apropiadamente&#10;            // Puedes mostrar un mensaje al usuario explicando por qué necesitas el permiso&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Llama este método en onCreate() de tu MainActivity&#10;     */&#10;    fun setupNotificationSystem(activity: ComponentActivity, viewModel: PlayerViewModel) {&#10;        playerViewModel = viewModel&#10;        &#10;        // Verificar y pedir permisos de notificación para Android 13+&#10;        if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10;            when {&#10;                ContextCompat.checkSelfPermission(&#10;                    activity,&#10;                    Manifest.permission.POST_NOTIFICATIONS&#10;                ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10;                    // Permiso ya concedido&#10;                    initializeNotificationSystem()&#10;                }&#10;                else -&gt; {&#10;                    // Pedir permiso&#10;                    notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10;                }&#10;            }&#10;        } else {&#10;            // Android 12 y menores no necesitan permiso explícito&#10;            initializeNotificationSystem()&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicializa el sistema de notificaciones&#10;     */&#10;    private fun initializeNotificationSystem() {&#10;        notificationManager = MusicNotificationManager(this)&#10;        notificationManager.startService()&#10;        &#10;        // Configurar listeners para actualizar notificación cuando cambie el track&#10;        setupNotificationListeners()&#10;    }&#10;    &#10;    /**&#10;     * Configura los listeners para sincronizar el PlayerViewModel con las notificaciones&#10;     */&#10;    private fun setupNotificationListeners() {&#10;        // Observar cambios en el track actual&#10;        playerViewModel.currentTrack.observe(this) { track -&gt;&#10;            track?.let {&#10;                notificationManager.updateSongInfo(it.name, it.artists)&#10;            }&#10;        }&#10;        &#10;        // Observar cambios en el título actual&#10;        playerViewModel.currentTitle.observe(this) { title -&gt;&#10;            title?.let {&#10;                // Si tienes información del artista disponible&#10;                val artist = &quot;Artista Desconocido&quot; // Reemplaza con la fuente real del artista&#10;                notificationManager.updateSongInfo(it, artist)&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Ejemplo de cómo reproducir una canción con notificación&#10;     */&#10;    fun playTrackWithNotification(audioUrl: String, title: String, artist: String) {&#10;        lifecycleScope.launch {&#10;            // Actualizar información en la notificación&#10;            notificationManager.updateSongInfo(title, artist)&#10;            &#10;            // Reproducir el audio en el servicio de notificación&#10;            notificationManager.playAudio(audioUrl, title, artist)&#10;            &#10;            // También reproducir en tu PlayerViewModel existente&#10;            // playerViewModel.playAudio(audioUrl) // Tu método existente&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Limpieza en onDestroy()&#10;     */&#10;    fun cleanupNotificationSystem() {&#10;        if (::notificationManager.isInitialized) {&#10;            notificationManager.stopService()&#10;        }&#10;    }&#10;}&#10;&#10;/**&#10; * INTEGRACIÓN COMPLETA EN TU MAINACTIVITY:&#10; * &#10; * class MainActivity : ComponentActivity() {&#10; *     private lateinit var notificationManager: MusicNotificationManager&#10; *     private lateinit var playerViewModel: PlayerViewModel&#10; *     &#10; *     // Launcher para permisos de notificación&#10; *     private val notificationPermissionLauncher = registerForActivityResult(&#10; *         ActivityResultContracts.RequestPermission()&#10; *     ) { isGranted -&gt;&#10; *         if (isGranted) {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onCreate(savedInstanceState: Bundle?) {&#10; *         super.onCreate(savedInstanceState)&#10; *         &#10; *         // Tu código existente...&#10; *         playerViewModel = ViewModelProvider(this)[PlayerViewModel::class.java]&#10; *         &#10; *         // Configurar notificaciones&#10; *         setupNotificationSystem()&#10; *         &#10; *         // Tu código de Compose...&#10; *     }&#10; *     &#10; *     private fun setupNotificationSystem() {&#10; *         if (Build.VERSION.SDK_INT &gt;= Build.VERSION_CODES.TIRAMISU) {&#10; *             when {&#10; *                 ContextCompat.checkSelfPermission(&#10; *                     this, Manifest.permission.POST_NOTIFICATIONS&#10; *                 ) == PackageManager.PERMISSION_GRANTED -&gt; {&#10; *                     initializeNotificationSystem()&#10; *                 }&#10; *                 else -&gt; {&#10; *                     notificationPermissionLauncher.launch(Manifest.permission.POST_NOTIFICATIONS)&#10; *                 }&#10; *             }&#10; *         } else {&#10; *             initializeNotificationSystem()&#10; *         }&#10; *     }&#10; *     &#10; *     private fun initializeNotificationSystem() {&#10; *         notificationManager = MusicNotificationManager(this)&#10; *         notificationManager.startService()&#10; *         &#10; *         // Observar cambios en el track actual&#10; *         playerViewModel.currentTrack.observe(this) { track -&gt;&#10; *             track?.let {&#10; *                 notificationManager.updateSongInfo(it.name, it.artists)&#10; *             }&#10; *         }&#10; *     }&#10; *     &#10; *     override fun onDestroy() {&#10; *         super.onDestroy()&#10; *         if (::notificationManager.isInitialized) {&#10; *             notificationManager.stopService()&#10; *         }&#10; *     }&#10; * }&#10; */" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SpotifyRepository.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/network/SpotifyRepository.kt" />
              <option name="originalContent" value="package com.plyr.network&#10;&#10;import android.annotation.SuppressLint&#10;import com.google.gson.Gson&#10;import com.google.gson.annotations.SerializedName&#10;import okhttp3.*&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import android.util.Base64&#10;import android.content.Context&#10;import com.plyr.utils.Config&#10;import androidx.core.net.toUri&#10;&#10;object SpotifyRepository {&#10;    &#10;    private val client = OkHttpClient()&#10;    private val gson = Gson()&#10;    &#10;    // URLs de Spotify&#10;    private const val AUTH_URL = &quot;https://accounts.spotify.com/authorize&quot;&#10;    private const val TOKEN_URL = &quot;https://accounts.spotify.com/api/token&quot;&#10;    private const val API_BASE_URL = &quot;https://api.spotify.com/v1&quot;&#10;    &#10;    // Generar URL de autorización&#10;    fun getAuthorizationUrl(context: Context): String? {&#10;        val clientId = Config.getSpotifyClientId(context)&#10;        return if (clientId != null) {&#10;            &quot;$AUTH_URL?client_id=$clientId&amp;response_type=code&amp;redirect_uri=${Config.SPOTIFY_REDIRECT_URI}&amp;scope=${Config.SPOTIFY_SCOPES.replace(&quot; &quot;, &quot;%20&quot;)}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    &#10;    // Iniciar flujo OAuth (abrir browser)&#10;    @SuppressLint(&quot;UseKtx&quot;)&#10;    fun startOAuthFlow(context: Context): Boolean {&#10;        val authUrl = getAuthorizationUrl(context)&#10;        return if (authUrl != null) {&#10;            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, authUrl.toUri())&#10;            context.startActivity(intent)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;    &#10;    // Intercambiar código de autorización por tokens&#10;    fun exchangeCodeForTokens(context: Context, authCode: String, callback: (SpotifyTokens?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;authorization_code&quot;)&#10;            .add(&quot;code&quot;, authCode)&#10;            .add(&quot;redirect_uri&quot;, Config.SPOTIFY_REDIRECT_URI)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing tokens: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Renovar access token usando refresh token&#10;    fun refreshAccessToken(context: Context, refreshToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;refresh_token&quot;)&#10;            .add(&quot;refresh_token&quot;, refreshToken)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens.accessToken, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing token: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener playlists del usuario con paginación (versión original para compatibilidad)&#10;    fun getUserPlaylists(accessToken: String, callback: (List&lt;SpotifyPlaylist&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/playlists?limit=$maxLimit&amp;offset=$offset&amp;fields=items(id,name,description,tracks(total),images)&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User playlists response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val playlistResponse = gson.fromJson(body, SpotifyPlaylistResponse::class.java)&#10;                            &#10;                            // Debug: log tracks data for cada playlist&#10;                            playlistResponse.items.forEachIndexed { index, playlist -&gt;&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist $index - '${playlist.name}': tracks=${playlist.tracks}, tracks.total=${playlist.tracks?.total}&quot;)&#10;                            }&#10;                            &#10;                            // Acumular resultados&#10;                            allPlaylists.addAll(playlistResponse.items)&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${playlistResponse.items.size} playlists, total accumulated: ${allPlaylists.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allPlaylists.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMorePlaylists = playlistResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMorePlaylists &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlists page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlists count: ${allPlaylists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de un álbum con paginación&#10;    fun getAlbumTracks(accessToken: String, albumId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/albums/$albumId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyTracksSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next album tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final album tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing album tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de una playlist con paginación&#10;    fun getPlaylistTracks(accessToken: String, playlistId: String, callback: (List&lt;SpotifyPlaylistTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyPlaylistTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyPlaylistTracksResponseRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlist tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlist tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlist tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener álbumes de un artista con paginación&#10;    fun getArtistAlbums(accessToken: String, artistId: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/artists/$artistId/albums?include_groups=album,single&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val albumsResponse = gson.fromJson(body, SpotifyAlbumsSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allAlbums.addAll(albumsResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albumsResponse.items.filterNotNull().size} albums, total accumulated: ${allAlbums.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = albumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next artist albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final artist albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing artist albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Buscar todo tipo de contenido en Spotify (canciones, álbumes, artistas, playlists)&#10;    fun searchAll(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=50&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search all response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchAllResponse::class.java)&#10;                        callback(searchResponse, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Seguir una playlist en Spotify&#10;    fun followPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(&quot;{}&quot;.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Dejar de seguir (eliminar) una playlist en Spotify&#10;    fun unfollowPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .delete()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Añadir una canción a una playlist en Spotify&#10;    fun addTrackToPlaylist(accessToken: String, playlistId: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;uris&quot; to listOf(&quot;spotify:track:$trackId&quot;)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(requestBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Eliminar una canción de una playlist en Spotify&#10;    fun removeTrackFromPlaylist(accessToken: String, playlistId: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;tracks&quot; to listOf(mapOf(&quot;uri&quot; to &quot;spotify:track:$trackId&quot;))))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .delete(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Buscar todo tipo de contenido en Spotify con paginación automática&#10;    fun searchAllWithPagination(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        // Por ahora, usar la función searchAll existente que ya maneja los resultados&#10;        searchAll(accessToken, query, callback)&#10;    }&#10;&#10;    // Guardar álbum en la biblioteca del usuario&#10;    fun saveAlbum(accessToken: String, albumId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;ids&quot; to listOf(albumId)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/albums&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Crear una nueva playlist en Spotify&#10;    fun createPlaylist(accessToken: String, name: String, description: String, isPublic: Boolean, trackIds: List&lt;String&gt; = emptyList(), callback: (Boolean, String?) -&gt; Unit) {&#10;        // Primero necesitamos obtener el ID del usuario&#10;        getUserProfile(accessToken) { userId, error -&gt;&#10;            if (userId != null) {&#10;                val playlistData = mapOf(&#10;                    &quot;name&quot; to name,&#10;                    &quot;description&quot; to description,&#10;                    &quot;public&quot; to isPublic&#10;                )&#10;                val jsonBody = gson.toJson(playlistData)&#10;                val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;$API_BASE_URL/users/$userId/playlists&quot;)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(requestBody)&#10;                    .build()&#10;&#10;                client.newCall(request).enqueue(object : Callback {&#10;                    override fun onFailure(call: Call, e: IOException) {&#10;                        callback(false, &quot;Error de red: ${e.message}&quot;)&#10;                    }&#10;&#10;                    override fun onResponse(call: Call, response: Response) {&#10;                        val body = response.body.string()&#10;                        if (response.isSuccessful) {&#10;                            // Si hay canciones para añadir, las añadimos ahora&#10;                            if (trackIds.isNotEmpty()) {&#10;                                try {&#10;                                    val createdPlaylist = gson.fromJson(body, SpotifyPlaylist::class.java)&#10;                                    // Añadir las canciones a la playlist recién creada&#10;                                    addTracksToPlaylist(accessToken, createdPlaylist.id, trackIds) { success, errorMsg -&gt;&#10;                                        if (success) {&#10;                                            callback(true, null)&#10;                                        } else {&#10;                                            callback(false, &quot;Playlist creada pero error añadiendo canciones: $errorMsg&quot;)&#10;                                        }&#10;                                    }&#10;                                } catch (e: Exception) {&#10;                                    callback(false, &quot;Error procesando playlist creada: ${e.message}&quot;)&#10;                                }&#10;                            } else {&#10;                                callback(true, null)&#10;                            }&#10;                        } else {&#10;                            callback(false, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                        }&#10;                    }&#10;                })&#10;            } else {&#10;                callback(false, error ?: &quot;Error obteniendo perfil de usuario&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Añadir múltiples canciones a una playlist&#10;    fun addTracksToPlaylist(accessToken: String, playlistId: String, trackIds: List&lt;String&gt;, callback: (Boolean, String?) -&gt; Unit) {&#10;        val uris = trackIds.map { &quot;spotify:track:$it&quot; }&#10;        val jsonBody = gson.toJson(mapOf(&quot;uris&quot; to uris))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener el perfil del usuario (necesario para crear playlists)&#10;    private fun getUserProfile(accessToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val userProfile = gson.fromJson(body, SpotifyUserProfile::class.java)&#10;                        callback(userProfile.id, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing user profile: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun createBasicAuthHeader(context: Context): String {&#10;        val credentials = &quot;${Config.getSpotifyClientId(context)}:${Config.getSpotifyClientSecret(context)}&quot;&#10;        val encodedCredentials = Base64.encodeToString(credentials.toByteArray(), Base64.NO_WRAP)&#10;        return &quot;Basic $encodedCredentials&quot;&#10;    }&#10;&#10;    // Obtener un track por ID&#10;    fun getTrack(accessToken: String, trackId: String, callback: (SpotifyTrack?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/tracks/$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val track = gson.fromJson(body, SpotifyTrack::class.java)&#10;                        callback(track, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing track: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener información detallada de un track (incluye información del álbum)&#10;    fun getTrackInfo(accessToken: String, trackId: String, callback: (SpotifyTrack?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/tracks/$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Track info response: $body&quot;)&#10;                        val track = gson.fromJson(body, SpotifyTrack::class.java)&#10;                        callback(track, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing track info: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener una playlist por ID&#10;    fun getPlaylist(accessToken: String, playlistId: String, callback: (SpotifyPlaylist?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val playlist = gson.fromJson(body, SpotifyPlaylist::class.java)&#10;                        callback(playlist, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing playlist: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener un álbum por ID&#10;    fun getAlbum(accessToken: String, albumId: String, callback: (SpotifyAlbum?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/albums/$albumId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val album = gson.fromJson(body, SpotifyAlbum::class.java)&#10;                        callback(album, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing album: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener un artista por ID&#10;    fun getArtist(accessToken: String, artistId: String, callback: (SpotifyArtistFull?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/artists/$artistId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val artist = gson.fromJson(body, SpotifyArtistFull::class.java)&#10;                        callback(artist, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing artist: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener los top tracks de un artista&#10;    fun getArtistTopTracks(accessToken: String, artistId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/artists/$artistId/top-tracks?market=US&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist top tracks response: ${body.take(200)}...&quot;)&#10;                        val topTracksResponse = gson.fromJson(body, SpotifyArtistTopTracksResponse::class.java)&#10;                        callback(topTracksResponse.tracks, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing artist top tracks: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener canciones favoritas del usuario (Liked Songs) con paginación&#10;    fun getUserSavedTracks(accessToken: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User saved tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val savedTracksResponse = gson.fromJson(body, SpotifySavedTracksResponse::class.java)&#10;&#10;                            // Extraer los tracks de los items y filtrar nulls&#10;                            val tracks = savedTracksResponse.items.mapNotNull { it.track }&#10;                            allTracks.addAll(tracks)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracks.size} saved tracks, total accumulated: ${allTracks.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = savedTracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;&#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next saved tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final saved tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing saved tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Añadir una canción a Liked Songs (favoritos del usuario)&#10;    fun saveTrack(accessToken: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks?ids=$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(&quot;{}&quot;.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;✓ Track añadido a Liked Songs: $trackId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error añadiendo a Liked Songs: ${response.code} - $errorBody&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Quitar una canción de Liked Songs (favoritos del usuario)&#10;    fun removeTrack(accessToken: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;ids&quot; to listOf(trackId)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .delete(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;✓ Track eliminado de Liked Songs: $trackId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error eliminando de Liked Songs: ${response.code} - $errorBody&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Verificar si una canción está en Liked Songs&#10;    fun checkSavedTrack(accessToken: String, trackId: String, callback: (Boolean?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks/contains?ids=$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val result = gson.fromJson(body, Array&lt;Boolean&gt;::class.java)&#10;                        callback(result.firstOrNull() ?: false, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing response: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener álbumes guardados del usuario (con paginación)&#10;    fun getUserSavedAlbums(accessToken: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/albums?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User saved albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val savedAlbumsResponse = gson.fromJson(body, SpotifySavedAlbumsResponse::class.java)&#10;&#10;                            // Extraer los álbumes de los items y filtrar nulls&#10;                            val albums = savedAlbumsResponse.items.mapNotNull { it.album }&#10;                            allAlbums.addAll(albums)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albums.size} saved albums, total accumulated: ${allAlbums.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = savedAlbumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;&#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next saved albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final saved albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing saved albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Obtener artistas seguidos del usuario (con paginación)&#10;    fun getUserFollowedArtists(accessToken: String, callback: (List&lt;SpotifyArtistFull&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allArtists = mutableListOf&lt;SpotifyArtistFull&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(after: String? = null) {&#10;            val url = if (after != null) {&#10;                &quot;$API_BASE_URL/me/following?type=artist&amp;limit=$maxLimit&amp;after=$after&quot;&#10;            } else {&#10;                &quot;$API_BASE_URL/me/following?type=artist&amp;limit=$maxLimit&quot;&#10;            }&#10;&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User followed artists response (after=$after): ${body.take(200)}...&quot;)&#10;                            val followedArtistsResponse = gson.fromJson(body, SpotifyFollowedArtistsResponse::class.java)&#10;&#10;                            // Extraer los artistas&#10;                            val artists = followedArtistsResponse.artists.items&#10;                            allArtists.addAll(artists)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${artists.size} followed artists, total accumulated: ${allArtists.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allArtists.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val nextCursor = followedArtistsResponse.artists.cursors?.after&#10;                            val hasMoreArtists = nextCursor != null &amp;&amp; artists.size == maxLimit&#10;&#10;                            // Si hay más contenido, continuar paginando&#10;                            if (hasMoreArtists) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next followed artists page: after=$nextCursor&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextCursor)&#10;                                }, 200)&#10;                            } else {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Followed artists pagination completed: no more results available&quot;)&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final followed artists count: ${allArtists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing followed artists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(null)&#10;    }&#10;}&#10;&#10;&#10;// Data classes para Spotify API&#10;data class SpotifyTokens(&#10;    @SerializedName(&quot;access_token&quot;) val accessToken: String,&#10;    @SerializedName(&quot;token_type&quot;) val tokenType: String,&#10;    @SerializedName(&quot;scope&quot;) val scope: String,&#10;    @SerializedName(&quot;expires_in&quot;) val expiresIn: Int,&#10;    @SerializedName(&quot;refresh_token&quot;) val refreshToken: String?&#10;)&#10;&#10;data class SpotifyPlaylistResponse(&#10;    val items: List&lt;SpotifyPlaylist&gt;&#10;)&#10;&#10;data class SpotifyPlaylist(&#10;    val id: String,&#10;    val name: String,&#10;    val description: String?,&#10;    val tracks: SpotifyPlaylistTracks?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;) {&#10;&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyPlaylistTracks(&#10;    val href: String?,&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyImage(&#10;    val url: String,&#10;    val height: Int?,&#10;    val width: Int?&#10;)&#10;&#10;data class SpotifyTrack(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    @SerializedName(&quot;duration_ms&quot;) val durationMs: Int? = null,&#10;    val album: SpotifyAlbumSimple? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;&#10;}&#10;&#10;// Simplified album info for track details&#10;data class SpotifyAlbumSimple(&#10;    val id: String,&#10;    val name: String,&#10;    @SerializedName(&quot;release_date&quot;) val releaseDate: String? = null,&#10;    val images: List&lt;SpotifyImage&gt;? = null&#10;)&#10;&#10;data class SpotifySearchAllResponse(&#10;    val tracks: SpotifyTracksSearchResult,&#10;    val albums: SpotifyAlbumsSearchResult,&#10;    val artists: SpotifyArtistsSearchResult,&#10;    val playlists: SpotifyPlaylistsSearchResult&#10;)&#10;&#10;data class SpotifyTracksSearchResult(&#10;    val items: List&lt;SpotifyTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResult(&#10;    val items: List&lt;SpotifyAlbum&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResult(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResult(&#10;    val items: List&lt;SpotifyPlaylist?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbum(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    @SerializedName(&quot;release_date&quot;) val releasedate: String? = null,&#10;    @SerializedName(&quot;total_tracks&quot;) val totaltracks: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyArtistFull(&#10;    val id: String,&#10;    val name: String,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    val followers: SpotifyFollowers?,&#10;    val genres: List&lt;String&gt;?&#10;) {&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;&#10;}&#10;&#10;data class SpotifyFollowers(&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyArtist(&#10;    val name: String&#10;)&#10;&#10;data class SpotifyPlaylistTracksResponseRaw(&#10;    val items: List&lt;SpotifyPlaylistTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTrack(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;// Data classes auxiliares para parsing (con nullable items)&#10;data class SpotifyTracksSearchResultRaw(&#10;    val items: List&lt;SpotifyTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResultRaw(&#10;    val items: List&lt;SpotifyAlbum?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;// Data class para perfil de usuario de Spotify&#10;data class SpotifyUserProfile(&#10;    val id: String,&#10;    @SerializedName(&quot;display_name&quot;) val displayName: String?,&#10;    val email: String?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;)&#10;&#10;data class SpotifySavedTracksResponse(&#10;    val items: List&lt;SpotifySavedTrackItem&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySavedTrackItem(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;data class SpotifySavedAlbumsResponse(&#10;    val items: List&lt;SpotifySavedAlbumItem&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySavedAlbumItem(&#10;    val album: SpotifyAlbum?,&#10;    @SerializedName(&quot;added_at&quot;) val addedAt: String?&#10;)&#10;&#10;data class SpotifyFollowedArtistsResponse(&#10;    val artists: SpotifyArtistsPage&#10;)&#10;&#10;data class SpotifyArtistsPage(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int,&#10;    val limit: Int,&#10;    val offset: Int,&#10;    val cursors: SpotifyCursors&#10;)&#10;&#10;data class SpotifyCursors(&#10;    val before: String?,&#10;    val after: String?&#10;)&#10;&#10;data class SpotifyArtistTopTracksResponse(&#10;    val tracks: List&lt;SpotifyTrack&gt;&#10;)&#10;" />
              <option name="updatedContent" value="package com.plyr.network&#10;&#10;import android.annotation.SuppressLint&#10;import com.google.gson.Gson&#10;import com.google.gson.annotations.SerializedName&#10;import okhttp3.*&#10;import okhttp3.MediaType.Companion.toMediaType&#10;import okhttp3.RequestBody.Companion.toRequestBody&#10;import java.io.IOException&#10;import android.util.Base64&#10;import android.content.Context&#10;import com.plyr.utils.Config&#10;import androidx.core.net.toUri&#10;&#10;object SpotifyRepository {&#10;    &#10;    private val client = OkHttpClient()&#10;    private val gson = Gson()&#10;    &#10;    // URLs de Spotify&#10;    private const val AUTH_URL = &quot;https://accounts.spotify.com/authorize&quot;&#10;    private const val TOKEN_URL = &quot;https://accounts.spotify.com/api/token&quot;&#10;    private const val API_BASE_URL = &quot;https://api.spotify.com/v1&quot;&#10;    &#10;    // Generar URL de autorización&#10;    fun getAuthorizationUrl(context: Context): String? {&#10;        val clientId = Config.getSpotifyClientId(context)&#10;        return if (clientId != null) {&#10;            &quot;$AUTH_URL?client_id=$clientId&amp;response_type=code&amp;redirect_uri=${Config.SPOTIFY_REDIRECT_URI}&amp;scope=${Config.SPOTIFY_SCOPES.replace(&quot; &quot;, &quot;%20&quot;)}&quot;&#10;        } else {&#10;            null&#10;        }&#10;    }&#10;    &#10;    // Iniciar flujo OAuth (abrir browser)&#10;    @SuppressLint(&quot;UseKtx&quot;)&#10;    fun startOAuthFlow(context: Context): Boolean {&#10;        val authUrl = getAuthorizationUrl(context)&#10;        return if (authUrl != null) {&#10;            val intent = android.content.Intent(android.content.Intent.ACTION_VIEW, authUrl.toUri())&#10;            context.startActivity(intent)&#10;            true&#10;        } else {&#10;            false&#10;        }&#10;    }&#10;    &#10;    // Intercambiar código de autorización por tokens&#10;    fun exchangeCodeForTokens(context: Context, authCode: String, callback: (SpotifyTokens?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;authorization_code&quot;)&#10;            .add(&quot;code&quot;, authCode)&#10;            .add(&quot;redirect_uri&quot;, Config.SPOTIFY_REDIRECT_URI)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing tokens: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;    &#10;    // Renovar access token usando refresh token&#10;    fun refreshAccessToken(context: Context, refreshToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        if (!Config.hasSpotifyCredentials(context)) {&#10;            callback(null, &quot;Spotify credentials not configured&quot;)&#10;            return&#10;        }&#10;        &#10;        val authHeader = createBasicAuthHeader(context)&#10;        val formBody = FormBody.Builder()&#10;            .add(&quot;grant_type&quot;, &quot;refresh_token&quot;)&#10;            .add(&quot;refresh_token&quot;, refreshToken)&#10;            .build()&#10;        &#10;        val request = Request.Builder()&#10;            .url(TOKEN_URL)&#10;            .addHeader(&quot;Authorization&quot;, authHeader)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/x-www-form-urlencoded&quot;)&#10;            .post(formBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val tokens = gson.fromJson(body, SpotifyTokens::class.java)&#10;                        callback(tokens.accessToken, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing token: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener playlists del usuario con paginación (versión original para compatibilidad)&#10;    fun getUserPlaylists(accessToken: String, callback: (List&lt;SpotifyPlaylist&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allPlaylists = mutableListOf&lt;SpotifyPlaylist&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/playlists?limit=$maxLimit&amp;offset=$offset&amp;fields=items(id,name,description,tracks(total),images)&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User playlists response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val playlistResponse = gson.fromJson(body, SpotifyPlaylistResponse::class.java)&#10;                            &#10;                            // Debug: log tracks data for cada playlist&#10;                            playlistResponse.items.forEachIndexed { index, playlist -&gt;&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist $index - '${playlist.name}': tracks=${playlist.tracks}, tracks.total=${playlist.tracks?.total}&quot;)&#10;                            }&#10;                            &#10;                            // Acumular resultados&#10;                            allPlaylists.addAll(playlistResponse.items)&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${playlistResponse.items.size} playlists, total accumulated: ${allPlaylists.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allPlaylists.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMorePlaylists = playlistResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMorePlaylists &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlists page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlists pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlists count: ${allPlaylists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de un álbum con paginación&#10;    fun getAlbumTracks(accessToken: String, albumId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/albums/$albumId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyTracksSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next album tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Album tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final album tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing album tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener tracks de una playlist con paginación&#10;    fun getPlaylistTracks(accessToken: String, playlistId: String, callback: (List&lt;SpotifyPlaylistTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyPlaylistTrack&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val tracksResponse = gson.fromJson(body, SpotifyPlaylistTracksResponseRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allTracks.addAll(tracksResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracksResponse.items.filterNotNull().size} tracks, total accumulated: ${allTracks.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = tracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next playlist tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Playlist tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final playlist tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing playlist tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Obtener álbumes de un artista con paginación&#10;    fun getArtistAlbums(accessToken: String, artistId: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;        &#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/artists/$artistId/albums?include_groups=album,single&amp;limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;            &#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;                &#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val albumsResponse = gson.fromJson(body, SpotifyAlbumsSearchResultRaw::class.java)&#10;                            &#10;                            // Acumular resultados (filtrando nulls)&#10;                            allAlbums.addAll(albumsResponse.items.filterNotNull())&#10;                            pageCount++&#10;                            &#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albumsResponse.items.filterNotNull().size} albums, total accumulated: ${allAlbums.size}&quot;)&#10;                            &#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;                            &#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = albumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;                            &#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next artist albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final artist albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing artist albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;        &#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;    &#10;    // Buscar todo tipo de contenido en Spotify (canciones, álbumes, artistas, playlists)&#10;    fun searchAll(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        val encodedQuery = java.net.URLEncoder.encode(query, &quot;UTF-8&quot;)&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/search?q=$encodedQuery&amp;type=track,album,artist,playlist&amp;limit=50&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Search all response: $body&quot;)&#10;                        val searchResponse = gson.fromJson(body, SpotifySearchAllResponse::class.java)&#10;                        callback(searchResponse, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing search results: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Seguir una playlist en Spotify&#10;    fun followPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(&quot;{}&quot;.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Dejar de seguir (eliminar) una playlist en Spotify&#10;    fun unfollowPlaylist(accessToken: String, playlistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;https://api.spotify.com/v1/playlists/$playlistId/followers&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .delete()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Añadir una canción a una playlist en Spotify&#10;    fun addTrackToPlaylist(accessToken: String, playlistId: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;uris&quot; to listOf(&quot;spotify:track:$trackId&quot;)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(requestBody)&#10;            .build()&#10;        &#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;            &#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Eliminar una canción de una playlist en Spotify&#10;    fun removeTrackFromPlaylist(accessToken: String, playlistId: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;tracks&quot; to listOf(mapOf(&quot;uri&quot; to &quot;spotify:track:$trackId&quot;))))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .delete(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Buscar todo tipo de contenido en Spotify con paginación automática&#10;    fun searchAllWithPagination(accessToken: String, query: String, callback: (SpotifySearchAllResponse?, String?) -&gt; Unit) {&#10;        // Por ahora, usar la función searchAll existente que ya maneja los resultados&#10;        searchAll(accessToken, query, callback)&#10;    }&#10;&#10;    // Guardar álbum en la biblioteca del usuario&#10;    fun saveAlbum(accessToken: String, albumId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;ids&quot; to listOf(albumId)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/albums&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Crear una nueva playlist en Spotify&#10;    fun createPlaylist(accessToken: String, name: String, description: String, isPublic: Boolean, trackIds: List&lt;String&gt; = emptyList(), callback: (Boolean, String?) -&gt; Unit) {&#10;        // Primero necesitamos obtener el ID del usuario&#10;        getUserProfile(accessToken) { userId, error -&gt;&#10;            if (userId != null) {&#10;                val playlistData = mapOf(&#10;                    &quot;name&quot; to name,&#10;                    &quot;description&quot; to description,&#10;                    &quot;public&quot; to isPublic&#10;                )&#10;                val jsonBody = gson.toJson(playlistData)&#10;                val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;                val request = Request.Builder()&#10;                    .url(&quot;$API_BASE_URL/users/$userId/playlists&quot;)&#10;                    .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                    .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;                    .post(requestBody)&#10;                    .build()&#10;&#10;                client.newCall(request).enqueue(object : Callback {&#10;                    override fun onFailure(call: Call, e: IOException) {&#10;                        callback(false, &quot;Error de red: ${e.message}&quot;)&#10;                    }&#10;&#10;                    override fun onResponse(call: Call, response: Response) {&#10;                        val body = response.body.string()&#10;                        if (response.isSuccessful) {&#10;                            // Si hay canciones para añadir, las añadimos ahora&#10;                            if (trackIds.isNotEmpty()) {&#10;                                try {&#10;                                    val createdPlaylist = gson.fromJson(body, SpotifyPlaylist::class.java)&#10;                                    // Añadir las canciones a la playlist recién creada&#10;                                    addTracksToPlaylist(accessToken, createdPlaylist.id, trackIds) { success, errorMsg -&gt;&#10;                                        if (success) {&#10;                                            callback(true, null)&#10;                                        } else {&#10;                                            callback(false, &quot;Playlist creada pero error añadiendo canciones: $errorMsg&quot;)&#10;                                        }&#10;                                    }&#10;                                } catch (e: Exception) {&#10;                                    callback(false, &quot;Error procesando playlist creada: ${e.message}&quot;)&#10;                                }&#10;                            } else {&#10;                                callback(true, null)&#10;                            }&#10;                        } else {&#10;                            callback(false, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                        }&#10;                    }&#10;                })&#10;            } else {&#10;                callback(false, error ?: &quot;Error obteniendo perfil de usuario&quot;)&#10;            }&#10;        }&#10;    }&#10;&#10;    // Añadir múltiples canciones a una playlist&#10;    fun addTracksToPlaylist(accessToken: String, playlistId: String, trackIds: List&lt;String&gt;, callback: (Boolean, String?) -&gt; Unit) {&#10;        val uris = trackIds.map { &quot;spotify:track:$it&quot; }&#10;        val jsonBody = gson.toJson(mapOf(&quot;uris&quot; to uris))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .post(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener el perfil del usuario (necesario para crear playlists)&#10;    private fun getUserProfile(accessToken: String, callback: (String?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val userProfile = gson.fromJson(body, SpotifyUserProfile::class.java)&#10;                        callback(userProfile.id, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing user profile: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    private fun createBasicAuthHeader(context: Context): String {&#10;        val credentials = &quot;${Config.getSpotifyClientId(context)}:${Config.getSpotifyClientSecret(context)}&quot;&#10;        val encodedCredentials = Base64.encodeToString(credentials.toByteArray(), Base64.NO_WRAP)&#10;        return &quot;Basic $encodedCredentials&quot;&#10;    }&#10;&#10;    // Obtener un track por ID&#10;    fun getTrack(accessToken: String, trackId: String, callback: (SpotifyTrack?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/tracks/$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val track = gson.fromJson(body, SpotifyTrack::class.java)&#10;                        callback(track, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing track: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener información detallada de un track (incluye información del álbum)&#10;    fun getTrackInfo(accessToken: String, trackId: String, callback: (SpotifyTrack?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/tracks/$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Track info response: $body&quot;)&#10;                        val track = gson.fromJson(body, SpotifyTrack::class.java)&#10;                        callback(track, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing track info: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener una playlist por ID&#10;    fun getPlaylist(accessToken: String, playlistId: String, callback: (SpotifyPlaylist?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/playlists/$playlistId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val playlist = gson.fromJson(body, SpotifyPlaylist::class.java)&#10;                        callback(playlist, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing playlist: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener un álbum por ID&#10;    fun getAlbum(accessToken: String, albumId: String, callback: (SpotifyAlbum?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/albums/$albumId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val album = gson.fromJson(body, SpotifyAlbum::class.java)&#10;                        callback(album, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing album: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener un artista por ID&#10;    fun getArtist(accessToken: String, artistId: String, callback: (SpotifyArtistFull?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/artists/$artistId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val artist = gson.fromJson(body, SpotifyArtistFull::class.java)&#10;                        callback(artist, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing artist: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener los top tracks de un artista&#10;    fun getArtistTopTracks(accessToken: String, artistId: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/artists/$artistId/top-tracks?market=US&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist top tracks response: ${body.take(200)}...&quot;)&#10;                        val topTracksResponse = gson.fromJson(body, SpotifyArtistTopTracksResponse::class.java)&#10;                        callback(topTracksResponse.tracks, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing artist top tracks: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener canciones favoritas del usuario (Liked Songs) con paginación&#10;    fun getUserSavedTracks(accessToken: String, callback: (List&lt;SpotifyTrack&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allTracks = mutableListOf&lt;SpotifyTrack&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/tracks?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User saved tracks response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val savedTracksResponse = gson.fromJson(body, SpotifySavedTracksResponse::class.java)&#10;&#10;                            // Extraer los tracks de los items y filtrar nulls&#10;                            val tracks = savedTracksResponse.items.mapNotNull { it.track }&#10;                            allTracks.addAll(tracks)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${tracks.size} saved tracks, total accumulated: ${allTracks.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allTracks.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreTracks = savedTracksResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;&#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreTracks &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next saved tracks page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved tracks pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved tracks pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final saved tracks count: ${allTracks.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing saved tracks: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Añadir una canción a Liked Songs (favoritos del usuario)&#10;    fun saveTrack(accessToken: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks?ids=$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(&quot;{}&quot;.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;✓ Track añadido a Liked Songs: $trackId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error añadiendo a Liked Songs: ${response.code} - $errorBody&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Quitar una canción de Liked Songs (favoritos del usuario)&#10;    fun removeTrack(accessToken: String, trackId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val jsonBody = gson.toJson(mapOf(&quot;ids&quot; to listOf(trackId)))&#10;        val requestBody = jsonBody.toRequestBody(&quot;application/json&quot;.toMediaType())&#10;&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .delete(requestBody)&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;✓ Track eliminado de Liked Songs: $trackId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    val errorBody = response.body.string()&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error eliminando de Liked Songs: ${response.code} - $errorBody&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $errorBody&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Verificar si una canción está en Liked Songs&#10;    fun checkSavedTrack(accessToken: String, trackId: String, callback: (Boolean?, String?) -&gt; Unit) {&#10;        val request = Request.Builder()&#10;            .url(&quot;$API_BASE_URL/me/tracks/contains?ids=$trackId&quot;)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        val result = gson.fromJson(body, Array&lt;Boolean&gt;::class.java)&#10;                        callback(result.firstOrNull() ?: false, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing response: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Obtener álbumes guardados del usuario (con paginación)&#10;    fun getUserSavedAlbums(accessToken: String, callback: (List&lt;SpotifyAlbum&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allAlbums = mutableListOf&lt;SpotifyAlbum&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(offset: Int = 0) {&#10;            val request = Request.Builder()&#10;                .url(&quot;$API_BASE_URL/me/albums?limit=$maxLimit&amp;offset=$offset&quot;)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User saved albums response (offset=$offset): ${body.take(200)}...&quot;)&#10;                            val savedAlbumsResponse = gson.fromJson(body, SpotifySavedAlbumsResponse::class.java)&#10;&#10;                            // Extraer los álbumes de los items y filtrar nulls&#10;                            val albums = savedAlbumsResponse.items.mapNotNull { it.album }&#10;                            allAlbums.addAll(albums)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${albums.size} saved albums, total accumulated: ${allAlbums.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allAlbums.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val hasMoreAlbums = savedAlbumsResponse.items.size == maxLimit&#10;                            val nextOffset = offset + maxLimit&#10;                            val wouldExceedLimit = nextOffset &gt;= 1000&#10;&#10;                            // Si hay más contenido y no excedemos el límite, continuar paginando&#10;                            if (hasMoreAlbums &amp;&amp; !wouldExceedLimit) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next saved albums page: offset=$nextOffset&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextOffset)&#10;                                }, 200)&#10;                            } else {&#10;                                if (wouldExceedLimit) {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved albums pagination stopped: reached API limit (offset would be $nextOffset &gt;= 1000)&quot;)&#10;                                } else {&#10;                                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Saved albums pagination completed: no more results available&quot;)&#10;                                }&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final saved albums count: ${allAlbums.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing saved albums: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(0)&#10;    }&#10;&#10;    // Obtener artistas seguidos del usuario (con paginación)&#10;    fun getUserFollowedArtists(accessToken: String, callback: (List&lt;SpotifyArtistFull&gt;?, String?) -&gt; Unit) {&#10;        val maxLimit = 50 // Máximo permitido por Spotify&#10;        val allArtists = mutableListOf&lt;SpotifyArtistFull&gt;()&#10;        var pageCount = 0&#10;&#10;        // Función recursiva para obtener todas las páginas&#10;        fun fetchPage(after: String? = null) {&#10;            val url = if (after != null) {&#10;                &quot;$API_BASE_URL/me/following?type=artist&amp;limit=$maxLimit&amp;after=$after&quot;&#10;            } else {&#10;                &quot;$API_BASE_URL/me/following?type=artist&amp;limit=$maxLimit&quot;&#10;            }&#10;&#10;            val request = Request.Builder()&#10;                .url(url)&#10;                .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;                .get()&#10;                .build()&#10;&#10;            client.newCall(request).enqueue(object : Callback {&#10;                override fun onFailure(call: Call, e: IOException) {&#10;                    callback(null, &quot;Error de red: ${e.message}&quot;)&#10;                }&#10;&#10;                override fun onResponse(call: Call, response: Response) {&#10;                    val body = response.body.string()&#10;                    if (response.isSuccessful) {&#10;                        try {&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;User followed artists response (after=$after): ${body.take(200)}...&quot;)&#10;                            val followedArtistsResponse = gson.fromJson(body, SpotifyFollowedArtistsResponse::class.java)&#10;&#10;                            // Extraer los artistas&#10;                            val artists = followedArtistsResponse.artists.items&#10;                            allArtists.addAll(artists)&#10;                            pageCount++&#10;&#10;                            android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Page $pageCount loaded: ${artists.size} followed artists, total accumulated: ${allArtists.size}&quot;)&#10;&#10;                            // Enviar resultados actualizados después de cada página&#10;                            callback(allArtists.toList(), null)&#10;&#10;                            // Verificar si hay más páginas que cargar&#10;                            val nextCursor = followedArtistsResponse.artists.cursors?.after&#10;                            val hasMoreArtists = nextCursor != null &amp;&amp; artists.size == maxLimit&#10;&#10;                            // Si hay más contenido, continuar paginando&#10;                            if (hasMoreArtists) {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Fetching next followed artists page: after=$nextCursor&quot;)&#10;                                android.os.Handler(android.os.Looper.getMainLooper()).postDelayed({&#10;                                    fetchPage(nextCursor)&#10;                                }, 200)&#10;                            } else {&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Followed artists pagination completed: no more results available&quot;)&#10;                                android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Final followed artists count: ${allArtists.size}&quot;)&#10;                            }&#10;                        } catch (e: Exception) {&#10;                            callback(null, &quot;Error parsing followed artists: ${e.message}&quot;)&#10;                        }&#10;                    } else {&#10;                        callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                    }&#10;                }&#10;            })&#10;        }&#10;&#10;        // Iniciar la paginación&#10;        fetchPage(null)&#10;    }&#10;&#10;    // Seguir a un artista&#10;    fun followArtist(accessToken: String, artistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val url = &quot;$API_BASE_URL/me/following?type=artist&amp;ids=$artistId&quot;&#10;        &#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .put(&quot;&quot;.toRequestBody(&quot;application/json&quot;.toMediaType()))&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist followed successfully: $artistId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error following artist: HTTP ${response.code}: $body&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Dejar de seguir a un artista&#10;    fun unfollowArtist(accessToken: String, artistId: String, callback: (Boolean, String?) -&gt; Unit) {&#10;        val url = &quot;$API_BASE_URL/me/following?type=artist&amp;ids=$artistId&quot;&#10;        &#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .addHeader(&quot;Content-Type&quot;, &quot;application/json&quot;)&#10;            .delete()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(false, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Artist unfollowed successfully: $artistId&quot;)&#10;                    callback(true, null)&#10;                } else {&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error unfollowing artist: HTTP ${response.code}: $body&quot;)&#10;                    callback(false, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;&#10;    // Verificar si el usuario sigue a un artista&#10;    fun checkIfFollowingArtist(accessToken: String, artistId: String, callback: (Boolean?, String?) -&gt; Unit) {&#10;        val url = &quot;$API_BASE_URL/me/following/contains?type=artist&amp;ids=$artistId&quot;&#10;        &#10;        val request = Request.Builder()&#10;            .url(url)&#10;            .addHeader(&quot;Authorization&quot;, &quot;Bearer $accessToken&quot;)&#10;            .get()&#10;            .build()&#10;&#10;        client.newCall(request).enqueue(object : Callback {&#10;            override fun onFailure(call: Call, e: IOException) {&#10;                callback(null, &quot;Error de red: ${e.message}&quot;)&#10;            }&#10;&#10;            override fun onResponse(call: Call, response: Response) {&#10;                val body = response.body.string()&#10;                if (response.isSuccessful) {&#10;                    try {&#10;                        // La API devuelve un array con un solo boolean&#10;                        val result = gson.fromJson(body, Array&lt;Boolean&gt;::class.java)&#10;                        val isFollowing = result.firstOrNull() ?: false&#10;                        android.util.Log.d(&quot;SpotifyRepository&quot;, &quot;Check if following artist $artistId: $isFollowing&quot;)&#10;                        callback(isFollowing, null)&#10;                    } catch (e: Exception) {&#10;                        callback(null, &quot;Error parsing response: ${e.message}&quot;)&#10;                    }&#10;                } else {&#10;                    android.util.Log.e(&quot;SpotifyRepository&quot;, &quot;Error checking if following artist: HTTP ${response.code}: $body&quot;)&#10;                    callback(null, &quot;Error HTTP ${response.code}: $body&quot;)&#10;                }&#10;            }&#10;        })&#10;    }&#10;}&#10;&#10;&#10;// Data classes para Spotify API&#10;data class SpotifyTokens(&#10;    @SerializedName(&quot;access_token&quot;) val accessToken: String,&#10;    @SerializedName(&quot;token_type&quot;) val tokenType: String,&#10;    @SerializedName(&quot;scope&quot;) val scope: String,&#10;    @SerializedName(&quot;expires_in&quot;) val expiresIn: Int,&#10;    @SerializedName(&quot;refresh_token&quot;) val refreshToken: String?&#10;)&#10;&#10;data class SpotifyPlaylistResponse(&#10;    val items: List&lt;SpotifyPlaylist&gt;&#10;)&#10;&#10;data class SpotifyPlaylist(&#10;    val id: String,&#10;    val name: String,&#10;    val description: String?,&#10;    val tracks: SpotifyPlaylistTracks?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;) {&#10;&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyPlaylistTracks(&#10;    val href: String?,&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyImage(&#10;    val url: String,&#10;    val height: Int?,&#10;    val width: Int?&#10;)&#10;&#10;data class SpotifyTrack(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    @SerializedName(&quot;duration_ms&quot;) val durationMs: Int? = null,&#10;    val album: SpotifyAlbumSimple? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;    &#10;    fun getDisplayName(): String {&#10;        return &quot;$name - ${getArtistNames()}&quot;&#10;    }&#10;&#10;}&#10;&#10;// Simplified album info for track details&#10;data class SpotifyAlbumSimple(&#10;    val id: String,&#10;    val name: String,&#10;    @SerializedName(&quot;release_date&quot;) val releaseDate: String? = null,&#10;    val images: List&lt;SpotifyImage&gt;? = null&#10;)&#10;&#10;data class SpotifySearchAllResponse(&#10;    val tracks: SpotifyTracksSearchResult,&#10;    val albums: SpotifyAlbumsSearchResult,&#10;    val artists: SpotifyArtistsSearchResult,&#10;    val playlists: SpotifyPlaylistsSearchResult&#10;)&#10;&#10;data class SpotifyTracksSearchResult(&#10;    val items: List&lt;SpotifyTrack&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResult(&#10;    val items: List&lt;SpotifyAlbum&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyArtistsSearchResult(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistsSearchResult(&#10;    val items: List&lt;SpotifyPlaylist?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbum(&#10;    val id: String,&#10;    val name: String,&#10;    val artists: List&lt;SpotifyArtist&gt;,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    @SerializedName(&quot;release_date&quot;) val releasedate: String? = null,&#10;    @SerializedName(&quot;total_tracks&quot;) val totaltracks: Int? = null&#10;) {&#10;    fun getArtistNames(): String {&#10;        return artists.joinToString(&quot;, &quot;) { it.name }&#10;    }&#10;&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;}&#10;&#10;data class SpotifyArtistFull(&#10;    val id: String,&#10;    val name: String,&#10;    val images: List&lt;SpotifyImage&gt;?,&#10;    val followers: SpotifyFollowers?,&#10;    val genres: List&lt;String&gt;?&#10;) {&#10;    fun getImageUrl(): String {&#10;        return images?.firstOrNull()?.url ?: &quot;&quot;&#10;    }&#10;&#10;}&#10;&#10;data class SpotifyFollowers(&#10;    val total: Int&#10;)&#10;&#10;data class SpotifyArtist(&#10;    val name: String&#10;)&#10;&#10;data class SpotifyPlaylistTracksResponseRaw(&#10;    val items: List&lt;SpotifyPlaylistTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyPlaylistTrack(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;// Data classes auxiliares para parsing (con nullable items)&#10;data class SpotifyTracksSearchResultRaw(&#10;    val items: List&lt;SpotifyTrack?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifyAlbumsSearchResultRaw(&#10;    val items: List&lt;SpotifyAlbum?&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;// Data class para perfil de usuario de Spotify&#10;data class SpotifyUserProfile(&#10;    val id: String,&#10;    @SerializedName(&quot;display_name&quot;) val displayName: String?,&#10;    val email: String?,&#10;    val images: List&lt;SpotifyImage&gt;?&#10;)&#10;&#10;data class SpotifySavedTracksResponse(&#10;    val items: List&lt;SpotifySavedTrackItem&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySavedTrackItem(&#10;    val track: SpotifyTrack?&#10;)&#10;&#10;data class SpotifySavedAlbumsResponse(&#10;    val items: List&lt;SpotifySavedAlbumItem&gt;,&#10;    val total: Int? = null,&#10;    val limit: Int? = null,&#10;    val offset: Int? = null,&#10;    val next: String? = null&#10;)&#10;&#10;data class SpotifySavedAlbumItem(&#10;    val album: SpotifyAlbum?,&#10;    @SerializedName(&quot;added_at&quot;) val addedAt: String?&#10;)&#10;&#10;data class SpotifyFollowedArtistsResponse(&#10;    val artists: SpotifyArtistsPage&#10;)&#10;&#10;data class SpotifyArtistsPage(&#10;    val items: List&lt;SpotifyArtistFull&gt;,&#10;    val total: Int,&#10;    val limit: Int,&#10;    val offset: Int,&#10;    val cursors: SpotifyCursors&#10;)&#10;&#10;data class SpotifyCursors(&#10;    val before: String?,&#10;    val after: String?&#10;)&#10;&#10;data class SpotifyArtistTopTracksResponse(&#10;    val tracks: List&lt;SpotifyTrack&gt;&#10;)&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/service/MusicNotificationManager.kt" />
              <option name="updatedContent" value="package com.plyr.service&#10;&#10;import android.content.ComponentName&#10;import android.content.Context&#10;import android.content.Intent&#10;import android.content.ServiceConnection&#10;import android.os.IBinder&#10;import android.util.Log&#10;import com.plyr.database.TrackEntity&#10;&#10;/**&#10; * MusicNotificationManager - Clase helper para gestionar la notificación de música&#10; * &#10; * Esta clase actúa como puente entre tu PlayerViewModel y el MusicService,&#10; * facilitando el control de la notificación sin tener que manejar directamente&#10; * el service binding en el ViewModel.&#10; */&#10;class MusicNotificationManager(private val context: Context) {&#10;    &#10;    private var musicService: MusicService? = null&#10;    private var isBound = false&#10;    &#10;    companion object {&#10;        private const val TAG = &quot;MusicNotificationManager&quot;&#10;    }&#10;    &#10;    /**&#10;     * Conexión con el servicio de música&#10;     */&#10;    private val serviceConnection = object : ServiceConnection {&#10;        override fun onServiceConnected(name: ComponentName?, service: IBinder?) {&#10;            Log.d(TAG, &quot;Service connected&quot;)&#10;            val binder = service as MusicService.MusicBinder&#10;            musicService = binder.getService()&#10;            isBound = true&#10;        }&#10;        &#10;        override fun onServiceDisconnected(name: ComponentName?) {&#10;            Log.d(TAG, &quot;Service disconnected&quot;)&#10;            musicService = null&#10;            isBound = false&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Inicia el servicio y se conecta a él&#10;     */&#10;    fun startService() {&#10;        Log.d(TAG, &quot;Starting MusicService&quot;)&#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.startService(serviceIntent)&#10;        context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;    }&#10;    &#10;    /**&#10;     * Para el servicio y se desconecta&#10;     */&#10;    fun stopService() {&#10;        Log.d(TAG, &quot;Stopping MusicService&quot;)&#10;        if (isBound) {&#10;            context.unbindService(serviceConnection)&#10;            isBound = false&#10;        }&#10;        &#10;        val serviceIntent = Intent(context, MusicService::class.java)&#10;        context.stopService(serviceIntent)&#10;        musicService = null&#10;    }&#10;    &#10;    /**&#10;     * Inicia la reproducción de audio con notificación&#10;     */&#10;    fun playAudio(audioUrl: String, title: String, artist: String) {&#10;        Log.d(TAG, &quot;Playing audio: $title by $artist&quot;)&#10;        &#10;        if (!isBound) {&#10;            // Si no está conectado, iniciar el servicio con los datos&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;AUDIO_URL&quot;, audioUrl)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;            context.bindService(serviceIntent, serviceConnection, Context.BIND_AUTO_CREATE)&#10;        } else {&#10;            // Si ya está conectado, usar el servicio directamente&#10;            musicService?.updateSongInfo(title, artist)&#10;            musicService?.playAudio(audioUrl)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza la información de la canción en la notificación&#10;     */&#10;    fun updateSongInfo(title: String, artist: String) {&#10;        Log.d(TAG, &quot;Updating song info: $title by $artist&quot;)&#10;        &#10;        if (isBound &amp;&amp; musicService != null) {&#10;            musicService?.updateSongInfo(title, artist)&#10;        } else {&#10;            // Si no está conectado, enviar intent de actualización&#10;            val serviceIntent = Intent(context, MusicService::class.java).apply {&#10;                putExtra(&quot;UPDATE_INFO&quot;, true)&#10;                putExtra(&quot;SONG_TITLE&quot;, title)&#10;                putExtra(&quot;SONG_ARTIST&quot;, artist)&#10;            }&#10;            context.startService(serviceIntent)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Actualiza usando un TrackEntity&#10;     */&#10;    fun updateSongInfo(track: TrackEntity) {&#10;        updateSongInfo(track.name, track.artists)&#10;    }&#10;    &#10;    /**&#10;     * Pausa/reanuda la reproducción desde la notificación&#10;     */&#10;    fun togglePlayPause() {&#10;        musicService?.togglePlayPause()&#10;    }&#10;    &#10;    /**&#10;     * Para completamente la reproducción&#10;     */&#10;    fun stopPlayback() {&#10;        musicService?.stopPlayback()&#10;    }&#10;    &#10;    /**&#10;     * Verifica si está reproduciendo&#10;     */&#10;    fun isPlaying(): Boolean {&#10;        return musicService?.isPlaying() ?: false&#10;    }&#10;    &#10;    /**&#10;     * Verifica si el servicio está conectado&#10;     */&#10;    fun isServiceConnected(): Boolean {&#10;        return isBound &amp;&amp; musicService != null&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/SearchScreen.kt" />
              <option name="originalContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import com.plyr.ui.components.search.YouTubePlaylistDetailView&#10;import com.plyr.ui.components.search.YouTubeSearchResults&#10;import com.plyr.ui.components.QrScannerDialog&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para resultados de YouTube (NUEVOS)&#10;    var youtubeAllResults by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubeSearchAllResult?&gt;(null) }&#10;    var showYouTubeAllResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist de YouTube (NUEVOS)&#10;    var selectedYouTubePlaylist by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubePlaylistInfo?&gt;(null) }&#10;&#10;    // Estados para añadir canciones a playlist&#10;    var showPlaylistSelectionDialog by remember { mutableStateOf(false) }&#10;    var selectedTrackToAdd by remember { mutableStateOf&lt;SpotifyTrack?&gt;(null) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Definir el estado en el composable principal&#10;    var showQrScanner by remember { mutableStateOf(false) }&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoading = true&#10;            } else {&#10;                isLoading = true&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                youtubeAllResults = null&#10;                showYouTubeAllResults = false&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        error = &quot;Query vacía después de procesar prefijo&quot;&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Limpiar resultados anteriores de YouTube&#10;                            youtubeAllResults = null&#10;                            showYouTubeAllResults = false&#10;&#10;                            // Usar la nueva búsqueda completa de YouTube (videos + playlists)&#10;                            val searchResults = youtubeSearchManager.searchYouTubeAll(finalQuery)&#10;&#10;                            // Establecer los nuevos resultados&#10;                            youtubeAllResults = searchResults&#10;                            showYouTubeAllResults = true&#10;&#10;                            // Mantener compatibilidad con el sistema legacy de videos&#10;                            val newResults = searchResults.videos.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            results = newResults&#10;&#10;                            isLoading = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                error = &quot;Error searching Spotify: $searchError&quot;&#10;                                            } else if (searchResults != null) {&#10;&#10;&#10;                                                // Filtrar playlists nulas antes de procesar&#10;                                                val validPlaylists = searchResults.playlists.items&#10;                                                searchResults.playlists.items.size - validPlaylists.size&#10;&#10;                                                // Crear un nuevo objeto de resultados con las playlists filtradas&#10;                                                val filteredResults = SpotifySearchAllResponse(&#10;                                                    tracks = searchResults.tracks,&#10;                                                    albums = searchResults.albums,&#10;                                                    artists = searchResults.artists,&#10;                                                    playlists = SpotifyPlaylistsSearchResult(&#10;                                                        items = validPlaylists,&#10;                                                        total = searchResults.playlists.total,&#10;                                                        limit = searchResults.playlists.limit,&#10;                                                        offset = searchResults.playlists.offset,&#10;                                                        next = searchResults.playlists.next&#10;                                                    )&#10;                                                )&#10;&#10;                                                spotifyResults = filteredResults&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                isLoading = false&#10;                                                showSpotifyResults = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    error = &quot;Token de Spotify no disponible&quot;&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                error = &quot;Spotify no está conectado&quot;&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            error = &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    error = &quot;Error en búsqueda: ${e.message}&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks de la playlist: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Volver de la vista detallada de playlist de YouTube&#10;                selectedYouTubePlaylist = null&#10;            }&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Nueva vista detallada para playlists de YouTube&#10;                YouTubePlaylistDetailView(&#10;                    playlist = selectedYouTubePlaylist!!,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                val album = selectedSpotifyAlbum!!&#10;                var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;                Column(&#10;                    modifier = Modifier.fillMaxSize().padding(16.dp)&#10;                ) {&#10;                    // Album header&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        AsyncImage(&#10;                            model = album.getImageUrl(),&#10;                            contentDescription = &quot;Album cover&quot;,&#10;                            modifier = Modifier.size(80.dp).clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 20.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                    // Action buttons&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&lt;start&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback from first track&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(8.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;rand&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFFD93D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback with shuffled tracks&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val shuffledTracks = selectedItemTracks.shuffled()&#10;                                    val trackEntities = shuffledTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(8.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;share&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                showShareDialog = true&#10;                            }.padding(8.dp)&#10;                        )&#10;                    }&#10;                    // Loading and error states&#10;                    if (isLoadingTracks) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;$ loading tracks...&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFFFD93D)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    error?.let {&#10;                        Text(&#10;                            &quot;ERR: $it&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Track list&#10;                    if (selectedItemTracks.isNotEmpty()) {&#10;                        val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                            TrackEntity(&#10;                                id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                playlistId = album.id,&#10;                                spotifyTrackId = spotifyTrack.id,&#10;                                name = spotifyTrack.name,&#10;                                artists = spotifyTrack.getArtistNames(),&#10;                                youtubeVideoId = null,&#10;                                audioUrl = null,&#10;                                position = trackIndex,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        }&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp)&#10;                        ) {&#10;                            items(selectedItemTracks.size) { index -&gt;&#10;                                val track = selectedItemTracks[index]&#10;                                val song = Song(&#10;                                    number = index + 1,&#10;                                    title = track.name,&#10;                                    artist = track.getArtistNames(),&#10;                                    spotifyId = track.id,&#10;                                    spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                )&#10;                                SongListItem(&#10;                                    song = song,&#10;                                    trackEntities = trackEntities,&#10;                                    index = index,&#10;                                    playerViewModel = playerViewModel,&#10;                                    coroutineScope = coroutineScope,&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showShareDialog) {&#10;                    ShareDialog(&#10;                        item = ShareableItem(&#10;                            spotifyId = album.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/album/${album.id}&quot;,&#10;                            youtubeId = null,&#10;                            title = album.name,&#10;                            artist = album.getArtistNames(),&#10;                            type = ShareType.ALBUM&#10;                        ),&#10;                        onDismiss = { showShareDialog = false }&#10;                    )&#10;                }&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums,&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    youtubeAllResults = youtubeAllResults,&#10;                    showYouTubeAllResults = showYouTubeAllResults,&#10;                    onYouTubePlaylistSelected = { playlist -&gt;&#10;                        selectedYouTubePlaylist = playlist&#10;                    },&#10;                    onShowQrScannerChange = { showQrScanner = it }&#10;                )&#10;                if (showQrScanner) {&#10;                    QrScannerDialog(&#10;                        onDismiss = { showQrScanner = false },&#10;                        onQrScanned = { qrResult -&gt;&#10;                            showQrScanner = false&#10;                            if (qrResult != null) {&#10;                                // Procesar el resultado del QR escaneado&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        when (qrResult.source) {&#10;                                            &quot;spotify&quot; -&gt; {&#10;                                                if (Config.isSpotifyConnected(context)) {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        isLoading = true&#10;                                                        when (qrResult.type) {&#10;                                                            &quot;track&quot; -&gt; {&#10;                                                                SpotifyRepository.getTrack(accessToken, qrResult.id) { track, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (track != null) {&#10;                                                                        // Buscar este track específico&#10;                                                                        searchQuery = &quot;${track.name} ${track.getArtistNames()}&quot;&#10;                                                                        performSearch(searchQuery, false)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo track: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;playlist&quot; -&gt; {&#10;                                                                SpotifyRepository.getPlaylist(accessToken, qrResult.id) { playlist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (playlist != null) {&#10;                                                                        loadSpotifyPlaylistTracks(playlist)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo playlist: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;album&quot; -&gt; {&#10;                                                                SpotifyRepository.getAlbum(accessToken, qrResult.id) { album, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (album != null) {&#10;                                                                        loadSpotifyAlbumTracks(album)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo álbum: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;artist&quot; -&gt; {&#10;                                                                SpotifyRepository.getArtist(accessToken, qrResult.id) { artist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (artist != null) {&#10;                                                                        loadArtistAlbums(artist)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo artista: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = &quot;Token de Spotify no disponible&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    error = &quot;Spotify no está conectado&quot;&#10;                                                }&#10;                                            }&#10;                                            &quot;youtube&quot; -&gt; {&#10;                                                // Buscar directamente el video ID en YouTube&#10;                                                val videoUrl = &quot;https://www.youtube.com/watch?v=${qrResult.id}&quot;&#10;                                                searchQuery = videoUrl&#10;                                                performSearch(videoUrl, false)&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        error = &quot;Error procesando QR: ${e.message}&quot;&#10;                                        isLoading = false&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Diálogo para selección de playlist&#10;        if (showPlaylistSelectionDialog &amp;&amp; selectedTrackToAdd != null) {&#10;            AlertDialog(&#10;                onDismissRequest = { showPlaylistSelectionDialog = false },&#10;                title = { Text(&quot;Seleccionar playlist&quot;) },&#10;                text = {&#10;                    Column {&#10;                        if (isLoadingPlaylists) {&#10;                            // Indicador de carga&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator()&#10;                            }&#10;                        } else {&#10;                            // Lista de playlists del usuario&#10;                            LazyColumn {&#10;                                items(userPlaylists) { playlist -&gt;&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Añadir la canción a la playlist seleccionada&#10;                                                coroutineScope.launch {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        SpotifyRepository.addTrackToPlaylist(accessToken, playlist.id, selectedTrackToAdd!!.id) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Cerrar diálogo y mostrar mensaje de éxito&#10;                                                                showPlaylistSelectionDialog = false&#10;                                                            } else {&#10;                                                                // Mostrar error&#10;                                                                error = &quot;Error añadiendo canción a la playlist: $errorMsg&quot;&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = &quot;Token de Spotify no disponible&quot;&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            // Cerrar diálogo sin acción&#10;                            showPlaylistSelectionDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Cancelar&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(0.9f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    youtubeAllResults: YouTubeSearchManager.YouTubeSearchAllResult?,&#10;    showYouTubeAllResults: Boolean,&#10;    onYouTubePlaylistSelected: (YouTubeSearchManager.YouTubePlaylistInfo) -&gt; Unit,&#10;    onShowQrScannerChange: (Boolean) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    &quot;&gt; search_audio&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                Row {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = {&#10;                            onSearchQueryChange(&quot;&quot;)&#10;                        }) {&#10;                            Text(&#10;                                text = &quot;x&quot;,&#10;                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    IconButton(onClick = { onShowQrScannerChange(true) }) {&#10;                        Text(&#10;                            text = &quot;qr&quot;,&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading...&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                onArtistSelected = onArtistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE CON PLAYLISTS (NUEVO) ===&#10;        if (showYouTubeAllResults &amp;&amp; youtubeAllResults != null) {&#10;            YouTubeSearchResults(&#10;                results = null, // Legacy results&#10;                youtubeAllResults = youtubeAllResults,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onPlaylistSelected = onYouTubePlaylistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE LEGACY ===&#10;        if (results.isNotEmpty() &amp;&amp; !showYouTubeAllResults) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                results = results,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(false) }&#10;    var albumsExpanded by remember { mutableStateOf(false) }&#10;    var playlistsExpanded by remember { mutableStateOf(false) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (tracksExpanded) &quot;v tracks&quot; else &quot;&gt; tracks&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                val trackEntities = results.tracks.items.take(5).mapIndexed { trackIndex, track -&gt;&#10;                    TrackEntity(&#10;                        id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                        playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                        spotifyTrackId = track.id,&#10;                        name = track.name,&#10;                        artists = track.getArtistNames(),&#10;                        youtubeVideoId = null,&#10;                        audioUrl = null,&#10;                        position = trackIndex,&#10;                        lastSyncTime = System.currentTimeMillis()&#10;                    )&#10;                }&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(1.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        val song = Song(&#10;                            number = index + 1,&#10;                            title = track.name,&#10;                            artist = track.getArtistNames(),&#10;                            spotifyId = track.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                        )&#10;                        SongListItem(&#10;                            song = song,&#10;                            trackEntities = trackEntities,&#10;                            index = index,&#10;                            playerViewModel = playerViewModel,&#10;                            coroutineScope = coroutineScope,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (albumsExpanded) &quot;v albums&quot; else &quot;&gt; albums&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = &quot;Album cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (playlistsExpanded) &quot;v playlists&quot; else &quot;&gt; playlists&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                val nonNullPlaylists = results.playlists.items.filterNotNull()&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(nonNullPlaylists) { playlist -&gt;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = &quot;Playlist cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (artistsExpanded) &quot;v artists&quot; else &quot;&gt; artists&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = &quot;Artist image&quot;,&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    results: List&lt;AudioItem&gt;,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var videosExpanded by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Videos section header&#10;        Text(&#10;            text = if (videosExpanded) &quot;v youtube results [${results.size}]&quot; else &quot;&gt; youtube results [${results.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { videosExpanded = !videosExpanded }&#10;                .padding(4.dp)&#10;        )&#10;&#10;        if (videosExpanded) {&#10;            val trackEntities = results.mapIndexed { trackIndex, item -&gt;&#10;                TrackEntity(&#10;                    id = &quot;youtube_${item.videoId}&quot;,&#10;                    playlistId = &quot;youtube_search&quot;,&#10;                    spotifyTrackId = item.videoId,&#10;                    name = item.title,&#10;                    artists = item.channel,&#10;                    youtubeVideoId = item.videoId,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                results.forEachIndexed { index, item -&gt;&#10;                    val song = Song(&#10;                        number = index + 1,&#10;                        title = item.title,&#10;                        artist = item.channel,&#10;                        youtubeId = item.videoId,&#10;                        spotifyUrl = &quot;https://www.youtube.com/watch?v=${item.videoId}&quot;&#10;                    )&#10;                    SongListItem(&#10;                        song = song,&#10;                        trackEntities = trackEntities,&#10;                        index = index,&#10;                        playerViewModel = playerViewModel,&#10;                        coroutineScope = coroutineScope,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Load more button if there are more results&#10;                if (results.size &gt;= 10) {&#10;                    Text(&#10;                        text = &quot;&gt; load more&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF4ECDC4)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { onLoadMore() }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui&#10;&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.lazy.LazyRow&#10;import androidx.compose.foundation.lazy.items&#10;import androidx.compose.foundation.rememberScrollState&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.foundation.text.KeyboardActions&#10;import androidx.compose.foundation.text.KeyboardOptions&#10;import androidx.compose.foundation.verticalScroll&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.input.ImeAction&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.model.AudioItem&#10;import com.plyr.network.*&#10;import com.plyr.utils.Config&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import com.plyr.service.YouTubeSearchManager&#10;import com.plyr.ui.components.Song&#10;import com.plyr.ui.components.SongListItem&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import com.plyr.ui.components.search.SpotifyArtistDetailView&#10;import com.plyr.ui.components.search.YouTubePlaylistDetailView&#10;import com.plyr.ui.components.search.YouTubeSearchResults&#10;import com.plyr.ui.components.QrScannerDialog&#10;import kotlinx.coroutines.launch&#10;import kotlinx.coroutines.CoroutineScope&#10;&#10;@Composable&#10;fun SearchScreen(&#10;    context: Context,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    var searchQuery by remember { mutableStateOf(&quot;&quot;) }&#10;    var results by remember { mutableStateOf&lt;List&lt;AudioItem&gt;&gt;(emptyList()) }&#10;    var isLoading by remember { mutableStateOf(false) }&#10;    var error by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;    // Estados para resultados de Spotify&#10;    var spotifyResults by remember { mutableStateOf&lt;SpotifySearchAllResponse?&gt;(null) }&#10;    var showSpotifyResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para resultados de YouTube (NUEVOS)&#10;    var youtubeAllResults by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubeSearchAllResult?&gt;(null) }&#10;    var showYouTubeAllResults by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist de YouTube (NUEVOS)&#10;    var selectedYouTubePlaylist by remember { mutableStateOf&lt;YouTubeSearchManager.YouTubePlaylistInfo?&gt;(null) }&#10;&#10;    // Estados para añadir canciones a playlist&#10;    var showPlaylistSelectionDialog by remember { mutableStateOf(false) }&#10;    var selectedTrackToAdd by remember { mutableStateOf&lt;SpotifyTrack?&gt;(null) }&#10;    var userPlaylists by remember { mutableStateOf&lt;List&lt;SpotifyPlaylist&gt;&gt;(emptyList()) }&#10;    var isLoadingPlaylists by remember { mutableStateOf(false) }&#10;&#10;    // Estados para vista detallada de playlist/álbum/artista&#10;    var selectedSpotifyPlaylist by remember { mutableStateOf&lt;SpotifyPlaylist?&gt;(null) }&#10;    var selectedSpotifyAlbum by remember { mutableStateOf&lt;SpotifyAlbum?&gt;(null) }&#10;    var selectedSpotifyArtist by remember { mutableStateOf&lt;SpotifyArtistFull?&gt;(null) }&#10;    var selectedItemTracks by remember { mutableStateOf&lt;List&lt;SpotifyTrack&gt;&gt;(emptyList()) }&#10;    var selectedArtistAlbums by remember { mutableStateOf&lt;List&lt;SpotifyAlbum&gt;&gt;(emptyList()) }&#10;    var isLoadingTracks by remember { mutableStateOf(false) }&#10;    var isLoadingArtistAlbums by remember { mutableStateOf(false) }&#10;&#10;    // YouTube search manager para búsquedas locales&#10;    val youtubeSearchManager = remember { YouTubeSearchManager(context) }&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Definir el estado en el composable principal&#10;    var showQrScanner by remember { mutableStateOf(false) }&#10;&#10;    // Search function with pagination support&#10;    val performSearch: (String, Boolean) -&gt; Unit = { searchQuery, isLoadMore -&gt;&#10;        if (searchQuery.isNotBlank() &amp;&amp; (!isLoading || isLoadMore)) {&#10;            if (isLoadMore) {&#10;                isLoading = true&#10;            } else {&#10;                isLoading = true&#10;                results = emptyList()&#10;                spotifyResults = null&#10;                showSpotifyResults = false&#10;                youtubeAllResults = null&#10;                showYouTubeAllResults = false&#10;            }&#10;            error = null&#10;&#10;            coroutineScope.launch {&#10;                try {&#10;                    val searchEngine = Config.getSearchEngine(context)&#10;&#10;                    // Permitir override temporal con prefijos&#10;                    val (finalSearchEngine, finalQuery) = when {&#10;                        searchQuery.startsWith(&quot;yt:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;youtube&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        searchQuery.startsWith(&quot;sp:&quot;, ignoreCase = true) -&gt; {&#10;                            &quot;spotify&quot; to searchQuery.substring(3).trim()&#10;                        }&#10;                        else -&gt; searchEngine to searchQuery&#10;                    }&#10;&#10;                    if (finalQuery.isEmpty()) {&#10;                        isLoading = false&#10;                        error = &quot;Query vacía después de procesar prefijo&quot;&#10;                        return@launch&#10;                    }&#10;&#10;                    when (finalSearchEngine) {&#10;                        &quot;youtube&quot; -&gt; {&#10;                            // Limpiar resultados anteriores de YouTube&#10;                            youtubeAllResults = null&#10;                            showYouTubeAllResults = false&#10;&#10;                            // Usar la nueva búsqueda completa de YouTube (videos + playlists)&#10;                            val searchResults = youtubeSearchManager.searchYouTubeAll(finalQuery)&#10;&#10;                            // Establecer los nuevos resultados&#10;                            youtubeAllResults = searchResults&#10;                            showYouTubeAllResults = true&#10;&#10;                            // Mantener compatibilidad con el sistema legacy de videos&#10;                            val newResults = searchResults.videos.map { videoInfo -&gt;&#10;                                AudioItem(&#10;                                    title = videoInfo.title,&#10;                                    url = &quot;&quot;, // Use empty string for url, required by AudioItem&#10;                                    videoId = videoInfo.videoId,&#10;                                    channel = videoInfo.uploader,&#10;                                    duration = videoInfo.getFormattedDuration()&#10;                                )&#10;                            }&#10;&#10;                            results = newResults&#10;&#10;                            isLoading = false&#10;                        }&#10;&#10;                        &quot;spotify&quot; -&gt; {&#10;                            // Search Spotify with pagination&#10;                            if (Config.isSpotifyConnected(context)) {&#10;                                val accessToken = Config.getSpotifyAccessToken(context)&#10;                                if (accessToken != null) {&#10;                                    SpotifyRepository.searchAllWithPagination(accessToken, finalQuery) { searchResults: SpotifySearchAllResponse?, searchError: String? -&gt;&#10;                                        // Asegurar que las actualizaciones se ejecuten en el hilo principal&#10;                                        android.os.Handler(android.os.Looper.getMainLooper()).post {&#10;                                            if (searchError != null) {&#10;                                                isLoading = false&#10;                                                error = &quot;Error searching Spotify: $searchError&quot;&#10;                                            } else if (searchResults != null) {&#10;&#10;&#10;                                                // Filtrar playlists nulas antes de procesar&#10;                                                val validPlaylists = searchResults.playlists.items&#10;                                                searchResults.playlists.items.size - validPlaylists.size&#10;&#10;                                                // Crear un nuevo objeto de resultados con las playlists filtradas&#10;                                                val filteredResults = SpotifySearchAllResponse(&#10;                                                    tracks = searchResults.tracks,&#10;                                                    albums = searchResults.albums,&#10;                                                    artists = searchResults.artists,&#10;                                                    playlists = SpotifyPlaylistsSearchResult(&#10;                                                        items = validPlaylists,&#10;                                                        total = searchResults.playlists.total,&#10;                                                        limit = searchResults.playlists.limit,&#10;                                                        offset = searchResults.playlists.offset,&#10;                                                        next = searchResults.playlists.next&#10;                                                    )&#10;                                                )&#10;&#10;                                                spotifyResults = filteredResults&#10;&#10;                                                // Para esta implementación, como searchAllWithPagination ya obtiene todos los resultados,&#10;                                                // no hay paginación manual adicional necesaria&#10;                                                isLoading = false&#10;                                                showSpotifyResults = true&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    isLoading = false&#10;                                    error = &quot;Token de Spotify no disponible&quot;&#10;                                }&#10;                            } else {&#10;                                isLoading = false&#10;                                error = &quot;Spotify no está conectado&quot;&#10;                            }&#10;                        }&#10;&#10;                        else -&gt; {&#10;                            isLoading = false&#10;                            error = &quot;Motor de búsqueda no reconocido: $finalSearchEngine&quot;&#10;                        }&#10;                    }&#10;&#10;                } catch (e: Exception) {&#10;                    isLoading = false&#10;                    error = &quot;Error en búsqueda: ${e.message}&quot;&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    // Funciones auxiliares para operaciones de Spotify&#10;    val saveSpotifyPlaylistToLibrary: () -&gt; Unit = {&#10;        coroutineScope.launch {&#10;            try {&#10;                selectedSpotifyPlaylist?.let { playlist -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.followPlaylist(accessToken, playlist.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;                selectedSpotifyAlbum?.let { album -&gt;&#10;                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                    if (accessToken != null) {&#10;                        SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                        }&#10;                    }&#10;                }&#10;            } catch (_: Exception) {&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyPlaylistTracks: (SpotifyPlaylist) -&gt; Unit = { playlist -&gt;&#10;        selectedSpotifyPlaylist = playlist&#10;        selectedSpotifyAlbum = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getPlaylistTracks(accessToken, playlist.id) { playlistTracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (playlistTracks != null) {&#10;                            // Convertir SpotifyPlaylistTrack a SpotifyTrack&#10;                            val tracks = playlistTracks.mapNotNull { it.track }&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks de la playlist: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks de la playlist: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadSpotifyAlbumTracks: (SpotifyAlbum) -&gt; Unit = { album -&gt;&#10;        selectedSpotifyAlbum = album&#10;        selectedSpotifyPlaylist = null&#10;        isLoadingTracks = true&#10;        error = null&#10;        selectedItemTracks = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getAlbumTracks(accessToken, album.id) { tracks, errorMsg -&gt;&#10;                        isLoadingTracks = false&#10;                        if (tracks != null) {&#10;                            selectedItemTracks = tracks&#10;                        } else {&#10;                            error = &quot;Error cargando tracks del álbum: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingTracks = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingTracks = false&#10;                error = &quot;Error cargando tracks del álbum: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    val loadArtistAlbums: (SpotifyArtistFull) -&gt; Unit = { artist -&gt;&#10;        selectedSpotifyArtist = artist&#10;        isLoadingArtistAlbums = true&#10;        error = null&#10;        selectedArtistAlbums = emptyList()&#10;&#10;        coroutineScope.launch {&#10;            try {&#10;                val accessToken = Config.getSpotifyAccessToken(context)&#10;                if (accessToken != null) {&#10;                    SpotifyRepository.getArtistAlbums(accessToken, artist.id) { albums, errorMsg -&gt;&#10;                        isLoadingArtistAlbums = false&#10;                        if (albums != null) {&#10;                            selectedArtistAlbums = albums&#10;                        } else {&#10;                            error = &quot;Error cargando álbumes del artista: $errorMsg&quot;&#10;                        }&#10;                    }&#10;                } else {&#10;                    isLoadingArtistAlbums = false&#10;                    error = &quot;Token de Spotify no disponible&quot;&#10;                }&#10;            } catch (e: Exception) {&#10;                isLoadingArtistAlbums = false&#10;                error = &quot;Error cargando álbumes del artista: ${e.message}&quot;&#10;            }&#10;        }&#10;    }&#10;&#10;    // Handle back button&#10;    BackHandler {&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Volver de la vista detallada de playlist de YouTube&#10;                selectedYouTubePlaylist = null&#10;            }&#10;            selectedSpotifyPlaylist != null || selectedSpotifyAlbum != null || selectedSpotifyArtist != null -&gt; {&#10;                // Volver de la vista detallada a los resultados de búsqueda&#10;                selectedSpotifyPlaylist = null&#10;                selectedSpotifyAlbum = null&#10;                selectedSpotifyArtist = null&#10;                selectedItemTracks = emptyList()&#10;                selectedArtistAlbums = emptyList()&#10;            }&#10;            else -&gt; onBack()&#10;        }&#10;    }&#10;&#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Mostrar vista detallada o búsqueda normal&#10;        when {&#10;            selectedYouTubePlaylist != null -&gt; {&#10;                // Nueva vista detallada para playlists de YouTube&#10;                YouTubePlaylistDetailView(&#10;                    playlist = selectedYouTubePlaylist!!,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyPlaylist != null -&gt; {&#10;                SpotifyPlaylistDetailView(&#10;                    playlist = selectedSpotifyPlaylist!!,&#10;                    tracks = selectedItemTracks,&#10;                    isLoading = isLoadingTracks,&#10;                    error = error,&#10;                    onStart = {&#10;                        // Reproducir playlist desde el primer track&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity&#10;                            val trackEntities = selectedItemTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onRandom = {&#10;                        // Reproducir playlist en orden aleatorio&#10;                        if (selectedItemTracks.isNotEmpty()) {&#10;&#10;                            // Convertir SpotifyTrack a TrackEntity y mezclar&#10;                            val shuffledTracks = selectedItemTracks.shuffled()&#10;                            val trackEntities = shuffledTracks.mapIndexed { index, spotifyTrack -&gt;&#10;                                TrackEntity(&#10;                                    id = &quot;spotify_${selectedSpotifyPlaylist!!.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                    playlistId = selectedSpotifyPlaylist!!.id,&#10;                                    spotifyTrackId = spotifyTrack.id,&#10;                                    name = spotifyTrack.name,&#10;                                    artists = spotifyTrack.getArtistNames(),&#10;                                    youtubeVideoId = null, // Se buscará dinámicamente&#10;                                    audioUrl = null,&#10;                                    position = index,&#10;                                    lastSyncTime = System.currentTimeMillis()&#10;                                )&#10;                            }&#10;&#10;                            // Establecer playlist mezclada y comenzar reproducción&#10;                            playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;&#10;                            // Buscar y reproducir el primer track de la lista mezclada&#10;                            trackEntities.firstOrNull()?.let { track -&gt;&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        playerViewModel?.loadAudioFromTrack(track)&#10;                                    } catch (_: Exception) {&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    },&#10;                    onSave = saveSpotifyPlaylistToLibrary,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope&#10;                )&#10;            }&#10;            selectedSpotifyAlbum != null -&gt; {&#10;                val album = selectedSpotifyAlbum!!&#10;                var showShareDialog by remember { mutableStateOf(false) }&#10;                var saveStatus by remember { mutableStateOf&lt;String?&gt;(null) }&#10;&#10;                Column(&#10;                    modifier = Modifier.fillMaxSize().padding(16.dp)&#10;                ) {&#10;                    // Album header&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        verticalAlignment = Alignment.CenterVertically&#10;                    ) {&#10;                        AsyncImage(&#10;                            model = album.getImageUrl(),&#10;                            contentDescription = &quot;Album cover&quot;,&#10;                            modifier = Modifier.size(80.dp).clip(RoundedCornerShape(8.dp))&#10;                        )&#10;                        Spacer(modifier = Modifier.width(16.dp))&#10;                        Text(&#10;                            text = album.name,&#10;                            style = MaterialTheme.typography.headlineMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 20.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            maxLines = 1,&#10;                            overflow = TextOverflow.Ellipsis&#10;                        )&#10;                    }&#10;                    // Action buttons&#10;                    Row(&#10;                        modifier = Modifier.fillMaxWidth().padding(bottom = 16.dp),&#10;                        horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;&lt;start&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF4ECDC4)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback from first track&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(8.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;rand&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFFD93D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                // Start playback with shuffled tracks&#10;                                if (selectedItemTracks.isNotEmpty()) {&#10;                                    val shuffledTracks = selectedItemTracks.shuffled()&#10;                                    val trackEntities = shuffledTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                                        TrackEntity(&#10;                                            id = &quot;spotify_${album.id}_${spotifyTrack.id}_shuffled&quot;,&#10;                                            playlistId = album.id,&#10;                                            spotifyTrackId = spotifyTrack.id,&#10;                                            name = spotifyTrack.name,&#10;                                            artists = spotifyTrack.getArtistNames(),&#10;                                            youtubeVideoId = null,&#10;                                            audioUrl = null,&#10;                                            position = trackIndex,&#10;                                            lastSyncTime = System.currentTimeMillis()&#10;                                        )&#10;                                    }&#10;                                    playerViewModel?.setCurrentPlaylist(trackEntities, 0)&#10;                                    trackEntities.firstOrNull()?.let { track -&gt;&#10;                                        coroutineScope.launch {&#10;                                            try {&#10;                                                playerViewModel?.loadAudioFromTrack(track)&#10;                                            } catch (_: Exception) {&#10;                                            }&#10;                                        }&#10;                                    }&#10;                                }&#10;                            }.padding(8.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;save&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFF6BCF7F)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        val accessToken = Config.getSpotifyAccessToken(context)&#10;                                        if (accessToken != null) {&#10;                                            saveStatus = &quot;saving...&quot;&#10;                                            SpotifyRepository.saveAlbum(accessToken, album.id) { success, errorMsg -&gt;&#10;                                                saveStatus = if (success) {&#10;                                                    &quot;saved!&quot;&#10;                                                } else {&#10;                                                    &quot;error: $errorMsg&quot;&#10;                                                }&#10;                                                // Clear status after 2 seconds&#10;                                                coroutineScope.launch {&#10;                                                    kotlinx.coroutines.delay(2000)&#10;                                                    saveStatus = null&#10;                                                }&#10;                                            }&#10;                                        } else {&#10;                                            saveStatus = &quot;error: no token&quot;&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        saveStatus = &quot;error: ${e.message}&quot;&#10;                                    }&#10;                                }&#10;                            }.padding(8.dp)&#10;                        )&#10;                        Text(&#10;                            text = &quot;&lt;share&gt;&quot;,&#10;                            style = MaterialTheme.typography.bodyLarge.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                fontSize = 16.sp,&#10;                                color = Color(0xFFFF6B9D)&#10;                            ),&#10;                            modifier = Modifier.clickable {&#10;                                showShareDialog = true&#10;                            }.padding(8.dp)&#10;                        )&#10;                    }&#10;                    // Save status message&#10;                    saveStatus?.let { status -&gt;&#10;                        Text(&#10;                            text = &quot;$ $status&quot;,&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = if (status.startsWith(&quot;error&quot;)) Color(0xFFFF6B6B) else Color(0xFF6BCF7F)&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Loading and error states&#10;                    if (isLoadingTracks) {&#10;                        Row(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            horizontalArrangement = Arrangement.Center&#10;                        ) {&#10;                            Text(&#10;                                text = &quot;$ loading tracks...&quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFFFD93D)&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    error?.let {&#10;                        Text(&#10;                            &quot;ERR: $it&quot;,&#10;                            color = Color(0xFFFF6B6B),&#10;                            style = MaterialTheme.typography.bodySmall.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(bottom = 8.dp)&#10;                        )&#10;                    }&#10;                    // Track list&#10;                    if (selectedItemTracks.isNotEmpty()) {&#10;                        val trackEntities = selectedItemTracks.mapIndexed { trackIndex, spotifyTrack -&gt;&#10;                            TrackEntity(&#10;                                id = &quot;spotify_${album.id}_${spotifyTrack.id}&quot;,&#10;                                playlistId = album.id,&#10;                                spotifyTrackId = spotifyTrack.id,&#10;                                name = spotifyTrack.name,&#10;                                artists = spotifyTrack.getArtistNames(),&#10;                                youtubeVideoId = null,&#10;                                audioUrl = null,&#10;                                position = trackIndex,&#10;                                lastSyncTime = System.currentTimeMillis()&#10;                            )&#10;                        }&#10;                        LazyColumn(&#10;                            modifier = Modifier.fillMaxWidth(),&#10;                            contentPadding = PaddingValues(bottom = 16.dp)&#10;                        ) {&#10;                            items(selectedItemTracks.size) { index -&gt;&#10;                                val track = selectedItemTracks[index]&#10;                                val song = Song(&#10;                                    number = index + 1,&#10;                                    title = track.name,&#10;                                    artist = track.getArtistNames(),&#10;                                    spotifyId = track.id,&#10;                                    spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                                )&#10;                                SongListItem(&#10;                                    song = song,&#10;                                    trackEntities = trackEntities,&#10;                                    index = index,&#10;                                    playerViewModel = playerViewModel,&#10;                                    coroutineScope = coroutineScope,&#10;                                    modifier = Modifier.fillMaxWidth()&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;&#10;                if (showShareDialog) {&#10;                    ShareDialog(&#10;                        item = ShareableItem(&#10;                            spotifyId = album.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/album/${album.id}&quot;,&#10;                            youtubeId = null,&#10;                            title = album.name,&#10;                            artist = album.getArtistNames(),&#10;                            type = ShareType.ALBUM&#10;                        ),&#10;                        onDismiss = { showShareDialog = false }&#10;                    )&#10;                }&#10;            }&#10;            selectedSpotifyArtist != null -&gt; {&#10;                // Nueva vista detallada para el artista&#10;                SpotifyArtistDetailView(&#10;                    artist = selectedSpotifyArtist!!,&#10;                    albums = selectedArtistAlbums,&#10;                    isLoading = isLoadingArtistAlbums,&#10;                    error = error,&#10;                    onAlbumClick = { album -&gt;&#10;                        // Navegar al álbum seleccionado&#10;                        loadSpotifyAlbumTracks(album)&#10;                    }&#10;                )&#10;            }&#10;            else -&gt; {&#10;                // Vista normal de búsqueda&#10;                SearchMainView(&#10;                    searchQuery = searchQuery,&#10;                    onSearchQueryChange = { searchQuery = it },&#10;                    results = results,&#10;                    spotifyResults = spotifyResults,&#10;                    showSpotifyResults = showSpotifyResults,&#10;                    isLoading = isLoading,&#10;                    error = error,&#10;                    onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                    onAlbumSelected = loadSpotifyAlbumTracks,&#10;                    onPlaylistSelected = loadSpotifyPlaylistTracks,&#10;                    onArtistSelected = loadArtistAlbums,&#10;                    onSearchTriggered = performSearch,&#10;                    playerViewModel = playerViewModel,&#10;                    coroutineScope = coroutineScope,&#10;                    youtubeAllResults = youtubeAllResults,&#10;                    showYouTubeAllResults = showYouTubeAllResults,&#10;                    onYouTubePlaylistSelected = { playlist -&gt;&#10;                        selectedYouTubePlaylist = playlist&#10;                    },&#10;                    onShowQrScannerChange = { showQrScanner = it }&#10;                )&#10;                if (showQrScanner) {&#10;                    QrScannerDialog(&#10;                        onDismiss = { showQrScanner = false },&#10;                        onQrScanned = { qrResult -&gt;&#10;                            showQrScanner = false&#10;                            if (qrResult != null) {&#10;                                // Procesar el resultado del QR escaneado&#10;                                coroutineScope.launch {&#10;                                    try {&#10;                                        when (qrResult.source) {&#10;                                            &quot;spotify&quot; -&gt; {&#10;                                                if (Config.isSpotifyConnected(context)) {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        isLoading = true&#10;                                                        when (qrResult.type) {&#10;                                                            &quot;track&quot; -&gt; {&#10;                                                                SpotifyRepository.getTrack(accessToken, qrResult.id) { track, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (track != null) {&#10;                                                                        // Buscar este track específico&#10;                                                                        searchQuery = &quot;${track.name} ${track.getArtistNames()}&quot;&#10;                                                                        performSearch(searchQuery, false)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo track: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;playlist&quot; -&gt; {&#10;                                                                SpotifyRepository.getPlaylist(accessToken, qrResult.id) { playlist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (playlist != null) {&#10;                                                                        loadSpotifyPlaylistTracks(playlist)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo playlist: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;album&quot; -&gt; {&#10;                                                                SpotifyRepository.getAlbum(accessToken, qrResult.id) { album, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (album != null) {&#10;                                                                        loadSpotifyAlbumTracks(album)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo álbum: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                            &quot;artist&quot; -&gt; {&#10;                                                                SpotifyRepository.getArtist(accessToken, qrResult.id) { artist, errorMsg -&gt;&#10;                                                                    isLoading = false&#10;                                                                    if (artist != null) {&#10;                                                                        loadArtistAlbums(artist)&#10;                                                                    } else {&#10;                                                                        error = &quot;Error obteniendo artista: $errorMsg&quot;&#10;                                                                    }&#10;                                                                }&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = &quot;Token de Spotify no disponible&quot;&#10;                                                    }&#10;                                                } else {&#10;                                                    error = &quot;Spotify no está conectado&quot;&#10;                                                }&#10;                                            }&#10;                                            &quot;youtube&quot; -&gt; {&#10;                                                // Buscar directamente el video ID en YouTube&#10;                                                val videoUrl = &quot;https://www.youtube.com/watch?v=${qrResult.id}&quot;&#10;                                                searchQuery = videoUrl&#10;                                                performSearch(videoUrl, false)&#10;                                            }&#10;                                        }&#10;                                    } catch (e: Exception) {&#10;                                        error = &quot;Error procesando QR: ${e.message}&quot;&#10;                                        isLoading = false&#10;                                    }&#10;                                }&#10;                            }&#10;                        }&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Diálogo para selección de playlist&#10;        if (showPlaylistSelectionDialog &amp;&amp; selectedTrackToAdd != null) {&#10;            AlertDialog(&#10;                onDismissRequest = { showPlaylistSelectionDialog = false },&#10;                title = { Text(&quot;Seleccionar playlist&quot;) },&#10;                text = {&#10;                    Column {&#10;                        if (isLoadingPlaylists) {&#10;                            // Indicador de carga&#10;                            Row(&#10;                                modifier = Modifier.fillMaxWidth(),&#10;                                horizontalArrangement = Arrangement.Center,&#10;                                verticalAlignment = Alignment.CenterVertically&#10;                            ) {&#10;                                CircularProgressIndicator()&#10;                            }&#10;                        } else {&#10;                            // Lista de playlists del usuario&#10;                            LazyColumn {&#10;                                items(userPlaylists) { playlist -&gt;&#10;                                    Text(&#10;                                        text = playlist.name,&#10;                                        modifier = Modifier&#10;                                            .fillMaxWidth()&#10;                                            .clickable {&#10;                                                // Añadir la canción a la playlist seleccionada&#10;                                                coroutineScope.launch {&#10;                                                    val accessToken = Config.getSpotifyAccessToken(context)&#10;                                                    if (accessToken != null) {&#10;                                                        SpotifyRepository.addTrackToPlaylist(accessToken, playlist.id, selectedTrackToAdd!!.id) { success, errorMsg -&gt;&#10;                                                            if (success) {&#10;                                                                // Cerrar diálogo y mostrar mensaje de éxito&#10;                                                                showPlaylistSelectionDialog = false&#10;                                                            } else {&#10;                                                                // Mostrar error&#10;                                                                error = &quot;Error añadiendo canción a la playlist: $errorMsg&quot;&#10;                                                            }&#10;                                                        }&#10;                                                    } else {&#10;                                                        error = &quot;Token de Spotify no disponible&quot;&#10;                                                    }&#10;                                                }&#10;                                            },&#10;                                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                                            fontFamily = FontFamily.Monospace,&#10;                                            color = Color(0xFFE0E0E0)&#10;                                        ),&#10;                                        maxLines = 1,&#10;                                        overflow = TextOverflow.Ellipsis&#10;                                    )&#10;                                }&#10;                            }&#10;                        }&#10;                    }&#10;                },&#10;                confirmButton = {&#10;                    TextButton(&#10;                        onClick = {&#10;                            // Cerrar diálogo sin acción&#10;                            showPlaylistSelectionDialog = false&#10;                        }&#10;                    ) {&#10;                        Text(&quot;Cancelar&quot;)&#10;                    }&#10;                },&#10;                modifier = Modifier.fillMaxWidth(0.9f)&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;&#10;&#10;@Composable&#10;private fun SearchMainView(&#10;    searchQuery: String,&#10;    onSearchQueryChange: (String) -&gt; Unit,&#10;    results: List&lt;AudioItem&gt;,&#10;    spotifyResults: SpotifySearchAllResponse?,&#10;    showSpotifyResults: Boolean,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onVideoSelectedFromSearch: (String, String, List&lt;AudioItem&gt;, Int) -&gt; Unit = { _, _, _, _ -&gt; },&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    onSearchTriggered: (String, Boolean) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope,&#10;    youtubeAllResults: YouTubeSearchManager.YouTubeSearchAllResult?,&#10;    showYouTubeAllResults: Boolean,&#10;    onYouTubePlaylistSelected: (YouTubeSearchManager.YouTubePlaylistInfo) -&gt; Unit,&#10;    onShowQrScannerChange: (Boolean) -&gt; Unit&#10;) {&#10;    Column(&#10;        modifier = Modifier&#10;            .fillMaxSize()&#10;            .verticalScroll(rememberScrollState())&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_search&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Search field with clear button and enter action&#10;        OutlinedTextField(&#10;            value = searchQuery,&#10;            onValueChange = onSearchQueryChange,&#10;            label = {&#10;                Text(&#10;                    &quot;&gt; search_audio&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace&#10;                    )&#10;                )&#10;            },&#10;            modifier = Modifier.fillMaxWidth(),&#10;            trailingIcon = {&#10;                Row {&#10;                    if (searchQuery.isNotEmpty()) {&#10;                        IconButton(onClick = {&#10;                            onSearchQueryChange(&quot;&quot;)&#10;                        }) {&#10;                            Text(&#10;                                text = &quot;x&quot;,&#10;                                style = MaterialTheme.typography.titleMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace&#10;                                )&#10;                            )&#10;                        }&#10;                    }&#10;                    IconButton(onClick = { onShowQrScannerChange(true) }) {&#10;                        Text(&#10;                            text = &quot;qr&quot;,&#10;                            style = MaterialTheme.typography.titleMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;            },&#10;            keyboardOptions = KeyboardOptions(imeAction = ImeAction.Search),&#10;            keyboardActions = KeyboardActions(&#10;                onSearch = {&#10;                    if (searchQuery.isNotBlank() &amp;&amp; !isLoading) {&#10;                        onSearchTriggered(searchQuery, false)&#10;                    }&#10;                }&#10;            ),&#10;            enabled = !isLoading,&#10;            colors = OutlinedTextFieldDefaults.colors(&#10;                focusedBorderColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedBorderColor = MaterialTheme.colorScheme.secondary,&#10;                focusedLabelColor = MaterialTheme.colorScheme.primary,&#10;                unfocusedLabelColor = MaterialTheme.colorScheme.secondary,&#10;                focusedTextColor = MaterialTheme.colorScheme.onSurface,&#10;                unfocusedTextColor = MaterialTheme.colorScheme.onSurface&#10;            ),&#10;            textStyle = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace&#10;            )&#10;        )&#10;&#10;        Spacer(Modifier.height(12.dp))&#10;&#10;        if (isLoading) {&#10;            Row(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                horizontalArrangement = Arrangement.Center,&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                Text(&#10;                    &quot;$ loading...&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        color = Color(0xFFFFD93D)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        error?.let {&#10;            Spacer(Modifier.height(8.dp))&#10;            Text(&#10;                &quot;ERR: $it&quot;,&#10;                color = Color(0xFFFF6B6B),&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace&#10;                )&#10;            )&#10;        }&#10;&#10;        // === MENÚS DESPLEGABLES DE SPOTIFY ===&#10;        if (showSpotifyResults &amp;&amp; spotifyResults != null) {&#10;            CollapsibleSpotifySearchResultsView(&#10;                results = spotifyResults,&#10;                onAlbumSelected = onAlbumSelected,&#10;                onPlaylistSelected = onPlaylistSelected,&#10;                onArtistSelected = onArtistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE CON PLAYLISTS (NUEVO) ===&#10;        if (showYouTubeAllResults &amp;&amp; youtubeAllResults != null) {&#10;            YouTubeSearchResults(&#10;                results = null, // Legacy results&#10;                youtubeAllResults = youtubeAllResults,&#10;                onVideoSelectedFromSearch = onVideoSelectedFromSearch,&#10;                onPlaylistSelected = onYouTubePlaylistSelected,&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;&#10;        // === RESULTADOS DE YOUTUBE LEGACY ===&#10;        if (results.isNotEmpty() &amp;&amp; !showYouTubeAllResults) {&#10;            CollapsibleYouTubeSearchResultsView(&#10;                results = results,&#10;                onLoadMore = { onSearchTriggered(searchQuery, true) },&#10;                playerViewModel = playerViewModel,&#10;                coroutineScope = coroutineScope&#10;            )&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleSpotifySearchResultsView(&#10;    results: SpotifySearchAllResponse,&#10;    onAlbumSelected: (SpotifyAlbum) -&gt; Unit,&#10;    onPlaylistSelected: (SpotifyPlaylist) -&gt; Unit,&#10;    onArtistSelected: (SpotifyArtistFull) -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var tracksExpanded by remember { mutableStateOf(false) }&#10;    var albumsExpanded by remember { mutableStateOf(false) }&#10;    var playlistsExpanded by remember { mutableStateOf(false) }&#10;    var artistsExpanded by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Tracks section&#10;        if (results.tracks.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (tracksExpanded) &quot;v tracks&quot; else &quot;&gt; tracks&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { tracksExpanded = !tracksExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (tracksExpanded) {&#10;                val trackEntities = results.tracks.items.take(5).mapIndexed { trackIndex, track -&gt;&#10;                    TrackEntity(&#10;                        id = &quot;spotify_search_${track.id}_$trackIndex&quot;,&#10;                        playlistId = &quot;spotify_search_${System.currentTimeMillis()}&quot;,&#10;                        spotifyTrackId = track.id,&#10;                        name = track.name,&#10;                        artists = track.getArtistNames(),&#10;                        youtubeVideoId = null,&#10;                        audioUrl = null,&#10;                        position = trackIndex,&#10;                        lastSyncTime = System.currentTimeMillis()&#10;                    )&#10;                }&#10;                Column(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    verticalArrangement = Arrangement.spacedBy(1.dp)&#10;                ) {&#10;                    results.tracks.items.take(5).forEachIndexed { index, track -&gt;&#10;                        val song = Song(&#10;                            number = index + 1,&#10;                            title = track.name,&#10;                            artist = track.getArtistNames(),&#10;                            spotifyId = track.id,&#10;                            spotifyUrl = &quot;https://open.spotify.com/track/${track.id}&quot;&#10;                        )&#10;                        SongListItem(&#10;                            song = song,&#10;                            trackEntities = trackEntities,&#10;                            index = index,&#10;                            playerViewModel = playerViewModel,&#10;                            coroutineScope = coroutineScope,&#10;                            modifier = Modifier.fillMaxWidth()&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Albums section&#10;        if (results.albums.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (albumsExpanded) &quot;v albums&quot; else &quot;&gt; albums&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { albumsExpanded = !albumsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (albumsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.albums.items.size) { index -&gt;&#10;                        val album = results.albums.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onAlbumSelected(album) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = album.getImageUrl(),&#10;                                contentDescription = &quot;Album cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;&#10;                            Text(&#10;                                text = album.getArtistNames(),&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFF95A5A6)&#10;                                ),&#10;                                maxLines = 1,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Playlists section&#10;        if (results.playlists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (playlistsExpanded) &quot;v playlists&quot; else &quot;&gt; playlists&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { playlistsExpanded = !playlistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (playlistsExpanded) {&#10;                val nonNullPlaylists = results.playlists.items.filterNotNull()&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(nonNullPlaylists) { playlist -&gt;&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(120.dp)&#10;                                .clickable { onPlaylistSelected(playlist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = playlist.getImageUrl(),&#10;                                contentDescription = &quot;Playlist cover&quot;,&#10;                                modifier = Modifier&#10;                                    .size(120.dp)&#10;                                    .clip(RoundedCornerShape(8.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = playlist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;&#10;        // Artists section&#10;        if (results.artists.items.isNotEmpty()) {&#10;            Text(&#10;                text = if (artistsExpanded) &quot;v artists&quot; else &quot;&gt; artists&quot;,&#10;                style = MaterialTheme.typography.titleMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFF4ECDC4)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { artistsExpanded = !artistsExpanded }&#10;                    .padding(4.dp)&#10;            )&#10;&#10;            if (artistsExpanded) {&#10;                LazyRow(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.spacedBy(12.dp),&#10;                    contentPadding = PaddingValues(horizontal = 8.dp)&#10;                ) {&#10;                    items(results.artists.items.size) { index -&gt;&#10;                        val artist = results.artists.items[index]&#10;                        Column(&#10;                            modifier = Modifier&#10;                                .width(100.dp)&#10;                                .clickable { onArtistSelected(artist) },&#10;                            horizontalAlignment = Alignment.CenterHorizontally&#10;                        ) {&#10;                            AsyncImage(&#10;                                model = artist.getImageUrl(),&#10;                                contentDescription = &quot;Artist image&quot;,&#10;                                modifier = Modifier&#10;                                    .size(100.dp)&#10;                                    .clip(RoundedCornerShape(50.dp))&#10;                            )&#10;&#10;                            Text(&#10;                                text = artist.name,&#10;                                style = MaterialTheme.typography.bodySmall.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    color = Color(0xFFE0E0E0)&#10;                                ),&#10;                                modifier = Modifier.padding(top = 4.dp),&#10;                                maxLines = 2,&#10;                                overflow = TextOverflow.Ellipsis,&#10;                                textAlign = androidx.compose.ui.text.style.TextAlign.Center&#10;                            )&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;&#10;@Composable&#10;fun CollapsibleYouTubeSearchResultsView(&#10;    results: List&lt;AudioItem&gt;,&#10;    onLoadMore: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel?,&#10;    coroutineScope: CoroutineScope&#10;) {&#10;    var videosExpanded by remember { mutableStateOf(true) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxWidth(),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Videos section header&#10;        Text(&#10;            text = if (videosExpanded) &quot;v youtube results [${results.size}]&quot; else &quot;&gt; youtube results [${results.size}]&quot;,&#10;            style = MaterialTheme.typography.titleMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier&#10;                .clickable { videosExpanded = !videosExpanded }&#10;                .padding(4.dp)&#10;        )&#10;&#10;        if (videosExpanded) {&#10;            val trackEntities = results.mapIndexed { trackIndex, item -&gt;&#10;                TrackEntity(&#10;                    id = &quot;youtube_${item.videoId}&quot;,&#10;                    playlistId = &quot;youtube_search&quot;,&#10;                    spotifyTrackId = item.videoId,&#10;                    name = item.title,&#10;                    artists = item.channel,&#10;                    youtubeVideoId = item.videoId,&#10;                    audioUrl = null,&#10;                    position = trackIndex,&#10;                    lastSyncTime = System.currentTimeMillis()&#10;                )&#10;            }&#10;            Column(&#10;                modifier = Modifier.fillMaxWidth(),&#10;                verticalArrangement = Arrangement.spacedBy(4.dp)&#10;            ) {&#10;                results.forEachIndexed { index, item -&gt;&#10;                    val song = Song(&#10;                        number = index + 1,&#10;                        title = item.title,&#10;                        artist = item.channel,&#10;                        youtubeId = item.videoId,&#10;                        spotifyUrl = &quot;https://www.youtube.com/watch?v=${item.videoId}&quot;&#10;                    )&#10;                    SongListItem(&#10;                        song = song,&#10;                        trackEntities = trackEntities,&#10;                        index = index,&#10;                        playerViewModel = playerViewModel,&#10;                        coroutineScope = coroutineScope,&#10;                        modifier = Modifier.fillMaxWidth()&#10;                    )&#10;                }&#10;&#10;                // Load more button if there are more results&#10;                if (results.size &gt;= 10) {&#10;                    Text(&#10;                        text = &quot;&gt; load more&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = Color(0xFF4ECDC4)&#10;                        ),&#10;                        modifier = Modifier&#10;                            .clickable { onLoadMore() }&#10;                            .padding(8.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyArtistDetailView.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/components/search/SpotifyArtistDetailView.kt" />
              <option name="originalContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.network.SpotifyArtistFull&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;&#10;/**&#10; * Vista detallada de un artista de Spotify&#10; * Muestra información del artista y sus álbumes principales&#10; */&#10;@Composable&#10;fun SpotifyArtistDetailView(&#10;    artist: SpotifyArtistFull,&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onAlbumClick: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header con información del artista&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Imagen del artista&#10;            artist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = &quot;Imagen de ${artist.name}&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(RoundedCornerShape(60.dp))&#10;                )&#10;            } ?: run {&#10;                // Placeholder si no hay imagen&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(RoundedCornerShape(60.dp)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 48.sp&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información del artista&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = artist.name,&#10;                    style = MaterialTheme.typography.headlineSmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                // Géneros del artista&#10;                if (!artist.genres.isNullOrEmpty()) {&#10;                    Text(&#10;                        text = artist.genres.take(3).joinToString(&quot;, &quot;),&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Botón de share para el artista&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            Text(&#10;                text = &quot;&lt;share&gt;&quot;,&#10;                style = MaterialTheme.typography.bodyLarge.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFFF6B9D)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { showShareDialog = true }&#10;                    .padding(8.dp)&#10;            )&#10;        }&#10;&#10;        // Lista de álbumes&#10;        when {&#10;            isLoading -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            color = Color(0xFF1DB954)&#10;                        )&#10;                        Text(&#10;                            text = &quot;Cargando álbumes...&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(top = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            error != null -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Error: $error&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.error&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            albums.isEmpty() -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No se encontraron álbumes para este artista&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                LazyColumn {&#10;&#10;                    items(albums.size) { index -&gt;&#10;                        val album = albums[index]&#10;                        AlbumItem(&#10;                            album = album,&#10;                            onClick = { onAlbumClick(album) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = artist.id,&#10;                spotifyUrl = &quot;https://open.spotify.com/artist/${artist.id}&quot;,&#10;                youtubeId = null,&#10;                title = artist.name,&#10;                artist = &quot;Artist&quot;,&#10;                type = ShareType.ARTIST&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Item individual de álbum en la lista&#10; */&#10;@Composable&#10;private fun AlbumItem(&#10;    album: SpotifyAlbum,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() }&#10;            .padding(vertical = 8.dp, horizontal = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Imagen del álbum&#10;        album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;            AsyncImage(&#10;                model = imageUrl,&#10;                contentDescription = &quot;Imagen de ${album.name}&quot;,&#10;                modifier = Modifier&#10;                    .size(56.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;            )&#10;        } ?: run {&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(56.dp)&#10;                    .clip(RoundedCornerShape(8.dp)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;♪&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;&#10;        // Información del álbum&#10;        Column(&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Text(&#10;                text = album.name,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                ),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Año de lanzamiento - Usar release_date en lugar de releaseDate&#10;                album.releasedate?.take(4)?.let { year -&gt;&#10;                    Text(&#10;                        text = &quot; $year&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Número de tracks - Usar total_tracks en lugar de totalTracks&#10;                album.totaltracks?.let { tracks -&gt;&#10;                    Text(&#10;                        text = &quot; • $tracks tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.ui.components.search&#10;&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.foundation.shape.RoundedCornerShape&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.draw.clip&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.platform.LocalContext&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.text.font.FontWeight&#10;import androidx.compose.ui.text.style.TextOverflow&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import coil.compose.AsyncImage&#10;import com.plyr.network.SpotifyArtistFull&#10;import com.plyr.network.SpotifyAlbum&#10;import com.plyr.network.SpotifyRepository&#10;import com.plyr.ui.components.ShareDialog&#10;import com.plyr.ui.components.ShareableItem&#10;import com.plyr.ui.components.ShareType&#10;import com.plyr.utils.Config&#10;import kotlinx.coroutines.launch&#10;&#10;/**&#10; * Vista detallada de un artista de Spotify&#10; * Muestra información del artista y sus álbumes principales&#10; */&#10;@Composable&#10;fun SpotifyArtistDetailView(&#10;    artist: SpotifyArtistFull,&#10;    albums: List&lt;SpotifyAlbum&gt;,&#10;    isLoading: Boolean,&#10;    error: String?,&#10;    onAlbumClick: (SpotifyAlbum) -&gt; Unit&#10;) {&#10;    var showShareDialog by remember { mutableStateOf(false) }&#10;    var isFollowing by remember { mutableStateOf&lt;Boolean?&gt;(null) }&#10;    var isCheckingFollow by remember { mutableStateOf(true) }&#10;    var isFollowActionLoading by remember { mutableStateOf(false) }&#10;    &#10;    val context = LocalContext.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;&#10;    // Verificar si ya se sigue al artista&#10;    LaunchedEffect(artist.id) {&#10;        val accessToken = Config.getSpotifyAccessToken(context)&#10;        if (accessToken != null) {&#10;            SpotifyRepository.checkIfFollowingArtist(accessToken, artist.id) { following, errorMsg -&gt;&#10;                isCheckingFollow = false&#10;                if (following != null) {&#10;                    isFollowing = following&#10;                } else {&#10;                    android.util.Log.e(&quot;SpotifyArtistDetailView&quot;, &quot;Error checking follow status: $errorMsg&quot;)&#10;                }&#10;            }&#10;        } else {&#10;            isCheckingFollow = false&#10;        }&#10;    }&#10;&#10;    Column(&#10;        modifier = Modifier.fillMaxSize()&#10;    ) {&#10;        // Header con información del artista&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            verticalAlignment = Alignment.CenterVertically&#10;        ) {&#10;            // Imagen del artista&#10;            artist.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;                AsyncImage(&#10;                    model = imageUrl,&#10;                    contentDescription = &quot;Imagen de ${artist.name}&quot;,&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(RoundedCornerShape(60.dp))&#10;                )&#10;            } ?: run {&#10;                // Placeholder si no hay imagen&#10;                Box(&#10;                    modifier = Modifier&#10;                        .size(120.dp)&#10;                        .clip(RoundedCornerShape(60.dp)),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;♫&quot;,&#10;                        style = MaterialTheme.typography.headlineLarge.copy(&#10;                            color = Color(0xFF1DB954),&#10;                            fontSize = 48.sp&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;&#10;            Spacer(modifier = Modifier.width(16.dp))&#10;&#10;            // Información del artista&#10;            Column(&#10;                modifier = Modifier.weight(1f)&#10;            ) {&#10;                Text(&#10;                    text = artist.name,&#10;                    style = MaterialTheme.typography.headlineSmall.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontWeight = FontWeight.Bold,&#10;                        color = MaterialTheme.colorScheme.primary&#10;                    ),&#10;                    maxLines = 2,&#10;                    overflow = TextOverflow.Ellipsis&#10;                )&#10;&#10;                // Géneros del artista&#10;                if (!artist.genres.isNullOrEmpty()) {&#10;                    Text(&#10;                        text = artist.genres.take(3).joinToString(&quot;, &quot;),&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.7f)&#10;                        ),&#10;                        maxLines = 1,&#10;                        overflow = TextOverflow.Ellipsis,&#10;                        modifier = Modifier.padding(top = 4.dp)&#10;                    )&#10;                }&#10;            }&#10;        }&#10;&#10;        // Botones de acción para el artista&#10;        Row(&#10;            modifier = Modifier&#10;                .fillMaxWidth()&#10;                .padding(bottom = 16.dp),&#10;            horizontalArrangement = Arrangement.spacedBy(16.dp)&#10;        ) {&#10;            // Botón de share&#10;            Text(&#10;                text = &quot;&lt;share&gt;&quot;,&#10;                style = MaterialTheme.typography.bodyLarge.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFFF6B9D)&#10;                ),&#10;                modifier = Modifier&#10;                    .clickable { showShareDialog = true }&#10;                    .padding(8.dp)&#10;            )&#10;&#10;            // Botón de follow/unfollow&#10;            if (isCheckingFollow) {&#10;                Text(&#10;                    text = &quot;&lt;...&gt;&quot;,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier.padding(8.dp)&#10;                )&#10;            } else {&#10;                val followText = when {&#10;                    isFollowActionLoading -&gt; &quot;&lt;loading...&gt;&quot;&#10;                    isFollowing == true -&gt; &quot;&lt;unfollow&gt;&quot;&#10;                    else -&gt; &quot;&lt;follow&gt;&quot;&#10;                }&#10;                val followColor = when {&#10;                    isFollowActionLoading -&gt; Color(0xFFFFD93D)&#10;                    isFollowing == true -&gt; Color(0xFFFF6B6B)&#10;                    else -&gt; Color(0xFF7FB069)&#10;                }&#10;&#10;                Text(&#10;                    text = followText,&#10;                    style = MaterialTheme.typography.bodyLarge.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = followColor&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable(enabled = !isFollowActionLoading) {&#10;                            isFollowActionLoading = true&#10;                            val accessToken = Config.getSpotifyAccessToken(context)&#10;                            if (accessToken != null) {&#10;                                if (isFollowing == true) {&#10;                                    // Dejar de seguir&#10;                                    SpotifyRepository.unfollowArtist(accessToken, artist.id) { success, errorMsg -&gt;&#10;                                        isFollowActionLoading = false&#10;                                        if (success) {&#10;                                            isFollowing = false&#10;                                            android.util.Log.d(&quot;SpotifyArtistDetailView&quot;, &quot;Artist unfollowed: ${artist.name}&quot;)&#10;                                        } else {&#10;                                            android.util.Log.e(&quot;SpotifyArtistDetailView&quot;, &quot;Error unfollowing artist: $errorMsg&quot;)&#10;                                        }&#10;                                    }&#10;                                } else {&#10;                                    // Seguir&#10;                                    SpotifyRepository.followArtist(accessToken, artist.id) { success, errorMsg -&gt;&#10;                                        isFollowActionLoading = false&#10;                                        if (success) {&#10;                                            isFollowing = true&#10;                                            android.util.Log.d(&quot;SpotifyArtistDetailView&quot;, &quot;Artist followed: ${artist.name}&quot;)&#10;                                        } else {&#10;                                            android.util.Log.e(&quot;SpotifyArtistDetailView&quot;, &quot;Error following artist: $errorMsg&quot;)&#10;                                        }&#10;                                    }&#10;                                }&#10;                            } else {&#10;                                isFollowActionLoading = false&#10;                                android.util.Log.e(&quot;SpotifyArtistDetailView&quot;, &quot;No access token available&quot;)&#10;                            }&#10;                        }&#10;                        .padding(8.dp)&#10;                )&#10;            }&#10;        }&#10;&#10;        // Lista de álbumes&#10;        when {&#10;            isLoading -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Column(&#10;                        horizontalAlignment = Alignment.CenterHorizontally&#10;                    ) {&#10;                        CircularProgressIndicator(&#10;                            color = Color(0xFF1DB954)&#10;                        )&#10;                        Text(&#10;                            text = &quot;Cargando álbumes...&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace&#10;                            ),&#10;                            modifier = Modifier.padding(top = 8.dp)&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;            error != null -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Error: $error&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.error&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            albums.isEmpty() -&gt; {&#10;                Box(&#10;                    modifier = Modifier.fillMaxSize(),&#10;                    contentAlignment = Alignment.Center&#10;                ) {&#10;                    Text(&#10;                        text = &quot;No se encontraron álbumes para este artista&quot;,&#10;                        style = MaterialTheme.typography.bodyMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;            else -&gt; {&#10;                LazyColumn {&#10;&#10;                    items(albums.size) { index -&gt;&#10;                        val album = albums[index]&#10;                        AlbumItem(&#10;                            album = album,&#10;                            onClick = { onAlbumClick(album) }&#10;                        )&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;&#10;    if (showShareDialog) {&#10;        ShareDialog(&#10;            item = ShareableItem(&#10;                spotifyId = artist.id,&#10;                spotifyUrl = &quot;https://open.spotify.com/artist/${artist.id}&quot;,&#10;                youtubeId = null,&#10;                title = artist.name,&#10;                artist = &quot;Artist&quot;,&#10;                type = ShareType.ARTIST&#10;            ),&#10;            onDismiss = { showShareDialog = false }&#10;        )&#10;    }&#10;}&#10;&#10;/**&#10; * Item individual de álbum en la lista&#10; */&#10;@Composable&#10;private fun AlbumItem(&#10;    album: SpotifyAlbum,&#10;    onClick: () -&gt; Unit&#10;) {&#10;    Row(&#10;        modifier = Modifier&#10;            .fillMaxWidth()&#10;            .clickable { onClick() }&#10;            .padding(vertical = 8.dp, horizontal = 4.dp),&#10;        verticalAlignment = Alignment.CenterVertically&#10;    ) {&#10;        // Imagen del álbum&#10;        album.images?.firstOrNull()?.url?.let { imageUrl -&gt;&#10;            AsyncImage(&#10;                model = imageUrl,&#10;                contentDescription = &quot;Imagen de ${album.name}&quot;,&#10;                modifier = Modifier&#10;                    .size(56.dp)&#10;                    .clip(RoundedCornerShape(8.dp))&#10;            )&#10;        } ?: run {&#10;            Box(&#10;                modifier = Modifier&#10;                    .size(56.dp)&#10;                    .clip(RoundedCornerShape(8.dp)),&#10;                contentAlignment = Alignment.Center&#10;            ) {&#10;                Text(&#10;                    text = &quot;♪&quot;,&#10;                    style = MaterialTheme.typography.titleMedium.copy(&#10;                        color = Color(0xFF1DB954)&#10;                    )&#10;                )&#10;            }&#10;        }&#10;&#10;        Spacer(modifier = Modifier.width(12.dp))&#10;&#10;        // Información del álbum&#10;        Column(&#10;            modifier = Modifier.weight(1f)&#10;        ) {&#10;            Text(&#10;                text = album.name,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontWeight = FontWeight.Medium,&#10;                    color = MaterialTheme.colorScheme.onSurface&#10;                ),&#10;                maxLines = 1,&#10;                overflow = TextOverflow.Ellipsis&#10;            )&#10;&#10;            Row(&#10;                verticalAlignment = Alignment.CenterVertically&#10;            ) {&#10;                // Año de lanzamiento - Usar release_date en lugar de releaseDate&#10;                album.releasedate?.take(4)?.let { year -&gt;&#10;                    Text(&#10;                        text = &quot; $year&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;&#10;                // Número de tracks - Usar total_tracks en lugar de totalTracks&#10;                album.totaltracks?.let { tracks -&gt;&#10;                    Text(&#10;                        text = &quot; • $tracks tracks&quot;,&#10;                        style = MaterialTheme.typography.bodySmall.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            color = MaterialTheme.colorScheme.onSurface.copy(alpha = 0.6f)&#10;                        )&#10;                    )&#10;                }&#10;            }&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/navigation/Screen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.navigation&#10;&#10;import androidx.compose.runtime.Stable&#10;&#10;// Estados para navegación&#10;enum class Screen {&#10;    HOME,&#10;    SEARCH,&#10;    QUEUE,&#10;    CONFIG,&#10;    PLAYLISTS&#10;}&#10;&#10;@Stable&#10;data class MenuOption(val screen: Screen, val title: String)" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/HomeScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.app.Activity&#10;import android.content.Context&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import com.plyr.ui.navigation.MenuOption&#10;import com.plyr.ui.navigation.Screen&#10;import kotlinx.coroutines.CoroutineScope&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.delay&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun HomeScreen(&#10;    context: Context,&#10;    onNavigateToScreen: (Screen) -&gt; Unit&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    var backPressedTime by remember { mutableStateOf(0L) }&#10;    var showExitMessage by remember { mutableStateOf(false) }&#10;    &#10;    // Handle double back press to exit&#10;    BackHandler {&#10;        val currentTime = System.currentTimeMillis()&#10;        if (currentTime - backPressedTime &gt; 2000) {&#10;            backPressedTime = currentTime&#10;            showExitMessage = true&#10;            // Hide message after 2 seconds&#10;            CoroutineScope(Dispatchers.Main).launch {&#10;                delay(2000)&#10;                showExitMessage = false&#10;            }&#10;        } else {&#10;            // Exit app&#10;            (context as? Activity)?.finish()&#10;        }&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp),&#10;        verticalArrangement = Arrangement.spacedBy(12.dp)&#10;    ) {&#10;        // Terminal-style header&#10;        Text(&#10;            text = &quot;$ plyr_home&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;&#10;        // Lista de opciones disponibles&#10;        val options = remember {&#10;            listOf(&#10;                MenuOption(Screen.SEARCH, &quot;&gt; search&quot;),&#10;                MenuOption(Screen.PLAYLISTS, &quot;&gt; playlists&quot;),&#10;                MenuOption(Screen.QUEUE, &quot;&gt; queue&quot;),&#10;                MenuOption(Screen.CONFIG, &quot;&gt; settings&quot;)&#10;            )&#10;        }&#10;        &#10;        Column(&#10;            verticalArrangement = Arrangement.spacedBy(12.dp)&#10;        ) {&#10;            options.forEach { option -&gt;&#10;                Text(&#10;                    text = option.title,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 20.sp,&#10;                        color = Color.White&#10;                    ),&#10;                    modifier = Modifier&#10;                        .clickable {&#10;                            haptic.performHapticFeedback(HapticFeedbackType.TextHandleMove)&#10;                            onNavigateToScreen(option.screen)&#10;                        }&#10;                        .padding(4.dp)&#10;                )&#10;            }&#10;        }&#10;        &#10;        Spacer(modifier = Modifier.weight(1f))&#10;&#10;        // Exit message&#10;        if (showExitMessage) {&#10;            Text(&#10;                text = &quot;&gt; Press back again to exit&quot;,&#10;                style = MaterialTheme.typography.bodySmall.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier&#10;                    .align(Alignment.CenterHorizontally)&#10;                    .padding(top = 8.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/ui/screens/QueueScreen.kt" />
              <option name="updatedContent" value="package com.plyr.ui.screens&#10;&#10;import android.content.Context&#10;import android.util.Log&#10;import androidx.activity.compose.BackHandler&#10;import androidx.compose.foundation.clickable&#10;import androidx.compose.foundation.layout.*&#10;import androidx.compose.foundation.lazy.LazyColumn&#10;import androidx.compose.material3.*&#10;import androidx.compose.runtime.*&#10;import androidx.compose.ui.Alignment&#10;import androidx.compose.ui.Modifier&#10;import androidx.compose.ui.graphics.Color&#10;import androidx.compose.ui.hapticfeedback.HapticFeedbackType&#10;import androidx.compose.ui.platform.LocalHapticFeedback&#10;import androidx.compose.ui.text.font.FontFamily&#10;import androidx.compose.ui.unit.dp&#10;import androidx.compose.ui.unit.sp&#10;import androidx.lifecycle.compose.collectAsStateWithLifecycle&#10;import com.plyr.ui.components.MarqueeText&#10;import com.plyr.viewmodel.PlayerViewModel&#10;import kotlinx.coroutines.launch&#10;&#10;@Composable&#10;fun QueueScreen(&#10;    context: Context,&#10;    onBack: () -&gt; Unit,&#10;    playerViewModel: PlayerViewModel? = null&#10;) {&#10;    val haptic = LocalHapticFeedback.current&#10;    val coroutineScope = rememberCoroutineScope()&#10;    &#10;    // Handle back button&#10;    BackHandler {&#10;        onBack()&#10;    }&#10;    &#10;    Column(&#10;        Modifier&#10;            .fillMaxSize()&#10;            .padding(16.dp)&#10;    ) {&#10;        // Header&#10;        Text(&#10;            text = &quot;$ plyr_queue&quot;,&#10;            style = MaterialTheme.typography.headlineMedium.copy(&#10;                fontFamily = FontFamily.Monospace,&#10;                fontSize = 24.sp,&#10;                color = Color(0xFF4ECDC4)&#10;            ),&#10;            modifier = Modifier.padding(bottom = 16.dp)&#10;        )&#10;        &#10;        // Queue content&#10;        if (playerViewModel != null) {&#10;            val queueState by playerViewModel.queueState.collectAsStateWithLifecycle()&#10;            val currentQueue = queueState.queue&#10;            &#10;            if (currentQueue.isNotEmpty()) {&#10;                // Queue header&#10;                Row(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    horizontalArrangement = Arrangement.SpaceBetween,&#10;                    verticalAlignment = Alignment.CenterVertically&#10;                ) {&#10;                    Text(&#10;                        text = &quot;Current queue [${currentQueue.size}]&quot;,&#10;                        style = MaterialTheme.typography.titleMedium.copy(&#10;                            fontFamily = FontFamily.Monospace,&#10;                            fontSize = 18.sp,&#10;                            color = Color(0xFFFFD93D)&#10;                        )&#10;                    )&#10;                    &#10;                    // Clear queue button&#10;                    TextButton(&#10;                        onClick = { &#10;                            playerViewModel.clearQueue()&#10;                            Log.d(&quot;QueueScreen&quot;, &quot;Queue cleared by user&quot;)&#10;                        }&#10;                    ) {&#10;                        Text(&#10;                            text = &quot;clear&quot;,&#10;                            style = MaterialTheme.typography.bodyMedium.copy(&#10;                                fontFamily = FontFamily.Monospace,&#10;                                color = Color(0xFF95A5A6)&#10;                            )&#10;                        )&#10;                    }&#10;                }&#10;                &#10;                Spacer(Modifier.height(16.dp))&#10;                &#10;                // Queue track list&#10;                LazyColumn(&#10;                    modifier = Modifier.fillMaxWidth(),&#10;                    contentPadding = PaddingValues(bottom = 16.dp)&#10;                ) {&#10;                    items(&#10;                        count = currentQueue.size,&#10;                        key = { index -&gt; currentQueue[index].id }&#10;                    ) { index -&gt;&#10;                        val track = currentQueue[index]&#10;                        val isCurrentTrack = queueState.currentIndex == index&#10;                        &#10;                        Row(&#10;                            modifier = Modifier&#10;                                .fillMaxWidth()&#10;                                .padding(vertical = 4.dp, horizontal = 4.dp)&#10;                                .clickable {&#10;                                    coroutineScope.launch {&#10;                                        if (queueState.currentIndex != index) {&#10;                                            playerViewModel.playQueueFromIndex(index)&#10;                                        } else {&#10;                                            playerViewModel.resumeIfPaused()&#10;                                        }&#10;                                    }&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Starting queue from index: $index&quot;)&#10;                                },&#10;                            verticalAlignment = Alignment.CenterVertically&#10;                        ) {&#10;                            // Position and status indicator&#10;                            Text(&#10;                                text = if (isCurrentTrack) &quot;♪ &quot; else &quot;${index + 1}. &quot;,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFF4ECDC4) else Color(0xFF95A5A6)&#10;                                ),&#10;                                modifier = Modifier.width(32.dp)&#10;                            )&#10;                            &#10;                            // Track name&#10;                            MarqueeText(&#10;                                text = track.name,&#10;                                style = MaterialTheme.typography.bodyMedium.copy(&#10;                                    fontFamily = FontFamily.Monospace,&#10;                                    fontSize = 14.sp,&#10;                                    color = if (isCurrentTrack) Color(0xFFE0E0E0) else Color(0xFFBDC3C7)&#10;                                ),&#10;                                modifier = Modifier.weight(1f)&#10;                            )&#10;                            &#10;                            // Remove from queue button&#10;                            TextButton(&#10;                                onClick = { &#10;                                    playerViewModel.removeFromQueue(index)&#10;                                    Log.d(&quot;QueueScreen&quot;, &quot;Removed track from queue at index: $index&quot;)&#10;                                }&#10;                            ) {&#10;                                Text(&#10;                                    text = &quot;×&quot;,&#10;                                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                                        fontFamily = FontFamily.Monospace,&#10;                                        color = Color(0xFF95A5A6)&#10;                                    )&#10;                                )&#10;                            }&#10;                        }&#10;                    }&#10;                }&#10;            } else {&#10;                // Empty queue message&#10;                Text(&#10;                    text = &quot;Queue is empty&quot;,&#10;                    style = MaterialTheme.typography.bodyMedium.copy(&#10;                        fontFamily = FontFamily.Monospace,&#10;                        fontSize = 16.sp,&#10;                        color = Color(0xFF95A5A6)&#10;                    ),&#10;                    modifier = Modifier&#10;                        .fillMaxWidth()&#10;                        .padding(32.dp)&#10;                )&#10;            }&#10;        } else {&#10;            Text(&#10;                text = &quot;Player not available&quot;,&#10;                style = MaterialTheme.typography.bodyMedium.copy(&#10;                    fontFamily = FontFamily.Monospace,&#10;                    fontSize = 16.sp,&#10;                    color = Color(0xFFE74C3C)&#10;                ),&#10;                modifier = Modifier.padding(16.dp)&#10;            )&#10;        }&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/Config.kt" />
              <option name="originalContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    &#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;dark&quot;&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;medium&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private user-read-email streaming&quot;&#10;    &#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;dark&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;    &#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine&lt;String?&gt; { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;}&#10;" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import android.content.SharedPreferences&#10;import androidx.core.content.edit&#10;import kotlinx.coroutines.Dispatchers&#10;import kotlinx.coroutines.runBlocking&#10;import kotlinx.coroutines.withContext&#10;import kotlin.coroutines.resume&#10;import kotlin.coroutines.suspendCoroutine&#10;&#10;/**&#10; * Config - Objeto singleton para gestión de configuración de la aplicación&#10; * &#10; * Maneja:&#10; * - Configuración de temas (claro/oscuro)&#10; * - Tokens y autenticación de Spotify&#10; * - Constantes de API de Spotify&#10; * - Persistencia de preferencias usando SharedPreferences&#10; * &#10; * Todos los datos se almacenan de forma segura en SharedPreferences&#10; * y se accede a través de métodos thread-safe.&#10; */&#10;object Config {&#10;    &#10;    // === CONSTANTES PRIVADAS ===&#10;    &#10;    /** Nombre del archivo de preferencias */&#10;    private const val PREFS_NAME = &quot;plyr_config&quot;&#10;    &#10;    // Claves para SharedPreferences&#10;    private const val KEY_THEME = &quot;theme&quot;&#10;    private const val KEY_SEARCH_ENGINE = &quot;search_engine&quot;&#10;    private const val KEY_AUDIO_QUALITY = &quot;audio_quality&quot;&#10;    private const val KEY_REPEAT_MODE = &quot;repeat_mode&quot;&#10;    private const val KEY_SPOTIFY_ACCESS_TOKEN = &quot;spotify_access_token&quot;&#10;    private const val KEY_SPOTIFY_REFRESH_TOKEN = &quot;spotify_refresh_token&quot;&#10;    private const val KEY_SPOTIFY_TOKEN_EXPIRY = &quot;spotify_token_expiry&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_ID = &quot;spotify_client_id&quot;&#10;    private const val KEY_SPOTIFY_CLIENT_SECRET = &quot;spotify_client_secret&quot;&#10;    &#10;    // Valores por defecto&#10;    private const val DEFAULT_THEME = &quot;dark&quot;&#10;    private const val DEFAULT_SEARCH_ENGINE = &quot;spotify&quot;&#10;    private const val DEFAULT_AUDIO_QUALITY = &quot;medium&quot;&#10;    private const val DEFAULT_REPEAT_MODE = &quot;off&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE SPOTIFY ===&#10;&#10;    /** URI de redirección para OAuth de Spotify */&#10;    const val SPOTIFY_REDIRECT_URI = &quot;plyr://spotify/callback&quot;&#10;    &#10;    /** Permisos solicitados a Spotify */&#10;    const val SPOTIFY_SCOPES = &quot;playlist-read-private playlist-read-collaborative playlist-modify-public playlist-modify-private user-library-modify user-library-read user-follow-modify user-follow-read user-read-private user-read-email streaming&quot;&#10;    &#10;    // === CONSTANTES PÚBLICAS DE CALIDAD DE AUDIO ===&#10;&#10;    /** Calidades de audio disponibles */&#10;    const val AUDIO_QUALITY_WORST = &quot;worst&quot;&#10;    const val AUDIO_QUALITY_MEDIUM = &quot;medium&quot;&#10;    const val AUDIO_QUALITY_BEST = &quot;best&quot;&#10;&#10;    // === CONSTANTES PÚBLICAS DE MODO DE REPETICIÓN ===&#10;&#10;    /** Modos de repetición disponibles */&#10;    const val REPEAT_MODE_OFF = &quot;off&quot;        // Sin repetición&#10;    const val REPEAT_MODE_ONE = &quot;one&quot;        // Repetir una sola vez&#10;    const val REPEAT_MODE_ALL = &quot;all&quot;        // Repetir indefinidamente&#10;&#10;    // === MÉTODOS PRIVADOS ===&#10;    &#10;    /**&#10;     * Obtiene la instancia de SharedPreferences para la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return SharedPreferences configurado con el nombre correcto&#10;     */&#10;    private fun getPrefs(context: Context): SharedPreferences {&#10;        return context.getSharedPreferences(PREFS_NAME, Context.MODE_PRIVATE)&#10;    }&#10;    &#10;    // === GESTIÓN DE TEMAS ===&#10;    &#10;    /**&#10;     * Establece el tema de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @param theme Tema a establecer (&quot;dark&quot;, &quot;light&quot;)&#10;     */&#10;    fun setTheme(context: Context, theme: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_THEME, theme) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el tema actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Tema actual (por defecto &quot;dark&quot;)&#10;     */&#10;    fun getTheme(context: Context): String {&#10;        return getPrefs(context).getString(KEY_THEME, DEFAULT_THEME) ?: DEFAULT_THEME&#10;    }&#10;    &#10;    // === GESTIÓN DE TOKENS DE SPOTIFY ===&#10;    &#10;    /**&#10;     * Almacena los tokens de autenticación de Spotify.&#10;     * Calcula automáticamente el tiempo de expiración basado en expiresIn.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @param accessToken Token de acceso para API calls&#10;     * @param refreshToken Token para renovar el acceso (puede ser null)&#10;     * @param expiresIn Tiempo de vida del token en segundos&#10;     */&#10;    fun setSpotifyTokens(context: Context, accessToken: String, refreshToken: String?, expiresIn: Int) {&#10;        val expiryTime = System.currentTimeMillis() + (expiresIn * 1000L)&#10;        getPrefs(context).edit { &#10;            putString(KEY_SPOTIFY_ACCESS_TOKEN, accessToken)&#10;            refreshToken?.let { putString(KEY_SPOTIFY_REFRESH_TOKEN, it) }&#10;            putLong(KEY_SPOTIFY_TOKEN_EXPIRY, expiryTime)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de acceso de Spotify si es válido.&#10;     * Si el token ha expirado pero existe un refresh token válido,&#10;     * automáticamente renueva el token y devuelve el nuevo.&#10;     *&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de acceso válido o null si no se pudo obtener/renovar&#10;     */&#10;    fun getSpotifyAccessToken(context: Context): String? {&#10;        val prefs = getPrefs(context)&#10;        val token = prefs.getString(KEY_SPOTIFY_ACCESS_TOKEN, null)&#10;        val expiryTime = prefs.getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0)&#10;&#10;        // Verificar que el token no haya expirado&#10;        if (token != null &amp;&amp; System.currentTimeMillis() &lt; expiryTime) {&#10;            return token&#10;        }&#10;&#10;        // Token expirado o no existe, intentar renovar con el refresh token&#10;        val refreshToken = prefs.getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;        if (refreshToken == null) {&#10;            return null&#10;        }&#10;&#10;        // Renovar el token de forma síncrona&#10;        return runBlocking {&#10;            withContext(Dispatchers.IO) {&#10;                suspendCoroutine&lt;String?&gt; { continuation -&gt;&#10;                    com.plyr.network.SpotifyRepository.refreshAccessToken(context, refreshToken) { newAccessToken, error -&gt;&#10;                        if (error != null) {&#10;                            continuation.resume(null)&#10;                        } else if (newAccessToken != null) {&#10;                            // Guardar el nuevo token&#10;                            val expiresIn = 3600 // Spotify tokens duran 1 hora&#10;                            setSpotifyTokens(context, newAccessToken, refreshToken, expiresIn)&#10;                            continuation.resume(newAccessToken)&#10;                        } else {&#10;                            continuation.resume(null)&#10;                        }&#10;                    }&#10;                }&#10;            }&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el token de renovación de Spotify.&#10;     * @param context Contexto de la aplicación&#10;     * @return Token de renovación o null si no existe&#10;     */&#10;    fun getSpotifyRefreshToken(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_REFRESH_TOKEN, null)&#10;    }&#10;    &#10;    /**&#10;     * Elimina todos los tokens de Spotify almacenados.&#10;     * Útil para cerrar sesión o limpiar autenticación.&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     */&#10;    fun clearSpotifyTokens(context: Context) {&#10;        getPrefs(context).edit { &#10;            remove(KEY_SPOTIFY_ACCESS_TOKEN)&#10;            remove(KEY_SPOTIFY_REFRESH_TOKEN)&#10;            remove(KEY_SPOTIFY_TOKEN_EXPIRY)&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Verifica si hay una conexión válida con Spotify.&#10;     * Considera válida la conexión si existe un token de acceso válido&#10;     * o un token de renovación (que puede usarse para obtener nuevos tokens).&#10;     * &#10;     * @param context Contexto de la aplicación&#10;     * @return true si hay conexión con Spotify, false en caso contrario&#10;     */&#10;    fun isSpotifyConnected(context: Context): Boolean {&#10;        val hasValidAccessToken = getSpotifyAccessToken(context) != null&#10;        val hasRefreshToken = getSpotifyRefreshToken(context) != null&#10;        return hasValidAccessToken || hasRefreshToken&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client ID de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client ID del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientId(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el Client Secret de Spotify configurado por el usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @return Client Secret del usuario o null si no está configurado&#10;     */&#10;    fun getSpotifyClientSecret(context: Context): String? {&#10;        return getPrefs(context).getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client ID de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientId Client ID del usuario&#10;     */&#10;    fun setSpotifyClientId(context: Context, clientId: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_ID, clientId.trim())&#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Establece el Client Secret de Spotify del usuario.&#10;     * @param context Contexto de la aplicación&#10;     * @param clientSecret Client Secret del usuario&#10;     */&#10;    fun setSpotifyClientSecret(context: Context, clientSecret: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_SPOTIFY_CLIENT_SECRET, clientSecret.trim())&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Verifica si el usuario tiene credenciales de Spotify configuradas.&#10;     * @param context Contexto de la aplicación&#10;     * @return true si tiene credenciales configuradas, false en caso contrario&#10;     */&#10;    fun hasSpotifyCredentials(context: Context): Boolean {&#10;        val prefs = getPrefs(context)&#10;        val clientId = prefs.getString(KEY_SPOTIFY_CLIENT_ID, null)&#10;        val clientSecret = prefs.getString(KEY_SPOTIFY_CLIENT_SECRET, null)&#10;        return !clientId.isNullOrBlank() &amp;&amp; !clientSecret.isNullOrBlank()&#10;    }&#10;&#10;    // === GESTIÓN DE MOTOR DE BÚSQUEDA ===&#10;    &#10;    /**&#10;     * Establece el motor de búsqueda predeterminado.&#10;     * @param context Contexto de la aplicación&#10;     * @param searchEngine Motor de búsqueda a establecer (&quot;spotify&quot;, &quot;youtube&quot;)&#10;     */&#10;    fun setSearchEngine(context: Context, searchEngine: String) {&#10;        getPrefs(context).edit { &#10;            putString(KEY_SEARCH_ENGINE, searchEngine) &#10;        }&#10;    }&#10;    &#10;    /**&#10;     * Obtiene el motor de búsqueda actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Motor de búsqueda actual (por defecto &quot;spotify&quot;)&#10;     */&#10;    fun getSearchEngine(context: Context): String {&#10;        return getPrefs(context).getString(KEY_SEARCH_ENGINE, DEFAULT_SEARCH_ENGINE) ?: DEFAULT_SEARCH_ENGINE&#10;    }&#10;&#10;    // === GESTIÓN DE CALIDAD DE AUDIO ===&#10;&#10;    /**&#10;     * Establece la calidad de audio predeterminada.&#10;     * @param context Contexto de la aplicación&#10;     * @param quality Calidad de audio a establecer (&quot;worst&quot;, &quot;medium&quot;, &quot;best&quot;)&#10;     */&#10;    fun setAudioQuality(context: Context, quality: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_AUDIO_QUALITY, quality)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene la calidad de audio actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Calidad de audio actual (por defecto &quot;medium&quot;)&#10;     */&#10;    fun getAudioQuality(context: Context): String {&#10;        return getPrefs(context).getString(KEY_AUDIO_QUALITY, DEFAULT_AUDIO_QUALITY) ?: DEFAULT_AUDIO_QUALITY&#10;    }&#10;&#10;    // === GESTIÓN DE MODO DE REPETICIÓN ===&#10;&#10;    /**&#10;     * Establece el modo de repetición.&#10;     * @param context Contexto de la aplicación&#10;     * @param repeatMode Modo de repetición a establecer (&quot;off&quot;, &quot;one&quot;, &quot;all&quot;)&#10;     */&#10;    fun setRepeatMode(context: Context, repeatMode: String) {&#10;        getPrefs(context).edit {&#10;            putString(KEY_REPEAT_MODE, repeatMode)&#10;        }&#10;    }&#10;&#10;    /**&#10;     * Obtiene el modo de repetición actual de la aplicación.&#10;     * @param context Contexto de la aplicación&#10;     * @return Modo de repetición actual (por defecto &quot;off&quot;)&#10;     */&#10;    fun getRepeatMode(context: Context): String {&#10;        return getPrefs(context).getString(KEY_REPEAT_MODE, DEFAULT_REPEAT_MODE) ?: DEFAULT_REPEAT_MODE&#10;    }&#10;&#10;    /**&#10;     * Obtiene el siguiente modo de repetición en el ciclo.&#10;     * @param currentMode Modo actual&#10;     * @return Siguiente modo en el ciclo off -&gt; one -&gt; all -&gt; off&#10;     */&#10;    fun getNextRepeatMode(currentMode: String): String {&#10;        return when (currentMode) {&#10;            REPEAT_MODE_OFF -&gt; REPEAT_MODE_ONE&#10;            REPEAT_MODE_ONE -&gt; REPEAT_MODE_ALL&#10;            REPEAT_MODE_ALL -&gt; REPEAT_MODE_OFF&#10;            else -&gt; REPEAT_MODE_OFF&#10;        }&#10;    }&#10;&#10;    // === GESTIÓN DE TIMESTAMPS DE TOKENS ===&#10;&#10;    /**&#10;     * Obtiene el timestamp de cuando se guardó el token actual.&#10;     * @param context Contexto de la aplicación&#10;     * @return Timestamp en milisegundos o 0 si no existe&#10;     */&#10;    fun getSpotifyTokenTimestamp(context: Context): Long {&#10;        return getPrefs(context).getLong(KEY_SPOTIFY_TOKEN_EXPIRY, 0L) - (3600 * 1000L) // Restar la duración del token&#10;    }&#10;&#10;    /**&#10;     * Obtiene el tiempo de expiración en segundos del token actual.&#10;     * @return Tiempo de expiración en segundos (por defecto 3600 = 1 hora)&#10;     */&#10;    fun getSpotifyTokenExpiresIn(): Int {&#10;        // Los tokens de Spotify duran 1 hora por defecto&#10;        return 3600&#10;    }&#10;&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/app/src/main/java/com/plyr/utils/PlayerViewModelExtensions.kt" />
              <option name="updatedContent" value="package com.plyr.utils&#10;&#10;import android.content.Context&#10;import com.plyr.database.TrackEntity&#10;import com.plyr.service.MusicNotificationManager&#10;import com.plyr.viewmodel.PlayerViewModel&#10;&#10;/**&#10; * Extensiones para integrar PlayerViewModel con notificaciones de música&#10; * &#10; * Estas extensiones facilitan el uso del sistema de notificaciones&#10; * sin modificar directamente el PlayerViewModel existente.&#10; */&#10;&#10;/**&#10; * Inicializa el manager de notificaciones&#10; */&#10;fun PlayerViewModel.initializeNotifications(context: Context): MusicNotificationManager {&#10;    return MusicNotificationManager(context).apply {&#10;        startService()&#10;    }&#10;}&#10;&#10;/**&#10; * Reproduce un track con notificación&#10; */&#10;fun PlayerViewModel.playWithNotification(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity,&#10;    onAudioUrlReady: (String) -&gt; Unit&#10;) {&#10;    // Actualizar la información del track en la notificación&#10;    notificationManager.updateSongInfo(track)&#10;    &#10;    // Tu lógica existente de reproducción aquí&#10;    // Cuando tengas la URL de audio, llamar:&#10;    // onAudioUrlReady(audioUrl)&#10;}&#10;&#10;/**&#10; * Actualiza la notificación cuando cambia el track&#10; */&#10;fun PlayerViewModel.updateNotificationTrack(&#10;    notificationManager: MusicNotificationManager,&#10;    track: TrackEntity?&#10;) {&#10;    track?.let {&#10;        notificationManager.updateSongInfo(it.name, it.artists)&#10;    }&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
        <entry key="$PROJECT_DIR$/build.gradle.kts">
          <value>
            <PendingDiffInfo>
              <option name="filePath" value="$PROJECT_DIR$/build.gradle.kts" />
              <option name="originalContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
              <option name="updatedContent" value="// Top-level build file where you can add configuration options common to all sub-projects/modules.&#10;plugins {&#10;    alias(libs.plugins.android.application) apply false&#10;    alias(libs.plugins.kotlin.android) apply false&#10;    alias(libs.plugins.kotlin.compose) apply false&#10;}" />
            </PendingDiffInfo>
          </value>
        </entry>
      </map>
    </option>
  </component>
</project>